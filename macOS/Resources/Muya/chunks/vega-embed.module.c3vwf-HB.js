import { Q as iL } from "./emojis.bYhmvyOg.js";
import { m as Ry, a as Ws, r as rL, d as aL, l as tp, i as sL, h as oL, n as uL, c as lL, u as ik, s as Yv, b as rk, e as ak, f as xc, g as Kv, j as Ty, k as sk, o as cL, p as fL, t as dL, q as g5, v as ok, w as Sh, x as hL, y as pL, z as uk, A as gL, B as mL, C as yL, D as bL, E as Pg, F as lk } from "./time.cCGe6j1n.js";
import { a as Ic, n as vL, b as xL, i as kf, c as $L, d as wL, e as EL, o as SL, f as zg, g as m5, l as Vu, t as Jv, h as Qv, j as y5, k as Dy, m as ck, p as Ea, q as Eo, r as Zv, s as Bc, u as AL, v as kL, w as CL, x as _L, y as FL, z as Ig, A as Vr, B as Bg, C as ML } from "./linear.aumxlp6i.js";
import { r as xt } from "./range.jFCxLvxp.js";
import { R as fk, B as OL, C as RL, D as TL, E as DL, F as b5, G as v5, H as e2, I as np, J as Hn, K as NL, L as LL, i as PL, a as zL, M as IL, N as BL, b as jL, f as UL, e as qL, n as GL, T as WL, t as HL, d as VL, s as t2, O as XL, P as YL, Q as KL, g as dk, h as hk, j as pk, k as gk, o as mk, m as yk, l as bk, r as vk, p as xk, q as $k, u as wk, w as Ek, v as Sk, x as Ak, y as kk, z as Ck, A as _k, S as mu } from "./step.sPVUIIxm.js";
import { i as So, a as rs } from "./init.rAwVKJwz.js";
import { I as Ba, o as as, i as JL } from "./ordinal.xaLJwwRP.js";
import { a as Fk } from "./arc.CIwEnYSO.js";
import { a as QL } from "./array.R1yjboNr.js";
import { w as Mk, c as Ot, p as Cf } from "./path.W_6FqIEh.js";
import { x as ZL, y as eP, l as n2 } from "./line.3WL5MWbk.js";
import "../locales/en.js";
function tP(e, t) {
  let n = 0, i, r = 0, a = 0;
  if (t === void 0)
    for (let s of e)
      s != null && (s = +s) >= s && (i = s - r, r += i / ++n, a += i * (s - r));
  else {
    let s = -1;
    for (let o of e)
      (o = t(o, ++s, e)) != null && (o = +o) >= o && (i = o - r, r += i / ++n, a += i * (o - r));
  }
  if (n > 1)
    return a / (n - 1);
}
function nP(e, t) {
  const n = tP(e, t);
  return n && Math.sqrt(n);
}
class Zt {
  constructor() {
    this._partials = new Float64Array(32), this._n = 0;
  }
  add(t) {
    const n = this._partials;
    let i = 0;
    for (let r = 0; r < this._n && r < 32; r++) {
      const a = n[r], s = t + a, o = Math.abs(t) < Math.abs(a) ? t - (s - a) : a - (s - t);
      o && (n[i++] = o), t = s;
    }
    return n[i] = t, this._n = i + 1, this;
  }
  valueOf() {
    const t = this._partials;
    let n = this._n, i, r, a, s = 0;
    if (n > 0) {
      for (s = t[--n]; n > 0 && (i = s, r = t[--n], s = i + r, a = r - (s - i), !a); )
        ;
      n > 0 && (a < 0 && t[n - 1] < 0 || a > 0 && t[n - 1] > 0) && (r = a * 2, i = s + r, r == i - s && (s = i));
    }
    return s;
  }
}
function iP(e, t) {
  return Array.from(t, (n) => e[n]);
}
function rP(e = Ic) {
  if (e === Ic)
    return Ok;
  if (typeof e != "function")
    throw new TypeError("compare is not a function");
  return (t, n) => {
    const i = e(t, n);
    return i || i === 0 ? i : (e(n, n) === 0) - (e(t, t) === 0);
  };
}
function Ok(e, t) {
  return (e == null || !(e >= e)) - (t == null || !(t >= t)) || (e < t ? -1 : e > t ? 1 : 0);
}
function Rk(e, t, n = 0, i = 1 / 0, r) {
  if (t = Math.floor(t), n = Math.floor(Math.max(0, n)), i = Math.floor(Math.min(e.length - 1, i)), !(n <= t && t <= i))
    return e;
  for (r = r === void 0 ? Ok : rP(r); i > n; ) {
    if (i - n > 600) {
      const u = i - n + 1, l = t - n + 1, c = Math.log(u), f = 0.5 * Math.exp(2 * c / 3), d = 0.5 * Math.sqrt(c * f * (u - f) / u) * (l - u / 2 < 0 ? -1 : 1), h = Math.max(n, Math.floor(t - l * f / u + d)), p = Math.min(i, Math.floor(t + (u - l) * f / u + d));
      Rk(e, t, h, p, r);
    }
    const a = e[t];
    let s = n, o = i;
    for (Cl(e, n, t), r(e[i], a) > 0 && Cl(e, n, i); s < o; ) {
      for (Cl(e, s, o), ++s, --o; r(e[s], a) < 0; )
        ++s;
      for (; r(e[o], a) > 0; )
        --o;
    }
    r(e[n], a) === 0 ? Cl(e, n, o) : (++o, Cl(e, o, i)), o <= t && (n = o + 1), t <= o && (i = o - 1);
  }
  return e;
}
function Cl(e, t, n) {
  const i = e[t];
  e[t] = e[n], e[n] = i;
}
function Ny(e, t, n) {
  if (e = Float64Array.from(vL(e, n)), !(!(i = e.length) || isNaN(t = +t))) {
    if (t <= 0 || i < 2)
      return Ry(e);
    if (t >= 1)
      return Ws(e);
    var i, r = (i - 1) * t, a = Math.floor(r), s = Ws(Rk(e, a).subarray(0, a + 1)), o = Ry(e.subarray(a + 1));
    return s + (o - s) * (r - a);
  }
}
function Tk(e, t, n = xL) {
  if (!(!(i = e.length) || isNaN(t = +t))) {
    if (t <= 0 || i < 2)
      return +n(e[0], 0, e);
    if (t >= 1)
      return +n(e[i - 1], i - 1, e);
    var i, r = (i - 1) * t, a = Math.floor(r), s = +n(e[a], a, e), o = +n(e[a + 1], a + 1, e);
    return s + (o - s) * (r - a);
  }
}
function aP(e, t) {
  let n = 0, i = 0;
  if (t === void 0)
    for (let r of e)
      r != null && (r = +r) >= r && (++n, i += r);
  else {
    let r = -1;
    for (let a of e)
      (a = t(a, ++r, e)) != null && (a = +a) >= a && (++n, i += a);
  }
  if (n)
    return i / n;
}
function Dk(e, t) {
  return Ny(e, 0.5, t);
}
function* sP(e) {
  for (const t of e)
    yield* t;
}
function Nk(e) {
  return Array.from(sP(e));
}
function Lk(e, t) {
  let n = 0;
  if (t === void 0)
    for (let i of e)
      (i = +i) && (n += i);
  else {
    let i = -1;
    for (let r of e)
      (r = +t(r, ++i, e)) && (n += r);
  }
  return n;
}
function oP(e, ...t) {
  e = new Ba(e), t = t.map(uP);
  e:
    for (const n of e)
      for (const i of t)
        if (!i.has(n)) {
          e.delete(n);
          continue e;
        }
  return e;
}
function uP(e) {
  return e instanceof Ba ? e : new Ba(e);
}
function lP(...e) {
  const t = new Ba();
  for (const n of e)
    for (const i of n)
      t.add(i);
  return t;
}
var Pk = -0.14861, i2 = 1.78277, r2 = -0.29227, jg = -0.90649, jc = 1.97294, x5 = jc * jg, $5 = jc * i2, w5 = i2 * r2 - jg * Pk;
function cP(e) {
  if (e instanceof Hs)
    return new Hs(e.h, e.s, e.l, e.opacity);
  e instanceof fk || (e = OL(e));
  var t = e.r / 255, n = e.g / 255, i = e.b / 255, r = (w5 * i + x5 * t - $5 * n) / (w5 + x5 - $5), a = i - r, s = (jc * (n - r) - r2 * a) / jg, o = Math.sqrt(s * s + a * a) / (jc * r * (1 - r)), u = o ? Math.atan2(s, a) * aL - 120 : NaN;
  return new Hs(u < 0 ? u + 360 : u, o, r, e.opacity);
}
function Ly(e, t, n, i) {
  return arguments.length === 1 ? cP(e) : new Hs(e, t, n, i ?? 1);
}
function Hs(e, t, n, i) {
  this.h = +e, this.s = +t, this.l = +n, this.opacity = +i;
}
RL(Hs, Ly, TL(DL, {
  brighter(e) {
    return e = e == null ? b5 : Math.pow(b5, e), new Hs(this.h, this.s, this.l * e, this.opacity);
  },
  darker(e) {
    return e = e == null ? v5 : Math.pow(v5, e), new Hs(this.h, this.s, this.l * e, this.opacity);
  },
  rgb() {
    var e = isNaN(this.h) ? 0 : (this.h + 120) * rL, t = +this.l, n = isNaN(this.s) ? 0 : this.s * t * (1 - t), i = Math.cos(e), r = Math.sin(e);
    return new fk(
      255 * (t + n * (Pk * i + i2 * r)),
      255 * (t + n * (r2 * i + jg * r)),
      255 * (t + n * (jc * i)),
      this.opacity
    );
  }
}));
function fP(e) {
  var t = e.length;
  return function(n) {
    return e[Math.max(0, Math.min(t - 1, Math.floor(n * t)))];
  };
}
function dP(e, t) {
  var n = e2(+e, +t);
  return function(i) {
    var r = n(i);
    return r - 360 * Math.floor(r / 360);
  };
}
var hP = 1e-12;
function E5(e) {
  return ((e = Math.exp(e)) + 1 / e) / 2;
}
function pP(e) {
  return ((e = Math.exp(e)) - 1 / e) / 2;
}
function gP(e) {
  return ((e = Math.exp(2 * e)) - 1) / (e + 1);
}
const mP = function e(t, n, i) {
  function r(a, s) {
    var o = a[0], u = a[1], l = a[2], c = s[0], f = s[1], d = s[2], h = c - o, p = f - u, g = h * h + p * p, m, y;
    if (g < hP)
      y = Math.log(d / l) / t, m = function($) {
        return [
          o + $ * h,
          u + $ * p,
          l * Math.exp(t * $ * y)
        ];
      };
    else {
      var b = Math.sqrt(g), v = (d * d - l * l + i * g) / (2 * l * n * b), x = (d * d - l * l - i * g) / (2 * d * n * b), w = Math.log(Math.sqrt(v * v + 1) - v), E = Math.log(Math.sqrt(x * x + 1) - x);
      y = (E - w) / t, m = function($) {
        var S = $ * y, A = E5(w), k = l / (n * b) * (A * gP(t * S + w) - pP(w));
        return [
          o + k * h,
          u + k * p,
          l * A / E5(t * S + w)
        ];
      };
    }
    return m.duration = y * 1e3 * t / Math.SQRT2, m;
  }
  return r.rho = function(a) {
    var s = Math.max(1e-3, +a), o = s * s, u = o * o;
    return e(s, o, u);
  }, r;
}(Math.SQRT2, 2, 4);
function zk(e) {
  return function(t, n) {
    var i = e((t = np(t)).h, (n = np(n)).h), r = Hn(t.s, n.s), a = Hn(t.l, n.l), s = Hn(t.opacity, n.opacity);
    return function(o) {
      return t.h = i(o), t.s = r(o), t.l = a(o), t.opacity = s(o), t + "";
    };
  };
}
const yP = zk(e2);
var bP = zk(Hn);
function vP(e, t) {
  var n = Hn((e = tp(e)).l, (t = tp(t)).l), i = Hn(e.a, t.a), r = Hn(e.b, t.b), a = Hn(e.opacity, t.opacity);
  return function(s) {
    return e.l = n(s), e.a = i(s), e.b = r(s), e.opacity = a(s), e + "";
  };
}
function Ik(e) {
  return function t(n) {
    n = +n;
    function i(r, a) {
      var s = e((r = Ly(r)).h, (a = Ly(a)).h), o = Hn(r.s, a.s), u = Hn(r.l, a.l), l = Hn(r.opacity, a.opacity);
      return function(c) {
        return r.h = s(c), r.s = o(c), r.l = u(Math.pow(c, n)), r.opacity = l(c), r + "";
      };
    }
    return i.gamma = t, i;
  }(1);
}
const xP = Ik(e2);
var $P = Ik(Hn);
function Xu(e, t) {
  t === void 0 && (t = e, e = kf);
  for (var n = 0, i = t.length - 1, r = t[0], a = new Array(i < 0 ? 0 : i); n < i; )
    a[n] = e(r, r = t[++n]);
  return function(s) {
    var o = Math.max(0, Math.min(i - 1, Math.floor(s *= i)));
    return a[o](s - o);
  };
}
function wP(e, t) {
  for (var n = new Array(t), i = 0; i < t; ++i)
    n[i] = e(i / (t - 1));
  return n;
}
const Ug = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  interpolate: kf,
  interpolateArray: $L,
  interpolateBasis: NL,
  interpolateBasisClosed: LL,
  interpolateCubehelix: xP,
  interpolateCubehelixLong: $P,
  interpolateDate: wL,
  interpolateDiscrete: fP,
  interpolateHcl: sL,
  interpolateHclLong: oL,
  interpolateHsl: yP,
  interpolateHslLong: bP,
  interpolateHue: dP,
  interpolateLab: vP,
  interpolateNumber: PL,
  interpolateNumberArray: EL,
  interpolateObject: SL,
  interpolateRgb: zL,
  interpolateRgbBasis: IL,
  interpolateRgbBasisClosed: BL,
  interpolateRound: zg,
  interpolateString: jL,
  interpolateTransformCss: UL,
  interpolateTransformSvg: qL,
  interpolateZoom: mP,
  piecewise: Xu,
  quantize: wP
}, Symbol.toStringTag, { value: "Module" }));
function EP(e, t, n) {
  var i = new WL(), r = t;
  return t == null ? (i.restart(e, t, n), i) : (i._restart = i.restart, i.restart = function(a, s, o) {
    s = +s, o = o == null ? GL() : +o, i._restart(function u(l) {
      l += r, i._restart(u, r += s, o), a(l);
    }, s, o);
  }, i.restart(e, t, n), i);
}
const Ur = 11102230246251565e-32, Ft = 134217729, SP = (3 + 8 * Ur) * Ur;
function l1(e, t, n, i, r) {
  let a, s, o, u, l = t[0], c = i[0], f = 0, d = 0;
  c > l == c > -l ? (a = l, l = t[++f]) : (a = c, c = i[++d]);
  let h = 0;
  if (f < e && d < n)
    for (c > l == c > -l ? (s = l + a, o = a - (s - l), l = t[++f]) : (s = c + a, o = a - (s - c), c = i[++d]), a = s, o !== 0 && (r[h++] = o); f < e && d < n; )
      c > l == c > -l ? (s = a + l, u = s - a, o = a - (s - u) + (l - u), l = t[++f]) : (s = a + c, u = s - a, o = a - (s - u) + (c - u), c = i[++d]), a = s, o !== 0 && (r[h++] = o);
  for (; f < e; )
    s = a + l, u = s - a, o = a - (s - u) + (l - u), l = t[++f], a = s, o !== 0 && (r[h++] = o);
  for (; d < n; )
    s = a + c, u = s - a, o = a - (s - u) + (c - u), c = i[++d], a = s, o !== 0 && (r[h++] = o);
  return (a !== 0 || h === 0) && (r[h++] = a), h;
}
function AP(e, t) {
  let n = t[0];
  for (let i = 1; i < e; i++)
    n += t[i];
  return n;
}
function _f(e) {
  return new Float64Array(e);
}
const kP = (3 + 16 * Ur) * Ur, CP = (2 + 12 * Ur) * Ur, _P = (9 + 64 * Ur) * Ur * Ur, Io = _f(4), S5 = _f(8), A5 = _f(12), k5 = _f(16), qt = _f(4);
function FP(e, t, n, i, r, a, s) {
  let o, u, l, c, f, d, h, p, g, m, y, b, v, x, w, E, $, S;
  const A = e - r, k = n - r, _ = t - a, P = i - a;
  x = A * P, d = Ft * A, h = d - (d - A), p = A - h, d = Ft * P, g = d - (d - P), m = P - g, w = p * m - (x - h * g - p * g - h * m), E = _ * k, d = Ft * _, h = d - (d - _), p = _ - h, d = Ft * k, g = d - (d - k), m = k - g, $ = p * m - (E - h * g - p * g - h * m), y = w - $, f = w - y, Io[0] = w - (y + f) + (f - $), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - E, f = v - y, Io[1] = v - (y + f) + (f - E), S = b + y, f = S - b, Io[2] = b - (S - f) + (y - f), Io[3] = S;
  let F = AP(4, Io), M = CP * s;
  if (F >= M || -F >= M || (f = e - A, o = e - (A + f) + (f - r), f = n - k, l = n - (k + f) + (f - r), f = t - _, u = t - (_ + f) + (f - a), f = i - P, c = i - (P + f) + (f - a), o === 0 && u === 0 && l === 0 && c === 0) || (M = _P * s + SP * Math.abs(F), F += A * c + P * o - (_ * l + k * u), F >= M || -F >= M))
    return F;
  x = o * P, d = Ft * o, h = d - (d - o), p = o - h, d = Ft * P, g = d - (d - P), m = P - g, w = p * m - (x - h * g - p * g - h * m), E = u * k, d = Ft * u, h = d - (d - u), p = u - h, d = Ft * k, g = d - (d - k), m = k - g, $ = p * m - (E - h * g - p * g - h * m), y = w - $, f = w - y, qt[0] = w - (y + f) + (f - $), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - E, f = v - y, qt[1] = v - (y + f) + (f - E), S = b + y, f = S - b, qt[2] = b - (S - f) + (y - f), qt[3] = S;
  const C = l1(4, Io, 4, qt, S5);
  x = A * c, d = Ft * A, h = d - (d - A), p = A - h, d = Ft * c, g = d - (d - c), m = c - g, w = p * m - (x - h * g - p * g - h * m), E = _ * l, d = Ft * _, h = d - (d - _), p = _ - h, d = Ft * l, g = d - (d - l), m = l - g, $ = p * m - (E - h * g - p * g - h * m), y = w - $, f = w - y, qt[0] = w - (y + f) + (f - $), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - E, f = v - y, qt[1] = v - (y + f) + (f - E), S = b + y, f = S - b, qt[2] = b - (S - f) + (y - f), qt[3] = S;
  const O = l1(C, S5, 4, qt, A5);
  x = o * c, d = Ft * o, h = d - (d - o), p = o - h, d = Ft * c, g = d - (d - c), m = c - g, w = p * m - (x - h * g - p * g - h * m), E = u * l, d = Ft * u, h = d - (d - u), p = u - h, d = Ft * l, g = d - (d - l), m = l - g, $ = p * m - (E - h * g - p * g - h * m), y = w - $, f = w - y, qt[0] = w - (y + f) + (f - $), b = x + y, f = b - x, v = x - (b - f) + (y - f), y = v - E, f = v - y, qt[1] = v - (y + f) + (f - E), S = b + y, f = S - b, qt[2] = b - (S - f) + (y - f), qt[3] = S;
  const L = l1(O, A5, 4, qt, k5);
  return k5[L - 1];
}
function jd(e, t, n, i, r, a) {
  const s = (t - a) * (n - r), o = (e - r) * (i - a), u = s - o, l = Math.abs(s + o);
  return Math.abs(u) >= kP * l ? u : -FP(e, t, n, i, r, a, l);
}
const C5 = Math.pow(2, -52), Ud = new Uint32Array(512);
class ip {
  static from(t, n = DP, i = NP) {
    const r = t.length, a = new Float64Array(r * 2);
    for (let s = 0; s < r; s++) {
      const o = t[s];
      a[2 * s] = n(o), a[2 * s + 1] = i(o);
    }
    return new ip(a);
  }
  constructor(t) {
    const n = t.length >> 1;
    if (n > 0 && typeof t[0] != "number")
      throw new Error("Expected coords to contain numbers.");
    this.coords = t;
    const i = Math.max(2 * n - 5, 0);
    this._triangles = new Uint32Array(i * 3), this._halfedges = new Int32Array(i * 3), this._hashSize = Math.ceil(Math.sqrt(n)), this._hullPrev = new Uint32Array(n), this._hullNext = new Uint32Array(n), this._hullTri = new Uint32Array(n), this._hullHash = new Int32Array(this._hashSize).fill(-1), this._ids = new Uint32Array(n), this._dists = new Float64Array(n), this.update();
  }
  update() {
    const { coords: t, _hullPrev: n, _hullNext: i, _hullTri: r, _hullHash: a } = this, s = t.length >> 1;
    let o = 1 / 0, u = 1 / 0, l = -1 / 0, c = -1 / 0;
    for (let k = 0; k < s; k++) {
      const _ = t[2 * k], P = t[2 * k + 1];
      _ < o && (o = _), P < u && (u = P), _ > l && (l = _), P > c && (c = P), this._ids[k] = k;
    }
    const f = (o + l) / 2, d = (u + c) / 2;
    let h = 1 / 0, p, g, m;
    for (let k = 0; k < s; k++) {
      const _ = c1(f, d, t[2 * k], t[2 * k + 1]);
      _ < h && (p = k, h = _);
    }
    const y = t[2 * p], b = t[2 * p + 1];
    h = 1 / 0;
    for (let k = 0; k < s; k++) {
      if (k === p)
        continue;
      const _ = c1(y, b, t[2 * k], t[2 * k + 1]);
      _ < h && _ > 0 && (g = k, h = _);
    }
    let v = t[2 * g], x = t[2 * g + 1], w = 1 / 0;
    for (let k = 0; k < s; k++) {
      if (k === p || k === g)
        continue;
      const _ = RP(y, b, v, x, t[2 * k], t[2 * k + 1]);
      _ < w && (m = k, w = _);
    }
    let E = t[2 * m], $ = t[2 * m + 1];
    if (w === 1 / 0) {
      for (let P = 0; P < s; P++)
        this._dists[P] = t[2 * P] - t[0] || t[2 * P + 1] - t[1];
      tu(this._ids, this._dists, 0, s - 1);
      const k = new Uint32Array(s);
      let _ = 0;
      for (let P = 0, F = -1 / 0; P < s; P++) {
        const M = this._ids[P];
        this._dists[M] > F && (k[_++] = M, F = this._dists[M]);
      }
      this.hull = k.subarray(0, _), this.triangles = new Uint32Array(0), this.halfedges = new Uint32Array(0);
      return;
    }
    if (jd(y, b, v, x, E, $) < 0) {
      const k = g, _ = v, P = x;
      g = m, v = E, x = $, m = k, E = _, $ = P;
    }
    const S = TP(y, b, v, x, E, $);
    this._cx = S.x, this._cy = S.y;
    for (let k = 0; k < s; k++)
      this._dists[k] = c1(t[2 * k], t[2 * k + 1], S.x, S.y);
    tu(this._ids, this._dists, 0, s - 1), this._hullStart = p;
    let A = 3;
    i[p] = n[m] = g, i[g] = n[p] = m, i[m] = n[g] = p, r[p] = 0, r[g] = 1, r[m] = 2, a.fill(-1), a[this._hashKey(y, b)] = p, a[this._hashKey(v, x)] = g, a[this._hashKey(E, $)] = m, this.trianglesLen = 0, this._addTriangle(p, g, m, -1, -1, -1);
    for (let k = 0, _, P; k < this._ids.length; k++) {
      const F = this._ids[k], M = t[2 * F], C = t[2 * F + 1];
      if (k > 0 && Math.abs(M - _) <= C5 && Math.abs(C - P) <= C5 || (_ = M, P = C, F === p || F === g || F === m))
        continue;
      let O = 0;
      for (let ie = 0, de = this._hashKey(M, C); ie < this._hashSize && (O = a[(de + ie) % this._hashSize], !(O !== -1 && O !== i[O])); ie++)
        ;
      O = n[O];
      let L = O, z;
      for (; z = i[L], jd(M, C, t[2 * L], t[2 * L + 1], t[2 * z], t[2 * z + 1]) >= 0; )
        if (L = z, L === O) {
          L = -1;
          break;
        }
      if (L === -1)
        continue;
      let W = this._addTriangle(L, F, i[L], -1, -1, r[L]);
      r[F] = this._legalize(W + 2), r[L] = W, A++;
      let J = i[L];
      for (; z = i[J], jd(M, C, t[2 * J], t[2 * J + 1], t[2 * z], t[2 * z + 1]) < 0; )
        W = this._addTriangle(J, F, z, r[F], -1, r[J]), r[F] = this._legalize(W + 2), i[J] = J, A--, J = z;
      if (L === O)
        for (; z = n[L], jd(M, C, t[2 * z], t[2 * z + 1], t[2 * L], t[2 * L + 1]) < 0; )
          W = this._addTriangle(z, F, L, -1, r[L], r[z]), this._legalize(W + 2), r[z] = W, i[L] = L, A--, L = z;
      this._hullStart = n[F] = L, i[L] = n[J] = F, i[F] = J, a[this._hashKey(M, C)] = F, a[this._hashKey(t[2 * L], t[2 * L + 1])] = L;
    }
    this.hull = new Uint32Array(A);
    for (let k = 0, _ = this._hullStart; k < A; k++)
      this.hull[k] = _, _ = i[_];
    this.triangles = this._triangles.subarray(0, this.trianglesLen), this.halfedges = this._halfedges.subarray(0, this.trianglesLen);
  }
  _hashKey(t, n) {
    return Math.floor(MP(t - this._cx, n - this._cy) * this._hashSize) % this._hashSize;
  }
  _legalize(t) {
    const { _triangles: n, _halfedges: i, coords: r } = this;
    let a = 0, s = 0;
    for (; ; ) {
      const o = i[t], u = t - t % 3;
      if (s = u + (t + 2) % 3, o === -1) {
        if (a === 0)
          break;
        t = Ud[--a];
        continue;
      }
      const l = o - o % 3, c = u + (t + 1) % 3, f = l + (o + 2) % 3, d = n[s], h = n[t], p = n[c], g = n[f];
      if (OP(
        r[2 * d],
        r[2 * d + 1],
        r[2 * h],
        r[2 * h + 1],
        r[2 * p],
        r[2 * p + 1],
        r[2 * g],
        r[2 * g + 1]
      )) {
        n[t] = g, n[o] = d;
        const y = i[f];
        if (y === -1) {
          let v = this._hullStart;
          do {
            if (this._hullTri[v] === f) {
              this._hullTri[v] = t;
              break;
            }
            v = this._hullPrev[v];
          } while (v !== this._hullStart);
        }
        this._link(t, y), this._link(o, i[s]), this._link(s, f);
        const b = l + (o + 1) % 3;
        a < Ud.length && (Ud[a++] = b);
      } else {
        if (a === 0)
          break;
        t = Ud[--a];
      }
    }
    return s;
  }
  _link(t, n) {
    this._halfedges[t] = n, n !== -1 && (this._halfedges[n] = t);
  }
  // add a new triangle given vertex indices and adjacent half-edge ids
  _addTriangle(t, n, i, r, a, s) {
    const o = this.trianglesLen;
    return this._triangles[o] = t, this._triangles[o + 1] = n, this._triangles[o + 2] = i, this._link(o, r), this._link(o + 1, a), this._link(o + 2, s), this.trianglesLen += 3, o;
  }
}
function MP(e, t) {
  const n = e / (Math.abs(e) + Math.abs(t));
  return (t > 0 ? 3 - n : 1 + n) / 4;
}
function c1(e, t, n, i) {
  const r = e - n, a = t - i;
  return r * r + a * a;
}
function OP(e, t, n, i, r, a, s, o) {
  const u = e - s, l = t - o, c = n - s, f = i - o, d = r - s, h = a - o, p = u * u + l * l, g = c * c + f * f, m = d * d + h * h;
  return u * (f * m - g * h) - l * (c * m - g * d) + p * (c * h - f * d) < 0;
}
function RP(e, t, n, i, r, a) {
  const s = n - e, o = i - t, u = r - e, l = a - t, c = s * s + o * o, f = u * u + l * l, d = 0.5 / (s * l - o * u), h = (l * c - o * f) * d, p = (s * f - u * c) * d;
  return h * h + p * p;
}
function TP(e, t, n, i, r, a) {
  const s = n - e, o = i - t, u = r - e, l = a - t, c = s * s + o * o, f = u * u + l * l, d = 0.5 / (s * l - o * u), h = e + (l * c - o * f) * d, p = t + (s * f - u * c) * d;
  return { x: h, y: p };
}
function tu(e, t, n, i) {
  if (i - n <= 20)
    for (let r = n + 1; r <= i; r++) {
      const a = e[r], s = t[a];
      let o = r - 1;
      for (; o >= n && t[e[o]] > s; )
        e[o + 1] = e[o--];
      e[o + 1] = a;
    }
  else {
    const r = n + i >> 1;
    let a = n + 1, s = i;
    _l(e, r, a), t[e[n]] > t[e[i]] && _l(e, n, i), t[e[a]] > t[e[i]] && _l(e, a, i), t[e[n]] > t[e[a]] && _l(e, n, a);
    const o = e[a], u = t[o];
    for (; ; ) {
      do
        a++;
      while (t[e[a]] < u);
      do
        s--;
      while (t[e[s]] > u);
      if (s < a)
        break;
      _l(e, a, s);
    }
    e[n + 1] = e[s], e[s] = o, i - a + 1 >= s - n ? (tu(e, t, a, i), tu(e, t, n, s - 1)) : (tu(e, t, n, s - 1), tu(e, t, a, i));
  }
}
function _l(e, t, n) {
  const i = e[t];
  e[t] = e[n], e[n] = i;
}
function DP(e) {
  return e[0];
}
function NP(e) {
  return e[1];
}
const _5 = 1e-6;
class Is {
  constructor() {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null, this._ = "";
  }
  moveTo(t, n) {
    this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}`;
  }
  closePath() {
    this._x1 !== null && (this._x1 = this._x0, this._y1 = this._y0, this._ += "Z");
  }
  lineTo(t, n) {
    this._ += `L${this._x1 = +t},${this._y1 = +n}`;
  }
  arc(t, n, i) {
    t = +t, n = +n, i = +i;
    const r = t + i, a = n;
    if (i < 0)
      throw new Error("negative radius");
    this._x1 === null ? this._ += `M${r},${a}` : (Math.abs(this._x1 - r) > _5 || Math.abs(this._y1 - a) > _5) && (this._ += "L" + r + "," + a), i && (this._ += `A${i},${i},0,1,1,${t - i},${n}A${i},${i},0,1,1,${this._x1 = r},${this._y1 = a}`);
  }
  rect(t, n, i, r) {
    this._ += `M${this._x0 = this._x1 = +t},${this._y0 = this._y1 = +n}h${+i}v${+r}h${-i}Z`;
  }
  value() {
    return this._ || null;
  }
}
class Py {
  constructor() {
    this._ = [];
  }
  moveTo(t, n) {
    this._.push([t, n]);
  }
  closePath() {
    this._.push(this._[0].slice());
  }
  lineTo(t, n) {
    this._.push([t, n]);
  }
  value() {
    return this._.length ? this._ : null;
  }
}
let LP = class {
  constructor(t, [n, i, r, a] = [0, 0, 960, 500]) {
    if (!((r = +r) >= (n = +n)) || !((a = +a) >= (i = +i)))
      throw new Error("invalid bounds");
    this.delaunay = t, this._circumcenters = new Float64Array(t.points.length * 2), this.vectors = new Float64Array(t.points.length * 2), this.xmax = r, this.xmin = n, this.ymax = a, this.ymin = i, this._init();
  }
  update() {
    return this.delaunay.update(), this._init(), this;
  }
  _init() {
    const { delaunay: { points: t, hull: n, triangles: i }, vectors: r } = this;
    let a, s;
    const o = this.circumcenters = this._circumcenters.subarray(0, i.length / 3 * 2);
    for (let g = 0, m = 0, y = i.length, b, v; g < y; g += 3, m += 2) {
      const x = i[g] * 2, w = i[g + 1] * 2, E = i[g + 2] * 2, $ = t[x], S = t[x + 1], A = t[w], k = t[w + 1], _ = t[E], P = t[E + 1], F = A - $, M = k - S, C = _ - $, O = P - S, L = (F * O - M * C) * 2;
      if (Math.abs(L) < 1e-9) {
        if (a === void 0) {
          a = s = 0;
          for (const W of n)
            a += t[W * 2], s += t[W * 2 + 1];
          a /= n.length, s /= n.length;
        }
        const z = 1e9 * Math.sign((a - $) * O - (s - S) * C);
        b = ($ + _) / 2 - z * O, v = (S + P) / 2 + z * C;
      } else {
        const z = 1 / L, W = F * F + M * M, J = C * C + O * O;
        b = $ + (O * W - M * J) * z, v = S + (F * J - C * W) * z;
      }
      o[m] = b, o[m + 1] = v;
    }
    let u = n[n.length - 1], l, c = u * 4, f, d = t[2 * u], h, p = t[2 * u + 1];
    r.fill(0);
    for (let g = 0; g < n.length; ++g)
      u = n[g], l = c, f = d, h = p, c = u * 4, d = t[2 * u], p = t[2 * u + 1], r[l + 2] = r[c] = h - p, r[l + 3] = r[c + 1] = d - f;
  }
  render(t) {
    const n = t == null ? t = new Is() : void 0, { delaunay: { halfedges: i, inedges: r, hull: a }, circumcenters: s, vectors: o } = this;
    if (a.length <= 1)
      return null;
    for (let c = 0, f = i.length; c < f; ++c) {
      const d = i[c];
      if (d < c)
        continue;
      const h = Math.floor(c / 3) * 2, p = Math.floor(d / 3) * 2, g = s[h], m = s[h + 1], y = s[p], b = s[p + 1];
      this._renderSegment(g, m, y, b, t);
    }
    let u, l = a[a.length - 1];
    for (let c = 0; c < a.length; ++c) {
      u = l, l = a[c];
      const f = Math.floor(r[l] / 3) * 2, d = s[f], h = s[f + 1], p = u * 4, g = this._project(d, h, o[p + 2], o[p + 3]);
      g && this._renderSegment(d, h, g[0], g[1], t);
    }
    return n && n.value();
  }
  renderBounds(t) {
    const n = t == null ? t = new Is() : void 0;
    return t.rect(this.xmin, this.ymin, this.xmax - this.xmin, this.ymax - this.ymin), n && n.value();
  }
  renderCell(t, n) {
    const i = n == null ? n = new Is() : void 0, r = this._clip(t);
    if (r === null || !r.length)
      return;
    n.moveTo(r[0], r[1]);
    let a = r.length;
    for (; r[0] === r[a - 2] && r[1] === r[a - 1] && a > 1; )
      a -= 2;
    for (let s = 2; s < a; s += 2)
      (r[s] !== r[s - 2] || r[s + 1] !== r[s - 1]) && n.lineTo(r[s], r[s + 1]);
    return n.closePath(), i && i.value();
  }
  *cellPolygons() {
    const { delaunay: { points: t } } = this;
    for (let n = 0, i = t.length / 2; n < i; ++n) {
      const r = this.cellPolygon(n);
      r && (r.index = n, yield r);
    }
  }
  cellPolygon(t) {
    const n = new Py();
    return this.renderCell(t, n), n.value();
  }
  _renderSegment(t, n, i, r, a) {
    let s;
    const o = this._regioncode(t, n), u = this._regioncode(i, r);
    o === 0 && u === 0 ? (a.moveTo(t, n), a.lineTo(i, r)) : (s = this._clipSegment(t, n, i, r, o, u)) && (a.moveTo(s[0], s[1]), a.lineTo(s[2], s[3]));
  }
  contains(t, n, i) {
    return n = +n, n !== n || (i = +i, i !== i) ? !1 : this.delaunay._step(t, n, i) === t;
  }
  *neighbors(t) {
    const n = this._clip(t);
    if (n)
      for (const i of this.delaunay.neighbors(t)) {
        const r = this._clip(i);
        if (r) {
          e:
            for (let a = 0, s = n.length; a < s; a += 2)
              for (let o = 0, u = r.length; o < u; o += 2)
                if (n[a] === r[o] && n[a + 1] === r[o + 1] && n[(a + 2) % s] === r[(o + u - 2) % u] && n[(a + 3) % s] === r[(o + u - 1) % u]) {
                  yield i;
                  break e;
                }
        }
      }
  }
  _cell(t) {
    const { circumcenters: n, delaunay: { inedges: i, halfedges: r, triangles: a } } = this, s = i[t];
    if (s === -1)
      return null;
    const o = [];
    let u = s;
    do {
      const l = Math.floor(u / 3);
      if (o.push(n[l * 2], n[l * 2 + 1]), u = u % 3 === 2 ? u - 2 : u + 1, a[u] !== t)
        break;
      u = r[u];
    } while (u !== s && u !== -1);
    return o;
  }
  _clip(t) {
    if (t === 0 && this.delaunay.hull.length === 1)
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    const n = this._cell(t);
    if (n === null)
      return null;
    const { vectors: i } = this, r = t * 4;
    return this._simplify(i[r] || i[r + 1] ? this._clipInfinite(t, n, i[r], i[r + 1], i[r + 2], i[r + 3]) : this._clipFinite(t, n));
  }
  _clipFinite(t, n) {
    const i = n.length;
    let r = null, a, s, o = n[i - 2], u = n[i - 1], l, c = this._regioncode(o, u), f, d = 0;
    for (let h = 0; h < i; h += 2)
      if (a = o, s = u, o = n[h], u = n[h + 1], l = c, c = this._regioncode(o, u), l === 0 && c === 0)
        f = d, d = 0, r ? r.push(o, u) : r = [o, u];
      else {
        let p, g, m, y, b;
        if (l === 0) {
          if ((p = this._clipSegment(a, s, o, u, l, c)) === null)
            continue;
          [g, m, y, b] = p;
        } else {
          if ((p = this._clipSegment(o, u, a, s, c, l)) === null)
            continue;
          [y, b, g, m] = p, f = d, d = this._edgecode(g, m), f && d && this._edge(t, f, d, r, r.length), r ? r.push(g, m) : r = [g, m];
        }
        f = d, d = this._edgecode(y, b), f && d && this._edge(t, f, d, r, r.length), r ? r.push(y, b) : r = [y, b];
      }
    if (r)
      f = d, d = this._edgecode(r[0], r[1]), f && d && this._edge(t, f, d, r, r.length);
    else if (this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2))
      return [this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax, this.xmin, this.ymin];
    return r;
  }
  _clipSegment(t, n, i, r, a, s) {
    const o = a < s;
    for (o && ([t, n, i, r, a, s] = [i, r, t, n, s, a]); ; ) {
      if (a === 0 && s === 0)
        return o ? [i, r, t, n] : [t, n, i, r];
      if (a & s)
        return null;
      let u, l, c = a || s;
      c & 8 ? (u = t + (i - t) * (this.ymax - n) / (r - n), l = this.ymax) : c & 4 ? (u = t + (i - t) * (this.ymin - n) / (r - n), l = this.ymin) : c & 2 ? (l = n + (r - n) * (this.xmax - t) / (i - t), u = this.xmax) : (l = n + (r - n) * (this.xmin - t) / (i - t), u = this.xmin), a ? (t = u, n = l, a = this._regioncode(t, n)) : (i = u, r = l, s = this._regioncode(i, r));
    }
  }
  _clipInfinite(t, n, i, r, a, s) {
    let o = Array.from(n), u;
    if ((u = this._project(o[0], o[1], i, r)) && o.unshift(u[0], u[1]), (u = this._project(o[o.length - 2], o[o.length - 1], a, s)) && o.push(u[0], u[1]), o = this._clipFinite(t, o))
      for (let l = 0, c = o.length, f, d = this._edgecode(o[c - 2], o[c - 1]); l < c; l += 2)
        f = d, d = this._edgecode(o[l], o[l + 1]), f && d && (l = this._edge(t, f, d, o, l), c = o.length);
    else
      this.contains(t, (this.xmin + this.xmax) / 2, (this.ymin + this.ymax) / 2) && (o = [this.xmin, this.ymin, this.xmax, this.ymin, this.xmax, this.ymax, this.xmin, this.ymax]);
    return o;
  }
  _edge(t, n, i, r, a) {
    for (; n !== i; ) {
      let s, o;
      switch (n) {
        case 5:
          n = 4;
          continue;
        case 4:
          n = 6, s = this.xmax, o = this.ymin;
          break;
        case 6:
          n = 2;
          continue;
        case 2:
          n = 10, s = this.xmax, o = this.ymax;
          break;
        case 10:
          n = 8;
          continue;
        case 8:
          n = 9, s = this.xmin, o = this.ymax;
          break;
        case 9:
          n = 1;
          continue;
        case 1:
          n = 5, s = this.xmin, o = this.ymin;
          break;
      }
      (r[a] !== s || r[a + 1] !== o) && this.contains(t, s, o) && (r.splice(a, 0, s, o), a += 2);
    }
    return a;
  }
  _project(t, n, i, r) {
    let a = 1 / 0, s, o, u;
    if (r < 0) {
      if (n <= this.ymin)
        return null;
      (s = (this.ymin - n) / r) < a && (u = this.ymin, o = t + (a = s) * i);
    } else if (r > 0) {
      if (n >= this.ymax)
        return null;
      (s = (this.ymax - n) / r) < a && (u = this.ymax, o = t + (a = s) * i);
    }
    if (i > 0) {
      if (t >= this.xmax)
        return null;
      (s = (this.xmax - t) / i) < a && (o = this.xmax, u = n + (a = s) * r);
    } else if (i < 0) {
      if (t <= this.xmin)
        return null;
      (s = (this.xmin - t) / i) < a && (o = this.xmin, u = n + (a = s) * r);
    }
    return [o, u];
  }
  _edgecode(t, n) {
    return (t === this.xmin ? 1 : t === this.xmax ? 2 : 0) | (n === this.ymin ? 4 : n === this.ymax ? 8 : 0);
  }
  _regioncode(t, n) {
    return (t < this.xmin ? 1 : t > this.xmax ? 2 : 0) | (n < this.ymin ? 4 : n > this.ymax ? 8 : 0);
  }
  _simplify(t) {
    if (t && t.length > 4) {
      for (let n = 0; n < t.length; n += 2) {
        const i = (n + 2) % t.length, r = (n + 4) % t.length;
        (t[n] === t[i] && t[i] === t[r] || t[n + 1] === t[i + 1] && t[i + 1] === t[r + 1]) && (t.splice(i, 2), n -= 2);
      }
      t.length || (t = null);
    }
    return t;
  }
};
const PP = 2 * Math.PI, Bo = Math.pow;
function zP(e) {
  return e[0];
}
function IP(e) {
  return e[1];
}
function BP(e) {
  const { triangles: t, coords: n } = e;
  for (let i = 0; i < t.length; i += 3) {
    const r = 2 * t[i], a = 2 * t[i + 1], s = 2 * t[i + 2];
    if ((n[s] - n[r]) * (n[a + 1] - n[r + 1]) - (n[a] - n[r]) * (n[s + 1] - n[r + 1]) > 1e-10)
      return !1;
  }
  return !0;
}
function jP(e, t, n) {
  return [e + Math.sin(e + t) * n, t + Math.cos(e - t) * n];
}
class a2 {
  static from(t, n = zP, i = IP, r) {
    return new a2("length" in t ? UP(t, n, i, r) : Float64Array.from(qP(t, n, i, r)));
  }
  constructor(t) {
    this._delaunator = new ip(t), this.inedges = new Int32Array(t.length / 2), this._hullIndex = new Int32Array(t.length / 2), this.points = this._delaunator.coords, this._init();
  }
  update() {
    return this._delaunator.update(), this._init(), this;
  }
  _init() {
    const t = this._delaunator, n = this.points;
    if (t.hull && t.hull.length > 2 && BP(t)) {
      this.collinear = Int32Array.from({ length: n.length / 2 }, (d, h) => h).sort((d, h) => n[2 * d] - n[2 * h] || n[2 * d + 1] - n[2 * h + 1]);
      const u = this.collinear[0], l = this.collinear[this.collinear.length - 1], c = [n[2 * u], n[2 * u + 1], n[2 * l], n[2 * l + 1]], f = 1e-8 * Math.hypot(c[3] - c[1], c[2] - c[0]);
      for (let d = 0, h = n.length / 2; d < h; ++d) {
        const p = jP(n[2 * d], n[2 * d + 1], f);
        n[2 * d] = p[0], n[2 * d + 1] = p[1];
      }
      this._delaunator = new ip(n);
    } else
      delete this.collinear;
    const i = this.halfedges = this._delaunator.halfedges, r = this.hull = this._delaunator.hull, a = this.triangles = this._delaunator.triangles, s = this.inedges.fill(-1), o = this._hullIndex.fill(-1);
    for (let u = 0, l = i.length; u < l; ++u) {
      const c = a[u % 3 === 2 ? u - 2 : u + 1];
      (i[u] === -1 || s[c] === -1) && (s[c] = u);
    }
    for (let u = 0, l = r.length; u < l; ++u)
      o[r[u]] = u;
    r.length <= 2 && r.length > 0 && (this.triangles = new Int32Array(3).fill(-1), this.halfedges = new Int32Array(3).fill(-1), this.triangles[0] = r[0], s[r[0]] = 1, r.length === 2 && (s[r[1]] = 0, this.triangles[1] = r[1], this.triangles[2] = r[1]));
  }
  voronoi(t) {
    return new LP(this, t);
  }
  *neighbors(t) {
    const { inedges: n, hull: i, _hullIndex: r, halfedges: a, triangles: s, collinear: o } = this;
    if (o) {
      const f = o.indexOf(t);
      f > 0 && (yield o[f - 1]), f < o.length - 1 && (yield o[f + 1]);
      return;
    }
    const u = n[t];
    if (u === -1)
      return;
    let l = u, c = -1;
    do {
      if (yield c = s[l], l = l % 3 === 2 ? l - 2 : l + 1, s[l] !== t)
        return;
      if (l = a[l], l === -1) {
        const f = i[(r[t] + 1) % i.length];
        f !== c && (yield f);
        return;
      }
    } while (l !== u);
  }
  find(t, n, i = 0) {
    if (t = +t, t !== t || (n = +n, n !== n))
      return -1;
    const r = i;
    let a;
    for (; (a = this._step(i, t, n)) >= 0 && a !== i && a !== r; )
      i = a;
    return a;
  }
  _step(t, n, i) {
    const { inedges: r, hull: a, _hullIndex: s, halfedges: o, triangles: u, points: l } = this;
    if (r[t] === -1 || !l.length)
      return (t + 1) % (l.length >> 1);
    let c = t, f = Bo(n - l[t * 2], 2) + Bo(i - l[t * 2 + 1], 2);
    const d = r[t];
    let h = d;
    do {
      let p = u[h];
      const g = Bo(n - l[p * 2], 2) + Bo(i - l[p * 2 + 1], 2);
      if (g < f && (f = g, c = p), h = h % 3 === 2 ? h - 2 : h + 1, u[h] !== t)
        break;
      if (h = o[h], h === -1) {
        if (h = a[(s[t] + 1) % a.length], h !== p && Bo(n - l[h * 2], 2) + Bo(i - l[h * 2 + 1], 2) < f)
          return h;
        break;
      }
    } while (h !== d);
    return c;
  }
  render(t) {
    const n = t == null ? t = new Is() : void 0, { points: i, halfedges: r, triangles: a } = this;
    for (let s = 0, o = r.length; s < o; ++s) {
      const u = r[s];
      if (u < s)
        continue;
      const l = a[s] * 2, c = a[u] * 2;
      t.moveTo(i[l], i[l + 1]), t.lineTo(i[c], i[c + 1]);
    }
    return this.renderHull(t), n && n.value();
  }
  renderPoints(t, n) {
    n === void 0 && (!t || typeof t.moveTo != "function") && (n = t, t = null), n = n == null ? 2 : +n;
    const i = t == null ? t = new Is() : void 0, { points: r } = this;
    for (let a = 0, s = r.length; a < s; a += 2) {
      const o = r[a], u = r[a + 1];
      t.moveTo(o + n, u), t.arc(o, u, n, 0, PP);
    }
    return i && i.value();
  }
  renderHull(t) {
    const n = t == null ? t = new Is() : void 0, { hull: i, points: r } = this, a = i[0] * 2, s = i.length;
    t.moveTo(r[a], r[a + 1]);
    for (let o = 1; o < s; ++o) {
      const u = 2 * i[o];
      t.lineTo(r[u], r[u + 1]);
    }
    return t.closePath(), n && n.value();
  }
  hullPolygon() {
    const t = new Py();
    return this.renderHull(t), t.value();
  }
  renderTriangle(t, n) {
    const i = n == null ? n = new Is() : void 0, { points: r, triangles: a } = this, s = a[t *= 3] * 2, o = a[t + 1] * 2, u = a[t + 2] * 2;
    return n.moveTo(r[s], r[s + 1]), n.lineTo(r[o], r[o + 1]), n.lineTo(r[u], r[u + 1]), n.closePath(), i && i.value();
  }
  *trianglePolygons() {
    const { triangles: t } = this;
    for (let n = 0, i = t.length / 3; n < i; ++n)
      yield this.trianglePolygon(n);
  }
  trianglePolygon(t) {
    const n = new Py();
    return this.renderTriangle(t, n), n.value();
  }
}
function UP(e, t, n, i) {
  const r = e.length, a = new Float64Array(r * 2);
  for (let s = 0; s < r; ++s) {
    const o = e[s];
    a[s * 2] = t.call(i, o, s, e), a[s * 2 + 1] = n.call(i, o, s, e);
  }
  return a;
}
function* qP(e, t, n, i) {
  let r = 0;
  for (const a of e)
    yield t.call(i, a, r, e), yield n.call(i, a, r, e), ++r;
}
var F5 = {}, f1 = {}, d1 = 34, Fl = 10, h1 = 13;
function Bk(e) {
  return new Function("d", "return {" + e.map(function(t, n) {
    return JSON.stringify(t) + ": d[" + n + '] || ""';
  }).join(",") + "}");
}
function GP(e, t) {
  var n = Bk(e);
  return function(i, r) {
    return t(n(i), r, e);
  };
}
function M5(e) {
  var t = /* @__PURE__ */ Object.create(null), n = [];
  return e.forEach(function(i) {
    for (var r in i)
      r in t || n.push(t[r] = r);
  }), n;
}
function cn(e, t) {
  var n = e + "", i = n.length;
  return i < t ? new Array(t - i + 1).join(0) + n : n;
}
function WP(e) {
  return e < 0 ? "-" + cn(-e, 6) : e > 9999 ? "+" + cn(e, 6) : cn(e, 4);
}
function HP(e) {
  var t = e.getUTCHours(), n = e.getUTCMinutes(), i = e.getUTCSeconds(), r = e.getUTCMilliseconds();
  return isNaN(e) ? "Invalid Date" : WP(e.getUTCFullYear()) + "-" + cn(e.getUTCMonth() + 1, 2) + "-" + cn(e.getUTCDate(), 2) + (r ? "T" + cn(t, 2) + ":" + cn(n, 2) + ":" + cn(i, 2) + "." + cn(r, 3) + "Z" : i ? "T" + cn(t, 2) + ":" + cn(n, 2) + ":" + cn(i, 2) + "Z" : n || t ? "T" + cn(t, 2) + ":" + cn(n, 2) + "Z" : "");
}
function VP(e) {
  var t = new RegExp('["' + e + `
\r]`), n = e.charCodeAt(0);
  function i(f, d) {
    var h, p, g = r(f, function(m, y) {
      if (h)
        return h(m, y - 1);
      p = m, h = d ? GP(m, d) : Bk(m);
    });
    return g.columns = p || [], g;
  }
  function r(f, d) {
    var h = [], p = f.length, g = 0, m = 0, y, b = p <= 0, v = !1;
    f.charCodeAt(p - 1) === Fl && --p, f.charCodeAt(p - 1) === h1 && --p;
    function x() {
      if (b)
        return f1;
      if (v)
        return v = !1, F5;
      var E, $ = g, S;
      if (f.charCodeAt($) === d1) {
        for (; g++ < p && f.charCodeAt(g) !== d1 || f.charCodeAt(++g) === d1; )
          ;
        return (E = g) >= p ? b = !0 : (S = f.charCodeAt(g++)) === Fl ? v = !0 : S === h1 && (v = !0, f.charCodeAt(g) === Fl && ++g), f.slice($ + 1, E - 1).replace(/""/g, '"');
      }
      for (; g < p; ) {
        if ((S = f.charCodeAt(E = g++)) === Fl)
          v = !0;
        else if (S === h1)
          v = !0, f.charCodeAt(g) === Fl && ++g;
        else if (S !== n)
          continue;
        return f.slice($, E);
      }
      return b = !0, f.slice($, p);
    }
    for (; (y = x()) !== f1; ) {
      for (var w = []; y !== F5 && y !== f1; )
        w.push(y), y = x();
      d && (w = d(w, m++)) == null || h.push(w);
    }
    return h;
  }
  function a(f, d) {
    return f.map(function(h) {
      return d.map(function(p) {
        return c(h[p]);
      }).join(e);
    });
  }
  function s(f, d) {
    return d == null && (d = M5(f)), [d.map(c).join(e)].concat(a(f, d)).join(`
`);
  }
  function o(f, d) {
    return d == null && (d = M5(f)), a(f, d).join(`
`);
  }
  function u(f) {
    return f.map(l).join(`
`);
  }
  function l(f) {
    return f.map(c).join(e);
  }
  function c(f) {
    return f == null ? "" : f instanceof Date ? HP(f) : t.test(f += "") ? '"' + f.replace(/"/g, '""') + '"' : f;
  }
  return {
    parse: i,
    parseRows: r,
    format: s,
    formatBody: o,
    formatRows: u,
    formatRow: l,
    formatValue: c
  };
}
function XP(e, t) {
  var n, i = 1;
  e == null && (e = 0), t == null && (t = 0);
  function r() {
    var a, s = n.length, o, u = 0, l = 0;
    for (a = 0; a < s; ++a)
      o = n[a], u += o.x, l += o.y;
    for (u = (u / s - e) * i, l = (l / s - t) * i, a = 0; a < s; ++a)
      o = n[a], o.x -= u, o.y -= l;
  }
  return r.initialize = function(a) {
    n = a;
  }, r.x = function(a) {
    return arguments.length ? (e = +a, r) : e;
  }, r.y = function(a) {
    return arguments.length ? (t = +a, r) : t;
  }, r.strength = function(a) {
    return arguments.length ? (i = +a, r) : i;
  }, r;
}
function YP(e) {
  const t = +this._x.call(null, e), n = +this._y.call(null, e);
  return jk(this.cover(t, n), t, n, e);
}
function jk(e, t, n, i) {
  if (isNaN(t) || isNaN(n))
    return e;
  var r, a = e._root, s = { data: i }, o = e._x0, u = e._y0, l = e._x1, c = e._y1, f, d, h, p, g, m, y, b;
  if (!a)
    return e._root = s, e;
  for (; a.length; )
    if ((g = t >= (f = (o + l) / 2)) ? o = f : l = f, (m = n >= (d = (u + c) / 2)) ? u = d : c = d, r = a, !(a = a[y = m << 1 | g]))
      return r[y] = s, e;
  if (h = +e._x.call(null, a.data), p = +e._y.call(null, a.data), t === h && n === p)
    return s.next = a, r ? r[y] = s : e._root = s, e;
  do
    r = r ? r[y] = new Array(4) : e._root = new Array(4), (g = t >= (f = (o + l) / 2)) ? o = f : l = f, (m = n >= (d = (u + c) / 2)) ? u = d : c = d;
  while ((y = m << 1 | g) === (b = (p >= d) << 1 | h >= f));
  return r[b] = a, r[y] = s, e;
}
function KP(e) {
  var t, n, i = e.length, r, a, s = new Array(i), o = new Array(i), u = 1 / 0, l = 1 / 0, c = -1 / 0, f = -1 / 0;
  for (n = 0; n < i; ++n)
    isNaN(r = +this._x.call(null, t = e[n])) || isNaN(a = +this._y.call(null, t)) || (s[n] = r, o[n] = a, r < u && (u = r), r > c && (c = r), a < l && (l = a), a > f && (f = a));
  if (u > c || l > f)
    return this;
  for (this.cover(u, l).cover(c, f), n = 0; n < i; ++n)
    jk(this, s[n], o[n], e[n]);
  return this;
}
function JP(e, t) {
  if (isNaN(e = +e) || isNaN(t = +t))
    return this;
  var n = this._x0, i = this._y0, r = this._x1, a = this._y1;
  if (isNaN(n))
    r = (n = Math.floor(e)) + 1, a = (i = Math.floor(t)) + 1;
  else {
    for (var s = r - n || 1, o = this._root, u, l; n > e || e >= r || i > t || t >= a; )
      switch (l = (t < i) << 1 | e < n, u = new Array(4), u[l] = o, o = u, s *= 2, l) {
        case 0:
          r = n + s, a = i + s;
          break;
        case 1:
          n = r - s, a = i + s;
          break;
        case 2:
          r = n + s, i = a - s;
          break;
        case 3:
          n = r - s, i = a - s;
          break;
      }
    this._root && this._root.length && (this._root = o);
  }
  return this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = a, this;
}
function QP() {
  var e = [];
  return this.visit(function(t) {
    if (!t.length)
      do
        e.push(t.data);
      while (t = t.next);
  }), e;
}
function ZP(e) {
  return arguments.length ? this.cover(+e[0][0], +e[0][1]).cover(+e[1][0], +e[1][1]) : isNaN(this._x0) ? void 0 : [[this._x0, this._y0], [this._x1, this._y1]];
}
function Jt(e, t, n, i, r) {
  this.node = e, this.x0 = t, this.y0 = n, this.x1 = i, this.y1 = r;
}
function ez(e, t, n) {
  var i, r = this._x0, a = this._y0, s, o, u, l, c = this._x1, f = this._y1, d = [], h = this._root, p, g;
  for (h && d.push(new Jt(h, r, a, c, f)), n == null ? n = 1 / 0 : (r = e - n, a = t - n, c = e + n, f = t + n, n *= n); p = d.pop(); )
    if (!(!(h = p.node) || (s = p.x0) > c || (o = p.y0) > f || (u = p.x1) < r || (l = p.y1) < a))
      if (h.length) {
        var m = (s + u) / 2, y = (o + l) / 2;
        d.push(
          new Jt(h[3], m, y, u, l),
          new Jt(h[2], s, y, m, l),
          new Jt(h[1], m, o, u, y),
          new Jt(h[0], s, o, m, y)
        ), (g = (t >= y) << 1 | e >= m) && (p = d[d.length - 1], d[d.length - 1] = d[d.length - 1 - g], d[d.length - 1 - g] = p);
      } else {
        var b = e - +this._x.call(null, h.data), v = t - +this._y.call(null, h.data), x = b * b + v * v;
        if (x < n) {
          var w = Math.sqrt(n = x);
          r = e - w, a = t - w, c = e + w, f = t + w, i = h.data;
        }
      }
  return i;
}
function tz(e) {
  if (isNaN(c = +this._x.call(null, e)) || isNaN(f = +this._y.call(null, e)))
    return this;
  var t, n = this._root, i, r, a, s = this._x0, o = this._y0, u = this._x1, l = this._y1, c, f, d, h, p, g, m, y;
  if (!n)
    return this;
  if (n.length)
    for (; ; ) {
      if ((p = c >= (d = (s + u) / 2)) ? s = d : u = d, (g = f >= (h = (o + l) / 2)) ? o = h : l = h, t = n, !(n = n[m = g << 1 | p]))
        return this;
      if (!n.length)
        break;
      (t[m + 1 & 3] || t[m + 2 & 3] || t[m + 3 & 3]) && (i = t, y = m);
    }
  for (; n.data !== e; )
    if (r = n, !(n = n.next))
      return this;
  return (a = n.next) && delete n.next, r ? (a ? r.next = a : delete r.next, this) : t ? (a ? t[m] = a : delete t[m], (n = t[0] || t[1] || t[2] || t[3]) && n === (t[3] || t[2] || t[1] || t[0]) && !n.length && (i ? i[y] = n : this._root = n), this) : (this._root = a, this);
}
function nz(e) {
  for (var t = 0, n = e.length; t < n; ++t)
    this.remove(e[t]);
  return this;
}
function iz() {
  return this._root;
}
function rz() {
  var e = 0;
  return this.visit(function(t) {
    if (!t.length)
      do
        ++e;
      while (t = t.next);
  }), e;
}
function az(e) {
  var t = [], n, i = this._root, r, a, s, o, u;
  for (i && t.push(new Jt(i, this._x0, this._y0, this._x1, this._y1)); n = t.pop(); )
    if (!e(i = n.node, a = n.x0, s = n.y0, o = n.x1, u = n.y1) && i.length) {
      var l = (a + o) / 2, c = (s + u) / 2;
      (r = i[3]) && t.push(new Jt(r, l, c, o, u)), (r = i[2]) && t.push(new Jt(r, a, c, l, u)), (r = i[1]) && t.push(new Jt(r, l, s, o, c)), (r = i[0]) && t.push(new Jt(r, a, s, l, c));
    }
  return this;
}
function sz(e) {
  var t = [], n = [], i;
  for (this._root && t.push(new Jt(this._root, this._x0, this._y0, this._x1, this._y1)); i = t.pop(); ) {
    var r = i.node;
    if (r.length) {
      var a, s = i.x0, o = i.y0, u = i.x1, l = i.y1, c = (s + u) / 2, f = (o + l) / 2;
      (a = r[0]) && t.push(new Jt(a, s, o, c, f)), (a = r[1]) && t.push(new Jt(a, c, o, u, f)), (a = r[2]) && t.push(new Jt(a, s, f, c, l)), (a = r[3]) && t.push(new Jt(a, c, f, u, l));
    }
    n.push(i);
  }
  for (; i = n.pop(); )
    e(i.node, i.x0, i.y0, i.x1, i.y1);
  return this;
}
function oz(e) {
  return e[0];
}
function uz(e) {
  return arguments.length ? (this._x = e, this) : this._x;
}
function lz(e) {
  return e[1];
}
function cz(e) {
  return arguments.length ? (this._y = e, this) : this._y;
}
function s2(e, t, n) {
  var i = new o2(t ?? oz, n ?? lz, NaN, NaN, NaN, NaN);
  return e == null ? i : i.addAll(e);
}
function o2(e, t, n, i, r, a) {
  this._x = e, this._y = t, this._x0 = n, this._y0 = i, this._x1 = r, this._y1 = a, this._root = void 0;
}
function O5(e) {
  for (var t = { data: e.data }, n = t; e = e.next; )
    n = n.next = { data: e.data };
  return t;
}
var on = s2.prototype = o2.prototype;
on.copy = function() {
  var e = new o2(this._x, this._y, this._x0, this._y0, this._x1, this._y1), t = this._root, n, i;
  if (!t)
    return e;
  if (!t.length)
    return e._root = O5(t), e;
  for (n = [{ source: t, target: e._root = new Array(4) }]; t = n.pop(); )
    for (var r = 0; r < 4; ++r)
      (i = t.source[r]) && (i.length ? n.push({ source: i, target: t.target[r] = new Array(4) }) : t.target[r] = O5(i));
  return e;
};
on.add = YP;
on.addAll = KP;
on.cover = JP;
on.data = QP;
on.extent = ZP;
on.find = ez;
on.remove = tz;
on.removeAll = nz;
on.root = iz;
on.size = rz;
on.visit = az;
on.visitAfter = sz;
on.x = uz;
on.y = cz;
function Qt(e) {
  return function() {
    return e;
  };
}
function Sa(e) {
  return (e() - 0.5) * 1e-6;
}
function fz(e) {
  return e.x + e.vx;
}
function dz(e) {
  return e.y + e.vy;
}
function hz(e) {
  var t, n, i, r = 1, a = 1;
  typeof e != "function" && (e = Qt(e == null ? 1 : +e));
  function s() {
    for (var l, c = t.length, f, d, h, p, g, m, y = 0; y < a; ++y)
      for (f = s2(t, fz, dz).visitAfter(o), l = 0; l < c; ++l)
        d = t[l], g = n[d.index], m = g * g, h = d.x + d.vx, p = d.y + d.vy, f.visit(b);
    function b(v, x, w, E, $) {
      var S = v.data, A = v.r, k = g + A;
      if (S) {
        if (S.index > d.index) {
          var _ = h - S.x - S.vx, P = p - S.y - S.vy, F = _ * _ + P * P;
          F < k * k && (_ === 0 && (_ = Sa(i), F += _ * _), P === 0 && (P = Sa(i), F += P * P), F = (k - (F = Math.sqrt(F))) / F * r, d.vx += (_ *= F) * (k = (A *= A) / (m + A)), d.vy += (P *= F) * k, S.vx -= _ * (k = 1 - k), S.vy -= P * k);
        }
        return;
      }
      return x > h + k || E < h - k || w > p + k || $ < p - k;
    }
  }
  function o(l) {
    if (l.data)
      return l.r = n[l.data.index];
    for (var c = l.r = 0; c < 4; ++c)
      l[c] && l[c].r > l.r && (l.r = l[c].r);
  }
  function u() {
    if (t) {
      var l, c = t.length, f;
      for (n = new Array(c), l = 0; l < c; ++l)
        f = t[l], n[f.index] = +e(f, l, t);
    }
  }
  return s.initialize = function(l, c) {
    t = l, i = c, u();
  }, s.iterations = function(l) {
    return arguments.length ? (a = +l, s) : a;
  }, s.strength = function(l) {
    return arguments.length ? (r = +l, s) : r;
  }, s.radius = function(l) {
    return arguments.length ? (e = typeof l == "function" ? l : Qt(+l), u(), s) : e;
  }, s;
}
function pz(e) {
  return e.index;
}
function R5(e, t) {
  var n = e.get(t);
  if (!n)
    throw new Error("node not found: " + t);
  return n;
}
function gz(e) {
  var t = pz, n = f, i, r = Qt(30), a, s, o, u, l, c = 1;
  e == null && (e = []);
  function f(m) {
    return 1 / Math.min(o[m.source.index], o[m.target.index]);
  }
  function d(m) {
    for (var y = 0, b = e.length; y < c; ++y)
      for (var v = 0, x, w, E, $, S, A, k; v < b; ++v)
        x = e[v], w = x.source, E = x.target, $ = E.x + E.vx - w.x - w.vx || Sa(l), S = E.y + E.vy - w.y - w.vy || Sa(l), A = Math.sqrt($ * $ + S * S), A = (A - a[v]) / A * m * i[v], $ *= A, S *= A, E.vx -= $ * (k = u[v]), E.vy -= S * k, w.vx += $ * (k = 1 - k), w.vy += S * k;
  }
  function h() {
    if (s) {
      var m, y = s.length, b = e.length, v = new Map(s.map((w, E) => [t(w, E, s), w])), x;
      for (m = 0, o = new Array(y); m < b; ++m)
        x = e[m], x.index = m, typeof x.source != "object" && (x.source = R5(v, x.source)), typeof x.target != "object" && (x.target = R5(v, x.target)), o[x.source.index] = (o[x.source.index] || 0) + 1, o[x.target.index] = (o[x.target.index] || 0) + 1;
      for (m = 0, u = new Array(b); m < b; ++m)
        x = e[m], u[m] = o[x.source.index] / (o[x.source.index] + o[x.target.index]);
      i = new Array(b), p(), a = new Array(b), g();
    }
  }
  function p() {
    if (s)
      for (var m = 0, y = e.length; m < y; ++m)
        i[m] = +n(e[m], m, e);
  }
  function g() {
    if (s)
      for (var m = 0, y = e.length; m < y; ++m)
        a[m] = +r(e[m], m, e);
  }
  return d.initialize = function(m, y) {
    s = m, l = y, h();
  }, d.links = function(m) {
    return arguments.length ? (e = m, h(), d) : e;
  }, d.id = function(m) {
    return arguments.length ? (t = m, d) : t;
  }, d.iterations = function(m) {
    return arguments.length ? (c = +m, d) : c;
  }, d.strength = function(m) {
    return arguments.length ? (n = typeof m == "function" ? m : Qt(+m), p(), d) : n;
  }, d.distance = function(m) {
    return arguments.length ? (r = typeof m == "function" ? m : Qt(+m), g(), d) : r;
  }, d;
}
const mz = 1664525, yz = 1013904223, T5 = 4294967296;
function bz() {
  let e = 1;
  return () => (e = (mz * e + yz) % T5) / T5;
}
function vz(e) {
  return e.x;
}
function xz(e) {
  return e.y;
}
var $z = 10, wz = Math.PI * (3 - Math.sqrt(5));
function Ez(e) {
  var t, n = 1, i = 1e-3, r = 1 - Math.pow(i, 1 / 300), a = 0, s = 0.6, o = /* @__PURE__ */ new Map(), u = HL(f), l = VL("tick", "end"), c = bz();
  e == null && (e = []);
  function f() {
    d(), l.call("tick", t), n < i && (u.stop(), l.call("end", t));
  }
  function d(g) {
    var m, y = e.length, b;
    g === void 0 && (g = 1);
    for (var v = 0; v < g; ++v)
      for (n += (a - n) * r, o.forEach(function(x) {
        x(n);
      }), m = 0; m < y; ++m)
        b = e[m], b.fx == null ? b.x += b.vx *= s : (b.x = b.fx, b.vx = 0), b.fy == null ? b.y += b.vy *= s : (b.y = b.fy, b.vy = 0);
    return t;
  }
  function h() {
    for (var g = 0, m = e.length, y; g < m; ++g) {
      if (y = e[g], y.index = g, y.fx != null && (y.x = y.fx), y.fy != null && (y.y = y.fy), isNaN(y.x) || isNaN(y.y)) {
        var b = $z * Math.sqrt(0.5 + g), v = g * wz;
        y.x = b * Math.cos(v), y.y = b * Math.sin(v);
      }
      (isNaN(y.vx) || isNaN(y.vy)) && (y.vx = y.vy = 0);
    }
  }
  function p(g) {
    return g.initialize && g.initialize(e, c), g;
  }
  return h(), t = {
    tick: d,
    restart: function() {
      return u.restart(f), t;
    },
    stop: function() {
      return u.stop(), t;
    },
    nodes: function(g) {
      return arguments.length ? (e = g, h(), o.forEach(p), t) : e;
    },
    alpha: function(g) {
      return arguments.length ? (n = +g, t) : n;
    },
    alphaMin: function(g) {
      return arguments.length ? (i = +g, t) : i;
    },
    alphaDecay: function(g) {
      return arguments.length ? (r = +g, t) : +r;
    },
    alphaTarget: function(g) {
      return arguments.length ? (a = +g, t) : a;
    },
    velocityDecay: function(g) {
      return arguments.length ? (s = 1 - g, t) : 1 - s;
    },
    randomSource: function(g) {
      return arguments.length ? (c = g, o.forEach(p), t) : c;
    },
    force: function(g, m) {
      return arguments.length > 1 ? (m == null ? o.delete(g) : o.set(g, p(m)), t) : o.get(g);
    },
    find: function(g, m, y) {
      var b = 0, v = e.length, x, w, E, $, S;
      for (y == null ? y = 1 / 0 : y *= y, b = 0; b < v; ++b)
        $ = e[b], x = g - $.x, w = m - $.y, E = x * x + w * w, E < y && (S = $, y = E);
      return S;
    },
    on: function(g, m) {
      return arguments.length > 1 ? (l.on(g, m), t) : l.on(g);
    }
  };
}
function Sz() {
  var e, t, n, i, r = Qt(-30), a, s = 1, o = 1 / 0, u = 0.81;
  function l(h) {
    var p, g = e.length, m = s2(e, vz, xz).visitAfter(f);
    for (i = h, p = 0; p < g; ++p)
      t = e[p], m.visit(d);
  }
  function c() {
    if (e) {
      var h, p = e.length, g;
      for (a = new Array(p), h = 0; h < p; ++h)
        g = e[h], a[g.index] = +r(g, h, e);
    }
  }
  function f(h) {
    var p = 0, g, m, y = 0, b, v, x;
    if (h.length) {
      for (b = v = x = 0; x < 4; ++x)
        (g = h[x]) && (m = Math.abs(g.value)) && (p += g.value, y += m, b += m * g.x, v += m * g.y);
      h.x = b / y, h.y = v / y;
    } else {
      g = h, g.x = g.data.x, g.y = g.data.y;
      do
        p += a[g.data.index];
      while (g = g.next);
    }
    h.value = p;
  }
  function d(h, p, g, m) {
    if (!h.value)
      return !0;
    var y = h.x - t.x, b = h.y - t.y, v = m - p, x = y * y + b * b;
    if (v * v / u < x)
      return x < o && (y === 0 && (y = Sa(n), x += y * y), b === 0 && (b = Sa(n), x += b * b), x < s && (x = Math.sqrt(s * x)), t.vx += y * h.value * i / x, t.vy += b * h.value * i / x), !0;
    if (h.length || x >= o)
      return;
    (h.data !== t || h.next) && (y === 0 && (y = Sa(n), x += y * y), b === 0 && (b = Sa(n), x += b * b), x < s && (x = Math.sqrt(s * x)));
    do
      h.data !== t && (v = a[h.data.index] * i / x, t.vx += y * v, t.vy += b * v);
    while (h = h.next);
  }
  return l.initialize = function(h, p) {
    e = h, n = p, c();
  }, l.strength = function(h) {
    return arguments.length ? (r = typeof h == "function" ? h : Qt(+h), c(), l) : r;
  }, l.distanceMin = function(h) {
    return arguments.length ? (s = h * h, l) : Math.sqrt(s);
  }, l.distanceMax = function(h) {
    return arguments.length ? (o = h * h, l) : Math.sqrt(o);
  }, l.theta = function(h) {
    return arguments.length ? (u = h * h, l) : Math.sqrt(u);
  }, l;
}
function Az(e) {
  var t = Qt(0.1), n, i, r;
  typeof e != "function" && (e = Qt(e == null ? 0 : +e));
  function a(o) {
    for (var u = 0, l = n.length, c; u < l; ++u)
      c = n[u], c.vx += (r[u] - c.x) * i[u] * o;
  }
  function s() {
    if (n) {
      var o, u = n.length;
      for (i = new Array(u), r = new Array(u), o = 0; o < u; ++o)
        i[o] = isNaN(r[o] = +e(n[o], o, n)) ? 0 : +t(n[o], o, n);
    }
  }
  return a.initialize = function(o) {
    n = o, s();
  }, a.strength = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : Qt(+o), s(), a) : t;
  }, a.x = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : Qt(+o), s(), a) : e;
  }, a;
}
function kz(e) {
  var t = Qt(0.1), n, i, r;
  typeof e != "function" && (e = Qt(e == null ? 0 : +e));
  function a(o) {
    for (var u = 0, l = n.length, c; u < l; ++u)
      c = n[u], c.vy += (r[u] - c.y) * i[u] * o;
  }
  function s() {
    if (n) {
      var o, u = n.length;
      for (i = new Array(u), r = new Array(u), o = 0; o < u; ++o)
        i[o] = isNaN(r[o] = +e(n[o], o, n)) ? 0 : +t(n[o], o, n);
    }
  }
  return a.initialize = function(o) {
    n = o, s();
  }, a.strength = function(o) {
    return arguments.length ? (t = typeof o == "function" ? o : Qt(+o), s(), a) : t;
  }, a.y = function(o) {
    return arguments.length ? (e = typeof o == "function" ? o : Qt(+o), s(), a) : e;
  }, a;
}
var ne = 1e-6, rp = 1e-12, fe = Math.PI, He = fe / 2, ap = fe / 4, nn = fe * 2, Xe = 180 / fe, ce = fe / 180, ge = Math.abs, Yu = Math.atan, Zn = Math.atan2, re = Math.cos, qd = Math.ceil, Uk = Math.exp, zy = Math.hypot, sp = Math.log, p1 = Math.pow, te = Math.sin, Vn = Math.sign || function(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}, rn = Math.sqrt, u2 = Math.tan;
function qk(e) {
  return e > 1 ? 0 : e < -1 ? fe : Math.acos(e);
}
function bn(e) {
  return e > 1 ? He : e < -1 ? -He : Math.asin(e);
}
function $t() {
}
function op(e, t) {
  e && N5.hasOwnProperty(e.type) && N5[e.type](e, t);
}
var D5 = {
  Feature: function(e, t) {
    op(e.geometry, t);
  },
  FeatureCollection: function(e, t) {
    for (var n = e.features, i = -1, r = n.length; ++i < r; )
      op(n[i].geometry, t);
  }
}, N5 = {
  Sphere: function(e, t) {
    t.sphere();
  },
  Point: function(e, t) {
    e = e.coordinates, t.point(e[0], e[1], e[2]);
  },
  MultiPoint: function(e, t) {
    for (var n = e.coordinates, i = -1, r = n.length; ++i < r; )
      e = n[i], t.point(e[0], e[1], e[2]);
  },
  LineString: function(e, t) {
    Iy(e.coordinates, t, 0);
  },
  MultiLineString: function(e, t) {
    for (var n = e.coordinates, i = -1, r = n.length; ++i < r; )
      Iy(n[i], t, 0);
  },
  Polygon: function(e, t) {
    L5(e.coordinates, t);
  },
  MultiPolygon: function(e, t) {
    for (var n = e.coordinates, i = -1, r = n.length; ++i < r; )
      L5(n[i], t);
  },
  GeometryCollection: function(e, t) {
    for (var n = e.geometries, i = -1, r = n.length; ++i < r; )
      op(n[i], t);
  }
};
function Iy(e, t, n) {
  var i = -1, r = e.length - n, a;
  for (t.lineStart(); ++i < r; )
    a = e[i], t.point(a[0], a[1], a[2]);
  t.lineEnd();
}
function L5(e, t) {
  var n = -1, i = e.length;
  for (t.polygonStart(); ++n < i; )
    Iy(e[n], t, 1);
  t.polygonEnd();
}
function zr(e, t) {
  e && D5.hasOwnProperty(e.type) ? D5[e.type](e, t) : op(e, t);
}
var up = new Zt(), lp = new Zt(), Gk, Wk, By, jy, Uy, cr = {
  point: $t,
  lineStart: $t,
  lineEnd: $t,
  polygonStart: function() {
    up = new Zt(), cr.lineStart = Cz, cr.lineEnd = _z;
  },
  polygonEnd: function() {
    var e = +up;
    lp.add(e < 0 ? nn + e : e), this.lineStart = this.lineEnd = this.point = $t;
  },
  sphere: function() {
    lp.add(nn);
  }
};
function Cz() {
  cr.point = Fz;
}
function _z() {
  Hk(Gk, Wk);
}
function Fz(e, t) {
  cr.point = Hk, Gk = e, Wk = t, e *= ce, t *= ce, By = e, jy = re(t = t / 2 + ap), Uy = te(t);
}
function Hk(e, t) {
  e *= ce, t *= ce, t = t / 2 + ap;
  var n = e - By, i = n >= 0 ? 1 : -1, r = i * n, a = re(t), s = te(t), o = Uy * s, u = jy * a + o * re(r), l = o * i * te(r);
  up.add(Zn(l, u)), By = e, jy = a, Uy = s;
}
function Vk(e) {
  return lp = new Zt(), zr(e, cr), lp * 2;
}
function cp(e) {
  return [Zn(e[1], e[0]), bn(e[2])];
}
function to(e) {
  var t = e[0], n = e[1], i = re(n);
  return [i * re(t), i * te(t), te(n)];
}
function Gd(e, t) {
  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
}
function yu(e, t) {
  return [e[1] * t[2] - e[2] * t[1], e[2] * t[0] - e[0] * t[2], e[0] * t[1] - e[1] * t[0]];
}
function g1(e, t) {
  e[0] += t[0], e[1] += t[1], e[2] += t[2];
}
function Wd(e, t) {
  return [e[0] * t, e[1] * t, e[2] * t];
}
function fp(e) {
  var t = rn(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
  e[0] /= t, e[1] /= t, e[2] /= t;
}
var Ue, dn, qe, Fn, _s, Xk, Yk, ou, $c, ma, Xr, Nr = {
  point: qy,
  lineStart: P5,
  lineEnd: z5,
  polygonStart: function() {
    Nr.point = Jk, Nr.lineStart = Mz, Nr.lineEnd = Oz, $c = new Zt(), cr.polygonStart();
  },
  polygonEnd: function() {
    cr.polygonEnd(), Nr.point = qy, Nr.lineStart = P5, Nr.lineEnd = z5, up < 0 ? (Ue = -(qe = 180), dn = -(Fn = 90)) : $c > ne ? Fn = 90 : $c < -ne && (dn = -90), Xr[0] = Ue, Xr[1] = qe;
  },
  sphere: function() {
    Ue = -(qe = 180), dn = -(Fn = 90);
  }
};
function qy(e, t) {
  ma.push(Xr = [Ue = e, qe = e]), t < dn && (dn = t), t > Fn && (Fn = t);
}
function Kk(e, t) {
  var n = to([e * ce, t * ce]);
  if (ou) {
    var i = yu(ou, n), r = [i[1], -i[0], 0], a = yu(r, i);
    fp(a), a = cp(a);
    var s = e - _s, o = s > 0 ? 1 : -1, u = a[0] * Xe * o, l, c = ge(s) > 180;
    c ^ (o * _s < u && u < o * e) ? (l = a[1] * Xe, l > Fn && (Fn = l)) : (u = (u + 360) % 360 - 180, c ^ (o * _s < u && u < o * e) ? (l = -a[1] * Xe, l < dn && (dn = l)) : (t < dn && (dn = t), t > Fn && (Fn = t))), c ? e < _s ? _n(Ue, e) > _n(Ue, qe) && (qe = e) : _n(e, qe) > _n(Ue, qe) && (Ue = e) : qe >= Ue ? (e < Ue && (Ue = e), e > qe && (qe = e)) : e > _s ? _n(Ue, e) > _n(Ue, qe) && (qe = e) : _n(e, qe) > _n(Ue, qe) && (Ue = e);
  } else
    ma.push(Xr = [Ue = e, qe = e]);
  t < dn && (dn = t), t > Fn && (Fn = t), ou = n, _s = e;
}
function P5() {
  Nr.point = Kk;
}
function z5() {
  Xr[0] = Ue, Xr[1] = qe, Nr.point = qy, ou = null;
}
function Jk(e, t) {
  if (ou) {
    var n = e - _s;
    $c.add(ge(n) > 180 ? n + (n > 0 ? 360 : -360) : n);
  } else
    Xk = e, Yk = t;
  cr.point(e, t), Kk(e, t);
}
function Mz() {
  cr.lineStart();
}
function Oz() {
  Jk(Xk, Yk), cr.lineEnd(), ge($c) > ne && (Ue = -(qe = 180)), Xr[0] = Ue, Xr[1] = qe, ou = null;
}
function _n(e, t) {
  return (t -= e) < 0 ? t + 360 : t;
}
function Rz(e, t) {
  return e[0] - t[0];
}
function I5(e, t) {
  return e[0] <= e[1] ? e[0] <= t && t <= e[1] : t < e[0] || e[1] < t;
}
function Qk(e) {
  var t, n, i, r, a, s, o;
  if (Fn = qe = -(Ue = dn = 1 / 0), ma = [], zr(e, Nr), n = ma.length) {
    for (ma.sort(Rz), t = 1, i = ma[0], a = [i]; t < n; ++t)
      r = ma[t], I5(i, r[0]) || I5(i, r[1]) ? (_n(i[0], r[1]) > _n(i[0], i[1]) && (i[1] = r[1]), _n(r[0], i[1]) > _n(i[0], i[1]) && (i[0] = r[0])) : a.push(i = r);
    for (s = -1 / 0, n = a.length - 1, t = 0, i = a[n]; t <= n; i = r, ++t)
      r = a[t], (o = _n(i[1], r[0])) > s && (s = o, Ue = r[0], qe = i[1]);
  }
  return ma = Xr = null, Ue === 1 / 0 || dn === 1 / 0 ? [[NaN, NaN], [NaN, NaN]] : [[Ue, dn], [qe, Fn]];
}
var Jl, dp, hp, pp, gp, mp, yp, bp, Gy, Wy, Hy, Zk, e9, Xt, Yt, Kt, yi = {
  sphere: $t,
  point: l2,
  lineStart: B5,
  lineEnd: j5,
  polygonStart: function() {
    yi.lineStart = Nz, yi.lineEnd = Lz;
  },
  polygonEnd: function() {
    yi.lineStart = B5, yi.lineEnd = j5;
  }
};
function l2(e, t) {
  e *= ce, t *= ce;
  var n = re(t);
  Ff(n * re(e), n * te(e), te(t));
}
function Ff(e, t, n) {
  ++Jl, hp += (e - hp) / Jl, pp += (t - pp) / Jl, gp += (n - gp) / Jl;
}
function B5() {
  yi.point = Tz;
}
function Tz(e, t) {
  e *= ce, t *= ce;
  var n = re(t);
  Xt = n * re(e), Yt = n * te(e), Kt = te(t), yi.point = Dz, Ff(Xt, Yt, Kt);
}
function Dz(e, t) {
  e *= ce, t *= ce;
  var n = re(t), i = n * re(e), r = n * te(e), a = te(t), s = Zn(rn((s = Yt * a - Kt * r) * s + (s = Kt * i - Xt * a) * s + (s = Xt * r - Yt * i) * s), Xt * i + Yt * r + Kt * a);
  dp += s, mp += s * (Xt + (Xt = i)), yp += s * (Yt + (Yt = r)), bp += s * (Kt + (Kt = a)), Ff(Xt, Yt, Kt);
}
function j5() {
  yi.point = l2;
}
function Nz() {
  yi.point = Pz;
}
function Lz() {
  t9(Zk, e9), yi.point = l2;
}
function Pz(e, t) {
  Zk = e, e9 = t, e *= ce, t *= ce, yi.point = t9;
  var n = re(t);
  Xt = n * re(e), Yt = n * te(e), Kt = te(t), Ff(Xt, Yt, Kt);
}
function t9(e, t) {
  e *= ce, t *= ce;
  var n = re(t), i = n * re(e), r = n * te(e), a = te(t), s = Yt * a - Kt * r, o = Kt * i - Xt * a, u = Xt * r - Yt * i, l = zy(s, o, u), c = bn(l), f = l && -c / l;
  Gy.add(f * s), Wy.add(f * o), Hy.add(f * u), dp += c, mp += c * (Xt + (Xt = i)), yp += c * (Yt + (Yt = r)), bp += c * (Kt + (Kt = a)), Ff(Xt, Yt, Kt);
}
function n9(e) {
  Jl = dp = hp = pp = gp = mp = yp = bp = 0, Gy = new Zt(), Wy = new Zt(), Hy = new Zt(), zr(e, yi);
  var t = +Gy, n = +Wy, i = +Hy, r = zy(t, n, i);
  return r < rp && (t = mp, n = yp, i = bp, dp < ne && (t = hp, n = pp, i = gp), r = zy(t, n, i), r < rp) ? [NaN, NaN] : [Zn(n, t) * Xe, bn(i / r) * Xe];
}
function Vy(e, t) {
  function n(i, r) {
    return i = e(i, r), t(i[0], i[1]);
  }
  return e.invert && t.invert && (n.invert = function(i, r) {
    return i = t.invert(i, r), i && e.invert(i[0], i[1]);
  }), n;
}
function Xy(e, t) {
  return ge(e) > fe && (e -= Math.round(e / nn) * nn), [e, t];
}
Xy.invert = Xy;
function i9(e, t, n) {
  return (e %= nn) ? t || n ? Vy(q5(e), G5(t, n)) : q5(e) : t || n ? G5(t, n) : Xy;
}
function U5(e) {
  return function(t, n) {
    return t += e, ge(t) > fe && (t -= Math.round(t / nn) * nn), [t, n];
  };
}
function q5(e) {
  var t = U5(e);
  return t.invert = U5(-e), t;
}
function G5(e, t) {
  var n = re(e), i = te(e), r = re(t), a = te(t);
  function s(o, u) {
    var l = re(u), c = re(o) * l, f = te(o) * l, d = te(u), h = d * n + c * i;
    return [
      Zn(f * r - h * a, c * n - d * i),
      bn(h * r + f * a)
    ];
  }
  return s.invert = function(o, u) {
    var l = re(u), c = re(o) * l, f = te(o) * l, d = te(u), h = d * r - f * a;
    return [
      Zn(f * r + d * a, c * n + h * i),
      bn(h * n - c * i)
    ];
  }, s;
}
function zz(e) {
  e = i9(e[0] * ce, e[1] * ce, e.length > 2 ? e[2] * ce : 0);
  function t(n) {
    return n = e(n[0] * ce, n[1] * ce), n[0] *= Xe, n[1] *= Xe, n;
  }
  return t.invert = function(n) {
    return n = e.invert(n[0] * ce, n[1] * ce), n[0] *= Xe, n[1] *= Xe, n;
  }, t;
}
function Iz(e, t, n, i, r, a) {
  if (n) {
    var s = re(t), o = te(t), u = i * n;
    r == null ? (r = t + i * nn, a = t - u / 2) : (r = W5(s, r), a = W5(s, a), (i > 0 ? r < a : r > a) && (r += i * nn));
    for (var l, c = r; i > 0 ? c > a : c < a; c -= u)
      l = cp([s, -o * re(c), -o * te(c)]), e.point(l[0], l[1]);
  }
}
function W5(e, t) {
  t = to(t), t[0] -= e, fp(t);
  var n = qk(-t[1]);
  return ((-t[2] < 0 ? -n : n) + nn - ne) % nn;
}
function r9() {
  var e = [], t;
  return {
    point: function(n, i, r) {
      t.push([n, i, r]);
    },
    lineStart: function() {
      e.push(t = []);
    },
    lineEnd: $t,
    rejoin: function() {
      e.length > 1 && e.push(e.pop().concat(e.shift()));
    },
    result: function() {
      var n = e;
      return e = [], t = null, n;
    }
  };
}
function Ah(e, t) {
  return ge(e[0] - t[0]) < ne && ge(e[1] - t[1]) < ne;
}
function Hd(e, t, n, i) {
  this.x = e, this.z = t, this.o = n, this.e = i, this.v = !1, this.n = this.p = null;
}
function a9(e, t, n, i, r) {
  var a = [], s = [], o, u;
  if (e.forEach(function(p) {
    if (!((g = p.length - 1) <= 0)) {
      var g, m = p[0], y = p[g], b;
      if (Ah(m, y)) {
        if (!m[2] && !y[2]) {
          for (r.lineStart(), o = 0; o < g; ++o)
            r.point((m = p[o])[0], m[1]);
          r.lineEnd();
          return;
        }
        y[0] += 2 * ne;
      }
      a.push(b = new Hd(m, p, null, !0)), s.push(b.o = new Hd(m, null, b, !1)), a.push(b = new Hd(y, p, null, !1)), s.push(b.o = new Hd(y, null, b, !0));
    }
  }), !!a.length) {
    for (s.sort(t), H5(a), H5(s), o = 0, u = s.length; o < u; ++o)
      s[o].e = n = !n;
    for (var l = a[0], c, f; ; ) {
      for (var d = l, h = !0; d.v; )
        if ((d = d.n) === l)
          return;
      c = d.z, r.lineStart();
      do {
        if (d.v = d.o.v = !0, d.e) {
          if (h)
            for (o = 0, u = c.length; o < u; ++o)
              r.point((f = c[o])[0], f[1]);
          else
            i(d.x, d.n.x, 1, r);
          d = d.n;
        } else {
          if (h)
            for (c = d.p.z, o = c.length - 1; o >= 0; --o)
              r.point((f = c[o])[0], f[1]);
          else
            i(d.x, d.p.x, -1, r);
          d = d.p;
        }
        d = d.o, c = d.z, h = !h;
      } while (!d.v);
      r.lineEnd();
    }
  }
}
function H5(e) {
  if (t = e.length) {
    for (var t, n = 0, i = e[0], r; ++n < t; )
      i.n = r = e[n], r.p = i, i = r;
    i.n = r = e[0], r.p = i;
  }
}
function m1(e) {
  return ge(e[0]) <= fe ? e[0] : Vn(e[0]) * ((ge(e[0]) + fe) % nn - fe);
}
function Bz(e, t) {
  var n = m1(t), i = t[1], r = te(i), a = [te(n), -re(n), 0], s = 0, o = 0, u = new Zt();
  r === 1 ? i = He + ne : r === -1 && (i = -He - ne);
  for (var l = 0, c = e.length; l < c; ++l)
    if (d = (f = e[l]).length)
      for (var f, d, h = f[d - 1], p = m1(h), g = h[1] / 2 + ap, m = te(g), y = re(g), b = 0; b < d; ++b, p = x, m = E, y = $, h = v) {
        var v = f[b], x = m1(v), w = v[1] / 2 + ap, E = te(w), $ = re(w), S = x - p, A = S >= 0 ? 1 : -1, k = A * S, _ = k > fe, P = m * E;
        if (u.add(Zn(P * A * te(k), y * $ + P * re(k))), s += _ ? S + A * nn : S, _ ^ p >= n ^ x >= n) {
          var F = yu(to(h), to(v));
          fp(F);
          var M = yu(a, F);
          fp(M);
          var C = (_ ^ S >= 0 ? -1 : 1) * bn(M[2]);
          (i > C || i === C && (F[0] || F[1])) && (o += _ ^ S >= 0 ? 1 : -1);
        }
      }
  return (s < -ne || s < ne && u < -rp) ^ o & 1;
}
function s9(e, t, n, i) {
  return function(r) {
    var a = t(r), s = r9(), o = t(s), u = !1, l, c, f, d = {
      point: h,
      lineStart: g,
      lineEnd: m,
      polygonStart: function() {
        d.point = y, d.lineStart = b, d.lineEnd = v, c = [], l = [];
      },
      polygonEnd: function() {
        d.point = h, d.lineStart = g, d.lineEnd = m, c = Nk(c);
        var x = Bz(l, i);
        c.length ? (u || (r.polygonStart(), u = !0), a9(c, Uz, x, n, r)) : x && (u || (r.polygonStart(), u = !0), r.lineStart(), n(null, null, 1, r), r.lineEnd()), u && (r.polygonEnd(), u = !1), c = l = null;
      },
      sphere: function() {
        r.polygonStart(), r.lineStart(), n(null, null, 1, r), r.lineEnd(), r.polygonEnd();
      }
    };
    function h(x, w) {
      e(x, w) && r.point(x, w);
    }
    function p(x, w) {
      a.point(x, w);
    }
    function g() {
      d.point = p, a.lineStart();
    }
    function m() {
      d.point = h, a.lineEnd();
    }
    function y(x, w) {
      f.push([x, w]), o.point(x, w);
    }
    function b() {
      o.lineStart(), f = [];
    }
    function v() {
      y(f[0][0], f[0][1]), o.lineEnd();
      var x = o.clean(), w = s.result(), E, $ = w.length, S, A, k;
      if (f.pop(), l.push(f), f = null, !!$) {
        if (x & 1) {
          if (A = w[0], (S = A.length - 1) > 0) {
            for (u || (r.polygonStart(), u = !0), r.lineStart(), E = 0; E < S; ++E)
              r.point((k = A[E])[0], k[1]);
            r.lineEnd();
          }
          return;
        }
        $ > 1 && x & 2 && w.push(w.pop().concat(w.shift())), c.push(w.filter(jz));
      }
    }
    return d;
  };
}
function jz(e) {
  return e.length > 1;
}
function Uz(e, t) {
  return ((e = e.x)[0] < 0 ? e[1] - He - ne : He - e[1]) - ((t = t.x)[0] < 0 ? t[1] - He - ne : He - t[1]);
}
const V5 = s9(
  function() {
    return !0;
  },
  qz,
  Wz,
  [-fe, -He]
);
function qz(e) {
  var t = NaN, n = NaN, i = NaN, r;
  return {
    lineStart: function() {
      e.lineStart(), r = 1;
    },
    point: function(a, s) {
      var o = a > 0 ? fe : -fe, u = ge(a - t);
      ge(u - fe) < ne ? (e.point(t, n = (n + s) / 2 > 0 ? He : -He), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(o, n), e.point(a, n), r = 0) : i !== o && u >= fe && (ge(t - i) < ne && (t -= i * ne), ge(a - o) < ne && (a -= o * ne), n = Gz(t, n, a, s), e.point(i, n), e.lineEnd(), e.lineStart(), e.point(o, n), r = 0), e.point(t = a, n = s), i = o;
    },
    lineEnd: function() {
      e.lineEnd(), t = n = NaN;
    },
    clean: function() {
      return 2 - r;
    }
  };
}
function Gz(e, t, n, i) {
  var r, a, s = te(e - n);
  return ge(s) > ne ? Yu((te(t) * (a = re(i)) * te(n) - te(i) * (r = re(t)) * te(e)) / (r * a * s)) : (t + i) / 2;
}
function Wz(e, t, n, i) {
  var r;
  if (e == null)
    r = n * He, i.point(-fe, r), i.point(0, r), i.point(fe, r), i.point(fe, 0), i.point(fe, -r), i.point(0, -r), i.point(-fe, -r), i.point(-fe, 0), i.point(-fe, r);
  else if (ge(e[0] - t[0]) > ne) {
    var a = e[0] < t[0] ? fe : -fe;
    r = n * a / 2, i.point(-a, r), i.point(0, r), i.point(a, r);
  } else
    i.point(t[0], t[1]);
}
function Hz(e) {
  var t = re(e), n = 6 * ce, i = t > 0, r = ge(t) > ne;
  function a(c, f, d, h) {
    Iz(h, e, n, d, c, f);
  }
  function s(c, f) {
    return re(c) * re(f) > t;
  }
  function o(c) {
    var f, d, h, p, g;
    return {
      lineStart: function() {
        p = h = !1, g = 1;
      },
      point: function(m, y) {
        var b = [m, y], v, x = s(m, y), w = i ? x ? 0 : l(m, y) : x ? l(m + (m < 0 ? fe : -fe), y) : 0;
        if (!f && (p = h = x) && c.lineStart(), x !== h && (v = u(f, b), (!v || Ah(f, v) || Ah(b, v)) && (b[2] = 1)), x !== h)
          g = 0, x ? (c.lineStart(), v = u(b, f), c.point(v[0], v[1])) : (v = u(f, b), c.point(v[0], v[1], 2), c.lineEnd()), f = v;
        else if (r && f && i ^ x) {
          var E;
          !(w & d) && (E = u(b, f, !0)) && (g = 0, i ? (c.lineStart(), c.point(E[0][0], E[0][1]), c.point(E[1][0], E[1][1]), c.lineEnd()) : (c.point(E[1][0], E[1][1]), c.lineEnd(), c.lineStart(), c.point(E[0][0], E[0][1], 3)));
        }
        x && (!f || !Ah(f, b)) && c.point(b[0], b[1]), f = b, h = x, d = w;
      },
      lineEnd: function() {
        h && c.lineEnd(), f = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function() {
        return g | (p && h) << 1;
      }
    };
  }
  function u(c, f, d) {
    var h = to(c), p = to(f), g = [1, 0, 0], m = yu(h, p), y = Gd(m, m), b = m[0], v = y - b * b;
    if (!v)
      return !d && c;
    var x = t * y / v, w = -t * b / v, E = yu(g, m), $ = Wd(g, x), S = Wd(m, w);
    g1($, S);
    var A = E, k = Gd($, A), _ = Gd(A, A), P = k * k - _ * (Gd($, $) - 1);
    if (!(P < 0)) {
      var F = rn(P), M = Wd(A, (-k - F) / _);
      if (g1(M, $), M = cp(M), !d)
        return M;
      var C = c[0], O = f[0], L = c[1], z = f[1], W;
      O < C && (W = C, C = O, O = W);
      var J = O - C, ie = ge(J - fe) < ne, de = ie || J < ne;
      if (!ie && z < L && (W = L, L = z, z = W), de ? ie ? L + z > 0 ^ M[1] < (ge(M[0] - C) < ne ? L : z) : L <= M[1] && M[1] <= z : J > fe ^ (C <= M[0] && M[0] <= O)) {
        var Re = Wd(A, (-k + F) / _);
        return g1(Re, $), [M, cp(Re)];
      }
    }
  }
  function l(c, f) {
    var d = i ? e : fe - e, h = 0;
    return c < -d ? h |= 1 : c > d && (h |= 2), f < -d ? h |= 4 : f > d && (h |= 8), h;
  }
  return s9(s, o, a, i ? [0, -e] : [-fe, e - fe]);
}
function Vz(e, t, n, i, r, a) {
  var s = e[0], o = e[1], u = t[0], l = t[1], c = 0, f = 1, d = u - s, h = l - o, p;
  if (p = n - s, !(!d && p > 0)) {
    if (p /= d, d < 0) {
      if (p < c)
        return;
      p < f && (f = p);
    } else if (d > 0) {
      if (p > f)
        return;
      p > c && (c = p);
    }
    if (p = r - s, !(!d && p < 0)) {
      if (p /= d, d < 0) {
        if (p > f)
          return;
        p > c && (c = p);
      } else if (d > 0) {
        if (p < c)
          return;
        p < f && (f = p);
      }
      if (p = i - o, !(!h && p > 0)) {
        if (p /= h, h < 0) {
          if (p < c)
            return;
          p < f && (f = p);
        } else if (h > 0) {
          if (p > f)
            return;
          p > c && (c = p);
        }
        if (p = a - o, !(!h && p < 0)) {
          if (p /= h, h < 0) {
            if (p > f)
              return;
            p > c && (c = p);
          } else if (h > 0) {
            if (p < c)
              return;
            p < f && (f = p);
          }
          return c > 0 && (e[0] = s + c * d, e[1] = o + c * h), f < 1 && (t[0] = s + f * d, t[1] = o + f * h), !0;
        }
      }
    }
  }
}
var Ql = 1e9, Vd = -Ql;
function o9(e, t, n, i) {
  function r(l, c) {
    return e <= l && l <= n && t <= c && c <= i;
  }
  function a(l, c, f, d) {
    var h = 0, p = 0;
    if (l == null || (h = s(l, f)) !== (p = s(c, f)) || u(l, c) < 0 ^ f > 0)
      do
        d.point(h === 0 || h === 3 ? e : n, h > 1 ? i : t);
      while ((h = (h + f + 4) % 4) !== p);
    else
      d.point(c[0], c[1]);
  }
  function s(l, c) {
    return ge(l[0] - e) < ne ? c > 0 ? 0 : 3 : ge(l[0] - n) < ne ? c > 0 ? 2 : 1 : ge(l[1] - t) < ne ? c > 0 ? 1 : 0 : c > 0 ? 3 : 2;
  }
  function o(l, c) {
    return u(l.x, c.x);
  }
  function u(l, c) {
    var f = s(l, 1), d = s(c, 1);
    return f !== d ? f - d : f === 0 ? c[1] - l[1] : f === 1 ? l[0] - c[0] : f === 2 ? l[1] - c[1] : c[0] - l[0];
  }
  return function(l) {
    var c = l, f = r9(), d, h, p, g, m, y, b, v, x, w, E, $ = {
      point: S,
      lineStart: P,
      lineEnd: F,
      polygonStart: k,
      polygonEnd: _
    };
    function S(C, O) {
      r(C, O) && c.point(C, O);
    }
    function A() {
      for (var C = 0, O = 0, L = h.length; O < L; ++O)
        for (var z = h[O], W = 1, J = z.length, ie = z[0], de, Re, we = ie[0], ln = ie[1]; W < J; ++W)
          de = we, Re = ln, ie = z[W], we = ie[0], ln = ie[1], Re <= i ? ln > i && (we - de) * (i - Re) > (ln - Re) * (e - de) && ++C : ln <= i && (we - de) * (i - Re) < (ln - Re) * (e - de) && --C;
      return C;
    }
    function k() {
      c = f, d = [], h = [], E = !0;
    }
    function _() {
      var C = A(), O = E && C, L = (d = Nk(d)).length;
      (O || L) && (l.polygonStart(), O && (l.lineStart(), a(null, null, 1, l), l.lineEnd()), L && a9(d, o, C, a, l), l.polygonEnd()), c = l, d = h = p = null;
    }
    function P() {
      $.point = M, h && h.push(p = []), w = !0, x = !1, b = v = NaN;
    }
    function F() {
      d && (M(g, m), y && x && f.rejoin(), d.push(f.result())), $.point = S, x && c.lineEnd();
    }
    function M(C, O) {
      var L = r(C, O);
      if (h && p.push([C, O]), w)
        g = C, m = O, y = L, w = !1, L && (c.lineStart(), c.point(C, O));
      else if (L && x)
        c.point(C, O);
      else {
        var z = [b = Math.max(Vd, Math.min(Ql, b)), v = Math.max(Vd, Math.min(Ql, v))], W = [C = Math.max(Vd, Math.min(Ql, C)), O = Math.max(Vd, Math.min(Ql, O))];
        Vz(z, W, e, t, n, i) ? (x || (c.lineStart(), c.point(z[0], z[1])), c.point(W[0], W[1]), L || c.lineEnd(), E = !1) : L && (c.lineStart(), c.point(C, O), E = !1);
      }
      b = C, v = O, x = L;
    }
    return $;
  };
}
function X5(e, t, n) {
  var i = xt(e, t - ne, n).concat(t);
  return function(r) {
    return i.map(function(a) {
      return [r, a];
    });
  };
}
function Y5(e, t, n) {
  var i = xt(e, t - ne, n).concat(t);
  return function(r) {
    return i.map(function(a) {
      return [a, r];
    });
  };
}
function Xz() {
  var e, t, n, i, r, a, s, o, u = 10, l = u, c = 90, f = 360, d, h, p, g, m = 2.5;
  function y() {
    return { type: "MultiLineString", coordinates: b() };
  }
  function b() {
    return xt(qd(i / c) * c, n, c).map(p).concat(xt(qd(o / f) * f, s, f).map(g)).concat(xt(qd(t / u) * u, e, u).filter(function(v) {
      return ge(v % c) > ne;
    }).map(d)).concat(xt(qd(a / l) * l, r, l).filter(function(v) {
      return ge(v % f) > ne;
    }).map(h));
  }
  return y.lines = function() {
    return b().map(function(v) {
      return { type: "LineString", coordinates: v };
    });
  }, y.outline = function() {
    return {
      type: "Polygon",
      coordinates: [
        p(i).concat(
          g(s).slice(1),
          p(n).reverse().slice(1),
          g(o).reverse().slice(1)
        )
      ]
    };
  }, y.extent = function(v) {
    return arguments.length ? y.extentMajor(v).extentMinor(v) : y.extentMinor();
  }, y.extentMajor = function(v) {
    return arguments.length ? (i = +v[0][0], n = +v[1][0], o = +v[0][1], s = +v[1][1], i > n && (v = i, i = n, n = v), o > s && (v = o, o = s, s = v), y.precision(m)) : [[i, o], [n, s]];
  }, y.extentMinor = function(v) {
    return arguments.length ? (t = +v[0][0], e = +v[1][0], a = +v[0][1], r = +v[1][1], t > e && (v = t, t = e, e = v), a > r && (v = a, a = r, r = v), y.precision(m)) : [[t, a], [e, r]];
  }, y.step = function(v) {
    return arguments.length ? y.stepMajor(v).stepMinor(v) : y.stepMinor();
  }, y.stepMajor = function(v) {
    return arguments.length ? (c = +v[0], f = +v[1], y) : [c, f];
  }, y.stepMinor = function(v) {
    return arguments.length ? (u = +v[0], l = +v[1], y) : [u, l];
  }, y.precision = function(v) {
    return arguments.length ? (m = +v, d = X5(a, r, 90), h = Y5(t, e, m), p = X5(o, s, 90), g = Y5(i, n, m), y) : m;
  }, y.extentMajor([[-180, -90 + ne], [180, 90 - ne]]).extentMinor([[-180, -80 - ne], [180, 80 + ne]]);
}
const Uc = (e) => e;
var y1 = new Zt(), Yy = new Zt(), u9, l9, Ky, Jy, $a = {
  point: $t,
  lineStart: $t,
  lineEnd: $t,
  polygonStart: function() {
    $a.lineStart = Yz, $a.lineEnd = Jz;
  },
  polygonEnd: function() {
    $a.lineStart = $a.lineEnd = $a.point = $t, y1.add(ge(Yy)), Yy = new Zt();
  },
  result: function() {
    var e = y1 / 2;
    return y1 = new Zt(), e;
  }
};
function Yz() {
  $a.point = Kz;
}
function Kz(e, t) {
  $a.point = c9, u9 = Ky = e, l9 = Jy = t;
}
function c9(e, t) {
  Yy.add(Jy * e - Ky * t), Ky = e, Jy = t;
}
function Jz() {
  c9(u9, l9);
}
const K5 = $a;
var bu = 1 / 0, vp = bu, qc = -bu, xp = qc, Qz = {
  point: Zz,
  lineStart: $t,
  lineEnd: $t,
  polygonStart: $t,
  polygonEnd: $t,
  result: function() {
    var e = [[bu, vp], [qc, xp]];
    return qc = xp = -(vp = bu = 1 / 0), e;
  }
};
function Zz(e, t) {
  e < bu && (bu = e), e > qc && (qc = e), t < vp && (vp = t), t > xp && (xp = t);
}
const $p = Qz;
var Qy = 0, Zy = 0, Zl = 0, wp = 0, Ep = 0, nu = 0, eb = 0, tb = 0, ec = 0, f9, d9, Zi, er, gi = {
  point: no,
  lineStart: J5,
  lineEnd: Q5,
  polygonStart: function() {
    gi.lineStart = nI, gi.lineEnd = iI;
  },
  polygonEnd: function() {
    gi.point = no, gi.lineStart = J5, gi.lineEnd = Q5;
  },
  result: function() {
    var e = ec ? [eb / ec, tb / ec] : nu ? [wp / nu, Ep / nu] : Zl ? [Qy / Zl, Zy / Zl] : [NaN, NaN];
    return Qy = Zy = Zl = wp = Ep = nu = eb = tb = ec = 0, e;
  }
};
function no(e, t) {
  Qy += e, Zy += t, ++Zl;
}
function J5() {
  gi.point = eI;
}
function eI(e, t) {
  gi.point = tI, no(Zi = e, er = t);
}
function tI(e, t) {
  var n = e - Zi, i = t - er, r = rn(n * n + i * i);
  wp += r * (Zi + e) / 2, Ep += r * (er + t) / 2, nu += r, no(Zi = e, er = t);
}
function Q5() {
  gi.point = no;
}
function nI() {
  gi.point = rI;
}
function iI() {
  h9(f9, d9);
}
function rI(e, t) {
  gi.point = h9, no(f9 = Zi = e, d9 = er = t);
}
function h9(e, t) {
  var n = e - Zi, i = t - er, r = rn(n * n + i * i);
  wp += r * (Zi + e) / 2, Ep += r * (er + t) / 2, nu += r, r = er * e - Zi * t, eb += r * (Zi + e), tb += r * (er + t), ec += r * 3, no(Zi = e, er = t);
}
const Z5 = gi;
function p9(e) {
  this._context = e;
}
p9.prototype = {
  _radius: 4.5,
  pointRadius: function(e) {
    return this._radius = e, this;
  },
  polygonStart: function() {
    this._line = 0;
  },
  polygonEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    this._line === 0 && this._context.closePath(), this._point = NaN;
  },
  point: function(e, t) {
    switch (this._point) {
      case 0: {
        this._context.moveTo(e, t), this._point = 1;
        break;
      }
      case 1: {
        this._context.lineTo(e, t);
        break;
      }
      default: {
        this._context.moveTo(e + this._radius, t), this._context.arc(e, t, this._radius, 0, nn);
        break;
      }
    }
  },
  result: $t
};
var nb = new Zt(), b1, g9, m9, tc, nc, Sp = {
  point: $t,
  lineStart: function() {
    Sp.point = aI;
  },
  lineEnd: function() {
    b1 && y9(g9, m9), Sp.point = $t;
  },
  polygonStart: function() {
    b1 = !0;
  },
  polygonEnd: function() {
    b1 = null;
  },
  result: function() {
    var e = +nb;
    return nb = new Zt(), e;
  }
};
function aI(e, t) {
  Sp.point = y9, g9 = tc = e, m9 = nc = t;
}
function y9(e, t) {
  tc -= e, nc -= t, nb.add(rn(tc * tc + nc * nc)), tc = e, nc = t;
}
const eS = Sp;
let tS, Ap, nS, iS;
class rS {
  constructor(t) {
    this._append = t == null ? b9 : sI(t), this._radius = 4.5, this._ = "";
  }
  pointRadius(t) {
    return this._radius = +t, this;
  }
  polygonStart() {
    this._line = 0;
  }
  polygonEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    this._line === 0 && (this._ += "Z"), this._point = NaN;
  }
  point(t, n) {
    switch (this._point) {
      case 0: {
        this._append`M${t},${n}`, this._point = 1;
        break;
      }
      case 1: {
        this._append`L${t},${n}`;
        break;
      }
      default: {
        if (this._append`M${t},${n}`, this._radius !== nS || this._append !== Ap) {
          const i = this._radius, r = this._;
          this._ = "", this._append`m0,${i}a${i},${i} 0 1,1 0,${-2 * i}a${i},${i} 0 1,1 0,${2 * i}z`, nS = i, Ap = this._append, iS = this._, this._ = r;
        }
        this._ += iS;
        break;
      }
    }
  }
  result() {
    const t = this._;
    return this._ = "", t.length ? t : null;
  }
}
function b9(e) {
  let t = 1;
  this._ += e[0];
  for (const n = e.length; t < n; ++t)
    this._ += arguments[t] + e[t];
}
function sI(e) {
  const t = Math.floor(e);
  if (!(t >= 0))
    throw new RangeError(`invalid digits: ${e}`);
  if (t > 15)
    return b9;
  if (t !== tS) {
    const n = 10 ** t;
    tS = t, Ap = function(r) {
      let a = 1;
      this._ += r[0];
      for (const s = r.length; a < s; ++a)
        this._ += Math.round(arguments[a] * n) / n + r[a];
    };
  }
  return Ap;
}
function v9(e, t) {
  let n = 3, i = 4.5, r, a;
  function s(o) {
    return o && (typeof i == "function" && a.pointRadius(+i.apply(this, arguments)), zr(o, r(a))), a.result();
  }
  return s.area = function(o) {
    return zr(o, r(K5)), K5.result();
  }, s.measure = function(o) {
    return zr(o, r(eS)), eS.result();
  }, s.bounds = function(o) {
    return zr(o, r($p)), $p.result();
  }, s.centroid = function(o) {
    return zr(o, r(Z5)), Z5.result();
  }, s.projection = function(o) {
    return arguments.length ? (r = o == null ? (e = null, Uc) : (e = o).stream, s) : e;
  }, s.context = function(o) {
    return arguments.length ? (a = o == null ? (t = null, new rS(n)) : new p9(t = o), typeof i != "function" && a.pointRadius(i), s) : t;
  }, s.pointRadius = function(o) {
    return arguments.length ? (i = typeof o == "function" ? o : (a.pointRadius(+o), +o), s) : i;
  }, s.digits = function(o) {
    if (!arguments.length)
      return n;
    if (o == null)
      n = null;
    else {
      const u = Math.floor(o);
      if (!(u >= 0))
        throw new RangeError(`invalid digits: ${o}`);
      n = u;
    }
    return t === null && (a = new rS(n)), s;
  }, s.projection(e).digits(n).context(t);
}
function qg(e) {
  return function(t) {
    var n = new ib();
    for (var i in e)
      n[i] = e[i];
    return n.stream = t, n;
  };
}
function ib() {
}
ib.prototype = {
  constructor: ib,
  point: function(e, t) {
    this.stream.point(e, t);
  },
  sphere: function() {
    this.stream.sphere();
  },
  lineStart: function() {
    this.stream.lineStart();
  },
  lineEnd: function() {
    this.stream.lineEnd();
  },
  polygonStart: function() {
    this.stream.polygonStart();
  },
  polygonEnd: function() {
    this.stream.polygonEnd();
  }
};
function c2(e, t, n) {
  var i = e.clipExtent && e.clipExtent();
  return e.scale(150).translate([0, 0]), i != null && e.clipExtent(null), zr(n, e.stream($p)), t($p.result()), i != null && e.clipExtent(i), e;
}
function Gg(e, t, n) {
  return c2(e, function(i) {
    var r = t[1][0] - t[0][0], a = t[1][1] - t[0][1], s = Math.min(r / (i[1][0] - i[0][0]), a / (i[1][1] - i[0][1])), o = +t[0][0] + (r - s * (i[1][0] + i[0][0])) / 2, u = +t[0][1] + (a - s * (i[1][1] + i[0][1])) / 2;
    e.scale(150 * s).translate([o, u]);
  }, n);
}
function f2(e, t, n) {
  return Gg(e, [[0, 0], t], n);
}
function d2(e, t, n) {
  return c2(e, function(i) {
    var r = +t, a = r / (i[1][0] - i[0][0]), s = (r - a * (i[1][0] + i[0][0])) / 2, o = -a * i[0][1];
    e.scale(150 * a).translate([s, o]);
  }, n);
}
function h2(e, t, n) {
  return c2(e, function(i) {
    var r = +t, a = r / (i[1][1] - i[0][1]), s = -a * i[0][0], o = (r - a * (i[1][1] + i[0][1])) / 2;
    e.scale(150 * a).translate([s, o]);
  }, n);
}
var aS = 16, oI = re(30 * ce);
function sS(e, t) {
  return +t ? lI(e, t) : uI(e);
}
function uI(e) {
  return qg({
    point: function(t, n) {
      t = e(t, n), this.stream.point(t[0], t[1]);
    }
  });
}
function lI(e, t) {
  function n(i, r, a, s, o, u, l, c, f, d, h, p, g, m) {
    var y = l - i, b = c - r, v = y * y + b * b;
    if (v > 4 * t && g--) {
      var x = s + d, w = o + h, E = u + p, $ = rn(x * x + w * w + E * E), S = bn(E /= $), A = ge(ge(E) - 1) < ne || ge(a - f) < ne ? (a + f) / 2 : Zn(w, x), k = e(A, S), _ = k[0], P = k[1], F = _ - i, M = P - r, C = b * F - y * M;
      (C * C / v > t || ge((y * F + b * M) / v - 0.5) > 0.3 || s * d + o * h + u * p < oI) && (n(i, r, a, s, o, u, _, P, A, x /= $, w /= $, E, g, m), m.point(_, P), n(_, P, A, x, w, E, l, c, f, d, h, p, g, m));
    }
  }
  return function(i) {
    var r, a, s, o, u, l, c, f, d, h, p, g, m = {
      point: y,
      lineStart: b,
      lineEnd: x,
      polygonStart: function() {
        i.polygonStart(), m.lineStart = w;
      },
      polygonEnd: function() {
        i.polygonEnd(), m.lineStart = b;
      }
    };
    function y(S, A) {
      S = e(S, A), i.point(S[0], S[1]);
    }
    function b() {
      f = NaN, m.point = v, i.lineStart();
    }
    function v(S, A) {
      var k = to([S, A]), _ = e(S, A);
      n(f, d, c, h, p, g, f = _[0], d = _[1], c = S, h = k[0], p = k[1], g = k[2], aS, i), i.point(f, d);
    }
    function x() {
      m.point = y, i.lineEnd();
    }
    function w() {
      b(), m.point = E, m.lineEnd = $;
    }
    function E(S, A) {
      v(r = S, A), a = f, s = d, o = h, u = p, l = g, m.point = v;
    }
    function $() {
      n(f, d, c, h, p, g, a, s, r, o, u, l, aS, i), m.lineEnd = x, x();
    }
    return m;
  };
}
var cI = qg({
  point: function(e, t) {
    this.stream.point(e * ce, t * ce);
  }
});
function fI(e) {
  return qg({
    point: function(t, n) {
      var i = e(t, n);
      return this.stream.point(i[0], i[1]);
    }
  });
}
function dI(e, t, n, i, r) {
  function a(s, o) {
    return s *= i, o *= r, [t + e * s, n - e * o];
  }
  return a.invert = function(s, o) {
    return [(s - t) / e * i, (n - o) / e * r];
  }, a;
}
function oS(e, t, n, i, r, a) {
  if (!a)
    return dI(e, t, n, i, r);
  var s = re(a), o = te(a), u = s * e, l = o * e, c = s / e, f = o / e, d = (o * n - s * t) / e, h = (o * t + s * n) / e;
  function p(g, m) {
    return g *= i, m *= r, [u * g - l * m + t, n - l * g - u * m];
  }
  return p.invert = function(g, m) {
    return [i * (c * g - f * m + d), r * (h - f * g - c * m)];
  }, p;
}
function yr(e) {
  return x9(function() {
    return e;
  })();
}
function x9(e) {
  var t, n = 150, i = 480, r = 250, a = 0, s = 0, o = 0, u = 0, l = 0, c, f = 0, d = 1, h = 1, p = null, g = V5, m = null, y, b, v, x = Uc, w = 0.5, E, $, S, A, k;
  function _(C) {
    return S(C[0] * ce, C[1] * ce);
  }
  function P(C) {
    return C = S.invert(C[0], C[1]), C && [C[0] * Xe, C[1] * Xe];
  }
  _.stream = function(C) {
    return A && k === C ? A : A = cI(fI(c)(g(E(x(k = C)))));
  }, _.preclip = function(C) {
    return arguments.length ? (g = C, p = void 0, M()) : g;
  }, _.postclip = function(C) {
    return arguments.length ? (x = C, m = y = b = v = null, M()) : x;
  }, _.clipAngle = function(C) {
    return arguments.length ? (g = +C ? Hz(p = C * ce) : (p = null, V5), M()) : p * Xe;
  }, _.clipExtent = function(C) {
    return arguments.length ? (x = C == null ? (m = y = b = v = null, Uc) : o9(m = +C[0][0], y = +C[0][1], b = +C[1][0], v = +C[1][1]), M()) : m == null ? null : [[m, y], [b, v]];
  }, _.scale = function(C) {
    return arguments.length ? (n = +C, F()) : n;
  }, _.translate = function(C) {
    return arguments.length ? (i = +C[0], r = +C[1], F()) : [i, r];
  }, _.center = function(C) {
    return arguments.length ? (a = C[0] % 360 * ce, s = C[1] % 360 * ce, F()) : [a * Xe, s * Xe];
  }, _.rotate = function(C) {
    return arguments.length ? (o = C[0] % 360 * ce, u = C[1] % 360 * ce, l = C.length > 2 ? C[2] % 360 * ce : 0, F()) : [o * Xe, u * Xe, l * Xe];
  }, _.angle = function(C) {
    return arguments.length ? (f = C % 360 * ce, F()) : f * Xe;
  }, _.reflectX = function(C) {
    return arguments.length ? (d = C ? -1 : 1, F()) : d < 0;
  }, _.reflectY = function(C) {
    return arguments.length ? (h = C ? -1 : 1, F()) : h < 0;
  }, _.precision = function(C) {
    return arguments.length ? (E = sS($, w = C * C), M()) : rn(w);
  }, _.fitExtent = function(C, O) {
    return Gg(_, C, O);
  }, _.fitSize = function(C, O) {
    return f2(_, C, O);
  }, _.fitWidth = function(C, O) {
    return d2(_, C, O);
  }, _.fitHeight = function(C, O) {
    return h2(_, C, O);
  };
  function F() {
    var C = oS(n, 0, 0, d, h, f).apply(null, t(a, s)), O = oS(n, i - C[0], r - C[1], d, h, f);
    return c = i9(o, u, l), $ = Vy(t, O), S = Vy(c, $), E = sS($, w), M();
  }
  function M() {
    return A = k = null, _;
  }
  return function() {
    return t = e.apply(this, arguments), _.invert = t.invert && P, F();
  };
}
function p2(e) {
  var t = 0, n = fe / 3, i = x9(e), r = i(t, n);
  return r.parallels = function(a) {
    return arguments.length ? i(t = a[0] * ce, n = a[1] * ce) : [t * Xe, n * Xe];
  }, r;
}
function hI(e) {
  var t = re(e);
  function n(i, r) {
    return [i * t, te(r) / t];
  }
  return n.invert = function(i, r) {
    return [i / t, bn(r * t)];
  }, n;
}
function pI(e, t) {
  var n = te(e), i = (n + te(t)) / 2;
  if (ge(i) < ne)
    return hI(e);
  var r = 1 + n * (2 * i - n), a = rn(r) / i;
  function s(o, u) {
    var l = rn(r - 2 * i * te(u)) / i;
    return [l * te(o *= i), a - l * re(o)];
  }
  return s.invert = function(o, u) {
    var l = a - u, c = Zn(o, ge(l)) * Vn(l);
    return l * i < 0 && (c -= fe * Vn(o) * Vn(l)), [c / i, bn((r - (o * o + l * l) * i * i) / (2 * i))];
  }, s;
}
function kp() {
  return p2(pI).scale(155.424).center([0, 33.6442]);
}
function $9() {
  return kp().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
function gI(e) {
  var t = e.length;
  return {
    point: function(n, i) {
      for (var r = -1; ++r < t; )
        e[r].point(n, i);
    },
    sphere: function() {
      for (var n = -1; ++n < t; )
        e[n].sphere();
    },
    lineStart: function() {
      for (var n = -1; ++n < t; )
        e[n].lineStart();
    },
    lineEnd: function() {
      for (var n = -1; ++n < t; )
        e[n].lineEnd();
    },
    polygonStart: function() {
      for (var n = -1; ++n < t; )
        e[n].polygonStart();
    },
    polygonEnd: function() {
      for (var n = -1; ++n < t; )
        e[n].polygonEnd();
    }
  };
}
function mI() {
  var e, t, n = $9(), i, r = kp().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]), a, s = kp().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]), o, u, l = { point: function(d, h) {
    u = [d, h];
  } };
  function c(d) {
    var h = d[0], p = d[1];
    return u = null, i.point(h, p), u || (a.point(h, p), u) || (o.point(h, p), u);
  }
  c.invert = function(d) {
    var h = n.scale(), p = n.translate(), g = (d[0] - p[0]) / h, m = (d[1] - p[1]) / h;
    return (m >= 0.12 && m < 0.234 && g >= -0.425 && g < -0.214 ? r : m >= 0.166 && m < 0.234 && g >= -0.214 && g < -0.115 ? s : n).invert(d);
  }, c.stream = function(d) {
    return e && t === d ? e : e = gI([n.stream(t = d), r.stream(d), s.stream(d)]);
  }, c.precision = function(d) {
    return arguments.length ? (n.precision(d), r.precision(d), s.precision(d), f()) : n.precision();
  }, c.scale = function(d) {
    return arguments.length ? (n.scale(d), r.scale(d * 0.35), s.scale(d), c.translate(n.translate())) : n.scale();
  }, c.translate = function(d) {
    if (!arguments.length)
      return n.translate();
    var h = n.scale(), p = +d[0], g = +d[1];
    return i = n.translate(d).clipExtent([[p - 0.455 * h, g - 0.238 * h], [p + 0.455 * h, g + 0.238 * h]]).stream(l), a = r.translate([p - 0.307 * h, g + 0.201 * h]).clipExtent([[p - 0.425 * h + ne, g + 0.12 * h + ne], [p - 0.214 * h - ne, g + 0.234 * h - ne]]).stream(l), o = s.translate([p - 0.205 * h, g + 0.212 * h]).clipExtent([[p - 0.214 * h + ne, g + 0.166 * h + ne], [p - 0.115 * h - ne, g + 0.234 * h - ne]]).stream(l), f();
  }, c.fitExtent = function(d, h) {
    return Gg(c, d, h);
  }, c.fitSize = function(d, h) {
    return f2(c, d, h);
  }, c.fitWidth = function(d, h) {
    return d2(c, d, h);
  }, c.fitHeight = function(d, h) {
    return h2(c, d, h);
  };
  function f() {
    return e = t = null, c;
  }
  return c.scale(1070);
}
function w9(e) {
  return function(t, n) {
    var i = re(t), r = re(n), a = e(i * r);
    return a === 1 / 0 ? [2, 0] : [
      a * r * te(t),
      a * te(n)
    ];
  };
}
function Mf(e) {
  return function(t, n) {
    var i = rn(t * t + n * n), r = e(i), a = te(r), s = re(r);
    return [
      Zn(t * a, i * s),
      bn(i && n * a / i)
    ];
  };
}
var E9 = w9(function(e) {
  return rn(2 / (1 + e));
});
E9.invert = Mf(function(e) {
  return 2 * bn(e / 2);
});
function yI() {
  return yr(E9).scale(124.75).clipAngle(180 - 1e-3);
}
var S9 = w9(function(e) {
  return (e = qk(e)) && e / te(e);
});
S9.invert = Mf(function(e) {
  return e;
});
function bI() {
  return yr(S9).scale(79.4188).clipAngle(180 - 1e-3);
}
function Wg(e, t) {
  return [e, sp(u2((He + t) / 2))];
}
Wg.invert = function(e, t) {
  return [e, 2 * Yu(Uk(t)) - He];
};
function vI() {
  return A9(Wg).scale(961 / nn);
}
function A9(e) {
  var t = yr(e), n = t.center, i = t.scale, r = t.translate, a = t.clipExtent, s = null, o, u, l;
  t.scale = function(f) {
    return arguments.length ? (i(f), c()) : i();
  }, t.translate = function(f) {
    return arguments.length ? (r(f), c()) : r();
  }, t.center = function(f) {
    return arguments.length ? (n(f), c()) : n();
  }, t.clipExtent = function(f) {
    return arguments.length ? (f == null ? s = o = u = l = null : (s = +f[0][0], o = +f[0][1], u = +f[1][0], l = +f[1][1]), c()) : s == null ? null : [[s, o], [u, l]];
  };
  function c() {
    var f = fe * i(), d = t(zz(t.rotate()).invert([0, 0]));
    return a(s == null ? [[d[0] - f, d[1] - f], [d[0] + f, d[1] + f]] : e === Wg ? [[Math.max(d[0] - f, s), o], [Math.min(d[0] + f, u), l]] : [[s, Math.max(d[1] - f, o)], [u, Math.min(d[1] + f, l)]]);
  }
  return c();
}
function Xd(e) {
  return u2((He + e) / 2);
}
function xI(e, t) {
  var n = re(e), i = e === t ? te(e) : sp(n / re(t)) / sp(Xd(t) / Xd(e)), r = n * p1(Xd(e), i) / i;
  if (!i)
    return Wg;
  function a(s, o) {
    r > 0 ? o < -He + ne && (o = -He + ne) : o > He - ne && (o = He - ne);
    var u = r / p1(Xd(o), i);
    return [u * te(i * s), r - u * re(i * s)];
  }
  return a.invert = function(s, o) {
    var u = r - o, l = Vn(i) * rn(s * s + u * u), c = Zn(s, ge(u)) * Vn(u);
    return u * i < 0 && (c -= fe * Vn(s) * Vn(u)), [c / i, 2 * Yu(p1(r / l, 1 / i)) - He];
  }, a;
}
function $I() {
  return p2(xI).scale(109.5).parallels([30, 30]);
}
function Cp(e, t) {
  return [e, t];
}
Cp.invert = Cp;
function wI() {
  return yr(Cp).scale(152.63);
}
function EI(e, t) {
  var n = re(e), i = e === t ? te(e) : (n - re(t)) / (t - e), r = n / i + e;
  if (ge(i) < ne)
    return Cp;
  function a(s, o) {
    var u = r - o, l = i * s;
    return [u * te(l), r - u * re(l)];
  }
  return a.invert = function(s, o) {
    var u = r - o, l = Zn(s, ge(u)) * Vn(u);
    return u * i < 0 && (l -= fe * Vn(s) * Vn(u)), [l / i, r - Vn(i) * rn(s * s + u * u)];
  }, a;
}
function SI() {
  return p2(EI).scale(131.154).center([0, 13.9389]);
}
var wc = 1.340264, Ec = -0.081106, Sc = 893e-6, Ac = 3796e-6, _p = rn(3) / 2, AI = 12;
function k9(e, t) {
  var n = bn(_p * te(t)), i = n * n, r = i * i * i;
  return [
    e * re(n) / (_p * (wc + 3 * Ec * i + r * (7 * Sc + 9 * Ac * i))),
    n * (wc + Ec * i + r * (Sc + Ac * i))
  ];
}
k9.invert = function(e, t) {
  for (var n = t, i = n * n, r = i * i * i, a = 0, s, o, u; a < AI && (o = n * (wc + Ec * i + r * (Sc + Ac * i)) - t, u = wc + 3 * Ec * i + r * (7 * Sc + 9 * Ac * i), n -= s = o / u, i = n * n, r = i * i * i, !(ge(s) < rp)); ++a)
    ;
  return [
    _p * e * (wc + 3 * Ec * i + r * (7 * Sc + 9 * Ac * i)) / re(n),
    bn(te(n) / _p)
  ];
};
function kI() {
  return yr(k9).scale(177.158);
}
function C9(e, t) {
  var n = re(t), i = re(e) * n;
  return [n * te(e) / i, te(t) / i];
}
C9.invert = Mf(Yu);
function CI() {
  return yr(C9).scale(144.049).clipAngle(60);
}
function _I() {
  var e = 1, t = 0, n = 0, i = 1, r = 1, a = 0, s, o, u = null, l, c, f, d = 1, h = 1, p = qg({
    point: function(x, w) {
      var E = v([x, w]);
      this.stream.point(E[0], E[1]);
    }
  }), g = Uc, m, y;
  function b() {
    return d = e * i, h = e * r, m = y = null, v;
  }
  function v(x) {
    var w = x[0] * d, E = x[1] * h;
    if (a) {
      var $ = E * s - w * o;
      w = w * s + E * o, E = $;
    }
    return [w + t, E + n];
  }
  return v.invert = function(x) {
    var w = x[0] - t, E = x[1] - n;
    if (a) {
      var $ = E * s + w * o;
      w = w * s - E * o, E = $;
    }
    return [w / d, E / h];
  }, v.stream = function(x) {
    return m && y === x ? m : m = p(g(y = x));
  }, v.postclip = function(x) {
    return arguments.length ? (g = x, u = l = c = f = null, b()) : g;
  }, v.clipExtent = function(x) {
    return arguments.length ? (g = x == null ? (u = l = c = f = null, Uc) : o9(u = +x[0][0], l = +x[0][1], c = +x[1][0], f = +x[1][1]), b()) : u == null ? null : [[u, l], [c, f]];
  }, v.scale = function(x) {
    return arguments.length ? (e = +x, b()) : e;
  }, v.translate = function(x) {
    return arguments.length ? (t = +x[0], n = +x[1], b()) : [t, n];
  }, v.angle = function(x) {
    return arguments.length ? (a = x % 360 * ce, o = te(a), s = re(a), b()) : a * Xe;
  }, v.reflectX = function(x) {
    return arguments.length ? (i = x ? -1 : 1, b()) : i < 0;
  }, v.reflectY = function(x) {
    return arguments.length ? (r = x ? -1 : 1, b()) : r < 0;
  }, v.fitExtent = function(x, w) {
    return Gg(v, x, w);
  }, v.fitSize = function(x, w) {
    return f2(v, x, w);
  }, v.fitWidth = function(x, w) {
    return d2(v, x, w);
  }, v.fitHeight = function(x, w) {
    return h2(v, x, w);
  }, v;
}
function _9(e, t) {
  var n = t * t, i = n * n;
  return [
    e * (0.8707 - 0.131979 * n + i * (-0.013791 + i * (3971e-6 * n - 1529e-6 * i))),
    t * (1.007226 + n * (0.015085 + i * (-0.044475 + 0.028874 * n - 5916e-6 * i)))
  ];
}
_9.invert = function(e, t) {
  var n = t, i = 25, r;
  do {
    var a = n * n, s = a * a;
    n -= r = (n * (1.007226 + a * (0.015085 + s * (-0.044475 + 0.028874 * a - 5916e-6 * s))) - t) / (1.007226 + a * (0.015085 * 3 + s * (-0.044475 * 7 + 0.028874 * 9 * a - 5916e-6 * 11 * s)));
  } while (ge(r) > ne && --i > 0);
  return [
    e / (0.8707 + (a = n * n) * (-0.131979 + a * (-0.013791 + a * a * a * (3971e-6 - 1529e-6 * a)))),
    n
  ];
};
function FI() {
  return yr(_9).scale(175.295);
}
function F9(e, t) {
  return [re(t) * te(e), te(t)];
}
F9.invert = Mf(bn);
function MI() {
  return yr(F9).scale(249.5).clipAngle(90 + ne);
}
function M9(e, t) {
  var n = re(t), i = 1 + re(e) * n;
  return [n * te(e) / i, te(t) / i];
}
M9.invert = Mf(function(e) {
  return 2 * Yu(e);
});
function OI() {
  return yr(M9).scale(250).clipAngle(142);
}
function O9(e, t) {
  return [sp(u2((He + t) / 2)), -e];
}
O9.invert = function(e, t) {
  return [-t, 2 * Yu(Uk(e)) - He];
};
function RI() {
  var e = A9(O9), t = e.center, n = e.rotate;
  return e.center = function(i) {
    return arguments.length ? t([-i[1], i[0]]) : (i = t(), [i[1], -i[0]]);
  }, e.rotate = function(i) {
    return arguments.length ? n([i[0], i[1], i.length > 2 ? i[2] + 90 : 90]) : (i = n(), [i[0], i[1], i[2] - 90]);
  }, n([0, 0, 90]).scale(159.155);
}
function TI(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function DI(e) {
  return e.reduce(NI, 0) / e.length;
}
function NI(e, t) {
  return e + t.x;
}
function LI(e) {
  return 1 + e.reduce(PI, 0);
}
function PI(e, t) {
  return Math.max(e, t.y);
}
function zI(e) {
  for (var t; t = e.children; )
    e = t[0];
  return e;
}
function II(e) {
  for (var t; t = e.children; )
    e = t[t.length - 1];
  return e;
}
function BI() {
  var e = TI, t = 1, n = 1, i = !1;
  function r(a) {
    var s, o = 0;
    a.eachAfter(function(d) {
      var h = d.children;
      h ? (d.x = DI(h), d.y = LI(h)) : (d.x = s ? o += e(d, s) : 0, d.y = 0, s = d);
    });
    var u = zI(a), l = II(a), c = u.x - e(u, l) / 2, f = l.x + e(l, u) / 2;
    return a.eachAfter(i ? function(d) {
      d.x = (d.x - a.x) * t, d.y = (a.y - d.y) * n;
    } : function(d) {
      d.x = (d.x - c) / (f - c) * t, d.y = (1 - (a.y ? d.y / a.y : 1)) * n;
    });
  }
  return r.separation = function(a) {
    return arguments.length ? (e = a, r) : e;
  }, r.size = function(a) {
    return arguments.length ? (i = !1, t = +a[0], n = +a[1], r) : i ? null : [t, n];
  }, r.nodeSize = function(a) {
    return arguments.length ? (i = !0, t = +a[0], n = +a[1], r) : i ? [t, n] : null;
  }, r;
}
function jI(e) {
  var t = 0, n = e.children, i = n && n.length;
  if (!i)
    t = 1;
  else
    for (; --i >= 0; )
      t += n[i].value;
  e.value = t;
}
function UI() {
  return this.eachAfter(jI);
}
function qI(e, t) {
  let n = -1;
  for (const i of this)
    e.call(t, i, ++n, this);
  return this;
}
function GI(e, t) {
  for (var n = this, i = [n], r, a, s = -1; n = i.pop(); )
    if (e.call(t, n, ++s, this), r = n.children)
      for (a = r.length - 1; a >= 0; --a)
        i.push(r[a]);
  return this;
}
function WI(e, t) {
  for (var n = this, i = [n], r = [], a, s, o, u = -1; n = i.pop(); )
    if (r.push(n), a = n.children)
      for (s = 0, o = a.length; s < o; ++s)
        i.push(a[s]);
  for (; n = r.pop(); )
    e.call(t, n, ++u, this);
  return this;
}
function HI(e, t) {
  let n = -1;
  for (const i of this)
    if (e.call(t, i, ++n, this))
      return i;
}
function VI(e) {
  return this.eachAfter(function(t) {
    for (var n = +e(t.data) || 0, i = t.children, r = i && i.length; --r >= 0; )
      n += i[r].value;
    t.value = n;
  });
}
function XI(e) {
  return this.eachBefore(function(t) {
    t.children && t.children.sort(e);
  });
}
function YI(e) {
  for (var t = this, n = KI(t, e), i = [t]; t !== n; )
    t = t.parent, i.push(t);
  for (var r = i.length; e !== n; )
    i.splice(r, 0, e), e = e.parent;
  return i;
}
function KI(e, t) {
  if (e === t)
    return e;
  var n = e.ancestors(), i = t.ancestors(), r = null;
  for (e = n.pop(), t = i.pop(); e === t; )
    r = e, e = n.pop(), t = i.pop();
  return r;
}
function JI() {
  for (var e = this, t = [e]; e = e.parent; )
    t.push(e);
  return t;
}
function QI() {
  return Array.from(this);
}
function ZI() {
  var e = [];
  return this.eachBefore(function(t) {
    t.children || e.push(t);
  }), e;
}
function eB() {
  var e = this, t = [];
  return e.each(function(n) {
    n !== e && t.push({ source: n.parent, target: n });
  }), t;
}
function* tB() {
  var e = this, t, n = [e], i, r, a;
  do
    for (t = n.reverse(), n = []; e = t.pop(); )
      if (yield e, i = e.children)
        for (r = 0, a = i.length; r < a; ++r)
          n.push(i[r]);
  while (n.length);
}
function g2(e, t) {
  e instanceof Map ? (e = [void 0, e], t === void 0 && (t = rB)) : t === void 0 && (t = iB);
  for (var n = new vu(e), i, r = [n], a, s, o, u; i = r.pop(); )
    if ((s = t(i.data)) && (u = (s = Array.from(s)).length))
      for (i.children = s, o = u - 1; o >= 0; --o)
        r.push(a = s[o] = new vu(s[o])), a.parent = i, a.depth = i.depth + 1;
  return n.eachBefore(R9);
}
function nB() {
  return g2(this).eachBefore(aB);
}
function iB(e) {
  return e.children;
}
function rB(e) {
  return Array.isArray(e) ? e[1] : null;
}
function aB(e) {
  e.data.value !== void 0 && (e.value = e.data.value), e.data = e.data.data;
}
function R9(e) {
  var t = 0;
  do
    e.height = t;
  while ((e = e.parent) && e.height < ++t);
}
function vu(e) {
  this.data = e, this.depth = this.height = 0, this.parent = null;
}
vu.prototype = g2.prototype = {
  constructor: vu,
  count: UI,
  each: qI,
  eachAfter: WI,
  eachBefore: GI,
  find: HI,
  sum: VI,
  sort: XI,
  path: YI,
  ancestors: JI,
  descendants: QI,
  leaves: ZI,
  links: eB,
  copy: nB,
  [Symbol.iterator]: tB
};
function kh(e) {
  return e == null ? null : T9(e);
}
function T9(e) {
  if (typeof e != "function")
    throw new Error();
  return e;
}
function Ms() {
  return 0;
}
function Zo(e) {
  return function() {
    return e;
  };
}
const sB = 1664525, oB = 1013904223, uS = 4294967296;
function uB() {
  let e = 1;
  return () => (e = (sB * e + oB) % uS) / uS;
}
function lB(e) {
  return typeof e == "object" && "length" in e ? e : Array.from(e);
}
function cB(e, t) {
  let n = e.length, i, r;
  for (; n; )
    r = t() * n-- | 0, i = e[n], e[n] = e[r], e[r] = i;
  return e;
}
function fB(e, t) {
  for (var n = 0, i = (e = cB(Array.from(e), t)).length, r = [], a, s; n < i; )
    a = e[n], s && D9(s, a) ? ++n : (s = hB(r = dB(r, a)), n = 0);
  return s;
}
function dB(e, t) {
  var n, i;
  if (v1(t, e))
    return [t];
  for (n = 0; n < e.length; ++n)
    if (Yd(t, e[n]) && v1(ic(e[n], t), e))
      return [e[n], t];
  for (n = 0; n < e.length - 1; ++n)
    for (i = n + 1; i < e.length; ++i)
      if (Yd(ic(e[n], e[i]), t) && Yd(ic(e[n], t), e[i]) && Yd(ic(e[i], t), e[n]) && v1(N9(e[n], e[i], t), e))
        return [e[n], e[i], t];
  throw new Error();
}
function Yd(e, t) {
  var n = e.r - t.r, i = t.x - e.x, r = t.y - e.y;
  return n < 0 || n * n < i * i + r * r;
}
function D9(e, t) {
  var n = e.r - t.r + Math.max(e.r, t.r, 1) * 1e-9, i = t.x - e.x, r = t.y - e.y;
  return n > 0 && n * n > i * i + r * r;
}
function v1(e, t) {
  for (var n = 0; n < t.length; ++n)
    if (!D9(e, t[n]))
      return !1;
  return !0;
}
function hB(e) {
  switch (e.length) {
    case 1:
      return pB(e[0]);
    case 2:
      return ic(e[0], e[1]);
    case 3:
      return N9(e[0], e[1], e[2]);
  }
}
function pB(e) {
  return {
    x: e.x,
    y: e.y,
    r: e.r
  };
}
function ic(e, t) {
  var n = e.x, i = e.y, r = e.r, a = t.x, s = t.y, o = t.r, u = a - n, l = s - i, c = o - r, f = Math.sqrt(u * u + l * l);
  return {
    x: (n + a + u / f * c) / 2,
    y: (i + s + l / f * c) / 2,
    r: (f + r + o) / 2
  };
}
function N9(e, t, n) {
  var i = e.x, r = e.y, a = e.r, s = t.x, o = t.y, u = t.r, l = n.x, c = n.y, f = n.r, d = i - s, h = i - l, p = r - o, g = r - c, m = u - a, y = f - a, b = i * i + r * r - a * a, v = b - s * s - o * o + u * u, x = b - l * l - c * c + f * f, w = h * p - d * g, E = (p * x - g * v) / (w * 2) - i, $ = (g * m - p * y) / w, S = (h * v - d * x) / (w * 2) - r, A = (d * y - h * m) / w, k = $ * $ + A * A - 1, _ = 2 * (a + E * $ + S * A), P = E * E + S * S - a * a, F = -(Math.abs(k) > 1e-6 ? (_ + Math.sqrt(_ * _ - 4 * k * P)) / (2 * k) : P / _);
  return {
    x: i + E + $ * F,
    y: r + S + A * F,
    r: F
  };
}
function lS(e, t, n) {
  var i = e.x - t.x, r, a, s = e.y - t.y, o, u, l = i * i + s * s;
  l ? (a = t.r + n.r, a *= a, u = e.r + n.r, u *= u, a > u ? (r = (l + u - a) / (2 * l), o = Math.sqrt(Math.max(0, u / l - r * r)), n.x = e.x - r * i - o * s, n.y = e.y - r * s + o * i) : (r = (l + a - u) / (2 * l), o = Math.sqrt(Math.max(0, a / l - r * r)), n.x = t.x + r * i - o * s, n.y = t.y + r * s + o * i)) : (n.x = t.x + n.r, n.y = t.y);
}
function cS(e, t) {
  var n = e.r + t.r - 1e-6, i = t.x - e.x, r = t.y - e.y;
  return n > 0 && n * n > i * i + r * r;
}
function fS(e) {
  var t = e._, n = e.next._, i = t.r + n.r, r = (t.x * n.r + n.x * t.r) / i, a = (t.y * n.r + n.y * t.r) / i;
  return r * r + a * a;
}
function Kd(e) {
  this._ = e, this.next = null, this.previous = null;
}
function gB(e, t) {
  if (!(a = (e = lB(e)).length))
    return 0;
  var n, i, r, a, s, o, u, l, c, f, d;
  if (n = e[0], n.x = 0, n.y = 0, !(a > 1))
    return n.r;
  if (i = e[1], n.x = -i.r, i.x = n.r, i.y = 0, !(a > 2))
    return n.r + i.r;
  lS(i, n, r = e[2]), n = new Kd(n), i = new Kd(i), r = new Kd(r), n.next = r.previous = i, i.next = n.previous = r, r.next = i.previous = n;
  e:
    for (u = 3; u < a; ++u) {
      lS(n._, i._, r = e[u]), r = new Kd(r), l = i.next, c = n.previous, f = i._.r, d = n._.r;
      do
        if (f <= d) {
          if (cS(l._, r._)) {
            i = l, n.next = i, i.previous = n, --u;
            continue e;
          }
          f += l._.r, l = l.next;
        } else {
          if (cS(c._, r._)) {
            n = c, n.next = i, i.previous = n, --u;
            continue e;
          }
          d += c._.r, c = c.previous;
        }
      while (l !== c.next);
      for (r.previous = n, r.next = i, n.next = i.previous = i = r, s = fS(n); (r = r.next) !== i; )
        (o = fS(r)) < s && (n = r, s = o);
      i = n.next;
    }
  for (n = [i._], r = i; (r = r.next) !== i; )
    n.push(r._);
  for (r = fB(n, t), u = 0; u < a; ++u)
    n = e[u], n.x -= r.x, n.y -= r.y;
  return r.r;
}
function mB(e) {
  return Math.sqrt(e.value);
}
function yB() {
  var e = null, t = 1, n = 1, i = Ms;
  function r(a) {
    const s = uB();
    return a.x = t / 2, a.y = n / 2, e ? a.eachBefore(dS(e)).eachAfter(x1(i, 0.5, s)).eachBefore(hS(1)) : a.eachBefore(dS(mB)).eachAfter(x1(Ms, 1, s)).eachAfter(x1(i, a.r / Math.min(t, n), s)).eachBefore(hS(Math.min(t, n) / (2 * a.r))), a;
  }
  return r.radius = function(a) {
    return arguments.length ? (e = kh(a), r) : e;
  }, r.size = function(a) {
    return arguments.length ? (t = +a[0], n = +a[1], r) : [t, n];
  }, r.padding = function(a) {
    return arguments.length ? (i = typeof a == "function" ? a : Zo(+a), r) : i;
  }, r;
}
function dS(e) {
  return function(t) {
    t.children || (t.r = Math.max(0, +e(t) || 0));
  };
}
function x1(e, t, n) {
  return function(i) {
    if (r = i.children) {
      var r, a, s = r.length, o = e(i) * t || 0, u;
      if (o)
        for (a = 0; a < s; ++a)
          r[a].r += o;
      if (u = gB(r, n), o)
        for (a = 0; a < s; ++a)
          r[a].r -= o;
      i.r = u + o;
    }
  };
}
function hS(e) {
  return function(t) {
    var n = t.parent;
    t.r *= e, n && (t.x = n.x + e * t.x, t.y = n.y + e * t.y);
  };
}
function L9(e) {
  e.x0 = Math.round(e.x0), e.y0 = Math.round(e.y0), e.x1 = Math.round(e.x1), e.y1 = Math.round(e.y1);
}
function Of(e, t, n, i, r) {
  for (var a = e.children, s, o = -1, u = a.length, l = e.value && (i - t) / e.value; ++o < u; )
    s = a[o], s.y0 = n, s.y1 = r, s.x0 = t, s.x1 = t += s.value * l;
}
function bB() {
  var e = 1, t = 1, n = 0, i = !1;
  function r(s) {
    var o = s.height + 1;
    return s.x0 = s.y0 = n, s.x1 = e, s.y1 = t / o, s.eachBefore(a(t, o)), i && s.eachBefore(L9), s;
  }
  function a(s, o) {
    return function(u) {
      u.children && Of(u, u.x0, s * (u.depth + 1) / o, u.x1, s * (u.depth + 2) / o);
      var l = u.x0, c = u.y0, f = u.x1 - n, d = u.y1 - n;
      f < l && (l = f = (l + f) / 2), d < c && (c = d = (c + d) / 2), u.x0 = l, u.y0 = c, u.x1 = f, u.y1 = d;
    };
  }
  return r.round = function(s) {
    return arguments.length ? (i = !!s, r) : i;
  }, r.size = function(s) {
    return arguments.length ? (e = +s[0], t = +s[1], r) : [e, t];
  }, r.padding = function(s) {
    return arguments.length ? (n = +s, r) : n;
  }, r;
}
var vB = { depth: -1 }, pS = {}, $1 = {};
function xB(e) {
  return e.id;
}
function $B(e) {
  return e.parentId;
}
function gS() {
  var e = xB, t = $B, n;
  function i(r) {
    var a = Array.from(r), s = e, o = t, u, l, c, f, d, h, p, g, m = /* @__PURE__ */ new Map();
    if (n != null) {
      const y = a.map((x, w) => wB(n(x, w, r))), b = y.map(mS), v = new Set(y).add("");
      for (const x of b)
        v.has(x) || (v.add(x), y.push(x), b.push(mS(x)), a.push($1));
      s = (x, w) => y[w], o = (x, w) => b[w];
    }
    for (c = 0, u = a.length; c < u; ++c)
      l = a[c], h = a[c] = new vu(l), (p = s(l, c, r)) != null && (p += "") && (g = h.id = p, m.set(g, m.has(g) ? pS : h)), (p = o(l, c, r)) != null && (p += "") && (h.parent = p);
    for (c = 0; c < u; ++c)
      if (h = a[c], p = h.parent) {
        if (d = m.get(p), !d)
          throw new Error("missing: " + p);
        if (d === pS)
          throw new Error("ambiguous: " + p);
        d.children ? d.children.push(h) : d.children = [h], h.parent = d;
      } else {
        if (f)
          throw new Error("multiple roots");
        f = h;
      }
    if (!f)
      throw new Error("no root");
    if (n != null) {
      for (; f.data === $1 && f.children.length === 1; )
        f = f.children[0], --u;
      for (let y = a.length - 1; y >= 0 && (h = a[y], h.data === $1); --y)
        h.data = null;
    }
    if (f.parent = vB, f.eachBefore(function(y) {
      y.depth = y.parent.depth + 1, --u;
    }).eachBefore(R9), f.parent = null, u > 0)
      throw new Error("cycle");
    return f;
  }
  return i.id = function(r) {
    return arguments.length ? (e = kh(r), i) : e;
  }, i.parentId = function(r) {
    return arguments.length ? (t = kh(r), i) : t;
  }, i.path = function(r) {
    return arguments.length ? (n = kh(r), i) : n;
  }, i;
}
function wB(e) {
  e = `${e}`;
  let t = e.length;
  return rb(e, t - 1) && !rb(e, t - 2) && (e = e.slice(0, -1)), e[0] === "/" ? e : `/${e}`;
}
function mS(e) {
  let t = e.length;
  if (t < 2)
    return "";
  for (; --t > 1 && !rb(e, t); )
    ;
  return e.slice(0, t);
}
function rb(e, t) {
  if (e[t] === "/") {
    let n = 0;
    for (; t > 0 && e[--t] === "\\"; )
      ++n;
    if (!(n & 1))
      return !0;
  }
  return !1;
}
function EB(e, t) {
  return e.parent === t.parent ? 1 : 2;
}
function w1(e) {
  var t = e.children;
  return t ? t[0] : e.t;
}
function E1(e) {
  var t = e.children;
  return t ? t[t.length - 1] : e.t;
}
function SB(e, t, n) {
  var i = n / (t.i - e.i);
  t.c -= i, t.s += n, e.c += i, t.z += n, t.m += n;
}
function AB(e) {
  for (var t = 0, n = 0, i = e.children, r = i.length, a; --r >= 0; )
    a = i[r], a.z += t, a.m += t, t += a.s + (n += a.c);
}
function kB(e, t, n) {
  return e.a.parent === t.parent ? e.a : n;
}
function Ch(e, t) {
  this._ = e, this.parent = null, this.children = null, this.A = null, this.a = this, this.z = 0, this.m = 0, this.c = 0, this.s = 0, this.t = null, this.i = t;
}
Ch.prototype = Object.create(vu.prototype);
function CB(e) {
  for (var t = new Ch(e, 0), n, i = [t], r, a, s, o; n = i.pop(); )
    if (a = n._.children)
      for (n.children = new Array(o = a.length), s = o - 1; s >= 0; --s)
        i.push(r = n.children[s] = new Ch(a[s], s)), r.parent = n;
  return (t.parent = new Ch(null, 0)).children = [t], t;
}
function _B() {
  var e = EB, t = 1, n = 1, i = null;
  function r(l) {
    var c = CB(l);
    if (c.eachAfter(a), c.parent.m = -c.z, c.eachBefore(s), i)
      l.eachBefore(u);
    else {
      var f = l, d = l, h = l;
      l.eachBefore(function(b) {
        b.x < f.x && (f = b), b.x > d.x && (d = b), b.depth > h.depth && (h = b);
      });
      var p = f === d ? 1 : e(f, d) / 2, g = p - f.x, m = t / (d.x + p + g), y = n / (h.depth || 1);
      l.eachBefore(function(b) {
        b.x = (b.x + g) * m, b.y = b.depth * y;
      });
    }
    return l;
  }
  function a(l) {
    var c = l.children, f = l.parent.children, d = l.i ? f[l.i - 1] : null;
    if (c) {
      AB(l);
      var h = (c[0].z + c[c.length - 1].z) / 2;
      d ? (l.z = d.z + e(l._, d._), l.m = l.z - h) : l.z = h;
    } else
      d && (l.z = d.z + e(l._, d._));
    l.parent.A = o(l, d, l.parent.A || f[0]);
  }
  function s(l) {
    l._.x = l.z + l.parent.m, l.m += l.parent.m;
  }
  function o(l, c, f) {
    if (c) {
      for (var d = l, h = l, p = c, g = d.parent.children[0], m = d.m, y = h.m, b = p.m, v = g.m, x; p = E1(p), d = w1(d), p && d; )
        g = w1(g), h = E1(h), h.a = l, x = p.z + b - d.z - m + e(p._, d._), x > 0 && (SB(kB(p, l, f), l, x), m += x, y += x), b += p.m, m += d.m, v += g.m, y += h.m;
      p && !E1(h) && (h.t = p, h.m += b - y), d && !w1(g) && (g.t = d, g.m += m - v, f = l);
    }
    return f;
  }
  function u(l) {
    l.x *= t, l.y = l.depth * n;
  }
  return r.separation = function(l) {
    return arguments.length ? (e = l, r) : e;
  }, r.size = function(l) {
    return arguments.length ? (i = !1, t = +l[0], n = +l[1], r) : i ? null : [t, n];
  }, r.nodeSize = function(l) {
    return arguments.length ? (i = !0, t = +l[0], n = +l[1], r) : i ? [t, n] : null;
  }, r;
}
function Hg(e, t, n, i, r) {
  for (var a = e.children, s, o = -1, u = a.length, l = e.value && (r - n) / e.value; ++o < u; )
    s = a[o], s.x0 = t, s.x1 = i, s.y0 = n, s.y1 = n += s.value * l;
}
var P9 = (1 + Math.sqrt(5)) / 2;
function z9(e, t, n, i, r, a) {
  for (var s = [], o = t.children, u, l, c = 0, f = 0, d = o.length, h, p, g = t.value, m, y, b, v, x, w, E; c < d; ) {
    h = r - n, p = a - i;
    do
      m = o[f++].value;
    while (!m && f < d);
    for (y = b = m, w = Math.max(p / h, h / p) / (g * e), E = m * m * w, x = Math.max(b / E, E / y); f < d; ++f) {
      if (m += l = o[f].value, l < y && (y = l), l > b && (b = l), E = m * m * w, v = Math.max(b / E, E / y), v > x) {
        m -= l;
        break;
      }
      x = v;
    }
    s.push(u = { value: m, dice: h < p, children: o.slice(c, f) }), u.dice ? Of(u, n, i, r, g ? i += p * m / g : a) : Hg(u, n, i, g ? n += h * m / g : r, a), g -= m, c = f;
  }
  return s;
}
const I9 = function e(t) {
  function n(i, r, a, s, o) {
    z9(t, i, r, a, s, o);
  }
  return n.ratio = function(i) {
    return e((i = +i) > 1 ? i : 1);
  }, n;
}(P9);
function FB() {
  var e = I9, t = !1, n = 1, i = 1, r = [0], a = Ms, s = Ms, o = Ms, u = Ms, l = Ms;
  function c(d) {
    return d.x0 = d.y0 = 0, d.x1 = n, d.y1 = i, d.eachBefore(f), r = [0], t && d.eachBefore(L9), d;
  }
  function f(d) {
    var h = r[d.depth], p = d.x0 + h, g = d.y0 + h, m = d.x1 - h, y = d.y1 - h;
    m < p && (p = m = (p + m) / 2), y < g && (g = y = (g + y) / 2), d.x0 = p, d.y0 = g, d.x1 = m, d.y1 = y, d.children && (h = r[d.depth + 1] = a(d) / 2, p += l(d) - h, g += s(d) - h, m -= o(d) - h, y -= u(d) - h, m < p && (p = m = (p + m) / 2), y < g && (g = y = (g + y) / 2), e(d, p, g, m, y));
  }
  return c.round = function(d) {
    return arguments.length ? (t = !!d, c) : t;
  }, c.size = function(d) {
    return arguments.length ? (n = +d[0], i = +d[1], c) : [n, i];
  }, c.tile = function(d) {
    return arguments.length ? (e = T9(d), c) : e;
  }, c.padding = function(d) {
    return arguments.length ? c.paddingInner(d).paddingOuter(d) : c.paddingInner();
  }, c.paddingInner = function(d) {
    return arguments.length ? (a = typeof d == "function" ? d : Zo(+d), c) : a;
  }, c.paddingOuter = function(d) {
    return arguments.length ? c.paddingTop(d).paddingRight(d).paddingBottom(d).paddingLeft(d) : c.paddingTop();
  }, c.paddingTop = function(d) {
    return arguments.length ? (s = typeof d == "function" ? d : Zo(+d), c) : s;
  }, c.paddingRight = function(d) {
    return arguments.length ? (o = typeof d == "function" ? d : Zo(+d), c) : o;
  }, c.paddingBottom = function(d) {
    return arguments.length ? (u = typeof d == "function" ? d : Zo(+d), c) : u;
  }, c.paddingLeft = function(d) {
    return arguments.length ? (l = typeof d == "function" ? d : Zo(+d), c) : l;
  }, c;
}
function MB(e, t, n, i, r) {
  var a = e.children, s, o = a.length, u, l = new Array(o + 1);
  for (l[0] = u = s = 0; s < o; ++s)
    l[s + 1] = u += a[s].value;
  c(0, o, e.value, t, n, i, r);
  function c(f, d, h, p, g, m, y) {
    if (f >= d - 1) {
      var b = a[f];
      b.x0 = p, b.y0 = g, b.x1 = m, b.y1 = y;
      return;
    }
    for (var v = l[f], x = h / 2 + v, w = f + 1, E = d - 1; w < E; ) {
      var $ = w + E >>> 1;
      l[$] < x ? w = $ + 1 : E = $;
    }
    x - l[w - 1] < l[w] - x && f + 1 < w && --w;
    var S = l[w] - v, A = h - S;
    if (m - p > y - g) {
      var k = h ? (p * A + m * S) / h : m;
      c(f, w, S, p, g, k, y), c(w, d, A, k, g, m, y);
    } else {
      var _ = h ? (g * A + y * S) / h : y;
      c(f, w, S, p, g, m, _), c(w, d, A, p, _, m, y);
    }
  }
}
function OB(e, t, n, i, r) {
  (e.depth & 1 ? Hg : Of)(e, t, n, i, r);
}
const RB = function e(t) {
  function n(i, r, a, s, o) {
    if ((u = i._squarify) && u.ratio === t)
      for (var u, l, c, f, d = -1, h, p = u.length, g = i.value; ++d < p; ) {
        for (l = u[d], c = l.children, f = l.value = 0, h = c.length; f < h; ++f)
          l.value += c[f].value;
        l.dice ? Of(l, r, a, s, g ? a += (o - a) * l.value / g : o) : Hg(l, r, a, g ? r += (s - r) * l.value / g : s, o), g -= l.value;
      }
    else
      i._squarify = u = z9(t, i, r, a, s, o), u.ratio = t;
  }
  return n.ratio = function(i) {
    return e((i = +i) > 1 ? i : 1);
  }, n;
}(P9);
function Rf(e) {
  var t;
  function n(i) {
    return i == null || isNaN(i = +i) ? t : i;
  }
  return n.invert = n, n.domain = n.range = function(i) {
    return arguments.length ? (e = Array.from(i, m5), n) : e.slice();
  }, n.unknown = function(i) {
    return arguments.length ? (t = i, n) : t;
  }, n.copy = function() {
    return Rf(e).unknown(t);
  }, e = arguments.length ? Array.from(e, m5) : [0, 1], Vu(n);
}
function yS(e) {
  return Math.log(e);
}
function bS(e) {
  return Math.exp(e);
}
function TB(e) {
  return -Math.log(-e);
}
function DB(e) {
  return -Math.exp(-e);
}
function NB(e) {
  return isFinite(e) ? +("1e" + e) : e < 0 ? 0 : e;
}
function LB(e) {
  return e === 10 ? NB : e === Math.E ? Math.exp : (t) => Math.pow(e, t);
}
function PB(e) {
  return e === Math.E ? Math.log : e === 10 && Math.log10 || e === 2 && Math.log2 || (e = Math.log(e), (t) => Math.log(t) / e);
}
function vS(e) {
  return (t, n) => -e(-t, n);
}
function m2(e) {
  const t = e(yS, bS), n = t.domain;
  let i = 10, r, a;
  function s() {
    return r = PB(i), a = LB(i), n()[0] < 0 ? (r = vS(r), a = vS(a), e(TB, DB)) : e(yS, bS), t;
  }
  return t.base = function(o) {
    return arguments.length ? (i = +o, s()) : i;
  }, t.domain = function(o) {
    return arguments.length ? (n(o), s()) : n();
  }, t.ticks = (o) => {
    const u = n();
    let l = u[0], c = u[u.length - 1];
    const f = c < l;
    f && ([l, c] = [c, l]);
    let d = r(l), h = r(c), p, g;
    const m = o == null ? 10 : +o;
    let y = [];
    if (!(i % 1) && h - d < m) {
      if (d = Math.floor(d), h = Math.ceil(h), l > 0) {
        for (; d <= h; ++d)
          for (p = 1; p < i; ++p)
            if (g = d < 0 ? p / a(-d) : p * a(d), !(g < l)) {
              if (g > c)
                break;
              y.push(g);
            }
      } else
        for (; d <= h; ++d)
          for (p = i - 1; p >= 1; --p)
            if (g = d > 0 ? p / a(-d) : p * a(d), !(g < l)) {
              if (g > c)
                break;
              y.push(g);
            }
      y.length * 2 < m && (y = y5(l, c, m));
    } else
      y = y5(d, h, Math.min(h - d, m)).map(a);
    return f ? y.reverse() : y;
  }, t.tickFormat = (o, u) => {
    if (o == null && (o = 10), u == null && (u = i === 10 ? "s" : ","), typeof u != "function" && (!(i % 1) && (u = Dy(u)).precision == null && (u.trim = !0), u = ck(u)), o === 1 / 0)
      return u;
    const l = Math.max(1, i * o / t.ticks().length);
    return (c) => {
      let f = c / a(Math.round(r(c)));
      return f * i < i - 0.5 && (f *= i), f <= l ? u(c) : "";
    };
  }, t.nice = () => n(uL(n(), {
    floor: (o) => a(Math.floor(r(o))),
    ceil: (o) => a(Math.ceil(r(o)))
  })), t;
}
function Tf() {
  const e = m2(Jv()).domain([1, 10]);
  return e.copy = () => Qv(e, Tf()).base(e.base()), So.apply(e, arguments), e;
}
function xS(e) {
  return function(t) {
    return Math.sign(t) * Math.log1p(Math.abs(t / e));
  };
}
function $S(e) {
  return function(t) {
    return Math.sign(t) * Math.expm1(Math.abs(t)) * e;
  };
}
function y2(e) {
  var t = 1, n = e(xS(t), $S(t));
  return n.constant = function(i) {
    return arguments.length ? e(xS(t = +i), $S(t)) : t;
  }, Vu(n);
}
function Df() {
  var e = y2(Jv());
  return e.copy = function() {
    return Qv(e, Df()).constant(e.constant());
  }, So.apply(e, arguments);
}
function wS(e) {
  return function(t) {
    return t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
  };
}
function zB(e) {
  return e < 0 ? -Math.sqrt(-e) : Math.sqrt(e);
}
function IB(e) {
  return e < 0 ? -e * e : e * e;
}
function b2(e) {
  var t = e(Ea, Ea), n = 1;
  function i() {
    return n === 1 ? e(Ea, Ea) : n === 0.5 ? e(zB, IB) : e(wS(n), wS(1 / n));
  }
  return t.exponent = function(r) {
    return arguments.length ? (n = +r, i()) : n;
  }, Vu(t);
}
function Ku() {
  var e = b2(Jv());
  return e.copy = function() {
    return Qv(e, Ku()).exponent(e.exponent());
  }, So.apply(e, arguments), e;
}
function Vg() {
  return Ku.apply(null, arguments).exponent(0.5);
}
function Nf() {
  var e = [], t = [], n = [], i;
  function r() {
    var s = 0, o = Math.max(1, t.length);
    for (n = new Array(o - 1); ++s < o; )
      n[s - 1] = Tk(e, s / o);
    return a;
  }
  function a(s) {
    return s == null || isNaN(s = +s) ? i : t[Eo(n, s)];
  }
  return a.invertExtent = function(s) {
    var o = t.indexOf(s);
    return o < 0 ? [NaN, NaN] : [
      o > 0 ? n[o - 1] : e[0],
      o < n.length ? n[o] : e[e.length - 1]
    ];
  }, a.domain = function(s) {
    if (!arguments.length)
      return e.slice();
    e = [];
    for (let o of s)
      o != null && !isNaN(o = +o) && e.push(o);
    return e.sort(Ic), r();
  }, a.range = function(s) {
    return arguments.length ? (t = Array.from(s), r()) : t.slice();
  }, a.unknown = function(s) {
    return arguments.length ? (i = s, a) : i;
  }, a.quantiles = function() {
    return n.slice();
  }, a.copy = function() {
    return Nf().domain(e).range(t).unknown(i);
  }, So.apply(a, arguments);
}
function Lf() {
  var e = 0, t = 1, n = 1, i = [0.5], r = [0, 1], a;
  function s(u) {
    return u != null && u <= u ? r[Eo(i, u, 0, n)] : a;
  }
  function o() {
    var u = -1;
    for (i = new Array(n); ++u < n; )
      i[u] = ((u + 1) * t - (u - n) * e) / (n + 1);
    return s;
  }
  return s.domain = function(u) {
    return arguments.length ? ([e, t] = u, e = +e, t = +t, o()) : [e, t];
  }, s.range = function(u) {
    return arguments.length ? (n = (r = Array.from(u)).length - 1, o()) : r.slice();
  }, s.invertExtent = function(u) {
    var l = r.indexOf(u);
    return l < 0 ? [NaN, NaN] : l < 1 ? [e, i[0]] : l >= n ? [i[n - 1], t] : [i[l - 1], i[l]];
  }, s.unknown = function(u) {
    return arguments.length && (a = u), s;
  }, s.thresholds = function() {
    return i.slice();
  }, s.copy = function() {
    return Lf().domain([e, t]).range(r).unknown(a);
  }, So.apply(Vu(s), arguments);
}
function Pf() {
  var e = [0.5], t = [0, 1], n, i = 1;
  function r(a) {
    return a != null && a <= a ? t[Eo(e, a, 0, i)] : n;
  }
  return r.domain = function(a) {
    return arguments.length ? (e = Array.from(a), i = Math.min(e.length, t.length - 1), r) : e.slice();
  }, r.range = function(a) {
    return arguments.length ? (t = Array.from(a), i = Math.min(e.length, t.length - 1), r) : t.slice();
  }, r.invertExtent = function(a) {
    var s = t.indexOf(a);
    return [e[s - 1], e[s]];
  }, r.unknown = function(a) {
    return arguments.length ? (n = a, r) : n;
  }, r.copy = function() {
    return Pf().domain(e).range(t).unknown(n);
  }, So.apply(r, arguments);
}
function Xg() {
  return So.apply(lL(fL, cL, sk, Ty, Kv, xc, ak, rk, Yv, ik).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function Yg() {
  var e = 0, t = 1, n, i, r, a, s = Ea, o = !1, u;
  function l(f) {
    return f == null || isNaN(f = +f) ? u : s(r === 0 ? 0.5 : (f = (a(f) - n) * r, o ? Math.max(0, Math.min(1, f)) : f));
  }
  l.domain = function(f) {
    return arguments.length ? ([e, t] = f, n = a(e = +e), i = a(t = +t), r = n === i ? 0 : 1 / (i - n), l) : [e, t];
  }, l.clamp = function(f) {
    return arguments.length ? (o = !!f, l) : o;
  }, l.interpolator = function(f) {
    return arguments.length ? (s = f, l) : s;
  };
  function c(f) {
    return function(d) {
      var h, p;
      return arguments.length ? ([h, p] = d, s = f(h, p), l) : [s(0), s(1)];
    };
  }
  return l.range = c(kf), l.rangeRound = c(zg), l.unknown = function(f) {
    return arguments.length ? (u = f, l) : u;
  }, function(f) {
    return a = f, n = f(e), i = f(t), r = n === i ? 0 : 1 / (i - n), l;
  };
}
function ss(e, t) {
  return t.domain(e.domain()).interpolator(e.interpolator()).clamp(e.clamp()).unknown(e.unknown());
}
function Qr() {
  var e = Vu(Yg()(Ea));
  return e.copy = function() {
    return ss(e, Qr());
  }, rs.apply(e, arguments);
}
function zf() {
  var e = m2(Yg()).domain([1, 10]);
  return e.copy = function() {
    return ss(e, zf()).base(e.base());
  }, rs.apply(e, arguments);
}
function If() {
  var e = y2(Yg());
  return e.copy = function() {
    return ss(e, If()).constant(e.constant());
  }, rs.apply(e, arguments);
}
function Ju() {
  var e = b2(Yg());
  return e.copy = function() {
    return ss(e, Ju()).exponent(e.exponent());
  }, rs.apply(e, arguments);
}
function Kg() {
  return Ju.apply(null, arguments).exponent(0.5);
}
function Jg() {
  var e = 0, t = 0.5, n = 1, i = 1, r, a, s, o, u, l = Ea, c, f = !1, d;
  function h(g) {
    return isNaN(g = +g) ? d : (g = 0.5 + ((g = +c(g)) - a) * (i * g < i * a ? o : u), l(f ? Math.max(0, Math.min(1, g)) : g));
  }
  h.domain = function(g) {
    return arguments.length ? ([e, t, n] = g, r = c(e = +e), a = c(t = +t), s = c(n = +n), o = r === a ? 0 : 0.5 / (a - r), u = a === s ? 0 : 0.5 / (s - a), i = a < r ? -1 : 1, h) : [e, t, n];
  }, h.clamp = function(g) {
    return arguments.length ? (f = !!g, h) : f;
  }, h.interpolator = function(g) {
    return arguments.length ? (l = g, h) : l;
  };
  function p(g) {
    return function(m) {
      var y, b, v;
      return arguments.length ? ([y, b, v] = m, l = Xu(g, [y, b, v]), h) : [l(0), l(0.5), l(1)];
    };
  }
  return h.range = p(kf), h.rangeRound = p(zg), h.unknown = function(g) {
    return arguments.length ? (d = g, h) : d;
  }, function(g) {
    return c = g, r = g(e), a = g(t), s = g(n), o = r === a ? 0 : 0.5 / (a - r), u = a === s ? 0 : 0.5 / (s - a), i = a < r ? -1 : 1, h;
  };
}
function Bf() {
  var e = Vu(Jg()(Ea));
  return e.copy = function() {
    return ss(e, Bf());
  }, rs.apply(e, arguments);
}
function jf() {
  var e = m2(Jg()).domain([0.1, 1, 10]);
  return e.copy = function() {
    return ss(e, jf()).base(e.base());
  }, rs.apply(e, arguments);
}
function Uf() {
  var e = y2(Jg());
  return e.copy = function() {
    return ss(e, Uf()).constant(e.constant());
  }, rs.apply(e, arguments);
}
function Qu() {
  var e = b2(Jg());
  return e.copy = function() {
    return ss(e, Qu()).exponent(e.exponent());
  }, rs.apply(e, arguments);
}
function Qg() {
  return Qu.apply(null, arguments).exponent(0.5);
}
function Zg(e, t, n) {
  var i = null, r = Ot(!0), a = null, s = t2, o = null, u = Mk(l);
  e = typeof e == "function" ? e : e === void 0 ? ZL : Ot(+e), t = typeof t == "function" ? t : t === void 0 ? Ot(0) : Ot(+t), n = typeof n == "function" ? n : n === void 0 ? eP : Ot(+n);
  function l(f) {
    var d, h, p, g = (f = QL(f)).length, m, y = !1, b, v = new Array(g), x = new Array(g);
    for (a == null && (o = s(b = u())), d = 0; d <= g; ++d) {
      if (!(d < g && r(m = f[d], d, f)) === y)
        if (y = !y)
          h = d, o.areaStart(), o.lineStart();
        else {
          for (o.lineEnd(), o.lineStart(), p = d - 1; p >= h; --p)
            o.point(v[p], x[p]);
          o.lineEnd(), o.areaEnd();
        }
      y && (v[d] = +e(m, d, f), x[d] = +t(m, d, f), o.point(i ? +i(m, d, f) : v[d], n ? +n(m, d, f) : x[d]));
    }
    if (b)
      return o = null, b + "" || null;
  }
  function c() {
    return n2().defined(r).curve(s).context(a);
  }
  return l.x = function(f) {
    return arguments.length ? (e = typeof f == "function" ? f : Ot(+f), i = null, l) : e;
  }, l.x0 = function(f) {
    return arguments.length ? (e = typeof f == "function" ? f : Ot(+f), l) : e;
  }, l.x1 = function(f) {
    return arguments.length ? (i = f == null ? null : typeof f == "function" ? f : Ot(+f), l) : i;
  }, l.y = function(f) {
    return arguments.length ? (t = typeof f == "function" ? f : Ot(+f), n = null, l) : t;
  }, l.y0 = function(f) {
    return arguments.length ? (t = typeof f == "function" ? f : Ot(+f), l) : t;
  }, l.y1 = function(f) {
    return arguments.length ? (n = f == null ? null : typeof f == "function" ? f : Ot(+f), l) : n;
  }, l.lineX0 = l.lineY0 = function() {
    return c().x(e).y(t);
  }, l.lineY1 = function() {
    return c().x(e).y(n);
  }, l.lineX1 = function() {
    return c().x(i).y(t);
  }, l.defined = function(f) {
    return arguments.length ? (r = typeof f == "function" ? f : Ot(!!f), l) : r;
  }, l.curve = function(f) {
    return arguments.length ? (s = f, a != null && (o = s(a)), l) : s;
  }, l.context = function(f) {
    return arguments.length ? (f == null ? a = o = null : o = s(a = f), l) : a;
  }, l;
}
const BB = {
  draw(e, t) {
    const n = YL(t / KL);
    e.moveTo(n, 0), e.arc(0, 0, n, 0, XL);
  }
};
function B9(e, t) {
  let n = null, i = Mk(r);
  e = typeof e == "function" ? e : Ot(e || BB), t = typeof t == "function" ? t : Ot(t === void 0 ? 64 : +t);
  function r() {
    let a;
    if (n || (n = a = i()), e.apply(this, arguments).draw(n, +t.apply(this, arguments)), a)
      return n = null, a + "" || null;
  }
  return r.type = function(a) {
    return arguments.length ? (e = typeof a == "function" ? a : Ot(a), r) : e;
  }, r.size = function(a) {
    return arguments.length ? (t = typeof a == "function" ? a : Ot(+a), r) : t;
  }, r.context = function(a) {
    return arguments.length ? (n = a ?? null, r) : n;
  }, r;
}
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2022 Joachim Wester
 * MIT licensed
 */
var jB = /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, r) {
      i.__proto__ = r;
    } || function(i, r) {
      for (var a in r)
        r.hasOwnProperty(a) && (i[a] = r[a]);
    }, e(t, n);
  };
  return function(t, n) {
    e(t, n);
    function i() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (i.prototype = n.prototype, new i());
  };
}(), UB = Object.prototype.hasOwnProperty;
function ab(e, t) {
  return UB.call(e, t);
}
function sb(e) {
  if (Array.isArray(e)) {
    for (var t = new Array(e.length), n = 0; n < t.length; n++)
      t[n] = "" + n;
    return t;
  }
  if (Object.keys)
    return Object.keys(e);
  var i = [];
  for (var r in e)
    ab(e, r) && i.push(r);
  return i;
}
function Rn(e) {
  switch (typeof e) {
    case "object":
      return JSON.parse(JSON.stringify(e));
    case "undefined":
      return null;
    default:
      return e;
  }
}
function ob(e) {
  for (var t = 0, n = e.length, i; t < n; ) {
    if (i = e.charCodeAt(t), i >= 48 && i <= 57) {
      t++;
      continue;
    }
    return !1;
  }
  return !0;
}
function Fs(e) {
  return e.indexOf("/") === -1 && e.indexOf("~") === -1 ? e : e.replace(/~/g, "~0").replace(/\//g, "~1");
}
function j9(e) {
  return e.replace(/~1/g, "/").replace(/~0/g, "~");
}
function ub(e) {
  if (e === void 0)
    return !0;
  if (e) {
    if (Array.isArray(e)) {
      for (var t = 0, n = e.length; t < n; t++)
        if (ub(e[t]))
          return !0;
    } else if (typeof e == "object") {
      for (var i = sb(e), r = i.length, a = 0; a < r; a++)
        if (ub(e[i[a]]))
          return !0;
    }
  }
  return !1;
}
function ES(e, t) {
  var n = [e];
  for (var i in t) {
    var r = typeof t[i] == "object" ? JSON.stringify(t[i], null, 2) : t[i];
    typeof r < "u" && n.push(i + ": " + r);
  }
  return n.join(`
`);
}
var U9 = (
  /** @class */
  function(e) {
    jB(t, e);
    function t(n, i, r, a, s) {
      var o = this.constructor, u = e.call(this, ES(n, { name: i, index: r, operation: a, tree: s })) || this;
      return u.name = i, u.index = r, u.operation = a, u.tree = s, Object.setPrototypeOf(u, o.prototype), u.message = ES(n, { name: i, index: r, operation: a, tree: s }), u;
    }
    return t;
  }(Error)
), Ge = U9, qB = Rn, iu = {
  add: function(e, t, n) {
    return e[t] = this.value, { newDocument: n };
  },
  remove: function(e, t, n) {
    var i = e[t];
    return delete e[t], { newDocument: n, removed: i };
  },
  replace: function(e, t, n) {
    var i = e[t];
    return e[t] = this.value, { newDocument: n, removed: i };
  },
  move: function(e, t, n) {
    var i = Fp(n, this.path);
    i && (i = Rn(i));
    var r = Vs(n, { op: "remove", path: this.from }).removed;
    return Vs(n, { op: "add", path: this.path, value: r }), { newDocument: n, removed: i };
  },
  copy: function(e, t, n) {
    var i = Fp(n, this.from);
    return Vs(n, { op: "add", path: this.path, value: Rn(i) }), { newDocument: n };
  },
  test: function(e, t, n) {
    return { newDocument: n, test: Gc(e[t], this.value) };
  },
  _get: function(e, t, n) {
    return this.value = e[t], { newDocument: n };
  }
}, GB = {
  add: function(e, t, n) {
    return ob(t) ? e.splice(t, 0, this.value) : e[t] = this.value, { newDocument: n, index: t };
  },
  remove: function(e, t, n) {
    var i = e.splice(t, 1);
    return { newDocument: n, removed: i[0] };
  },
  replace: function(e, t, n) {
    var i = e[t];
    return e[t] = this.value, { newDocument: n, removed: i };
  },
  move: iu.move,
  copy: iu.copy,
  test: iu.test,
  _get: iu._get
};
function Fp(e, t) {
  if (t == "")
    return e;
  var n = { op: "_get", path: t };
  return Vs(e, n), n.value;
}
function Vs(e, t, n, i, r, a) {
  if (n === void 0 && (n = !1), i === void 0 && (i = !0), r === void 0 && (r = !0), a === void 0 && (a = 0), n && (typeof n == "function" ? n(t, 0, e, t.path) : Mp(t, 0)), t.path === "") {
    var s = { newDocument: e };
    if (t.op === "add")
      return s.newDocument = t.value, s;
    if (t.op === "replace")
      return s.newDocument = t.value, s.removed = e, s;
    if (t.op === "move" || t.op === "copy")
      return s.newDocument = Fp(e, t.from), t.op === "move" && (s.removed = e), s;
    if (t.op === "test") {
      if (s.test = Gc(e, t.value), s.test === !1)
        throw new Ge("Test operation failed", "TEST_OPERATION_FAILED", a, t, e);
      return s.newDocument = e, s;
    } else {
      if (t.op === "remove")
        return s.removed = e, s.newDocument = null, s;
      if (t.op === "_get")
        return t.value = e, s;
      if (n)
        throw new Ge("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", a, t, e);
      return s;
    }
  } else {
    i || (e = Rn(e));
    var o = t.path || "", u = o.split("/"), l = e, c = 1, f = u.length, d = void 0, h = void 0, p = void 0;
    for (typeof n == "function" ? p = n : p = Mp; ; ) {
      if (h = u[c], h && h.indexOf("~") != -1 && (h = j9(h)), r && (h == "__proto__" || h == "prototype" && c > 0 && u[c - 1] == "constructor"))
        throw new TypeError("JSON-Patch: modifying `__proto__` or `constructor/prototype` prop is banned for security reasons, if this was on purpose, please set `banPrototypeModifications` flag false and pass it to this function. More info in fast-json-patch README");
      if (n && d === void 0 && (l[h] === void 0 ? d = u.slice(0, c).join("/") : c == f - 1 && (d = t.path), d !== void 0 && p(t, 0, e, d)), c++, Array.isArray(l)) {
        if (h === "-")
          h = l.length;
        else {
          if (n && !ob(h))
            throw new Ge("Expected an unsigned base-10 integer value, making the new referenced value the array element with the zero-based index", "OPERATION_PATH_ILLEGAL_ARRAY_INDEX", a, t, e);
          ob(h) && (h = ~~h);
        }
        if (c >= f) {
          if (n && t.op === "add" && h > l.length)
            throw new Ge("The specified index MUST NOT be greater than the number of elements in the array", "OPERATION_VALUE_OUT_OF_BOUNDS", a, t, e);
          var s = GB[t.op].call(t, l, h, e);
          if (s.test === !1)
            throw new Ge("Test operation failed", "TEST_OPERATION_FAILED", a, t, e);
          return s;
        }
      } else if (c >= f) {
        var s = iu[t.op].call(t, l, h, e);
        if (s.test === !1)
          throw new Ge("Test operation failed", "TEST_OPERATION_FAILED", a, t, e);
        return s;
      }
      if (l = l[h], n && c < f && (!l || typeof l != "object"))
        throw new Ge("Cannot perform operation at the desired path", "OPERATION_PATH_UNRESOLVABLE", a, t, e);
    }
  }
}
function e0(e, t, n, i, r) {
  if (i === void 0 && (i = !0), r === void 0 && (r = !0), n && !Array.isArray(t))
    throw new Ge("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
  i || (e = Rn(e));
  for (var a = new Array(t.length), s = 0, o = t.length; s < o; s++)
    a[s] = Vs(e, t[s], n, !0, r, s), e = a[s].newDocument;
  return a.newDocument = e, a;
}
function WB(e, t, n) {
  var i = Vs(e, t);
  if (i.test === !1)
    throw new Ge("Test operation failed", "TEST_OPERATION_FAILED", n, t, e);
  return i.newDocument;
}
function Mp(e, t, n, i) {
  if (typeof e != "object" || e === null || Array.isArray(e))
    throw new Ge("Operation is not an object", "OPERATION_NOT_AN_OBJECT", t, e, n);
  if (iu[e.op]) {
    if (typeof e.path != "string")
      throw new Ge("Operation `path` property is not a string", "OPERATION_PATH_INVALID", t, e, n);
    if (e.path.indexOf("/") !== 0 && e.path.length > 0)
      throw new Ge('Operation `path` property must start with "/"', "OPERATION_PATH_INVALID", t, e, n);
    if ((e.op === "move" || e.op === "copy") && typeof e.from != "string")
      throw new Ge("Operation `from` property is not present (applicable in `move` and `copy` operations)", "OPERATION_FROM_REQUIRED", t, e, n);
    if ((e.op === "add" || e.op === "replace" || e.op === "test") && e.value === void 0)
      throw new Ge("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_REQUIRED", t, e, n);
    if ((e.op === "add" || e.op === "replace" || e.op === "test") && ub(e.value))
      throw new Ge("Operation `value` property is not present (applicable in `add`, `replace` and `test` operations)", "OPERATION_VALUE_CANNOT_CONTAIN_UNDEFINED", t, e, n);
    if (n) {
      if (e.op == "add") {
        var r = e.path.split("/").length, a = i.split("/").length;
        if (r !== a + 1 && r !== a)
          throw new Ge("Cannot perform an `add` operation at the desired path", "OPERATION_PATH_CANNOT_ADD", t, e, n);
      } else if (e.op === "replace" || e.op === "remove" || e.op === "_get") {
        if (e.path !== i)
          throw new Ge("Cannot perform the operation at a path that does not exist", "OPERATION_PATH_UNRESOLVABLE", t, e, n);
      } else if (e.op === "move" || e.op === "copy") {
        var s = { op: "_get", path: e.from, value: void 0 }, o = q9([s], n);
        if (o && o.name === "OPERATION_PATH_UNRESOLVABLE")
          throw new Ge("Cannot perform the operation from a path that does not exist", "OPERATION_FROM_UNRESOLVABLE", t, e, n);
      }
    }
  } else
    throw new Ge("Operation `op` property is not one of operations defined in RFC-6902", "OPERATION_OP_INVALID", t, e, n);
}
function q9(e, t, n) {
  try {
    if (!Array.isArray(e))
      throw new Ge("Patch sequence must be an array", "SEQUENCE_NOT_AN_ARRAY");
    if (t)
      e0(Rn(t), Rn(e), n || !0);
    else {
      n = n || Mp;
      for (var i = 0; i < e.length; i++)
        n(e[i], i, t, void 0);
    }
  } catch (r) {
    if (r instanceof Ge)
      return r;
    throw r;
  }
}
function Gc(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    var n = Array.isArray(e), i = Array.isArray(t), r, a, s;
    if (n && i) {
      if (a = e.length, a != t.length)
        return !1;
      for (r = a; r-- !== 0; )
        if (!Gc(e[r], t[r]))
          return !1;
      return !0;
    }
    if (n != i)
      return !1;
    var o = Object.keys(e);
    if (a = o.length, a !== Object.keys(t).length)
      return !1;
    for (r = a; r-- !== 0; )
      if (!t.hasOwnProperty(o[r]))
        return !1;
    for (r = a; r-- !== 0; )
      if (s = o[r], !Gc(e[s], t[s]))
        return !1;
    return !0;
  }
  return e !== e && t !== t;
}
const HB = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  JsonPatchError: Ge,
  _areEquals: Gc,
  applyOperation: Vs,
  applyPatch: e0,
  applyReducer: WB,
  deepClone: qB,
  getValueByPointer: Fp,
  validate: q9,
  validator: Mp
}, Symbol.toStringTag, { value: "Module" }));
/*!
 * https://github.com/Starcounter-Jack/JSON-Patch
 * (c) 2017-2021 Joachim Wester
 * MIT license
 */
var v2 = /* @__PURE__ */ new WeakMap(), VB = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t) {
      this.observers = /* @__PURE__ */ new Map(), this.obj = t;
    }
    return e;
  }()
), XB = (
  /** @class */
  /* @__PURE__ */ function() {
    function e(t, n) {
      this.callback = t, this.observer = n;
    }
    return e;
  }()
);
function YB(e) {
  return v2.get(e);
}
function KB(e, t) {
  return e.observers.get(t);
}
function JB(e, t) {
  e.observers.delete(t.callback);
}
function QB(e, t) {
  t.unobserve();
}
function ZB(e, t) {
  var n = [], i, r = YB(e);
  if (!r)
    r = new VB(e), v2.set(e, r);
  else {
    var a = KB(r, t);
    i = a && a.observer;
  }
  if (i)
    return i;
  if (i = {}, r.value = Rn(e), t) {
    i.callback = t, i.next = null;
    var s = function() {
      lb(i);
    }, o = function() {
      clearTimeout(i.next), i.next = setTimeout(s);
    };
    typeof window < "u" && (window.addEventListener("mouseup", o), window.addEventListener("keyup", o), window.addEventListener("mousedown", o), window.addEventListener("keydown", o), window.addEventListener("change", o));
  }
  return i.patches = n, i.object = e, i.unobserve = function() {
    lb(i), clearTimeout(i.next), JB(r, i), typeof window < "u" && (window.removeEventListener("mouseup", o), window.removeEventListener("keyup", o), window.removeEventListener("mousedown", o), window.removeEventListener("keydown", o), window.removeEventListener("change", o));
  }, r.observers.set(t, new XB(t, i)), i;
}
function lb(e, t) {
  t === void 0 && (t = !1);
  var n = v2.get(e.object);
  x2(n.value, e.object, e.patches, "", t), e.patches.length && e0(n.value, e.patches);
  var i = e.patches;
  return i.length > 0 && (e.patches = [], e.callback && e.callback(i)), i;
}
function x2(e, t, n, i, r) {
  if (t !== e) {
    typeof t.toJSON == "function" && (t = t.toJSON());
    for (var a = sb(t), s = sb(e), o = !1, u = s.length - 1; u >= 0; u--) {
      var l = s[u], c = e[l];
      if (ab(t, l) && !(t[l] === void 0 && c !== void 0 && Array.isArray(t) === !1)) {
        var f = t[l];
        typeof c == "object" && c != null && typeof f == "object" && f != null && Array.isArray(c) === Array.isArray(f) ? x2(c, f, n, i + "/" + Fs(l), r) : c !== f && (r && n.push({ op: "test", path: i + "/" + Fs(l), value: Rn(c) }), n.push({ op: "replace", path: i + "/" + Fs(l), value: Rn(f) }));
      } else
        Array.isArray(e) === Array.isArray(t) ? (r && n.push({ op: "test", path: i + "/" + Fs(l), value: Rn(c) }), n.push({ op: "remove", path: i + "/" + Fs(l) }), o = !0) : (r && n.push({ op: "test", path: i, value: e }), n.push({ op: "replace", path: i, value: t }));
    }
    if (!(!o && a.length == s.length))
      for (var u = 0; u < a.length; u++) {
        var l = a[u];
        !ab(e, l) && t[l] !== void 0 && n.push({ op: "add", path: i + "/" + Fs(l), value: Rn(t[l]) });
      }
  }
}
function ej(e, t, n) {
  n === void 0 && (n = !1);
  var i = [];
  return x2(e, t, i, "", n), i;
}
const tj = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  compare: ej,
  generate: lb,
  observe: ZB,
  unobserve: QB
}, Symbol.toStringTag, { value: "Module" }));
Object.assign({}, HB, tj, {
  JsonPatchError: U9,
  deepClone: Rn,
  escapePathComponent: Fs,
  unescapePathComponent: j9
});
var nj = /("(?:[^\\"]|\\.)*")|[:,]/g, ij = function(t, n) {
  var i, r, a;
  return n = n || {}, i = JSON.stringify(
    [1],
    void 0,
    n.indent === void 0 ? 2 : n.indent
  ).slice(2, -3), r = i === "" ? 1 / 0 : n.maxLength === void 0 ? 80 : n.maxLength, a = n.replacer, function s(o, u, l) {
    var c, f, d, h, p, g, m, y, b, v, x, w;
    if (o && typeof o.toJSON == "function" && (o = o.toJSON()), x = JSON.stringify(o, a), x === void 0)
      return x;
    if (m = r - u.length - l, x.length <= m && (b = x.replace(
      nj,
      function(E, $) {
        return $ || E + " ";
      }
    ), b.length <= m))
      return b;
    if (a != null && (o = JSON.parse(x), a = void 0), typeof o == "object" && o !== null) {
      if (y = u + i, d = [], f = 0, Array.isArray(o))
        for (v = "[", c = "]", m = o.length; f < m; f++)
          d.push(
            s(o[f], y, f === m - 1 ? 0 : 1) || "null"
          );
      else
        for (v = "{", c = "}", g = Object.keys(o), m = g.length; f < m; f++)
          h = g[f], p = JSON.stringify(h) + ": ", w = s(
            o[h],
            y,
            p.length + (f === m - 1 ? 0 : 1)
          ), w !== void 0 && d.push(p + w);
      if (d.length > 0)
        return [v, i + d.join(`,
` + y), c].join(
          `
` + u
        );
    }
    return x;
  }(t, "", 0);
};
const S1 = /* @__PURE__ */ iL(ij);
function An(e, t, n) {
  return e.fields = t || [], e.fname = n, e;
}
function Ve(e) {
  return e == null ? null : e.fname;
}
function Pt(e) {
  return e == null ? null : e.fields;
}
function G9(e) {
  return e.length === 1 ? rj(e[0]) : aj(e);
}
const rj = (e) => function(t) {
  return t[e];
}, aj = (e) => {
  const t = e.length;
  return function(n) {
    for (let i = 0; i < t; ++i)
      n = n[e[i]];
    return n;
  };
};
function D(e) {
  throw Error(e);
}
function br(e) {
  const t = [], n = e.length;
  let i = null, r = 0, a = "", s, o, u;
  e = e + "";
  function l() {
    t.push(a + e.substring(s, o)), a = "", s = o + 1;
  }
  for (s = o = 0; o < n; ++o)
    if (u = e[o], u === "\\")
      a += e.substring(s, o++), s = o;
    else if (u === i)
      l(), i = null, r = -1;
    else {
      if (i)
        continue;
      s === r && u === '"' || s === r && u === "'" ? (s = o + 1, i = u) : u === "." && !r ? o > s ? l() : s = o + 1 : u === "[" ? (o > s && l(), r = s = o + 1) : u === "]" && (r || D("Access path missing open bracket: " + e), r > 0 && l(), r = 0, s = o + 1);
    }
  return r && D("Access path missing closing bracket: " + e), i && D("Access path missing closing quote: " + e), o > s && (o++, l()), t;
}
function At(e, t, n) {
  const i = br(e);
  return e = i.length === 1 ? i[0] : e, An((n && n.get || G9)(i), [e], t || e);
}
const qf = At("id"), kt = An((e) => e, [], "identity"), wa = An(() => 0, [], "zero"), Zu = An(() => 1, [], "one"), jt = An(() => !0, [], "true"), ha = An(() => !1, [], "false");
function sj(e, t, n) {
  const i = [t].concat([].slice.call(n));
  console[e].apply(console, i);
}
const W9 = 0, $2 = 1, w2 = 2, H9 = 3, V9 = 4;
function E2(e, t) {
  let n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : sj, i = e || W9;
  return {
    level(r) {
      return arguments.length ? (i = +r, this) : i;
    },
    error() {
      return i >= $2 && n(t || "error", "ERROR", arguments), this;
    },
    warn() {
      return i >= w2 && n(t || "warn", "WARN", arguments), this;
    },
    info() {
      return i >= H9 && n(t || "log", "INFO", arguments), this;
    },
    debug() {
      return i >= V9 && n(t || "log", "DEBUG", arguments), this;
    }
  };
}
var R = Array.isArray;
function X(e) {
  return e === Object(e);
}
const SS = (e) => e !== "__proto__";
function el() {
  for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++)
    t[n] = arguments[n];
  return t.reduce((i, r) => {
    for (const a in r)
      if (a === "signals")
        i.signals = oj(i.signals, r.signals);
      else {
        const s = a === "legend" ? {
          layout: 1
        } : a === "style" ? !0 : null;
        tl(i, a, r[a], s);
      }
    return i;
  }, {});
}
function tl(e, t, n, i) {
  if (!SS(t))
    return;
  let r, a;
  if (X(n) && !R(n)) {
    a = X(e[t]) ? e[t] : e[t] = {};
    for (r in n)
      i && (i === !0 || i[r]) ? tl(a, r, n[r]) : SS(r) && (a[r] = n[r]);
  } else
    e[t] = n;
}
function oj(e, t) {
  if (e == null)
    return t;
  const n = {}, i = [];
  function r(a) {
    n[a.name] || (n[a.name] = 1, i.push(a));
  }
  return t.forEach(r), e.forEach(r), i;
}
function ae(e) {
  return e[e.length - 1];
}
function Fe(e) {
  return e == null || e === "" ? null : +e;
}
const X9 = (e) => (t) => e * Math.exp(t), Y9 = (e) => (t) => Math.log(e * t), K9 = (e) => (t) => Math.sign(t) * Math.log1p(Math.abs(t / e)), J9 = (e) => (t) => Math.sign(t) * Math.expm1(Math.abs(t)) * e, Op = (e) => (t) => t < 0 ? -Math.pow(-t, e) : Math.pow(t, e);
function t0(e, t, n, i) {
  const r = n(e[0]), a = n(ae(e)), s = (a - r) * t;
  return [i(r - s), i(a - s)];
}
function S2(e, t) {
  return t0(e, t, Fe, kt);
}
function A2(e, t) {
  var n = Math.sign(e[0]);
  return t0(e, t, Y9(n), X9(n));
}
function k2(e, t, n) {
  return t0(e, t, Op(n), Op(1 / n));
}
function C2(e, t, n) {
  return t0(e, t, K9(n), J9(n));
}
function n0(e, t, n, i, r) {
  const a = i(e[0]), s = i(ae(e)), o = t != null ? i(t) : (a + s) / 2;
  return [r(o + (a - o) * n), r(o + (s - o) * n)];
}
function i0(e, t, n) {
  return n0(e, t, n, Fe, kt);
}
function r0(e, t, n) {
  const i = Math.sign(e[0]);
  return n0(e, t, n, Y9(i), X9(i));
}
function Wc(e, t, n, i) {
  return n0(e, t, n, Op(i), Op(1 / i));
}
function a0(e, t, n, i) {
  return n0(e, t, n, K9(i), J9(i));
}
function _2(e) {
  return 1 + ~~(new Date(e).getMonth() / 3);
}
function F2(e) {
  return 1 + ~~(new Date(e).getUTCMonth() / 3);
}
function G(e) {
  return e != null ? R(e) ? e : [e] : [];
}
function M2(e, t, n) {
  let i = e[0], r = e[1], a;
  return r < i && (a = r, r = i, i = a), a = r - i, a >= n - t ? [t, n] : [i = Math.min(Math.max(i, t), n - a), i + a];
}
function oe(e) {
  return typeof e == "function";
}
const uj = "descending";
function O2(e, t, n) {
  n = n || {}, t = G(t) || [];
  const i = [], r = [], a = {}, s = n.comparator || lj;
  return G(e).forEach((o, u) => {
    o != null && (i.push(t[u] === uj ? -1 : 1), r.push(o = oe(o) ? o : At(o, null, n)), (Pt(o) || []).forEach((l) => a[l] = 1));
  }), r.length === 0 ? null : An(s(r, i), Object.keys(a));
}
const s0 = (e, t) => (e < t || e == null) && t != null ? -1 : (e > t || t == null) && e != null ? 1 : (t = t instanceof Date ? +t : t, (e = e instanceof Date ? +e : e) !== e && t === t ? -1 : t !== t && e === e ? 1 : 0), lj = (e, t) => e.length === 1 ? cj(e[0], t[0]) : fj(e, t, e.length), cj = (e, t) => function(n, i) {
  return s0(e(n), e(i)) * t;
}, fj = (e, t, n) => (t.push(0), function(i, r) {
  let a, s = 0, o = -1;
  for (; s === 0 && ++o < n; )
    a = e[o], s = s0(a(i), a(r));
  return s * t[o];
});
function Ut(e) {
  return oe(e) ? e : () => e;
}
function R2(e, t) {
  let n;
  return (i) => {
    n && clearTimeout(n), n = setTimeout(() => (t(i), n = null), e);
  };
}
function ue(e) {
  for (let t, n, i = 1, r = arguments.length; i < r; ++i) {
    t = arguments[i];
    for (n in t)
      e[n] = t[n];
  }
  return e;
}
function Ci(e, t) {
  let n = 0, i, r, a, s;
  if (e && (i = e.length))
    if (t == null) {
      for (r = e[n]; n < i && (r == null || r !== r); r = e[++n])
        ;
      for (a = s = r; n < i; ++n)
        r = e[n], r != null && (r < a && (a = r), r > s && (s = r));
    } else {
      for (r = t(e[n]); n < i && (r == null || r !== r); r = t(e[++n]))
        ;
      for (a = s = r; n < i; ++n)
        r = t(e[n]), r != null && (r < a && (a = r), r > s && (s = r));
    }
  return [a, s];
}
function Q9(e, t) {
  const n = e.length;
  let i = -1, r, a, s, o, u;
  if (t == null) {
    for (; ++i < n; )
      if (a = e[i], a != null && a >= a) {
        r = s = a;
        break;
      }
    if (i === n)
      return [-1, -1];
    for (o = u = i; ++i < n; )
      a = e[i], a != null && (r > a && (r = a, o = i), s < a && (s = a, u = i));
  } else {
    for (; ++i < n; )
      if (a = t(e[i], i, e), a != null && a >= a) {
        r = s = a;
        break;
      }
    if (i === n)
      return [-1, -1];
    for (o = u = i; ++i < n; )
      a = t(e[i], i, e), a != null && (r > a && (r = a, o = i), s < a && (s = a, u = i));
  }
  return [o, u];
}
const dj = Object.prototype.hasOwnProperty;
function Y(e, t) {
  return dj.call(e, t);
}
const Jd = {};
function nl(e) {
  let t = {}, n;
  function i(a) {
    return Y(t, a) && t[a] !== Jd;
  }
  const r = {
    size: 0,
    empty: 0,
    object: t,
    has: i,
    get(a) {
      return i(a) ? t[a] : void 0;
    },
    set(a, s) {
      return i(a) || (++r.size, t[a] === Jd && --r.empty), t[a] = s, this;
    },
    delete(a) {
      return i(a) && (--r.size, ++r.empty, t[a] = Jd), this;
    },
    clear() {
      r.size = r.empty = 0, r.object = t = {};
    },
    test(a) {
      return arguments.length ? (n = a, r) : n;
    },
    clean() {
      const a = {};
      let s = 0;
      for (const o in t) {
        const u = t[o];
        u !== Jd && (!n || !n(u)) && (a[o] = u, ++s);
      }
      r.size = s, r.empty = 0, r.object = t = a;
    }
  };
  return e && Object.keys(e).forEach((a) => {
    r.set(a, e[a]);
  }), r;
}
function T2(e, t, n, i, r, a) {
  if (!n && n !== 0)
    return a;
  const s = +n;
  let o = e[0], u = ae(e), l;
  u < o && (l = o, o = u, u = l), l = Math.abs(t - o);
  const c = Math.abs(u - t);
  return l < c && l <= s ? i : c <= s ? r : a;
}
function B(e, t, n) {
  const i = e.prototype = Object.create(t.prototype);
  return Object.defineProperty(i, "constructor", {
    value: e,
    writable: !0,
    enumerable: !0,
    configurable: !0
  }), ue(i, n);
}
function bi(e, t, n, i) {
  let r = t[0], a = t[t.length - 1], s;
  return r > a && (s = r, r = a, a = s), n = n === void 0 || n, i = i === void 0 || i, (n ? r <= e : r < e) && (i ? e <= a : e < a);
}
function Zr(e) {
  return typeof e == "boolean";
}
function Kn(e) {
  return Object.prototype.toString.call(e) === "[object Date]";
}
function Z9(e) {
  return e && oe(e[Symbol.iterator]);
}
function ye(e) {
  return typeof e == "number";
}
function D2(e) {
  return Object.prototype.toString.call(e) === "[object RegExp]";
}
function V(e) {
  return typeof e == "string";
}
function N2(e, t, n) {
  e && (e = t ? G(e).map((o) => o.replace(/\\(.)/g, "$1")) : G(e));
  const i = e && e.length, r = n && n.get || G9, a = (o) => r(t ? [o] : br(o));
  let s;
  if (!i)
    s = function() {
      return "";
    };
  else if (i === 1) {
    const o = a(e[0]);
    s = function(u) {
      return "" + o(u);
    };
  } else {
    const o = e.map(a);
    s = function(u) {
      let l = "" + o[0](u), c = 0;
      for (; ++c < i; )
        l += "|" + o[c](u);
      return l;
    };
  }
  return An(s, e, "key");
}
function L2(e, t) {
  const n = e[0], i = ae(e), r = +t;
  return r ? r === 1 ? i : n + r * (i - n) : n;
}
const hj = 1e4;
function P2(e) {
  e = +e || hj;
  let t, n, i;
  const r = () => {
    t = {}, n = {}, i = 0;
  }, a = (s, o) => (++i > e && (n = t, t = {}, i = 1), t[s] = o);
  return r(), {
    clear: r,
    has: (s) => Y(t, s) || Y(n, s),
    get: (s) => Y(t, s) ? t[s] : Y(n, s) ? a(s, n[s]) : void 0,
    set: (s, o) => Y(t, s) ? t[s] = o : a(s, o)
  };
}
function e8(e, t, n, i) {
  const r = t.length, a = n.length;
  if (!a)
    return t;
  if (!r)
    return n;
  const s = i || new t.constructor(r + a);
  let o = 0, u = 0, l = 0;
  for (; o < r && u < a; ++l)
    s[l] = e(t[o], n[u]) > 0 ? n[u++] : t[o++];
  for (; o < r; ++o, ++l)
    s[l] = t[o];
  for (; u < a; ++u, ++l)
    s[l] = n[u];
  return s;
}
function rc(e, t) {
  let n = "";
  for (; --t >= 0; )
    n += e;
  return n;
}
function z2(e, t, n, i) {
  const r = n || " ", a = e + "", s = t - a.length;
  return s <= 0 ? a : i === "left" ? rc(r, s) + a : i === "center" ? rc(r, ~~(s / 2)) + a + rc(r, Math.ceil(s / 2)) : a + rc(r, s);
}
function il(e) {
  return e && ae(e) - e[0] || 0;
}
function U(e) {
  return R(e) ? "[" + e.map(U) + "]" : X(e) || V(e) ? (
    // Output valid JSON and JS source strings.
    // See http://timelessrepo.com/json-isnt-a-javascript-subset
    JSON.stringify(e).replace("\u2028", "\\u2028").replace("\u2029", "\\u2029")
  ) : e;
}
function o0(e) {
  return e == null || e === "" ? null : !e || e === "false" || e === "0" ? !1 : !!e;
}
const pj = (e) => ye(e) || Kn(e) ? e : Date.parse(e);
function u0(e, t) {
  return t = t || pj, e == null || e === "" ? null : t(e);
}
function l0(e) {
  return e == null || e === "" ? null : e + "";
}
function an(e) {
  const t = {}, n = e.length;
  for (let i = 0; i < n; ++i)
    t[e[i]] = !0;
  return t;
}
function I2(e, t, n, i) {
  const r = i ?? "", a = e + "", s = a.length, o = Math.max(0, t - r.length);
  return s <= t ? a : n === "left" ? r + a.slice(s - o) : n === "center" ? a.slice(0, Math.ceil(o / 2)) + r + a.slice(s - ~~(o / 2)) : a.slice(0, o) + r;
}
function ya(e, t, n) {
  if (e)
    if (t) {
      const i = e.length;
      for (let r = 0; r < i; ++r) {
        const a = t(e[r]);
        a && n(a, r, e);
      }
    } else
      e.forEach(n);
}
function gj(e) {
  return e;
}
function mj(e) {
  if (e == null)
    return gj;
  var t, n, i = e.scale[0], r = e.scale[1], a = e.translate[0], s = e.translate[1];
  return function(o, u) {
    u || (t = n = 0);
    var l = 2, c = o.length, f = new Array(c);
    for (f[0] = (t += o[0]) * i + a, f[1] = (n += o[1]) * r + s; l < c; )
      f[l] = o[l], ++l;
    return f;
  };
}
function yj(e, t) {
  for (var n, i = e.length, r = i - t; r < --i; )
    n = e[r], e[r++] = e[i], e[i] = n;
}
function bj(e, t) {
  return typeof t == "string" && (t = e.objects[t]), t.type === "GeometryCollection" ? { type: "FeatureCollection", features: t.geometries.map(function(n) {
    return AS(e, n);
  }) } : AS(e, t);
}
function AS(e, t) {
  var n = t.id, i = t.bbox, r = t.properties == null ? {} : t.properties, a = t8(e, t);
  return n == null && i == null ? { type: "Feature", properties: r, geometry: a } : i == null ? { type: "Feature", id: n, properties: r, geometry: a } : { type: "Feature", id: n, bbox: i, properties: r, geometry: a };
}
function t8(e, t) {
  var n = mj(e.transform), i = e.arcs;
  function r(c, f) {
    f.length && f.pop();
    for (var d = i[c < 0 ? ~c : c], h = 0, p = d.length; h < p; ++h)
      f.push(n(d[h], h));
    c < 0 && yj(f, p);
  }
  function a(c) {
    return n(c);
  }
  function s(c) {
    for (var f = [], d = 0, h = c.length; d < h; ++d)
      r(c[d], f);
    return f.length < 2 && f.push(f[0]), f;
  }
  function o(c) {
    for (var f = s(c); f.length < 4; )
      f.push(f[0]);
    return f;
  }
  function u(c) {
    return c.map(o);
  }
  function l(c) {
    var f = c.type, d;
    switch (f) {
      case "GeometryCollection":
        return { type: f, geometries: c.geometries.map(l) };
      case "Point":
        d = a(c.coordinates);
        break;
      case "MultiPoint":
        d = c.coordinates.map(a);
        break;
      case "LineString":
        d = s(c.arcs);
        break;
      case "MultiLineString":
        d = c.arcs.map(s);
        break;
      case "Polygon":
        d = u(c.arcs);
        break;
      case "MultiPolygon":
        d = c.arcs.map(u);
        break;
      default:
        return null;
    }
    return { type: f, coordinates: d };
  }
  return l(t);
}
function vj(e, t) {
  var n = {}, i = {}, r = {}, a = [], s = -1;
  t.forEach(function(l, c) {
    var f = e.arcs[l < 0 ? ~l : l], d;
    f.length < 3 && !f[1][0] && !f[1][1] && (d = t[++s], t[s] = l, t[c] = d);
  }), t.forEach(function(l) {
    var c = o(l), f = c[0], d = c[1], h, p;
    if (h = r[f])
      if (delete r[h.end], h.push(l), h.end = d, p = i[d]) {
        delete i[p.start];
        var g = p === h ? h : h.concat(p);
        i[g.start = h.start] = r[g.end = p.end] = g;
      } else
        i[h.start] = r[h.end] = h;
    else if (h = i[d])
      if (delete i[h.start], h.unshift(l), h.start = f, p = r[f]) {
        delete r[p.end];
        var m = p === h ? h : p.concat(h);
        i[m.start = p.start] = r[m.end = h.end] = m;
      } else
        i[h.start] = r[h.end] = h;
    else
      h = [l], i[h.start = f] = r[h.end = d] = h;
  });
  function o(l) {
    var c = e.arcs[l < 0 ? ~l : l], f = c[0], d;
    return e.transform ? (d = [0, 0], c.forEach(function(h) {
      d[0] += h[0], d[1] += h[1];
    })) : d = c[c.length - 1], l < 0 ? [d, f] : [f, d];
  }
  function u(l, c) {
    for (var f in l) {
      var d = l[f];
      delete c[d.start], delete d.start, delete d.end, d.forEach(function(h) {
        n[h < 0 ? ~h : h] = 1;
      }), a.push(d);
    }
  }
  return u(r, i), u(i, r), t.forEach(function(l) {
    n[l < 0 ? ~l : l] || a.push([l]);
  }), a;
}
function xj(e) {
  return t8(e, $j.apply(this, arguments));
}
function $j(e, t, n) {
  var i, r, a;
  if (arguments.length > 1)
    i = wj(e, t, n);
  else
    for (r = 0, i = new Array(a = e.arcs.length); r < a; ++r)
      i[r] = r;
  return { type: "MultiLineString", arcs: vj(e, i) };
}
function wj(e, t, n) {
  var i = [], r = [], a;
  function s(f) {
    var d = f < 0 ? ~f : f;
    (r[d] || (r[d] = [])).push({ i: f, g: a });
  }
  function o(f) {
    f.forEach(s);
  }
  function u(f) {
    f.forEach(o);
  }
  function l(f) {
    f.forEach(u);
  }
  function c(f) {
    switch (a = f, f.type) {
      case "GeometryCollection":
        f.geometries.forEach(c);
        break;
      case "LineString":
        o(f.arcs);
        break;
      case "MultiLineString":
      case "Polygon":
        u(f.arcs);
        break;
      case "MultiPolygon":
        l(f.arcs);
        break;
    }
  }
  return c(t), r.forEach(n == null ? function(f) {
    i.push(f[0].i);
  } : function(f) {
    n(f[0].g, f[f.length - 1].g) && i.push(f[0].i);
  }), i;
}
const Et = "year", vn = "quarter", zt = "month", nt = "week", xn = "date", Dt = "day", fr = "dayofyear", Nn = "hours", Ln = "minutes", ei = "seconds", _i = "milliseconds", B2 = [Et, vn, zt, nt, xn, Dt, fr, Nn, Ln, ei, _i], A1 = B2.reduce((e, t, n) => (e[t] = 1 + n, e), {});
function j2(e) {
  const t = G(e).slice(), n = {};
  return t.length || D("Missing time unit."), t.forEach((r) => {
    Y(A1, r) ? n[r] = 1 : D(`Invalid time unit: ${r}.`);
  }), (n[nt] || n[Dt] ? 1 : 0) + (n[vn] || n[zt] || n[xn] ? 1 : 0) + (n[fr] ? 1 : 0) > 1 && D(`Incompatible time units: ${e}`), t.sort((r, a) => A1[r] - A1[a]), t;
}
const Ej = {
  [Et]: "%Y ",
  [vn]: "Q%q ",
  [zt]: "%b ",
  [xn]: "%d ",
  [nt]: "W%U ",
  [Dt]: "%a ",
  [fr]: "%j ",
  [Nn]: "%H:00",
  [Ln]: "00:%M",
  [ei]: ":%S",
  [_i]: ".%L",
  [`${Et}-${zt}`]: "%Y-%m ",
  [`${Et}-${zt}-${xn}`]: "%Y-%m-%d ",
  [`${Nn}-${Ln}`]: "%H:%M"
};
function U2(e, t) {
  const n = ue({}, Ej, t), i = j2(e), r = i.length;
  let a = "", s = 0, o, u;
  for (s = 0; s < r; )
    for (o = i.length; o > s; --o)
      if (u = i.slice(s, o).join("-"), n[u] != null) {
        a += n[u], s = o;
        break;
      }
  return a.trim();
}
const Os = /* @__PURE__ */ new Date();
function q2(e) {
  return Os.setFullYear(e), Os.setMonth(0), Os.setDate(1), Os.setHours(0, 0, 0, 0), Os;
}
function G2(e) {
  return n8(new Date(e));
}
function W2(e) {
  return cb(new Date(e));
}
function n8(e) {
  return Sh.count(q2(e.getFullYear()) - 1, e);
}
function cb(e) {
  return ok.count(q2(e.getFullYear()) - 1, e);
}
function fb(e) {
  return q2(e).getDay();
}
function Sj(e, t, n, i, r, a, s) {
  if (0 <= e && e < 100) {
    const o = new Date(-1, t, n, i, r, a, s);
    return o.setFullYear(e), o;
  }
  return new Date(e, t, n, i, r, a, s);
}
function H2(e) {
  return i8(new Date(e));
}
function V2(e) {
  return db(new Date(e));
}
function i8(e) {
  const t = Date.UTC(e.getUTCFullYear(), 0, 1);
  return xc.count(t - 1, e);
}
function db(e) {
  const t = Date.UTC(e.getUTCFullYear(), 0, 1);
  return Kv.count(t - 1, e);
}
function hb(e) {
  return Os.setTime(Date.UTC(e, 0, 1)), Os.getUTCDay();
}
function Aj(e, t, n, i, r, a, s) {
  if (0 <= e && e < 100) {
    const o = new Date(Date.UTC(-1, t, n, i, r, a, s));
    return o.setUTCFullYear(n.y), o;
  }
  return new Date(Date.UTC(e, t, n, i, r, a, s));
}
function r8(e, t, n, i, r) {
  const a = t || 1, s = ae(e), o = (y, b, v) => (v = v || y, kj(n[v], i[v], y === s && a, b)), u = /* @__PURE__ */ new Date(), l = an(e), c = l[Et] ? o(Et) : Ut(2012), f = l[zt] ? o(zt) : l[vn] ? o(vn) : wa, d = l[nt] && l[Dt] ? o(Dt, 1, nt + Dt) : l[nt] ? o(nt, 1) : l[Dt] ? o(Dt, 1) : l[xn] ? o(xn, 1) : l[fr] ? o(fr, 1) : Zu, h = l[Nn] ? o(Nn) : wa, p = l[Ln] ? o(Ln) : wa, g = l[ei] ? o(ei) : wa, m = l[_i] ? o(_i) : wa;
  return function(y) {
    u.setTime(+y);
    const b = c(u);
    return r(b, f(u), d(u, b), h(u), p(u), g(u), m(u));
  };
}
function kj(e, t, n, i) {
  const r = n <= 1 ? e : i ? (a, s) => i + n * Math.floor((e(a, s) - i) / n) : (a, s) => n * Math.floor(e(a, s) / n);
  return t ? (a, s) => t(r(a, s), s) : r;
}
function xu(e, t, n) {
  return t + e * 7 - (n + 6) % 7;
}
const Cj = {
  [Et]: (e) => e.getFullYear(),
  [vn]: (e) => Math.floor(e.getMonth() / 3),
  [zt]: (e) => e.getMonth(),
  [xn]: (e) => e.getDate(),
  [Nn]: (e) => e.getHours(),
  [Ln]: (e) => e.getMinutes(),
  [ei]: (e) => e.getSeconds(),
  [_i]: (e) => e.getMilliseconds(),
  [fr]: (e) => n8(e),
  [nt]: (e) => cb(e),
  [nt + Dt]: (e, t) => xu(cb(e), e.getDay(), fb(t)),
  [Dt]: (e, t) => xu(1, e.getDay(), fb(t))
}, _j = {
  [vn]: (e) => 3 * e,
  [nt]: (e, t) => xu(e, 0, fb(t))
};
function a8(e, t) {
  return r8(e, t || 1, Cj, _j, Sj);
}
const Fj = {
  [Et]: (e) => e.getUTCFullYear(),
  [vn]: (e) => Math.floor(e.getUTCMonth() / 3),
  [zt]: (e) => e.getUTCMonth(),
  [xn]: (e) => e.getUTCDate(),
  [Nn]: (e) => e.getUTCHours(),
  [Ln]: (e) => e.getUTCMinutes(),
  [ei]: (e) => e.getUTCSeconds(),
  [_i]: (e) => e.getUTCMilliseconds(),
  [fr]: (e) => i8(e),
  [nt]: (e) => db(e),
  [Dt]: (e, t) => xu(1, e.getUTCDay(), hb(t)),
  [nt + Dt]: (e, t) => xu(db(e), e.getUTCDay(), hb(t))
}, Mj = {
  [vn]: (e) => 3 * e,
  [nt]: (e, t) => xu(e, 0, hb(t))
};
function s8(e, t) {
  return r8(e, t || 1, Fj, Mj, Aj);
}
const Oj = {
  [Et]: dL,
  [vn]: g5.every(3),
  [zt]: g5,
  [nt]: ok,
  [xn]: Sh,
  [Dt]: Sh,
  [fr]: Sh,
  [Nn]: hL,
  [Ln]: pL,
  [ei]: Yv,
  [_i]: uk
}, Rj = {
  [Et]: sk,
  [vn]: Ty.every(3),
  [zt]: Ty,
  [nt]: Kv,
  [xn]: xc,
  [Dt]: xc,
  [fr]: xc,
  [Nn]: ak,
  [Ln]: rk,
  [ei]: Yv,
  [_i]: uk
};
function rl(e) {
  return Oj[e];
}
function al(e) {
  return Rj[e];
}
function o8(e, t, n) {
  return e ? e.offset(t, n) : void 0;
}
function X2(e, t, n) {
  return o8(rl(e), t, n);
}
function Y2(e, t, n) {
  return o8(al(e), t, n);
}
function u8(e, t, n, i) {
  return e ? e.range(t, n, i) : void 0;
}
function K2(e, t, n, i) {
  return u8(rl(e), t, n, i);
}
function J2(e, t, n, i) {
  return u8(al(e), t, n, i);
}
const ac = 1e3, sc = ac * 60, oc = sc * 60, c0 = oc * 24, Tj = c0 * 7, kS = c0 * 30, pb = c0 * 365, l8 = [Et, zt, xn, Nn, Ln, ei, _i], uc = l8.slice(0, -1), lc = uc.slice(0, -1), cc = lc.slice(0, -1), Dj = cc.slice(0, -1), Nj = [Et, nt], CS = [Et, zt], c8 = [Et], Ml = [[uc, 1, ac], [uc, 5, 5 * ac], [uc, 15, 15 * ac], [uc, 30, 30 * ac], [lc, 1, sc], [lc, 5, 5 * sc], [lc, 15, 15 * sc], [lc, 30, 30 * sc], [cc, 1, oc], [cc, 3, 3 * oc], [cc, 6, 6 * oc], [cc, 12, 12 * oc], [Dj, 1, c0], [Nj, 1, Tj], [CS, 1, kS], [CS, 3, 3 * kS], [c8, 1, pb]];
function f8(e) {
  const t = e.extent, n = e.maxbins || 40, i = Math.abs(il(t)) / n;
  let r = Zv((o) => o[2]).right(Ml, i), a, s;
  return r === Ml.length ? (a = c8, s = Bc(t[0] / pb, t[1] / pb, n)) : r ? (r = Ml[i / Ml[r - 1][2] < Ml[r][2] / i ? r - 1 : r], a = r[0], s = r[1]) : (a = l8, s = Math.max(Bc(t[0], t[1], n), 1)), {
    units: a,
    step: s
  };
}
function fc(e) {
  const t = {};
  return (n) => t[n] || (t[n] = e(n));
}
function Lj(e, t) {
  return (n) => {
    const i = e(n), r = i.indexOf(t);
    if (r < 0)
      return i;
    let a = Pj(i, r);
    const s = a < i.length ? i.slice(a) : "";
    for (; --a > r; )
      if (i[a] !== "0") {
        ++a;
        break;
      }
    return i.slice(0, a) + s;
  };
}
function Pj(e, t) {
  let n = e.lastIndexOf("e"), i;
  if (n > 0)
    return n;
  for (n = e.length; --n > t; )
    if (i = e.charCodeAt(n), i >= 48 && i <= 57)
      return n + 1;
}
function d8(e) {
  const t = fc(e.format), n = e.formatPrefix;
  return {
    format: t,
    formatPrefix: n,
    formatFloat(i) {
      const r = Dy(i || ",");
      if (r.precision == null) {
        switch (r.precision = 12, r.type) {
          case "%":
            r.precision -= 2;
            break;
          case "e":
            r.precision -= 1;
            break;
        }
        return Lj(
          t(r),
          // number format
          t(".1f")(1)[1]
          // decimal point character
        );
      } else
        return t(r);
    },
    formatSpan(i, r, a, s) {
      s = Dy(s ?? ",f");
      const o = Bc(i, r, a), u = Math.max(Math.abs(i), Math.abs(r));
      let l;
      if (s.precision == null)
        switch (s.type) {
          case "s":
            return isNaN(l = CL(o, u)) || (s.precision = l), n(s, u);
          case "":
          case "e":
          case "g":
          case "p":
          case "r": {
            isNaN(l = kL(o, u)) || (s.precision = l - (s.type === "e"));
            break;
          }
          case "f":
          case "%": {
            isNaN(l = AL(o)) || (s.precision = l - (s.type === "%") * 2);
            break;
          }
        }
      return t(s);
    }
  };
}
let gb;
h8();
function h8() {
  return gb = d8({
    format: ck,
    formatPrefix: _L
  });
}
function p8(e) {
  return d8(FL(e));
}
function Rp(e) {
  return arguments.length ? gb = p8(e) : gb;
}
function _S(e, t, n) {
  n = n || {}, X(n) || D(`Invalid time multi-format specifier: ${n}`);
  const i = t(ei), r = t(Ln), a = t(Nn), s = t(xn), o = t(nt), u = t(zt), l = t(vn), c = t(Et), f = e(n[_i] || ".%L"), d = e(n[ei] || ":%S"), h = e(n[Ln] || "%I:%M"), p = e(n[Nn] || "%I %p"), g = e(n[xn] || n[Dt] || "%a %d"), m = e(n[nt] || "%b %d"), y = e(n[zt] || "%B"), b = e(n[vn] || "%B"), v = e(n[Et] || "%Y");
  return (x) => (i(x) < x ? f : r(x) < x ? d : a(x) < x ? h : s(x) < x ? p : u(x) < x ? o(x) < x ? g : m : c(x) < x ? l(x) < x ? y : b : v)(x);
}
function g8(e) {
  const t = fc(e.format), n = fc(e.utcFormat);
  return {
    timeFormat: (i) => V(i) ? t(i) : _S(t, rl, i),
    utcFormat: (i) => V(i) ? n(i) : _S(n, al, i),
    timeParse: fc(e.parse),
    utcParse: fc(e.utcParse)
  };
}
let mb;
m8();
function m8() {
  return mb = g8({
    format: gL,
    parse: mL,
    utcFormat: ik,
    utcParse: yL
  });
}
function y8(e) {
  return g8(bL(e));
}
function Hc(e) {
  return arguments.length ? mb = y8(e) : mb;
}
const yb = (e, t) => ue({}, e, t);
function b8(e, t) {
  const n = e ? p8(e) : Rp(), i = t ? y8(t) : Hc();
  return yb(n, i);
}
function Q2(e, t) {
  const n = arguments.length;
  return n && n !== 2 && D("defaultLocale expects either zero or two arguments."), n ? yb(Rp(e), Hc(t)) : yb(Rp(), Hc());
}
function zj() {
  return h8(), m8(), Q2();
}
const Ij = /^(data:|([A-Za-z]+:)?\/\/)/, Bj = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i, jj = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g, FS = "file://";
function Uj(e, t) {
  return (n) => ({
    options: n || {},
    sanitize: Gj,
    load: qj,
    fileAccess: !!t,
    file: Wj(t),
    http: Vj(e)
  });
}
async function qj(e, t) {
  const n = await this.sanitize(e, t), i = n.href;
  return n.localFile ? this.file(i) : this.http(i, t);
}
async function Gj(e, t) {
  t = ue({}, this.options, t);
  const n = this.fileAccess, i = {
    href: null
  };
  let r, a, s;
  const o = Bj.test(e.replace(jj, ""));
  (e == null || typeof e != "string" || !o) && D("Sanitize failure, invalid URI: " + U(e));
  const u = Ij.test(e);
  return (s = t.baseURL) && !u && (!e.startsWith("/") && !s.endsWith("/") && (e = "/" + e), e = s + e), a = (r = e.startsWith(FS)) || t.mode === "file" || t.mode !== "http" && !u && n, r ? e = e.slice(FS.length) : e.startsWith("//") && (t.defaultProtocol === "file" ? (e = e.slice(2), a = !0) : e = (t.defaultProtocol || "http") + ":" + e), Object.defineProperty(i, "localFile", {
    value: !!a
  }), i.href = e, t.target && (i.target = t.target + ""), t.rel && (i.rel = t.rel + ""), t.context === "image" && t.crossOrigin && (i.crossOrigin = t.crossOrigin + ""), i;
}
function Wj(e) {
  return e ? (t) => new Promise((n, i) => {
    e.readFile(t, (r, a) => {
      r ? i(r) : n(a);
    });
  }) : Hj;
}
async function Hj() {
  D("No file system access.");
}
function Vj(e) {
  return e ? async function(t, n) {
    const i = ue({}, this.options.http, n), r = n && n.response, a = await e(t, i);
    return a.ok ? oe(a[r]) ? a[r]() : a.text() : D(a.status + "" + a.statusText);
  } : Xj;
}
async function Xj() {
  D("No HTTP fetch method available.");
}
const Yj = (e) => e != null && e === e, Kj = (e) => e === "true" || e === "false" || e === !0 || e === !1, Jj = (e) => !Number.isNaN(Date.parse(e)), v8 = (e) => !Number.isNaN(+e) && !(e instanceof Date), Qj = (e) => v8(e) && Number.isInteger(+e), bb = {
  boolean: o0,
  integer: Fe,
  number: Fe,
  date: u0,
  string: l0,
  unknown: kt
}, Qd = [Kj, Qj, v8, Jj], Zj = ["boolean", "integer", "number", "date"];
function x8(e, t) {
  if (!e || !e.length)
    return "unknown";
  const n = e.length, i = Qd.length, r = Qd.map((a, s) => s + 1);
  for (let a = 0, s = 0, o, u; a < n; ++a)
    for (u = t ? e[a][t] : e[a], o = 0; o < i; ++o)
      if (r[o] && Yj(u) && !Qd[o](u) && (r[o] = 0, ++s, s === Qd.length))
        return "string";
  return Zj[r.reduce((a, s) => a === 0 ? s : a, 0) - 1];
}
function $8(e, t) {
  return t.reduce((n, i) => (n[i] = x8(e, i), n), {});
}
function MS(e) {
  const t = function(n, i) {
    const r = {
      delimiter: e
    };
    return Z2(n, i ? ue(i, r) : r);
  };
  return t.responseType = "text", t;
}
function Z2(e, t) {
  return t.header && (e = t.header.map(U).join(t.delimiter) + `
` + e), VP(t.delimiter).parse(e + "");
}
Z2.responseType = "text";
function eU(e) {
  return typeof Buffer == "function" && oe(Buffer.isBuffer) ? Buffer.isBuffer(e) : !1;
}
function ex(e, t) {
  const n = t && t.property ? At(t.property) : kt;
  return X(e) && !eU(e) ? tU(n(e), t) : n(JSON.parse(e));
}
ex.responseType = "json";
function tU(e, t) {
  return !R(e) && Z9(e) && (e = [...e]), t && t.copy ? JSON.parse(JSON.stringify(e)) : e;
}
const nU = {
  interior: (e, t) => e !== t,
  exterior: (e, t) => e === t
};
function w8(e, t) {
  let n, i, r, a;
  return e = ex(e, t), t && t.feature ? (n = bj, r = t.feature) : t && t.mesh ? (n = xj, r = t.mesh, a = nU[t.filter]) : D("Missing TopoJSON feature or mesh parameter."), i = (i = e.objects[r]) ? n(e, i, a) : D("Invalid TopoJSON object: " + r), i && i.features || [i];
}
w8.responseType = "json";
const _h = {
  dsv: Z2,
  csv: MS(","),
  tsv: MS("	"),
  json: ex,
  topojson: w8
};
function tx(e, t) {
  return arguments.length > 1 ? (_h[e] = t, this) : Y(_h, e) ? _h[e] : null;
}
function E8(e) {
  const t = tx(e);
  return t && t.responseType || "text";
}
function S8(e, t, n, i) {
  t = t || {};
  const r = tx(t.type || "json");
  return r || D("Unknown data format type: " + t.type), e = r(e, t), t.parse && iU(e, t.parse, n, i), Y(e, "columns") && delete e.columns, e;
}
function iU(e, t, n, i) {
  if (!e.length)
    return;
  const r = Hc();
  n = n || r.timeParse, i = i || r.utcParse;
  let a = e.columns || Object.keys(e[0]), s, o, u, l, c, f;
  t === "auto" && (t = $8(e, a)), a = Object.keys(t);
  const d = a.map((h) => {
    const p = t[h];
    let g, m;
    if (p && (p.startsWith("date:") || p.startsWith("utc:")))
      return g = p.split(/:(.+)?/, 2), m = g[1], (m[0] === "'" && m[m.length - 1] === "'" || m[0] === '"' && m[m.length - 1] === '"') && (m = m.slice(1, -1)), (g[0] === "utc" ? i : n)(m);
    if (!bb[p])
      throw Error("Illegal format pattern: " + h + ":" + p);
    return bb[p];
  });
  for (u = 0, c = e.length, f = a.length; u < c; ++u)
    for (s = e[u], l = 0; l < f; ++l)
      o = a[l], s[o] = d[l](s[o]);
}
const sl = Uj(
  typeof fetch < "u" && fetch,
  // use built-in fetch API
  null
  // no file system access
);
function f0(e) {
  const t = e || kt, n = [], i = {};
  return n.add = (r) => {
    const a = t(r);
    return i[a] || (i[a] = 1, n.push(r)), n;
  }, n.remove = (r) => {
    const a = t(r);
    if (i[a]) {
      i[a] = 0;
      const s = n.indexOf(r);
      s >= 0 && n.splice(s, 1);
    }
    return n;
  }, n;
}
async function Fh(e, t) {
  try {
    await t(e);
  } catch (n) {
    e.error(n);
  }
}
const A8 = Symbol("vega_id");
let rU = 1;
function ol(e) {
  return !!(e && ee(e));
}
function ee(e) {
  return e[A8];
}
function k8(e, t) {
  return e[A8] = t, e;
}
function $e(e) {
  const t = e === Object(e) ? e : {
    data: e
  };
  return ee(t) ? t : k8(t, rU++);
}
function nx(e) {
  return d0(e, $e({}));
}
function d0(e, t) {
  for (const n in e)
    t[n] = e[n];
  return t;
}
function C8(e, t) {
  return k8(t, ee(e));
}
function Ao(e, t) {
  return e ? t ? (n, i) => e(n, i) || ee(t(n)) - ee(t(i)) : (n, i) => e(n, i) || ee(n) - ee(i) : null;
}
function _8(e) {
  return e && e.constructor === ko;
}
function ko() {
  const e = [], t = [], n = [], i = [], r = [];
  let a = null, s = !1;
  return {
    constructor: ko,
    insert(o) {
      const u = G(o), l = u.length;
      for (let c = 0; c < l; ++c)
        e.push(u[c]);
      return this;
    },
    remove(o) {
      const u = oe(o) ? i : t, l = G(o), c = l.length;
      for (let f = 0; f < c; ++f)
        u.push(l[f]);
      return this;
    },
    modify(o, u, l) {
      const c = {
        field: u,
        value: Ut(l)
      };
      return oe(o) ? (c.filter = o, r.push(c)) : (c.tuple = o, n.push(c)), this;
    },
    encode(o, u) {
      return oe(o) ? r.push({
        filter: o,
        field: u
      }) : n.push({
        tuple: o,
        field: u
      }), this;
    },
    clean(o) {
      return a = o, this;
    },
    reflow() {
      return s = !0, this;
    },
    pulse(o, u) {
      const l = {}, c = {};
      let f, d, h, p, g, m;
      for (f = 0, d = u.length; f < d; ++f)
        l[ee(u[f])] = 1;
      for (f = 0, d = t.length; f < d; ++f)
        g = t[f], l[ee(g)] = -1;
      for (f = 0, d = i.length; f < d; ++f)
        p = i[f], u.forEach((b) => {
          p(b) && (l[ee(b)] = -1);
        });
      for (f = 0, d = e.length; f < d; ++f)
        g = e[f], m = ee(g), l[m] ? l[m] = 1 : o.add.push($e(e[f]));
      for (f = 0, d = u.length; f < d; ++f)
        g = u[f], l[ee(g)] < 0 && o.rem.push(g);
      function y(b, v, x) {
        x ? b[v] = x(b) : o.encode = v, s || (c[ee(b)] = b);
      }
      for (f = 0, d = n.length; f < d; ++f)
        h = n[f], g = h.tuple, p = h.field, m = l[ee(g)], m > 0 && (y(g, p, h.value), o.modifies(p));
      for (f = 0, d = r.length; f < d; ++f)
        h = r[f], p = h.filter, u.forEach((b) => {
          p(b) && l[ee(b)] > 0 && y(b, h.field, h.value);
        }), o.modifies(h.field);
      if (s)
        o.mod = t.length || i.length ? u.filter((b) => l[ee(b)] > 0) : u.slice();
      else
        for (m in c)
          o.mod.push(c[m]);
      return (a || a == null && (t.length || i.length)) && o.clean(!0), o;
    }
  };
}
const Mh = "_:mod:_";
function h0() {
  Object.defineProperty(this, Mh, {
    writable: !0,
    value: {}
  });
}
h0.prototype = {
  /**
   * Set a parameter value. If the parameter value changes, the parameter
   * will be recorded as modified.
   * @param {string} name - The parameter name.
   * @param {number} index - The index into an array-value parameter. Ignored if
   *   the argument is undefined, null or less than zero.
   * @param {*} value - The parameter value to set.
   * @param {boolean} [force=false] - If true, records the parameter as modified
   *   even if the value is unchanged.
   * @return {Parameters} - This parameter object.
   */
  set(e, t, n, i) {
    const r = this, a = r[e], s = r[Mh];
    return t != null && t >= 0 ? (a[t] !== n || i) && (a[t] = n, s[t + ":" + e] = -1, s[e] = -1) : (a !== n || i) && (r[e] = n, s[e] = R(n) ? 1 + n.length : -1), r;
  },
  /**
   * Tests if one or more parameters has been modified. If invoked with no
   * arguments, returns true if any parameter value has changed. If the first
   * argument is array, returns trues if any parameter name in the array has
   * changed. Otherwise, tests if the given name and optional array index has
   * changed.
   * @param {string} name - The parameter name to test.
   * @param {number} [index=undefined] - The parameter array index to test.
   * @return {boolean} - Returns true if a queried parameter was modified.
   */
  modified(e, t) {
    const n = this[Mh];
    if (arguments.length) {
      if (R(e)) {
        for (let i = 0; i < e.length; ++i)
          if (n[e[i]])
            return !0;
        return !1;
      }
    } else {
      for (const i in n)
        if (n[i])
          return !0;
      return !1;
    }
    return t != null && t >= 0 ? t + 1 < n[e] || !!n[t + ":" + e] : !!n[e];
  },
  /**
   * Clears the modification records. After calling this method,
   * all parameters are considered unmodified.
   */
  clear() {
    return this[Mh] = {}, this;
  }
};
let aU = 0;
const sU = "pulse", oU = new h0(), uU = 1, lU = 2;
function Me(e, t, n, i) {
  this.id = ++aU, this.value = e, this.stamp = -1, this.rank = -1, this.qrank = -1, this.flags = 0, t && (this._update = t), n && this.parameters(n, i);
}
function OS(e) {
  return function(t) {
    const n = this.flags;
    return arguments.length === 0 ? !!(n & e) : (this.flags = t ? n | e : n & ~e, this);
  };
}
Me.prototype = {
  /**
   * Returns a list of target operators dependent on this operator.
   * If this list does not exist, it is created and then returned.
   * @return {UniqueList}
   */
  targets() {
    return this._targets || (this._targets = f0(qf));
  },
  /**
   * Sets the value of this operator.
   * @param {*} value - the value to set.
   * @return {Number} Returns 1 if the operator value has changed
   *   according to strict equality, returns 0 otherwise.
   */
  set(e) {
    return this.value !== e ? (this.value = e, 1) : 0;
  },
  /**
   * Indicates that operator evaluation should be skipped on the next pulse.
   * This operator will still propagate incoming pulses, but its update function
   * will not be invoked. The skip flag is reset after every pulse, so calling
   * this method will affect processing of the next pulse only.
   */
  skip: OS(uU),
  /**
   * Indicates that this operator's value has been modified on its most recent
   * pulse. Normally modification is checked via strict equality; however, in
   * some cases it is more efficient to update the internal state of an object.
   * In those cases, the modified flag can be used to trigger propagation. Once
   * set, the modification flag persists across pulses until unset. The flag can
   * be used with the last timestamp to test if a modification is recent.
   */
  modified: OS(lU),
  /**
   * Sets the parameters for this operator. The parameter values are analyzed for
   * operator instances. If found, this operator will be added as a dependency
   * of the parameterizing operator. Operator values are dynamically marshalled
   * from each operator parameter prior to evaluation. If a parameter value is
   * an array, the array will also be searched for Operator instances. However,
   * the search does not recurse into sub-arrays or object properties.
   * @param {object} params - A hash of operator parameters.
   * @param {boolean} [react=true] - A flag indicating if this operator should
   *   automatically update (react) when parameter values change. In other words,
   *   this flag determines if the operator registers itself as a listener on
   *   any upstream operators included in the parameters.
   * @param {boolean} [initonly=false] - A flag indicating if this operator
   *   should calculate an update only upon its initial evaluation, then
   *   deregister dependencies and suppress all future update invocations.
   * @return {Operator[]} - An array of upstream dependencies.
   */
  parameters(e, t, n) {
    t = t !== !1;
    const i = this._argval = this._argval || new h0(), r = this._argops = this._argops || [], a = [];
    let s, o, u, l;
    const c = (f, d, h) => {
      h instanceof Me ? (h !== this && (t && h.targets().add(this), a.push(h)), r.push({
        op: h,
        name: f,
        index: d
      })) : i.set(f, d, h);
    };
    for (s in e)
      if (o = e[s], s === sU)
        G(o).forEach((f) => {
          f instanceof Me ? f !== this && (f.targets().add(this), a.push(f)) : D("Pulse parameters must be operator instances.");
        }), this.source = o;
      else if (R(o))
        for (i.set(s, -1, Array(u = o.length)), l = 0; l < u; ++l)
          c(s, l, o[l]);
      else
        c(s, -1, o);
    return this.marshall().clear(), n && (r.initonly = !0), a;
  },
  /**
   * Internal method for marshalling parameter values.
   * Visits each operator dependency to pull the latest value.
   * @return {Parameters} A Parameters object to pass to the update function.
   */
  marshall(e) {
    const t = this._argval || oU, n = this._argops;
    let i, r, a, s;
    if (n) {
      const o = n.length;
      for (r = 0; r < o; ++r)
        i = n[r], a = i.op, s = a.modified() && a.stamp === e, t.set(i.name, i.index, a.value, s);
      if (n.initonly) {
        for (r = 0; r < o; ++r)
          i = n[r], i.op.targets().remove(this);
        this._argops = null, this._update = null;
      }
    }
    return t;
  },
  /**
   * Detach this operator from the dataflow.
   * Unregisters listeners on upstream dependencies.
   */
  detach() {
    const e = this._argops;
    let t, n, i, r;
    if (e)
      for (t = 0, n = e.length; t < n; ++t)
        i = e[t], r = i.op, r._targets && r._targets.remove(this);
    this.pulse = null, this.source = null;
  },
  /**
   * Delegate method to perform operator processing.
   * Subclasses can override this method to perform custom processing.
   * By default, it marshalls parameters and calls the update function
   * if that function is defined. If the update function does not
   * change the operator value then StopPropagation is returned.
   * If no update function is defined, this method does nothing.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return The output pulse or StopPropagation. A falsy return value
   *   (including undefined) will let the input pulse pass through.
   */
  evaluate(e) {
    const t = this._update;
    if (t) {
      const n = this.marshall(e.stamp), i = t.call(this, n, e);
      if (n.clear(), i !== this.value)
        this.value = i;
      else if (!this.modified())
        return e.StopPropagation;
    }
  },
  /**
   * Run this operator for the current pulse. If this operator has already
   * been run at (or after) the pulse timestamp, returns StopPropagation.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(e) {
    if (e.stamp < this.stamp)
      return e.StopPropagation;
    let t;
    return this.skip() ? (this.skip(!1), t = 0) : t = this.evaluate(e), this.pulse = t || e;
  }
};
function cU(e, t, n, i) {
  let r = 1, a;
  return e instanceof Me ? a = e : e && e.prototype instanceof Me ? a = new e() : oe(e) ? a = new Me(null, e) : (r = 0, a = new Me(e, t)), this.rank(a), r && (i = n, n = t), n && this.connect(a, a.parameters(n, i)), this.touch(a), a;
}
function fU(e, t) {
  const n = e.rank, i = t.length;
  for (let r = 0; r < i; ++r)
    if (n < t[r].rank) {
      this.rerank(e);
      return;
    }
}
let dU = 0;
function p0(e, t, n) {
  this.id = ++dU, this.value = null, n && (this.receive = n), e && (this._filter = e), t && (this._apply = t);
}
function pa(e, t, n) {
  return new p0(e, t, n);
}
p0.prototype = {
  _filter: jt,
  _apply: kt,
  targets() {
    return this._targets || (this._targets = f0(qf));
  },
  consume(e) {
    return arguments.length ? (this._consume = !!e, this) : !!this._consume;
  },
  receive(e) {
    if (this._filter(e)) {
      const t = this.value = this._apply(e), n = this._targets, i = n ? n.length : 0;
      for (let r = 0; r < i; ++r)
        n[r].receive(t);
      this._consume && (e.preventDefault(), e.stopPropagation());
    }
  },
  filter(e) {
    const t = pa(e);
    return this.targets().add(t), t;
  },
  apply(e) {
    const t = pa(null, e);
    return this.targets().add(t), t;
  },
  merge() {
    const e = pa();
    this.targets().add(e);
    for (let t = 0, n = arguments.length; t < n; ++t)
      arguments[t].targets().add(e);
    return e;
  },
  throttle(e) {
    let t = -1;
    return this.filter(() => {
      const n = Date.now();
      return n - t > e ? (t = n, 1) : 0;
    });
  },
  debounce(e) {
    const t = pa();
    return this.targets().add(pa(null, null, R2(e, (n) => {
      const i = n.dataflow;
      t.receive(n), i && i.run && i.run();
    }))), t;
  },
  between(e, t) {
    let n = !1;
    return e.targets().add(pa(null, null, () => n = !0)), t.targets().add(pa(null, null, () => n = !1)), this.filter(() => n);
  },
  detach() {
    this._filter = jt, this._targets = null;
  }
};
function hU(e, t, n, i) {
  const r = this, a = pa(n, i), s = function(l) {
    l.dataflow = r;
    try {
      a.receive(l);
    } catch (c) {
      r.error(c);
    } finally {
      r.run();
    }
  };
  let o;
  typeof e == "string" && typeof document < "u" ? o = document.querySelectorAll(e) : o = G(e);
  const u = o.length;
  for (let l = 0; l < u; ++l)
    o[l].addEventListener(t, s);
  return a;
}
function pU(e, t) {
  const n = this.locale();
  return S8(e, t, n.timeParse, n.utcParse);
}
function gU(e, t, n) {
  return t = this.parse(t, n), this.pulse(e, this.changeset().insert(t));
}
async function mU(e, t) {
  const n = this;
  let i = 0, r;
  try {
    r = await n.loader().load(e, {
      context: "dataflow",
      response: E8(t && t.type)
    });
    try {
      r = n.parse(r, t);
    } catch (a) {
      i = -2, n.warn("Data ingestion failed", e, a);
    }
  } catch (a) {
    i = -1, n.warn("Loading failed", e, a);
  }
  return {
    data: r,
    status: i
  };
}
async function yU(e, t, n) {
  const i = this, r = i._pending || bU(i);
  r.requests += 1;
  const a = await i.request(t, n);
  return i.pulse(e, i.changeset().remove(jt).insert(a.data || [])), r.done(), a;
}
function bU(e) {
  let t;
  const n = new Promise((i) => t = i);
  return n.requests = 0, n.done = () => {
    --n.requests === 0 && (e._pending = null, t(e));
  }, e._pending = n;
}
const vU = {
  skip: !0
};
function xU(e, t, n, i, r) {
  return (e instanceof Me ? wU : $U)(this, e, t, n, i, r), this;
}
function $U(e, t, n, i, r, a) {
  const s = ue({}, a, vU);
  let o, u;
  oe(n) || (n = Ut(n)), i === void 0 ? o = (l) => e.touch(n(l)) : oe(i) ? (u = new Me(null, i, r, !1), o = (l) => {
    u.evaluate(l);
    const c = n(l), f = u.value;
    _8(f) ? e.pulse(c, f, a) : e.update(c, f, s);
  }) : o = (l) => e.update(n(l), i, s), t.apply(o);
}
function wU(e, t, n, i, r, a) {
  if (i === void 0)
    t.targets().add(n);
  else {
    const s = a || {}, o = new Me(null, EU(n, i), r, !1);
    o.modified(s.force), o.rank = t.rank, t.targets().add(o), n && (o.skip(!0), o.value = n.value, o.targets().add(n), e.connect(n, [o]));
  }
}
function EU(e, t) {
  return t = oe(t) ? t : Ut(t), e ? function(n, i) {
    const r = t(n, i);
    return e.skip() || (e.skip(r !== this.value).value = r), r;
  } : t;
}
function SU(e) {
  e.rank = ++this._rank;
}
function AU(e) {
  const t = [e];
  let n, i, r;
  for (; t.length; )
    if (this.rank(n = t.pop()), i = n._targets)
      for (r = i.length; --r >= 0; )
        t.push(n = i[r]), n === e && D("Cycle detected in dataflow graph.");
}
const Tp = {}, Yi = 1, ba = 2, Tr = 4, kU = Yi | ba, RS = Yi | Tr, jo = Yi | ba | Tr, TS = 8, Ol = 16, DS = 32, NS = 64;
function Da(e, t, n) {
  this.dataflow = e, this.stamp = t ?? -1, this.add = [], this.rem = [], this.mod = [], this.fields = null, this.encode = n || null;
}
function k1(e, t) {
  const n = [];
  return ya(e, t, (i) => n.push(i)), n;
}
function LS(e, t) {
  const n = {};
  return e.visit(t, (i) => {
    n[ee(i)] = 1;
  }), (i) => n[ee(i)] ? null : i;
}
function Zd(e, t) {
  return e ? (n, i) => e(n, i) && t(n, i) : t;
}
Da.prototype = {
  /**
   * Sentinel value indicating pulse propagation should stop.
   */
  StopPropagation: Tp,
  /**
   * Boolean flag indicating ADD (added) tuples.
   */
  ADD: Yi,
  /**
   * Boolean flag indicating REM (removed) tuples.
   */
  REM: ba,
  /**
   * Boolean flag indicating MOD (modified) tuples.
   */
  MOD: Tr,
  /**
   * Boolean flag indicating ADD (added) and REM (removed) tuples.
   */
  ADD_REM: kU,
  /**
   * Boolean flag indicating ADD (added) and MOD (modified) tuples.
   */
  ADD_MOD: RS,
  /**
   * Boolean flag indicating ADD, REM and MOD tuples.
   */
  ALL: jo,
  /**
   * Boolean flag indicating all tuples in a data source
   * except for the ADD, REM and MOD tuples.
   */
  REFLOW: TS,
  /**
   * Boolean flag indicating a 'pass-through' to a
   * backing data source, ignoring ADD, REM and MOD tuples.
   */
  SOURCE: Ol,
  /**
   * Boolean flag indicating that source data should be
   * suppressed when creating a forked pulse.
   */
  NO_SOURCE: DS,
  /**
   * Boolean flag indicating that field modifications should be
   * suppressed when creating a forked pulse.
   */
  NO_FIELDS: NS,
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created.
   * @return {Pulse} - The forked pulse instance.
   * @see init
   */
  fork(e) {
    return new Da(this.dataflow).init(this, e);
  },
  /**
   * Creates a copy of this pulse with new materialized array
   * instances for the ADD, REM, MOD, and SOURCE arrays.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse} - The cloned pulse instance.
   * @see init
   */
  clone() {
    const e = this.fork(jo);
    return e.add = e.add.slice(), e.rem = e.rem.slice(), e.mod = e.mod.slice(), e.source && (e.source = e.source.slice()), e.materialize(jo | Ol);
  },
  /**
   * Returns a pulse that adds all tuples from a backing source. This is
   * useful for cases where operators are added to a dataflow after an
   * upstream data pipeline has already been processed, ensuring that
   * new operators can observe all tuples within a stream.
   * @return {Pulse} - A pulse instance with all source tuples included
   *   in the add array. If the current pulse already has all source
   *   tuples in its add array, it is returned directly. If the current
   *   pulse does not have a backing source, it is returned directly.
   */
  addAll() {
    let e = this;
    return !e.source || e.add === e.rem || !e.rem.length && e.source.length === e.add.length || (e = new Da(this.dataflow).init(this), e.add = e.source, e.rem = []), e;
  },
  /**
   * Initialize this pulse based on the values of another pulse. This method
   * is used internally by {@link fork} to initialize a new forked tuple.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {Pulse} src - The source pulse to copy from.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created. By default, source data arrays are copied
   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.
   * @return {Pulse} - Returns this Pulse instance.
   */
  init(e, t) {
    const n = this;
    return n.stamp = e.stamp, n.encode = e.encode, e.fields && !(t & NS) && (n.fields = e.fields), t & Yi ? (n.addF = e.addF, n.add = e.add) : (n.addF = null, n.add = []), t & ba ? (n.remF = e.remF, n.rem = e.rem) : (n.remF = null, n.rem = []), t & Tr ? (n.modF = e.modF, n.mod = e.mod) : (n.modF = null, n.mod = []), t & DS ? (n.srcF = null, n.source = null) : (n.srcF = e.srcF, n.source = e.source, e.cleans && (n.cleans = e.cleans)), n;
  },
  /**
   * Schedules a function to run after pulse propagation completes.
   * @param {function} func - The function to run.
   */
  runAfter(e) {
    this.dataflow.runAfter(e);
  },
  /**
   * Indicates if tuples have been added, removed or modified.
   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.
   *   Defaults to ALL, returning true if any tuple type has changed.
   * @return {boolean} - Returns true if one or more queried tuple types have
   *   changed, false otherwise.
   */
  changed(e) {
    const t = e || jo;
    return t & Yi && this.add.length || t & ba && this.rem.length || t & Tr && this.mod.length;
  },
  /**
   * Forces a "reflow" of tuple values, such that all tuples in the backing
   * source are added to the MOD set, unless already present in the ADD set.
   * @param {boolean} [fork=false] - If true, returns a forked copy of this
   *   pulse, and invokes reflow on that derived pulse.
   * @return {Pulse} - The reflowed pulse instance.
   */
  reflow(e) {
    if (e)
      return this.fork(jo).reflow();
    const t = this.add.length, n = this.source && this.source.length;
    return n && n !== t && (this.mod = this.source, t && this.filter(Tr, LS(this, Yi))), this;
  },
  /**
   * Get/set metadata to pulse requesting garbage collection
   * to reclaim currently unused resources.
   */
  clean(e) {
    return arguments.length ? (this.cleans = !!e, this) : this.cleans;
  },
  /**
   * Marks one or more data field names as modified to assist dependency
   * tracking and incremental processing by transform operators.
   * @param {string|Array<string>} _ - The field(s) to mark as modified.
   * @return {Pulse} - This pulse instance.
   */
  modifies(e) {
    const t = this.fields || (this.fields = {});
    return R(e) ? e.forEach((n) => t[n] = !0) : t[e] = !0, this;
  },
  /**
   * Checks if one or more data fields have been modified during this pulse
   * propagation timestamp.
   * @param {string|Array<string>} _ - The field(s) to check for modified.
   * @param {boolean} nomod - If true, will check the modified flag even if
   *   no mod tuples exist. If false (default), mod tuples must be present.
   * @return {boolean} - Returns true if any of the provided fields has been
   *   marked as modified, false otherwise.
   */
  modified(e, t) {
    const n = this.fields;
    return (t || this.mod.length) && n ? arguments.length ? R(e) ? e.some((i) => n[i]) : n[e] : !!n : !1;
  },
  /**
   * Adds a filter function to one more tuple sets. Filters are applied to
   * backing tuple arrays, to determine the actual set of tuples considered
   * added, removed or modified. They can be used to delay materialization of
   * a tuple set in order to avoid expensive array copies. In addition, the
   * filter functions can serve as value transformers: unlike standard predicate
   * function (which return boolean values), Pulse filters should return the
   * actual tuple value to process. If a tuple set is already filtered, the
   * new filter function will be appended into a conjuntive ('and') query.
   * @param {number} flags - Flags indicating the tuple set(s) to filter.
   * @param {function(*):object} filter - Filter function that will be applied
   *   to the tuple set array, and should return a data tuple if the value
   *   should be included in the tuple set, and falsy (or null) otherwise.
   * @return {Pulse} - Returns this pulse instance.
   */
  filter(e, t) {
    const n = this;
    return e & Yi && (n.addF = Zd(n.addF, t)), e & ba && (n.remF = Zd(n.remF, t)), e & Tr && (n.modF = Zd(n.modF, t)), e & Ol && (n.srcF = Zd(n.srcF, t)), n;
  },
  /**
   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have
   * a registered filter function, it will be applied and the tuple set(s) will
   * be replaced with materialized tuple arrays.
   * @param {number} flags - Flags indicating the tuple set(s) to materialize.
   * @return {Pulse} - Returns this pulse instance.
   */
  materialize(e) {
    e = e || jo;
    const t = this;
    return e & Yi && t.addF && (t.add = k1(t.add, t.addF), t.addF = null), e & ba && t.remF && (t.rem = k1(t.rem, t.remF), t.remF = null), e & Tr && t.modF && (t.mod = k1(t.mod, t.modF), t.modF = null), e & Ol && t.srcF && (t.source = t.source.filter(t.srcF), t.srcF = null), t;
  },
  /**
   * Visit one or more tuple sets in this pulse.
   * @param {number} flags - Flags indicating the tuple set(s) to visit.
   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source
   *   has been set).
   * @param {function(object):*} - Visitor function invoked per-tuple.
   * @return {Pulse} - Returns this pulse instance.
   */
  visit(e, t) {
    const n = this, i = t;
    if (e & Ol)
      return ya(n.source, n.srcF, i), n;
    e & Yi && ya(n.add, n.addF, i), e & ba && ya(n.rem, n.remF, i), e & Tr && ya(n.mod, n.modF, i);
    const r = n.source;
    if (e & TS && r) {
      const a = n.add.length + n.mod.length;
      a === r.length || (a ? ya(r, LS(n, RS), i) : ya(r, n.srcF, i));
    }
    return n;
  }
};
function ix(e, t, n, i) {
  const r = this;
  let a = 0;
  this.dataflow = e, this.stamp = t, this.fields = null, this.encode = i || null, this.pulses = n;
  for (const s of n)
    if (s.stamp === t) {
      if (s.fields) {
        const o = r.fields || (r.fields = {});
        for (const u in s.fields)
          o[u] = 1;
      }
      s.changed(r.ADD) && (a |= r.ADD), s.changed(r.REM) && (a |= r.REM), s.changed(r.MOD) && (a |= r.MOD);
    }
  this.changes = a;
}
B(ix, Da, {
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse}
   */
  fork(e) {
    const t = new Da(this.dataflow).init(this, e & this.NO_FIELDS);
    return e !== void 0 && (e & t.ADD && this.visit(t.ADD, (n) => t.add.push(n)), e & t.REM && this.visit(t.REM, (n) => t.rem.push(n)), e & t.MOD && this.visit(t.MOD, (n) => t.mod.push(n))), t;
  },
  changed(e) {
    return this.changes & e;
  },
  modified(e) {
    const t = this, n = t.fields;
    return n && t.changes & t.MOD ? R(e) ? e.some((i) => n[i]) : n[e] : 0;
  },
  filter() {
    D("MultiPulse does not support filtering.");
  },
  materialize() {
    D("MultiPulse does not support materialization.");
  },
  visit(e, t) {
    const n = this, i = n.pulses, r = i.length;
    let a = 0;
    if (e & n.SOURCE)
      for (; a < r; ++a)
        i[a].visit(e, t);
    else
      for (; a < r; ++a)
        i[a].stamp === n.stamp && i[a].visit(e, t);
    return n;
  }
});
async function CU(e, t, n) {
  const i = this, r = [];
  if (i._pulse)
    return F8(i);
  if (i._pending && await i._pending, t && await Fh(i, t), !i._touched.length)
    return i.debug("Dataflow invoked, but nothing to do."), i;
  const a = ++i._clock;
  i._pulse = new Da(i, a, e), i._touched.forEach((c) => i._enqueue(c, !0)), i._touched = f0(qf);
  let s = 0, o, u, l;
  try {
    for (; i._heap.size() > 0; ) {
      if (o = i._heap.pop(), o.rank !== o.qrank) {
        i._enqueue(o, !0);
        continue;
      }
      u = o.run(i._getPulse(o, e)), u.then ? u = await u : u.async && (r.push(u.async), u = Tp), u !== Tp && o._targets && o._targets.forEach((c) => i._enqueue(c)), ++s;
    }
  } catch (c) {
    i._heap.clear(), l = c;
  }
  if (i._input = {}, i._pulse = null, i.debug(`Pulse ${a}: ${s} operators`), l && (i._postrun = [], i.error(l)), i._postrun.length) {
    const c = i._postrun.sort((f, d) => d.priority - f.priority);
    i._postrun = [];
    for (let f = 0; f < c.length; ++f)
      await Fh(i, c[f].callback);
  }
  return n && await Fh(i, n), r.length && Promise.all(r).then((c) => i.runAsync(null, () => {
    c.forEach((f) => {
      try {
        f(i);
      } catch (d) {
        i.error(d);
      }
    });
  })), i;
}
async function _U(e, t, n) {
  for (; this._running; )
    await this._running;
  const i = () => this._running = null;
  return (this._running = this.evaluate(e, t, n)).then(i, i), this._running;
}
function FU(e, t, n) {
  return this._pulse ? F8(this) : (this.evaluate(e, t, n), this);
}
function MU(e, t, n) {
  if (this._pulse || t)
    this._postrun.push({
      priority: n || 0,
      callback: e
    });
  else
    try {
      e(this);
    } catch (i) {
      this.error(i);
    }
}
function F8(e) {
  return e.error("Dataflow already running. Use runAsync() to chain invocations."), e;
}
function OU(e, t) {
  const n = e.stamp < this._clock;
  n && (e.stamp = this._clock), (n || t) && (e.qrank = e.rank, this._heap.push(e));
}
function RU(e, t) {
  const n = e.source, i = this._clock;
  return n && R(n) ? new ix(this, i, n.map((r) => r.pulse), t) : this._input[e.id] || TU(this._pulse, n && n.pulse);
}
function TU(e, t) {
  return t && t.stamp === e.stamp ? t : (e = e.fork(), t && t !== Tp && (e.source = t.source), e);
}
const rx = {
  skip: !1,
  force: !1
};
function DU(e, t) {
  const n = t || rx;
  return this._pulse ? this._enqueue(e) : this._touched.add(e), n.skip && e.skip(!0), this;
}
function NU(e, t, n) {
  const i = n || rx;
  return (e.set(t) || i.force) && this.touch(e, i), this;
}
function LU(e, t, n) {
  this.touch(e, n || rx);
  const i = new Da(this, this._clock + (this._pulse ? 0 : 1)), r = e.pulse && e.pulse.source || [];
  return i.target = e, this._input[e.id] = t.pulse(i, r), this;
}
function PU(e) {
  let t = [];
  return {
    clear: () => t = [],
    size: () => t.length,
    peek: () => t[0],
    push: (n) => (t.push(n), M8(t, 0, t.length - 1, e)),
    pop: () => {
      const n = t.pop();
      let i;
      return t.length ? (i = t[0], t[0] = n, zU(t, 0, e)) : i = n, i;
    }
  };
}
function M8(e, t, n, i) {
  let r, a;
  const s = e[n];
  for (; n > t; ) {
    if (a = n - 1 >> 1, r = e[a], i(s, r) < 0) {
      e[n] = r, n = a;
      continue;
    }
    break;
  }
  return e[n] = s;
}
function zU(e, t, n) {
  const i = t, r = e.length, a = e[t];
  let s = (t << 1) + 1, o;
  for (; s < r; )
    o = s + 1, o < r && n(e[s], e[o]) >= 0 && (s = o), e[t] = e[s], t = s, s = (t << 1) + 1;
  return e[t] = a, M8(e, i, t, n);
}
function uu() {
  this.logger(E2()), this.logLevel($2), this._clock = 0, this._rank = 0, this._locale = Q2();
  try {
    this._loader = sl();
  } catch {
  }
  this._touched = f0(qf), this._input = {}, this._pulse = null, this._heap = PU((e, t) => e.qrank - t.qrank), this._postrun = [];
}
function Rl(e) {
  return function() {
    return this._log[e].apply(this, arguments);
  };
}
uu.prototype = {
  /**
   * The current timestamp of this dataflow. This value reflects the
   * timestamp of the previous dataflow run. The dataflow is initialized
   * with a stamp value of 0. The initial run of the dataflow will have
   * a timestap of 1, and so on. This value will match the
   * {@link Pulse.stamp} property.
   * @return {number} - The current timestamp value.
   */
  stamp() {
    return this._clock;
  },
  /**
   * Gets or sets the loader instance to use for data file loading. A
   * loader object must provide a "load" method for loading files and a
   * "sanitize" method for checking URL/filename validity. Both methods
   * should accept a URI and options hash as arguments, and return a Promise
   * that resolves to the loaded file contents (load) or a hash containing
   * sanitized URI data with the sanitized url assigned to the "href" property
   * (sanitize).
   * @param {object} _ - The loader instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current loader instance. Otherwise returns this Dataflow instance.
   */
  loader(e) {
    return arguments.length ? (this._loader = e, this) : this._loader;
  },
  /**
   * Gets or sets the locale instance to use for formatting and parsing
   * string values. The locale object should be provided by the
   * vega-format library, and include methods such as format, timeFormat,
   * utcFormat, timeParse, and utcParse.
   * @param {object} _ - The locale instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current locale instance. Otherwise returns this Dataflow instance.
   */
  locale(e) {
    return arguments.length ? (this._locale = e, this) : this._locale;
  },
  /**
   * Get or set the logger instance used to log messages. If no arguments are
   * provided, returns the current logger instance. Otherwise, sets the logger
   * and return this Dataflow instance. Provided loggers must support the full
   * API of logger objects generated by the vega-util logger method. Note that
   * by default the log level of the new logger will be used; use the logLevel
   * method to adjust the log level as needed.
   */
  logger(e) {
    return arguments.length ? (this._log = e, this) : this._log;
  },
  /**
   * Logs an error message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit error messages.
   */
  error: Rl("error"),
  /**
   * Logs a warning message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit warning messages.
   */
  warn: Rl("warn"),
  /**
   * Logs a information message. By default, logged messages are written to
   * console output. The message will only be logged if the current log level is
   * high enough to permit information messages.
   */
  info: Rl("info"),
  /**
   * Logs a debug message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit debug messages.
   */
  debug: Rl("debug"),
  /**
   * Get or set the current log level. If an argument is provided, it
   * will be used as the new log level.
   * @param {number} [level] - Should be one of None, Warn, Info
   * @return {number} - The current log level.
   */
  logLevel: Rl("level"),
  /**
   * Empty entry threshold for garbage cleaning. Map data structures will
   * perform cleaning once the number of empty entries exceeds this value.
   */
  cleanThreshold: 1e4,
  // OPERATOR REGISTRATION
  add: cU,
  connect: fU,
  rank: SU,
  rerank: AU,
  // OPERATOR UPDATES
  pulse: LU,
  touch: DU,
  update: NU,
  changeset: ko,
  // DATA LOADING
  ingest: gU,
  parse: pU,
  preload: yU,
  request: mU,
  // EVENT HANDLING
  events: hU,
  on: xU,
  // PULSE PROPAGATION
  evaluate: CU,
  run: FU,
  runAsync: _U,
  runAfter: MU,
  _enqueue: OU,
  _getPulse: RU
};
function T(e, t) {
  Me.call(this, e, null, t);
}
B(T, Me, {
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(e) {
    if (e.stamp < this.stamp)
      return e.StopPropagation;
    let t;
    return this.skip() ? this.skip(!1) : t = this.evaluate(e), t = t || e, t.then ? t = t.then((n) => this.pulse = n) : t !== e.StopPropagation && (this.pulse = t), t;
  },
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Marshalls parameter values and then invokes {@link transform}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
       value (including undefined) will let the input pulse pass through.
  */
  evaluate(e) {
    const t = this.marshall(e.stamp), n = this.transform(t, e);
    return t.clear(), n;
  },
  /**
   * Process incoming pulses.
   * Subclasses should override this method to implement transforms.
   * @param {Parameters} _ - The operator parameter values.
   * @param {Pulse} pulse - The current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
   *   value (including undefined) will let the input pulse pass through.
   */
  transform() {
  }
});
const $u = {};
function O8(e) {
  const t = R8(e);
  return t && t.Definition || null;
}
function R8(e) {
  return e = e && e.toLowerCase(), Y($u, e) ? $u[e] : null;
}
function* T8(e, t) {
  if (t == null)
    for (let n of e)
      n != null && n !== "" && (n = +n) >= n && (yield n);
  else {
    let n = -1;
    for (let i of e)
      i = t(i, ++n, e), i != null && i !== "" && (i = +i) >= i && (yield i);
  }
}
function ax(e, t, n) {
  const i = Float64Array.from(T8(e, n));
  return i.sort(Ic), t.map((r) => Tk(i, r));
}
function sx(e, t) {
  return ax(e, [0.25, 0.5, 0.75], t);
}
function ox(e, t) {
  const n = e.length, i = nP(e, t), r = sx(e, t), a = (r[2] - r[0]) / 1.34;
  return 1.06 * (Math.min(i, a) || i || Math.abs(r[0]) || 1) * Math.pow(n, -0.2);
}
function D8(e) {
  const t = e.maxbins || 20, n = e.base || 10, i = Math.log(n), r = e.divide || [5, 2];
  let a = e.extent[0], s = e.extent[1], o, u, l, c, f, d;
  const h = e.span || s - a || Math.abs(a) || 1;
  if (e.step)
    o = e.step;
  else if (e.steps) {
    for (c = h / t, f = 0, d = e.steps.length; f < d && e.steps[f] < c; ++f)
      ;
    o = e.steps[Math.max(0, f - 1)];
  } else {
    for (u = Math.ceil(Math.log(t) / i), l = e.minstep || 0, o = Math.max(l, Math.pow(n, Math.round(Math.log(h) / i) - u)); Math.ceil(h / o) > t; )
      o *= n;
    for (f = 0, d = r.length; f < d; ++f)
      c = o / r[f], c >= l && h / c <= t && (o = c);
  }
  c = Math.log(o);
  const p = c >= 0 ? 0 : ~~(-c / i) + 1, g = Math.pow(n, -p - 1);
  return (e.nice || e.nice === void 0) && (c = Math.floor(a / o + g) * o, a = a < c ? c - o : c, s = Math.ceil(s / o) * o), {
    start: a,
    stop: s === a ? a + o : s,
    step: o
  };
}
var Pn = Math.random;
function IU(e) {
  Pn = e;
}
function N8(e, t, n, i) {
  if (!e.length)
    return [void 0, void 0];
  const r = Float64Array.from(T8(e, i)), a = r.length, s = t;
  let o, u, l, c;
  for (l = 0, c = Array(s); l < s; ++l) {
    for (o = 0, u = 0; u < a; ++u)
      o += r[~~(Pn() * a)];
    c[l] = o / a;
  }
  return c.sort(Ic), [Ny(c, n / 2), Ny(c, 1 - n / 2)];
}
function L8(e, t, n, i) {
  i = i || ((d) => d);
  const r = e.length, a = new Float64Array(r);
  let s = 0, o = 1, u = i(e[0]), l = u, c = u + t, f;
  for (; o < r; ++o) {
    if (f = i(e[o]), f >= c) {
      for (l = (u + l) / 2; s < o; ++s)
        a[s] = l;
      c = f + t, u = f;
    }
    l = f;
  }
  for (l = (u + l) / 2; s < o; ++s)
    a[s] = l;
  return n ? BU(a, t + t / 4) : a;
}
function BU(e, t) {
  const n = e.length;
  let i = 0, r = 1, a, s;
  for (; e[i] === e[r]; )
    ++r;
  for (; r < n; ) {
    for (a = r + 1; e[r] === e[a]; )
      ++a;
    if (e[r] - e[r - 1] < t) {
      for (s = r + (i + a - r - r >> 1); s < r; )
        e[s++] = e[r];
      for (; s > r; )
        e[s--] = e[i];
    }
    i = r, r = a;
  }
  return e;
}
function jU(e) {
  return function() {
    return e = (1103515245 * e + 12345) % 2147483647, e / 2147483647;
  };
}
function UU(e, t) {
  t == null && (t = e, e = 0);
  let n, i, r;
  const a = {
    min(s) {
      return arguments.length ? (n = s || 0, r = i - n, a) : n;
    },
    max(s) {
      return arguments.length ? (i = s || 0, r = i - n, a) : i;
    },
    sample() {
      return n + Math.floor(r * Pn());
    },
    pdf(s) {
      return s === Math.floor(s) && s >= n && s < i ? 1 / r : 0;
    },
    cdf(s) {
      const o = Math.floor(s);
      return o < n ? 0 : o >= i ? 1 : (o - n + 1) / r;
    },
    icdf(s) {
      return s >= 0 && s <= 1 ? n - 1 + Math.floor(s * r) : NaN;
    }
  };
  return a.min(e).max(t);
}
const P8 = Math.sqrt(2 * Math.PI), qU = Math.SQRT2;
let Tl = NaN;
function Gf(e, t) {
  e = e || 0, t = t ?? 1;
  let n = 0, i = 0, r, a;
  if (Tl === Tl)
    n = Tl, Tl = NaN;
  else {
    do
      n = Pn() * 2 - 1, i = Pn() * 2 - 1, r = n * n + i * i;
    while (r === 0 || r > 1);
    a = Math.sqrt(-2 * Math.log(r) / r), n *= a, Tl = i * a;
  }
  return e + n * t;
}
function g0(e, t, n) {
  n = n ?? 1;
  const i = (e - (t || 0)) / n;
  return Math.exp(-0.5 * i * i) / (n * P8);
}
function Wf(e, t, n) {
  t = t || 0, n = n ?? 1;
  const i = (e - t) / n, r = Math.abs(i);
  let a;
  if (r > 37)
    a = 0;
  else {
    const s = Math.exp(-r * r / 2);
    let o;
    r < 7.07106781186547 ? (o = 0.0352624965998911 * r + 0.700383064443688, o = o * r + 6.37396220353165, o = o * r + 33.912866078383, o = o * r + 112.079291497871, o = o * r + 221.213596169931, o = o * r + 220.206867912376, a = s * o, o = 0.0883883476483184 * r + 1.75566716318264, o = o * r + 16.064177579207, o = o * r + 86.7807322029461, o = o * r + 296.564248779674, o = o * r + 637.333633378831, o = o * r + 793.826512519948, o = o * r + 440.413735824752, a = a / o) : (o = r + 0.65, o = r + 4 / o, o = r + 3 / o, o = r + 2 / o, o = r + 1 / o, a = s / o / 2.506628274631);
  }
  return i > 0 ? 1 - a : a;
}
function Hf(e, t, n) {
  return e < 0 || e > 1 ? NaN : (t || 0) + (n ?? 1) * qU * GU(2 * e - 1);
}
function GU(e) {
  let t = -Math.log((1 - e) * (1 + e)), n;
  return t < 6.25 ? (t -= 3.125, n = -364441206401782e-35, n = -16850591381820166e-35 + n * t, n = 128584807152564e-32 + n * t, n = 11157877678025181e-33 + n * t, n = -1333171662854621e-31 + n * t, n = 20972767875968562e-33 + n * t, n = 6637638134358324e-30 + n * t, n = -4054566272975207e-29 + n * t, n = -8151934197605472e-29 + n * t, n = 26335093153082323e-28 + n * t, n = -12975133253453532e-27 + n * t, n = -5415412054294628e-26 + n * t, n = 10512122733215323e-25 + n * t, n = -4112633980346984e-24 + n * t, n = -29070369957882005e-24 + n * t, n = 42347877827932404e-23 + n * t, n = -13654692000834679e-22 + n * t, n = -13882523362786469e-21 + n * t, n = 18673420803405714e-20 + n * t, n = -740702534166267e-18 + n * t, n = -0.006033670871430149 + n * t, n = 0.24015818242558962 + n * t, n = 1.6536545626831027 + n * t) : t < 16 ? (t = Math.sqrt(t) - 3.25, n = 22137376921775787e-25, n = 9075656193888539e-23 + n * t, n = -27517406297064545e-23 + n * t, n = 18239629214389228e-24 + n * t, n = 15027403968909828e-22 + n * t, n = -4013867526981546e-21 + n * t, n = 29234449089955446e-22 + n * t, n = 12475304481671779e-21 + n * t, n = -47318229009055734e-21 + n * t, n = 6828485145957318e-20 + n * t, n = 24031110387097894e-21 + n * t, n = -3550375203628475e-19 + n * t, n = 9532893797373805e-19 + n * t, n = -0.0016882755560235047 + n * t, n = 0.002491442096107851 + n * t, n = -0.003751208507569241 + n * t, n = 0.005370914553590064 + n * t, n = 1.0052589676941592 + n * t, n = 3.0838856104922208 + n * t) : Number.isFinite(t) ? (t = Math.sqrt(t) - 5, n = -27109920616438573e-27, n = -2555641816996525e-25 + n * t, n = 15076572693500548e-25 + n * t, n = -3789465440126737e-24 + n * t, n = 761570120807834e-23 + n * t, n = -1496002662714924e-23 + n * t, n = 2914795345090108e-23 + n * t, n = -6771199775845234e-23 + n * t, n = 22900482228026655e-23 + n * t, n = -99298272942317e-20 + n * t, n = 4526062597223154e-21 + n * t, n = -1968177810553167e-20 + n * t, n = 7599527703001776e-20 + n * t, n = -21503011930044477e-20 + n * t, n = -13871931833623122e-20 + n * t, n = 1.0103004648645344 + n * t, n = 4.849906401408584 + n * t) : n = 1 / 0, n * e;
}
function ux(e, t) {
  let n, i;
  const r = {
    mean(a) {
      return arguments.length ? (n = a || 0, r) : n;
    },
    stdev(a) {
      return arguments.length ? (i = a ?? 1, r) : i;
    },
    sample: () => Gf(n, i),
    pdf: (a) => g0(a, n, i),
    cdf: (a) => Wf(a, n, i),
    icdf: (a) => Hf(a, n, i)
  };
  return r.mean(e).stdev(t);
}
function lx(e, t) {
  const n = ux();
  let i = 0;
  const r = {
    data(a) {
      return arguments.length ? (e = a, i = a ? a.length : 0, r.bandwidth(t)) : e;
    },
    bandwidth(a) {
      return arguments.length ? (t = a, !t && e && (t = ox(e)), r) : t;
    },
    sample() {
      return e[~~(Pn() * i)] + t * n.sample();
    },
    pdf(a) {
      let s = 0, o = 0;
      for (; o < i; ++o)
        s += n.pdf((a - e[o]) / t);
      return s / t / i;
    },
    cdf(a) {
      let s = 0, o = 0;
      for (; o < i; ++o)
        s += n.cdf((a - e[o]) / t);
      return s / i;
    },
    icdf() {
      throw Error("KDE icdf not supported.");
    }
  };
  return r.data(e);
}
function m0(e, t) {
  return e = e || 0, t = t ?? 1, Math.exp(e + Gf() * t);
}
function y0(e, t, n) {
  if (e <= 0)
    return 0;
  t = t || 0, n = n ?? 1;
  const i = (Math.log(e) - t) / n;
  return Math.exp(-0.5 * i * i) / (n * P8 * e);
}
function b0(e, t, n) {
  return Wf(Math.log(e), t, n);
}
function v0(e, t, n) {
  return Math.exp(Hf(e, t, n));
}
function z8(e, t) {
  let n, i;
  const r = {
    mean(a) {
      return arguments.length ? (n = a || 0, r) : n;
    },
    stdev(a) {
      return arguments.length ? (i = a ?? 1, r) : i;
    },
    sample: () => m0(n, i),
    pdf: (a) => y0(a, n, i),
    cdf: (a) => b0(a, n, i),
    icdf: (a) => v0(a, n, i)
  };
  return r.mean(e).stdev(t);
}
function I8(e, t) {
  let n = 0, i;
  function r(s) {
    const o = [];
    let u = 0, l;
    for (l = 0; l < n; ++l)
      u += o[l] = s[l] == null ? 1 : +s[l];
    for (l = 0; l < n; ++l)
      o[l] /= u;
    return o;
  }
  const a = {
    weights(s) {
      return arguments.length ? (i = r(t = s || []), a) : t;
    },
    distributions(s) {
      return arguments.length ? (s ? (n = s.length, e = s) : (n = 0, e = []), a.weights(t)) : e;
    },
    sample() {
      const s = Pn();
      let o = e[n - 1], u = i[0], l = 0;
      for (; l < n - 1; u += i[++l])
        if (s < u) {
          o = e[l];
          break;
        }
      return o.sample();
    },
    pdf(s) {
      let o = 0, u = 0;
      for (; u < n; ++u)
        o += i[u] * e[u].pdf(s);
      return o;
    },
    cdf(s) {
      let o = 0, u = 0;
      for (; u < n; ++u)
        o += i[u] * e[u].cdf(s);
      return o;
    },
    icdf() {
      throw Error("Mixture icdf not supported.");
    }
  };
  return a.distributions(e).weights(t);
}
function x0(e, t) {
  return t == null && (t = e ?? 1, e = 0), e + (t - e) * Pn();
}
function $0(e, t, n) {
  return n == null && (n = t ?? 1, t = 0), e >= t && e <= n ? 1 / (n - t) : 0;
}
function w0(e, t, n) {
  return n == null && (n = t ?? 1, t = 0), e < t ? 0 : e > n ? 1 : (e - t) / (n - t);
}
function E0(e, t, n) {
  return n == null && (n = t ?? 1, t = 0), e >= 0 && e <= 1 ? t + e * (n - t) : NaN;
}
function B8(e, t) {
  let n, i;
  const r = {
    min(a) {
      return arguments.length ? (n = a || 0, r) : n;
    },
    max(a) {
      return arguments.length ? (i = a ?? 1, r) : i;
    },
    sample: () => x0(n, i),
    pdf: (a) => $0(a, n, i),
    cdf: (a) => w0(a, n, i),
    icdf: (a) => E0(a, n, i)
  };
  return t == null && (t = e ?? 1, e = 0), r.min(e).max(t);
}
function cx(e, t, n) {
  let i = 0, r = 0;
  for (const a of e) {
    const s = n(a);
    t(a) == null || s == null || isNaN(s) || (i += (s - i) / ++r);
  }
  return {
    coef: [i],
    predict: () => i,
    rSquared: 0
  };
}
function Vf(e, t, n, i) {
  const r = i - e * e, a = Math.abs(r) < 1e-24 ? 0 : (n - e * t) / r;
  return [t - a * e, a];
}
function S0(e, t, n, i) {
  e = e.filter((h) => {
    let p = t(h), g = n(h);
    return p != null && (p = +p) >= p && g != null && (g = +g) >= g;
  }), i && e.sort((h, p) => t(h) - t(p));
  const r = e.length, a = new Float64Array(r), s = new Float64Array(r);
  let o = 0, u = 0, l = 0, c, f, d;
  for (d of e)
    a[o] = c = +t(d), s[o] = f = +n(d), ++o, u += (c - u) / o, l += (f - l) / o;
  for (o = 0; o < r; ++o)
    a[o] -= u, s[o] -= l;
  return [a, s, u, l];
}
function Xf(e, t, n, i) {
  let r = -1, a, s;
  for (const o of e)
    a = t(o), s = n(o), a != null && (a = +a) >= a && s != null && (s = +s) >= s && i(a, s, ++r);
}
function ul(e, t, n, i, r) {
  let a = 0, s = 0;
  return Xf(e, t, n, (o, u) => {
    const l = u - r(o), c = u - i;
    a += l * l, s += c * c;
  }), 1 - a / s;
}
function fx(e, t, n) {
  let i = 0, r = 0, a = 0, s = 0, o = 0;
  Xf(e, t, n, (c, f) => {
    ++o, i += (c - i) / o, r += (f - r) / o, a += (c * f - a) / o, s += (c * c - s) / o;
  });
  const u = Vf(i, r, a, s), l = (c) => u[0] + u[1] * c;
  return {
    coef: u,
    predict: l,
    rSquared: ul(e, t, n, r, l)
  };
}
function j8(e, t, n) {
  let i = 0, r = 0, a = 0, s = 0, o = 0;
  Xf(e, t, n, (c, f) => {
    ++o, c = Math.log(c), i += (c - i) / o, r += (f - r) / o, a += (c * f - a) / o, s += (c * c - s) / o;
  });
  const u = Vf(i, r, a, s), l = (c) => u[0] + u[1] * Math.log(c);
  return {
    coef: u,
    predict: l,
    rSquared: ul(e, t, n, r, l)
  };
}
function U8(e, t, n) {
  const [i, r, a, s] = S0(e, t, n);
  let o = 0, u = 0, l = 0, c = 0, f = 0, d, h, p;
  Xf(e, t, n, (b, v) => {
    d = i[f++], h = Math.log(v), p = d * v, o += (v * h - o) / f, u += (p - u) / f, l += (p * h - l) / f, c += (d * p - c) / f;
  });
  const [g, m] = Vf(u / s, o / s, l / s, c / s), y = (b) => Math.exp(g + m * (b - a));
  return {
    coef: [Math.exp(g - m * a), m],
    predict: y,
    rSquared: ul(e, t, n, s, y)
  };
}
function q8(e, t, n) {
  let i = 0, r = 0, a = 0, s = 0, o = 0, u = 0;
  Xf(e, t, n, (f, d) => {
    const h = Math.log(f), p = Math.log(d);
    ++u, i += (h - i) / u, r += (p - r) / u, a += (h * p - a) / u, s += (h * h - s) / u, o += (d - o) / u;
  });
  const l = Vf(i, r, a, s), c = (f) => l[0] * Math.pow(f, l[1]);
  return l[0] = Math.exp(l[0]), {
    coef: l,
    predict: c,
    rSquared: ul(e, t, n, o, c)
  };
}
function dx(e, t, n) {
  const [i, r, a, s] = S0(e, t, n), o = i.length;
  let u = 0, l = 0, c = 0, f = 0, d = 0, h, p, g, m;
  for (h = 0; h < o; )
    p = i[h], g = r[h++], m = p * p, u += (m - u) / h, l += (m * p - l) / h, c += (m * m - c) / h, f += (p * g - f) / h, d += (m * g - d) / h;
  const y = c - u * u, b = u * y - l * l, v = (d * u - f * l) / b, x = (f * y - d * l) / b, w = -v * u, E = ($) => ($ = $ - a, v * $ * $ + x * $ + w + s);
  return {
    coef: [w - x * a + v * a * a + s, x - 2 * v * a, v],
    predict: E,
    rSquared: ul(e, t, n, s, E)
  };
}
function G8(e, t, n, i) {
  if (i === 0)
    return cx(e, t, n);
  if (i === 1)
    return fx(e, t, n);
  if (i === 2)
    return dx(e, t, n);
  const [r, a, s, o] = S0(e, t, n), u = r.length, l = [], c = [], f = i + 1;
  let d, h, p, g, m;
  for (d = 0; d < f; ++d) {
    for (p = 0, g = 0; p < u; ++p)
      g += Math.pow(r[p], d) * a[p];
    for (l.push(g), m = new Float64Array(f), h = 0; h < f; ++h) {
      for (p = 0, g = 0; p < u; ++p)
        g += Math.pow(r[p], d + h);
      m[h] = g;
    }
    c.push(m);
  }
  c.push(l);
  const y = HU(c), b = (v) => {
    v -= s;
    let x = o + y[0] + y[1] * v + y[2] * v * v;
    for (d = 3; d < f; ++d)
      x += y[d] * Math.pow(v, d);
    return x;
  };
  return {
    coef: WU(f, y, -s, o),
    predict: b,
    rSquared: ul(e, t, n, o, b)
  };
}
function WU(e, t, n, i) {
  const r = Array(e);
  let a, s, o, u;
  for (a = 0; a < e; ++a)
    r[a] = 0;
  for (a = e - 1; a >= 0; --a)
    for (o = t[a], u = 1, r[a] += o, s = 1; s <= a; ++s)
      u *= (a + 1 - s) / s, r[a - s] += o * Math.pow(n, s) * u;
  return r[0] += i, r;
}
function HU(e) {
  const t = e.length - 1, n = [];
  let i, r, a, s, o;
  for (i = 0; i < t; ++i) {
    for (s = i, r = i + 1; r < t; ++r)
      Math.abs(e[i][r]) > Math.abs(e[i][s]) && (s = r);
    for (a = i; a < t + 1; ++a)
      o = e[a][i], e[a][i] = e[a][s], e[a][s] = o;
    for (r = i + 1; r < t; ++r)
      for (a = t; a >= i; a--)
        e[a][r] -= e[a][i] * e[i][r] / e[i][i];
  }
  for (r = t - 1; r >= 0; --r) {
    for (o = 0, a = r + 1; a < t; ++a)
      o += e[a][r] * n[a];
    n[r] = (e[t][r] - o) / e[r][r];
  }
  return n;
}
const PS = 2, zS = 1e-12;
function W8(e, t, n, i) {
  const [r, a, s, o] = S0(e, t, n, !0), u = r.length, l = Math.max(2, ~~(i * u)), c = new Float64Array(u), f = new Float64Array(u), d = new Float64Array(u).fill(1);
  for (let h = -1; ++h <= PS; ) {
    const p = [0, l - 1];
    for (let m = 0; m < u; ++m) {
      const y = r[m], b = p[0], v = p[1], x = y - r[b] > r[v] - y ? b : v;
      let w = 0, E = 0, $ = 0, S = 0, A = 0;
      const k = 1 / Math.abs(r[x] - y || 1);
      for (let F = b; F <= v; ++F) {
        const M = r[F], C = a[F], O = VU(Math.abs(y - M) * k) * d[F], L = M * O;
        w += O, E += L, $ += C * O, S += C * L, A += M * L;
      }
      const [_, P] = Vf(E / w, $ / w, S / w, A / w);
      c[m] = _ + P * y, f[m] = Math.abs(a[m] - c[m]), XU(r, m + 1, p);
    }
    if (h === PS)
      break;
    const g = Dk(f);
    if (Math.abs(g) < zS)
      break;
    for (let m = 0, y, b; m < u; ++m)
      y = f[m] / (6 * g), d[m] = y >= 1 ? zS : (b = 1 - y * y) * b;
  }
  return YU(r, c, s, o);
}
function VU(e) {
  return (e = 1 - e * e * e) * e * e;
}
function XU(e, t, n) {
  const i = e[t];
  let r = n[0], a = n[1] + 1;
  if (!(a >= e.length))
    for (; t > r && e[a] - i <= i - e[r]; )
      n[0] = ++r, n[1] = a, ++a;
}
function YU(e, t, n, i) {
  const r = e.length, a = [];
  let s = 0, o = 0, u = [], l;
  for (; s < r; ++s)
    l = e[s] + n, u[0] === l ? u[1] += (t[s] - u[1]) / ++o : (o = 0, u[1] += i, u = [l, t[s]], a.push(u));
  return u[1] += i, a;
}
const KU = 0.5 * Math.PI / 180;
function A0(e, t, n, i) {
  n = n || 25, i = Math.max(n, i || 200);
  const r = (g) => [g, e(g)], a = t[0], s = t[1], o = s - a, u = o / i, l = [r(a)], c = [];
  if (n === i) {
    for (let g = 1; g < i; ++g)
      l.push(r(a + g / n * o));
    return l.push(r(s)), l;
  } else {
    c.push(r(s));
    for (let g = n; --g > 0; )
      c.push(r(a + g / n * o));
  }
  let f = l[0], d = c[c.length - 1];
  const h = 1 / o, p = JU(f[1], c);
  for (; d; ) {
    const g = r((f[0] + d[0]) / 2);
    g[0] - f[0] >= u && QU(f, g, d, h, p) > KU ? c.push(g) : (f = d, l.push(d), c.pop()), d = c[c.length - 1];
  }
  return l;
}
function JU(e, t) {
  let n = e, i = e;
  const r = t.length;
  for (let a = 0; a < r; ++a) {
    const s = t[a][1];
    s < n && (n = s), s > i && (i = s);
  }
  return 1 / (i - n);
}
function QU(e, t, n, i, r) {
  const a = Math.atan2(r * (n[1] - e[1]), i * (n[0] - e[0])), s = Math.atan2(r * (t[1] - e[1]), i * (t[0] - e[0]));
  return Math.abs(a - s);
}
function ZU(e) {
  return (t) => {
    const n = e.length;
    let i = 1, r = String(e[0](t));
    for (; i < n; ++i)
      r += "|" + e[i](t);
    return r;
  };
}
function vb(e) {
  return !e || !e.length ? function() {
    return "";
  } : e.length === 1 ? e[0] : ZU(e);
}
function H8(e, t, n) {
  return n || e + (t ? "_" + t : "");
}
const C1 = () => {
}, eq = {
  init: C1,
  add: C1,
  rem: C1,
  idx: 0
}, Vc = {
  values: {
    init: (e) => e.cell.store = !0,
    value: (e) => e.cell.data.values(),
    idx: -1
  },
  count: {
    value: (e) => e.cell.num
  },
  __count__: {
    value: (e) => e.missing + e.valid
  },
  missing: {
    value: (e) => e.missing
  },
  valid: {
    value: (e) => e.valid
  },
  sum: {
    init: (e) => e.sum = 0,
    value: (e) => e.sum,
    add: (e, t) => e.sum += +t,
    rem: (e, t) => e.sum -= t
  },
  product: {
    init: (e) => e.product = 1,
    value: (e) => e.valid ? e.product : void 0,
    add: (e, t) => e.product *= t,
    rem: (e, t) => e.product /= t
  },
  mean: {
    init: (e) => e.mean = 0,
    value: (e) => e.valid ? e.mean : void 0,
    add: (e, t) => (e.mean_d = t - e.mean, e.mean += e.mean_d / e.valid),
    rem: (e, t) => (e.mean_d = t - e.mean, e.mean -= e.valid ? e.mean_d / e.valid : e.mean)
  },
  average: {
    value: (e) => e.valid ? e.mean : void 0,
    req: ["mean"],
    idx: 1
  },
  variance: {
    init: (e) => e.dev = 0,
    value: (e) => e.valid > 1 ? e.dev / (e.valid - 1) : void 0,
    add: (e, t) => e.dev += e.mean_d * (t - e.mean),
    rem: (e, t) => e.dev -= e.mean_d * (t - e.mean),
    req: ["mean"],
    idx: 1
  },
  variancep: {
    value: (e) => e.valid > 1 ? e.dev / e.valid : void 0,
    req: ["variance"],
    idx: 2
  },
  stdev: {
    value: (e) => e.valid > 1 ? Math.sqrt(e.dev / (e.valid - 1)) : void 0,
    req: ["variance"],
    idx: 2
  },
  stdevp: {
    value: (e) => e.valid > 1 ? Math.sqrt(e.dev / e.valid) : void 0,
    req: ["variance"],
    idx: 2
  },
  stderr: {
    value: (e) => e.valid > 1 ? Math.sqrt(e.dev / (e.valid * (e.valid - 1))) : void 0,
    req: ["variance"],
    idx: 2
  },
  distinct: {
    value: (e) => e.cell.data.distinct(e.get),
    req: ["values"],
    idx: 3
  },
  ci0: {
    value: (e) => e.cell.data.ci0(e.get),
    req: ["values"],
    idx: 3
  },
  ci1: {
    value: (e) => e.cell.data.ci1(e.get),
    req: ["values"],
    idx: 3
  },
  median: {
    value: (e) => e.cell.data.q2(e.get),
    req: ["values"],
    idx: 3
  },
  q1: {
    value: (e) => e.cell.data.q1(e.get),
    req: ["values"],
    idx: 3
  },
  q3: {
    value: (e) => e.cell.data.q3(e.get),
    req: ["values"],
    idx: 3
  },
  min: {
    init: (e) => e.min = void 0,
    value: (e) => e.min = Number.isNaN(e.min) ? e.cell.data.min(e.get) : e.min,
    add: (e, t) => {
      (t < e.min || e.min === void 0) && (e.min = t);
    },
    rem: (e, t) => {
      t <= e.min && (e.min = NaN);
    },
    req: ["values"],
    idx: 4
  },
  max: {
    init: (e) => e.max = void 0,
    value: (e) => e.max = Number.isNaN(e.max) ? e.cell.data.max(e.get) : e.max,
    add: (e, t) => {
      (t > e.max || e.max === void 0) && (e.max = t);
    },
    rem: (e, t) => {
      t >= e.max && (e.max = NaN);
    },
    req: ["values"],
    idx: 4
  },
  argmin: {
    init: (e) => e.argmin = void 0,
    value: (e) => e.argmin || e.cell.data.argmin(e.get),
    add: (e, t, n) => {
      t < e.min && (e.argmin = n);
    },
    rem: (e, t) => {
      t <= e.min && (e.argmin = void 0);
    },
    req: ["min", "values"],
    idx: 3
  },
  argmax: {
    init: (e) => e.argmax = void 0,
    value: (e) => e.argmax || e.cell.data.argmax(e.get),
    add: (e, t, n) => {
      t > e.max && (e.argmax = n);
    },
    rem: (e, t) => {
      t >= e.max && (e.argmax = void 0);
    },
    req: ["max", "values"],
    idx: 3
  },
  exponential: {
    init: (e, t) => {
      e.exp = 0, e.exp_r = t;
    },
    value: (e) => e.valid ? e.exp * (1 - e.exp_r) / (1 - e.exp_r ** e.valid) : void 0,
    add: (e, t) => e.exp = e.exp_r * e.exp + t,
    rem: (e, t) => e.exp = (e.exp - t / e.exp_r ** (e.valid - 1)) / e.exp_r
  },
  exponentialb: {
    value: (e) => e.valid ? e.exp * (1 - e.exp_r) : void 0,
    req: ["exponential"],
    idx: 1
  }
}, Yf = Object.keys(Vc).filter((e) => e !== "__count__");
function tq(e, t) {
  return (n, i) => ue({
    name: e,
    aggregate_param: i,
    out: n || e
  }, eq, t);
}
[...Yf, "__count__"].forEach((e) => {
  Vc[e] = tq(e, Vc[e]);
});
function V8(e, t, n) {
  return Vc[e](n, t);
}
function X8(e, t) {
  return e.idx - t.idx;
}
function nq(e) {
  const t = {};
  e.forEach((i) => t[i.name] = i);
  const n = (i) => {
    i.req && i.req.forEach((r) => {
      t[r] || n(t[r] = Vc[r]());
    });
  };
  return e.forEach(n), Object.values(t).sort(X8);
}
function iq() {
  this.valid = 0, this.missing = 0, this._ops.forEach((e) => e.aggregate_param == null ? e.init(this) : e.init(this, e.aggregate_param));
}
function rq(e, t) {
  if (e == null || e === "") {
    ++this.missing;
    return;
  }
  e === e && (++this.valid, this._ops.forEach((n) => n.add(this, e, t)));
}
function aq(e, t) {
  if (e == null || e === "") {
    --this.missing;
    return;
  }
  e === e && (--this.valid, this._ops.forEach((n) => n.rem(this, e, t)));
}
function sq(e) {
  return this._out.forEach((t) => e[t.out] = t.value(this)), e;
}
function Y8(e, t) {
  const n = t || kt, i = nq(e), r = e.slice().sort(X8);
  function a(s) {
    this._ops = i, this._out = r, this.cell = s, this.init();
  }
  return a.prototype.init = iq, a.prototype.add = rq, a.prototype.rem = aq, a.prototype.set = sq, a.prototype.get = n, a.fields = e.map((s) => s.out), a;
}
function hx(e) {
  this._key = e ? At(e) : ee, this.reset();
}
const _t = hx.prototype;
_t.reset = function() {
  this._add = [], this._rem = [], this._ext = null, this._get = null, this._q = null;
};
_t.add = function(e) {
  this._add.push(e);
};
_t.rem = function(e) {
  this._rem.push(e);
};
_t.values = function() {
  if (this._get = null, this._rem.length === 0)
    return this._add;
  const e = this._add, t = this._rem, n = this._key, i = e.length, r = t.length, a = Array(i - r), s = {};
  let o, u, l;
  for (o = 0; o < r; ++o)
    s[n(t[o])] = 1;
  for (o = 0, u = 0; o < i; ++o)
    s[n(l = e[o])] ? s[n(l)] = 0 : a[u++] = l;
  return this._rem = [], this._add = a;
};
_t.distinct = function(e) {
  const t = this.values(), n = {};
  let i = t.length, r = 0, a;
  for (; --i >= 0; )
    a = e(t[i]) + "", Y(n, a) || (n[a] = 1, ++r);
  return r;
};
_t.extent = function(e) {
  if (this._get !== e || !this._ext) {
    const t = this.values(), n = Q9(t, e);
    this._ext = [t[n[0]], t[n[1]]], this._get = e;
  }
  return this._ext;
};
_t.argmin = function(e) {
  return this.extent(e)[0] || {};
};
_t.argmax = function(e) {
  return this.extent(e)[1] || {};
};
_t.min = function(e) {
  const t = this.extent(e)[0];
  return t != null ? e(t) : void 0;
};
_t.max = function(e) {
  const t = this.extent(e)[1];
  return t != null ? e(t) : void 0;
};
_t.quartile = function(e) {
  return (this._get !== e || !this._q) && (this._q = sx(this.values(), e), this._get = e), this._q;
};
_t.q1 = function(e) {
  return this.quartile(e)[0];
};
_t.q2 = function(e) {
  return this.quartile(e)[1];
};
_t.q3 = function(e) {
  return this.quartile(e)[2];
};
_t.ci = function(e) {
  return (this._get !== e || !this._ci) && (this._ci = N8(this.values(), 1e3, 0.05, e), this._get = e), this._ci;
};
_t.ci0 = function(e) {
  return this.ci(e)[0];
};
_t.ci1 = function(e) {
  return this.ci(e)[1];
};
function ja(e) {
  T.call(this, null, e), this._adds = [], this._mods = [], this._alen = 0, this._mlen = 0, this._drop = !0, this._cross = !1, this._dims = [], this._dnames = [], this._measures = [], this._countOnly = !1, this._counts = null, this._prev = null, this._inputs = null, this._outputs = null;
}
ja.Definition = {
  type: "Aggregate",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "ops",
    type: "enum",
    array: !0,
    values: Yf
  }, {
    name: "aggregate_params",
    type: "field",
    null: !0,
    array: !0,
    default: [null]
  }, {
    name: "fields",
    type: "field",
    null: !0,
    array: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }, {
    name: "drop",
    type: "boolean",
    default: !0
  }, {
    name: "cross",
    type: "boolean",
    default: !1
  }, {
    name: "key",
    type: "field"
  }]
};
B(ja, T, {
  transform(e, t) {
    const n = this, i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = e.modified();
    return n.stamp = i.stamp, n.value && (r || t.modified(n._inputs, !0)) ? (n._prev = n.value, n.value = r ? n.init(e) : /* @__PURE__ */ Object.create(null), t.visit(t.SOURCE, (a) => n.add(a))) : (n.value = n.value || n.init(e), t.visit(t.REM, (a) => n.rem(a)), t.visit(t.ADD, (a) => n.add(a))), i.modifies(n._outputs), n._drop = e.drop !== !1, e.cross && n._dims.length > 1 && (n._drop = !1, n.cross()), t.clean() && n._drop && i.clean(!0).runAfter(() => this.clean()), n.changes(i);
  },
  cross() {
    const e = this, t = e.value, n = e._dnames, i = n.map(() => ({})), r = n.length;
    function a(o) {
      let u, l, c, f;
      for (u in o)
        for (c = o[u].tuple, l = 0; l < r; ++l)
          i[l][f = c[n[l]]] = f;
    }
    a(e._prev), a(t);
    function s(o, u, l) {
      const c = n[l], f = i[l++];
      for (const d in f) {
        const h = o ? o + "|" + d : d;
        u[c] = f[d], l < r ? s(h, u, l) : t[h] || e.cell(h, u);
      }
    }
    s("", {}, 0);
  },
  init(e) {
    const t = this._inputs = [], n = this._outputs = [], i = {};
    function r(b) {
      const v = G(Pt(b)), x = v.length;
      let w = 0, E;
      for (; w < x; ++w)
        i[E = v[w]] || (i[E] = 1, t.push(E));
    }
    this._dims = G(e.groupby), this._dnames = this._dims.map((b) => {
      const v = Ve(b);
      return r(b), n.push(v), v;
    }), this.cellkey = e.key ? e.key : vb(this._dims), this._countOnly = !0, this._counts = [], this._measures = [];
    const a = e.fields || [null], s = e.ops || ["count"], o = e.aggregate_params || [null], u = e.as || [], l = a.length, c = {};
    let f, d, h, p, g, m, y;
    for (l !== s.length && D("Unmatched number of fields and aggregate ops."), y = 0; y < l; ++y) {
      if (f = a[y], d = s[y], h = o[y] || null, f == null && d !== "count" && D("Null aggregate field specified."), g = Ve(f), m = H8(d, g, u[y]), n.push(m), d === "count") {
        this._counts.push(m);
        continue;
      }
      p = c[g], p || (r(f), p = c[g] = [], p.field = f, this._measures.push(p)), d !== "count" && (this._countOnly = !1), p.push(V8(d, h, m));
    }
    return this._measures = this._measures.map((b) => Y8(b, b.field)), /* @__PURE__ */ Object.create(null);
  },
  // -- Cell Management -----
  cellkey: vb(),
  cell(e, t) {
    let n = this.value[e];
    return n ? n.num === 0 && this._drop && n.stamp < this.stamp ? (n.stamp = this.stamp, this._adds[this._alen++] = n) : n.stamp < this.stamp && (n.stamp = this.stamp, this._mods[this._mlen++] = n) : (n = this.value[e] = this.newcell(e, t), this._adds[this._alen++] = n), n;
  },
  newcell(e, t) {
    const n = {
      key: e,
      num: 0,
      agg: null,
      tuple: this.newtuple(t, this._prev && this._prev[e]),
      stamp: this.stamp,
      store: !1
    };
    if (!this._countOnly) {
      const i = this._measures, r = i.length;
      n.agg = Array(r);
      for (let a = 0; a < r; ++a)
        n.agg[a] = new i[a](n);
    }
    return n.store && (n.data = new hx()), n;
  },
  newtuple(e, t) {
    const n = this._dnames, i = this._dims, r = i.length, a = {};
    for (let s = 0; s < r; ++s)
      a[n[s]] = i[s](e);
    return t ? C8(t.tuple, a) : $e(a);
  },
  clean() {
    const e = this.value;
    for (const t in e)
      e[t].num === 0 && delete e[t];
  },
  // -- Process Tuples -----
  add(e) {
    const t = this.cellkey(e), n = this.cell(t, e);
    if (n.num += 1, this._countOnly)
      return;
    n.store && n.data.add(e);
    const i = n.agg;
    for (let r = 0, a = i.length; r < a; ++r)
      i[r].add(i[r].get(e), e);
  },
  rem(e) {
    const t = this.cellkey(e), n = this.cell(t, e);
    if (n.num -= 1, this._countOnly)
      return;
    n.store && n.data.rem(e);
    const i = n.agg;
    for (let r = 0, a = i.length; r < a; ++r)
      i[r].rem(i[r].get(e), e);
  },
  celltuple(e) {
    const t = e.tuple, n = this._counts;
    e.store && e.data.values();
    for (let i = 0, r = n.length; i < r; ++i)
      t[n[i]] = e.num;
    if (!this._countOnly) {
      const i = e.agg;
      for (let r = 0, a = i.length; r < a; ++r)
        i[r].set(t);
    }
    return t;
  },
  changes(e) {
    const t = this._adds, n = this._mods, i = this._prev, r = this._drop, a = e.add, s = e.rem, o = e.mod;
    let u, l, c, f;
    if (i)
      for (l in i)
        u = i[l], (!r || u.num) && s.push(u.tuple);
    for (c = 0, f = this._alen; c < f; ++c)
      a.push(this.celltuple(t[c])), t[c] = null;
    for (c = 0, f = this._mlen; c < f; ++c)
      u = n[c], (u.num === 0 && r ? s : o).push(this.celltuple(u)), n[c] = null;
    return this._alen = this._mlen = 0, this._prev = null, e;
  }
});
const oq = 1e-14;
function px(e) {
  T.call(this, null, e);
}
px.Definition = {
  type: "Bin",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "interval",
    type: "boolean",
    default: !0
  }, {
    name: "anchor",
    type: "number"
  }, {
    name: "maxbins",
    type: "number",
    default: 20
  }, {
    name: "base",
    type: "number",
    default: 10
  }, {
    name: "divide",
    type: "number",
    array: !0,
    default: [5, 2]
  }, {
    name: "extent",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "span",
    type: "number"
  }, {
    name: "step",
    type: "number"
  }, {
    name: "steps",
    type: "number",
    array: !0
  }, {
    name: "minstep",
    type: "number",
    default: 0
  }, {
    name: "nice",
    type: "boolean",
    default: !0
  }, {
    name: "name",
    type: "string"
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["bin0", "bin1"]
  }]
};
B(px, T, {
  transform(e, t) {
    const n = e.interval !== !1, i = this._bins(e), r = i.start, a = i.step, s = e.as || ["bin0", "bin1"], o = s[0], u = s[1];
    let l;
    return e.modified() ? (t = t.reflow(!0), l = t.SOURCE) : l = t.modified(Pt(e.field)) ? t.ADD_MOD : t.ADD, t.visit(l, n ? (c) => {
      const f = i(c);
      c[o] = f, c[u] = f == null ? null : r + a * (1 + (f - r) / a);
    } : (c) => c[o] = i(c)), t.modifies(n ? s : o);
  },
  _bins(e) {
    if (this.value && !e.modified())
      return this.value;
    const t = e.field, n = D8(e), i = n.step;
    let r = n.start, a = r + Math.ceil((n.stop - r) / i) * i, s, o;
    (s = e.anchor) != null && (o = s - (r + i * Math.floor((s - r) / i)), r += o, a += o);
    const u = function(l) {
      let c = Fe(t(l));
      return c == null ? null : c < r ? -1 / 0 : c > a ? 1 / 0 : (c = Math.max(r, Math.min(c, a - i)), r + i * Math.floor(oq + (c - r) / i));
    };
    return u.start = r, u.stop = n.stop, u.step = i, this.value = An(u, Pt(t), e.name || "bin_" + Ve(t));
  }
});
function K8(e, t, n) {
  const i = e;
  let r = t || [], a = n || [], s = {}, o = 0;
  return {
    add: (u) => a.push(u),
    remove: (u) => s[i(u)] = ++o,
    size: () => r.length,
    data: (u, l) => (o && (r = r.filter((c) => !s[i(c)]), s = {}, o = 0), l && u && r.sort(u), a.length && (r = u ? e8(u, r, a.sort(u)) : r.concat(a), a = []), r)
  };
}
function gx(e) {
  T.call(this, [], e);
}
gx.Definition = {
  type: "Collect",
  metadata: {
    source: !0
  },
  params: [{
    name: "sort",
    type: "compare"
  }]
};
B(gx, T, {
  transform(e, t) {
    const n = t.fork(t.ALL), i = K8(ee, this.value, n.materialize(n.ADD).add), r = e.sort, a = t.changed() || r && (e.modified("sort") || t.modified(r.fields));
    return n.visit(n.REM, i.remove), this.modified(a), this.value = n.source = i.data(Ao(r), a), t.source && t.source.root && (this.value.root = t.source.root), n;
  }
});
function J8(e) {
  Me.call(this, null, uq, e);
}
B(J8, Me);
function uq(e) {
  return this.value && !e.modified() ? this.value : O2(e.fields, e.orders);
}
function mx(e) {
  T.call(this, null, e);
}
mx.Definition = {
  type: "CountPattern",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "case",
    type: "enum",
    values: ["upper", "lower", "mixed"],
    default: "mixed"
  }, {
    name: "pattern",
    type: "string",
    default: '[\\w"]+'
  }, {
    name: "stopwords",
    type: "string",
    default: ""
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["text", "count"]
  }]
};
function lq(e, t, n) {
  switch (t) {
    case "upper":
      e = e.toUpperCase();
      break;
    case "lower":
      e = e.toLowerCase();
      break;
  }
  return e.match(n);
}
B(mx, T, {
  transform(e, t) {
    const n = (f) => (d) => {
      for (var h = lq(o(d), e.case, a) || [], p, g = 0, m = h.length; g < m; ++g)
        s.test(p = h[g]) || f(p);
    }, i = this._parameterCheck(e, t), r = this._counts, a = this._match, s = this._stop, o = e.field, u = e.as || ["text", "count"], l = n((f) => r[f] = 1 + (r[f] || 0)), c = n((f) => r[f] -= 1);
    return i ? t.visit(t.SOURCE, l) : (t.visit(t.ADD, l), t.visit(t.REM, c)), this._finish(t, u);
  },
  _parameterCheck(e, t) {
    let n = !1;
    return (e.modified("stopwords") || !this._stop) && (this._stop = new RegExp("^" + (e.stopwords || "") + "$", "i"), n = !0), (e.modified("pattern") || !this._match) && (this._match = new RegExp(e.pattern || "[\\w']+", "g"), n = !0), (e.modified("field") || t.modified(e.field.fields)) && (n = !0), n && (this._counts = {}), n;
  },
  _finish(e, t) {
    const n = this._counts, i = this._tuples || (this._tuples = {}), r = t[0], a = t[1], s = e.fork(e.NO_SOURCE | e.NO_FIELDS);
    let o, u, l;
    for (o in n)
      u = i[o], l = n[o] || 0, !u && l ? (i[o] = u = $e({}), u[r] = o, u[a] = l, s.add.push(u)) : l === 0 ? (u && s.rem.push(u), n[o] = null, i[o] = null) : u[a] !== l && (u[a] = l, s.mod.push(u));
    return s.modifies(t);
  }
});
function yx(e) {
  T.call(this, null, e);
}
yx.Definition = {
  type: "Cross",
  metadata: {
    generates: !0
  },
  params: [{
    name: "filter",
    type: "expr"
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["a", "b"]
  }]
};
B(yx, T, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), i = e.as || ["a", "b"], r = i[0], a = i[1], s = !this.value || t.changed(t.ADD_REM) || e.modified("as") || e.modified("filter");
    let o = this.value;
    return s ? (o && (n.rem = o), o = t.materialize(t.SOURCE).source, n.add = this.value = cq(o, r, a, e.filter || jt)) : n.mod = o, n.source = this.value, n.modifies(i);
  }
});
function cq(e, t, n, i) {
  for (var r = [], a = {}, s = e.length, o = 0, u, l; o < s; ++o)
    for (a[t] = l = e[o], u = 0; u < s; ++u)
      a[n] = e[u], i(a) && (r.push($e(a)), a = {}, a[t] = l);
  return r;
}
const IS = {
  kde: lx,
  mixture: I8,
  normal: ux,
  lognormal: z8,
  uniform: B8
}, fq = "distributions", BS = "function", dq = "field";
function Q8(e, t) {
  const n = e[BS];
  Y(IS, n) || D("Unknown distribution function: " + n);
  const i = IS[n]();
  for (const r in e)
    r === dq ? i.data((e.from || t()).map(e[r])) : r === fq ? i[r](e[r].map((a) => Q8(a, t))) : typeof i[r] === BS && i[r](e[r]);
  return i;
}
function bx(e) {
  T.call(this, null, e);
}
const Z8 = [{
  key: {
    function: "normal"
  },
  params: [{
    name: "mean",
    type: "number",
    default: 0
  }, {
    name: "stdev",
    type: "number",
    default: 1
  }]
}, {
  key: {
    function: "lognormal"
  },
  params: [{
    name: "mean",
    type: "number",
    default: 0
  }, {
    name: "stdev",
    type: "number",
    default: 1
  }]
}, {
  key: {
    function: "uniform"
  },
  params: [{
    name: "min",
    type: "number",
    default: 0
  }, {
    name: "max",
    type: "number",
    default: 1
  }]
}, {
  key: {
    function: "kde"
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "from",
    type: "data"
  }, {
    name: "bandwidth",
    type: "number",
    default: 0
  }]
}], hq = {
  key: {
    function: "mixture"
  },
  params: [{
    name: "distributions",
    type: "param",
    array: !0,
    params: Z8
  }, {
    name: "weights",
    type: "number",
    array: !0
  }]
};
bx.Definition = {
  type: "Density",
  metadata: {
    generates: !0
  },
  params: [{
    name: "extent",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "steps",
    type: "number"
  }, {
    name: "minsteps",
    type: "number",
    default: 25
  }, {
    name: "maxsteps",
    type: "number",
    default: 200
  }, {
    name: "method",
    type: "string",
    default: "pdf",
    values: ["pdf", "cdf"]
  }, {
    name: "distribution",
    type: "param",
    params: Z8.concat(hq)
  }, {
    name: "as",
    type: "string",
    array: !0,
    default: ["value", "density"]
  }]
};
B(bx, T, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const i = Q8(e.distribution, pq(t)), r = e.steps || e.minsteps || 25, a = e.steps || e.maxsteps || 200;
      let s = e.method || "pdf";
      s !== "pdf" && s !== "cdf" && D("Invalid density method: " + s), !e.extent && !i.data && D("Missing density extent parameter."), s = i[s];
      const o = e.as || ["value", "density"], u = e.extent || Ci(i.data()), l = A0(s, u, r, a).map((c) => {
        const f = {};
        return f[o[0]] = c[0], f[o[1]] = c[1], $e(f);
      });
      this.value && (n.rem = this.value), this.value = n.add = n.source = l;
    }
    return n;
  }
});
function pq(e) {
  return () => e.materialize(e.SOURCE).source;
}
function eC(e, t) {
  return e ? e.map((n, i) => t[i] || Ve(n)) : null;
}
function vx(e, t, n) {
  const i = [], r = (f) => f(u);
  let a, s, o, u, l, c;
  if (t == null)
    i.push(e.map(n));
  else
    for (a = {}, s = 0, o = e.length; s < o; ++s)
      u = e[s], l = t.map(r), c = a[l], c || (a[l] = c = [], c.dims = l, i.push(c)), c.push(n(u));
  return i;
}
const tC = "bin";
function xx(e) {
  T.call(this, null, e);
}
xx.Definition = {
  type: "DotBin",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "step",
    type: "number"
  }, {
    name: "smooth",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    default: tC
  }]
};
const gq = (e, t) => il(Ci(e, t)) / 30;
B(xx, T, {
  transform(e, t) {
    if (this.value && !(e.modified() || t.changed()))
      return t;
    const n = t.materialize(t.SOURCE).source, i = vx(t.source, e.groupby, kt), r = e.smooth || !1, a = e.field, s = e.step || gq(n, a), o = Ao((p, g) => a(p) - a(g)), u = e.as || tC, l = i.length;
    let c = 1 / 0, f = -1 / 0, d = 0, h;
    for (; d < l; ++d) {
      const p = i[d].sort(o);
      h = -1;
      for (const g of L8(p, s, r, a))
        g < c && (c = g), g > f && (f = g), p[++h][u] = g;
    }
    return this.value = {
      start: c,
      stop: f,
      step: s
    }, t.reflow(!0).modifies(u);
  }
});
function nC(e) {
  Me.call(this, null, mq, e), this.modified(!0);
}
B(nC, Me);
function mq(e) {
  const t = e.expr;
  return this.value && !e.modified("expr") ? this.value : An((n) => t(n, e), Pt(t), Ve(t));
}
function $x(e) {
  T.call(this, [void 0, void 0], e);
}
$x.Definition = {
  type: "Extent",
  metadata: {},
  params: [{
    name: "field",
    type: "field",
    required: !0
  }]
};
B($x, T, {
  transform(e, t) {
    const n = this.value, i = e.field, r = t.changed() || t.modified(i.fields) || e.modified("field");
    let a = n[0], s = n[1];
    if ((r || a == null) && (a = 1 / 0, s = -1 / 0), t.visit(r ? t.SOURCE : t.ADD, (o) => {
      const u = Fe(i(o));
      u != null && (u < a && (a = u), u > s && (s = u));
    }), !Number.isFinite(a) || !Number.isFinite(s)) {
      let o = Ve(i);
      o && (o = ` for field "${o}"`), t.dataflow.warn(`Infinite extent${o}: [${a}, ${s}]`), a = s = void 0;
    }
    this.value = [a, s];
  }
});
function wx(e, t) {
  Me.call(this, e), this.parent = t, this.count = 0;
}
B(wx, Me, {
  /**
   * Routes pulses from this subflow to a target transform.
   * @param {Transform} target - A transform that receives the subflow of tuples.
   */
  connect(e) {
    return this.detachSubflow = e.detachSubflow, this.targets().add(e), e.source = this;
  },
  /**
   * Add an 'add' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being added.
   */
  add(e) {
    this.count += 1, this.value.add.push(e);
  },
  /**
   * Add a 'rem' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being removed.
   */
  rem(e) {
    this.count -= 1, this.value.rem.push(e);
  },
  /**
   * Add a 'mod' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being modified.
   */
  mod(e) {
    this.value.mod.push(e);
  },
  /**
   * Re-initialize this operator's pulse value.
   * @param {Pulse} pulse - The pulse to copy from.
   * @see Pulse.init
   */
  init(e) {
    this.value.init(e, e.NO_SOURCE);
  },
  /**
   * Evaluate this operator. This method overrides the
   * default behavior to simply return the contained pulse value.
   * @return {Pulse}
   */
  evaluate() {
    return this.value;
  }
});
function k0(e) {
  T.call(this, {}, e), this._keys = nl();
  const t = this._targets = [];
  t.active = 0, t.forEach = (n) => {
    for (let i = 0, r = t.active; i < r; ++i)
      n(t[i], i, t);
  };
}
B(k0, T, {
  activate(e) {
    this._targets[this._targets.active++] = e;
  },
  // parent argument provided by PreFacet subclass
  subflow(e, t, n, i) {
    const r = this.value;
    let a = Y(r, e) && r[e], s, o;
    return a ? a.value.stamp < n.stamp && (a.init(n), this.activate(a)) : (o = i || (o = this._group[e]) && o.tuple, s = n.dataflow, a = new wx(n.fork(n.NO_SOURCE), this), s.add(a).connect(t(s, e, o)), r[e] = a, this.activate(a)), a;
  },
  clean() {
    const e = this.value;
    let t = 0;
    for (const n in e)
      if (e[n].count === 0) {
        const i = e[n].detachSubflow;
        i && i(), delete e[n], ++t;
      }
    if (t) {
      const n = this._targets.filter((i) => i && i.count > 0);
      this.initTargets(n);
    }
  },
  initTargets(e) {
    const t = this._targets, n = t.length, i = e ? e.length : 0;
    let r = 0;
    for (; r < i; ++r)
      t[r] = e[r];
    for (; r < n && t[r] != null; ++r)
      t[r] = null;
    t.active = i;
  },
  transform(e, t) {
    const n = t.dataflow, i = e.key, r = e.subflow, a = this._keys, s = e.modified("key"), o = (u) => this.subflow(u, r, t);
    return this._group = e.group || {}, this.initTargets(), t.visit(t.REM, (u) => {
      const l = ee(u), c = a.get(l);
      c !== void 0 && (a.delete(l), o(c).rem(u));
    }), t.visit(t.ADD, (u) => {
      const l = i(u);
      a.set(ee(u), l), o(l).add(u);
    }), s || t.modified(i.fields) ? t.visit(t.MOD, (u) => {
      const l = ee(u), c = a.get(l), f = i(u);
      c === f ? o(f).mod(u) : (a.set(l, f), o(c).rem(u), o(f).add(u));
    }) : t.changed(t.MOD) && t.visit(t.MOD, (u) => {
      o(a.get(ee(u))).mod(u);
    }), s && t.visit(t.REFLOW, (u) => {
      const l = ee(u), c = a.get(l), f = i(u);
      c !== f && (a.set(l, f), o(c).rem(u), o(f).add(u));
    }), t.clean() ? n.runAfter(() => {
      this.clean(), a.clean();
    }) : a.empty > n.cleanThreshold && n.runAfter(a.clean), t;
  }
});
function iC(e) {
  Me.call(this, null, yq, e);
}
B(iC, Me);
function yq(e) {
  return this.value && !e.modified() ? this.value : R(e.name) ? G(e.name).map((t) => At(t)) : At(e.name, e.as);
}
function Ex(e) {
  T.call(this, nl(), e);
}
Ex.Definition = {
  type: "Filter",
  metadata: {
    changes: !0
  },
  params: [{
    name: "expr",
    type: "expr",
    required: !0
  }]
};
B(Ex, T, {
  transform(e, t) {
    const n = t.dataflow, i = this.value, r = t.fork(), a = r.add, s = r.rem, o = r.mod, u = e.expr;
    let l = !0;
    t.visit(t.REM, (f) => {
      const d = ee(f);
      i.has(d) ? i.delete(d) : s.push(f);
    }), t.visit(t.ADD, (f) => {
      u(f, e) ? a.push(f) : i.set(ee(f), 1);
    });
    function c(f) {
      const d = ee(f), h = u(f, e), p = i.get(d);
      h && p ? (i.delete(d), a.push(f)) : !h && !p ? (i.set(d, 1), s.push(f)) : l && h && !p && o.push(f);
    }
    return t.visit(t.MOD, c), e.modified() && (l = !1, t.visit(t.REFLOW, c)), i.empty > n.cleanThreshold && n.runAfter(i.clean), r;
  }
});
function Sx(e) {
  T.call(this, [], e);
}
Sx.Definition = {
  type: "Flatten",
  metadata: {
    generates: !0
  },
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "index",
    type: "string"
  }, {
    name: "as",
    type: "string",
    array: !0
  }]
};
B(Sx, T, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), i = e.fields, r = eC(i, e.as || []), a = e.index || null, s = r.length;
    return n.rem = this.value, t.visit(t.SOURCE, (o) => {
      const u = i.map((p) => p(o)), l = u.reduce((p, g) => Math.max(p, g.length), 0);
      let c = 0, f, d, h;
      for (; c < l; ++c) {
        for (d = nx(o), f = 0; f < s; ++f)
          d[r[f]] = (h = u[f][c]) == null ? null : h;
        a && (d[a] = c), n.add.push(d);
      }
    }), this.value = n.source = n.add, a && n.modifies(a), n.modifies(r);
  }
});
function Ax(e) {
  T.call(this, [], e);
}
Ax.Definition = {
  type: "Fold",
  metadata: {
    generates: !0
  },
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["key", "value"]
  }]
};
B(Ax, T, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), i = e.fields, r = i.map(Ve), a = e.as || ["key", "value"], s = a[0], o = a[1], u = i.length;
    return n.rem = this.value, t.visit(t.SOURCE, (l) => {
      for (let c = 0, f; c < u; ++c)
        f = nx(l), f[s] = r[c], f[o] = i[c](l), n.add.push(f);
    }), this.value = n.source = n.add, n.modifies(a);
  }
});
function kx(e) {
  T.call(this, null, e);
}
kx.Definition = {
  type: "Formula",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "expr",
    type: "expr",
    required: !0
  }, {
    name: "as",
    type: "string",
    required: !0
  }, {
    name: "initonly",
    type: "boolean"
  }]
};
B(kx, T, {
  transform(e, t) {
    const n = e.expr, i = e.as, r = e.modified(), a = e.initonly ? t.ADD : r ? t.SOURCE : t.modified(n.fields) || t.modified(i) ? t.ADD_MOD : t.ADD;
    return r && (t = t.materialize().reflow(!0)), e.initonly || t.modifies(i), t.visit(a, (s) => s[i] = n(s, e));
  }
});
function rC(e) {
  T.call(this, [], e);
}
B(rC, T, {
  transform(e, t) {
    const n = t.fork(t.ALL), i = e.generator;
    let r = this.value, a = e.size - r.length, s, o, u;
    if (a > 0) {
      for (s = []; --a >= 0; )
        s.push(u = $e(i(e))), r.push(u);
      n.add = n.add.length ? n.materialize(n.ADD).add.concat(s) : s;
    } else
      o = r.slice(0, -a), n.rem = n.rem.length ? n.materialize(n.REM).rem.concat(o) : o, r = r.slice(-a);
    return n.source = this.value = r, n;
  }
});
const eh = {
  value: "value",
  median: Dk,
  mean: aP,
  min: Ry,
  max: Ws
}, bq = [];
function Cx(e) {
  T.call(this, [], e);
}
Cx.Definition = {
  type: "Impute",
  metadata: {
    changes: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "key",
    type: "field",
    required: !0
  }, {
    name: "keyvals",
    array: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "method",
    type: "enum",
    default: "value",
    values: ["value", "mean", "median", "max", "min"]
  }, {
    name: "value",
    default: 0
  }]
};
function vq(e) {
  var t = e.method || eh.value, n;
  if (eh[t] == null)
    D("Unrecognized imputation method: " + t);
  else
    return t === eh.value ? (n = e.value !== void 0 ? e.value : 0, () => n) : eh[t];
}
function xq(e) {
  const t = e.field;
  return (n) => n ? t(n) : NaN;
}
B(Cx, T, {
  transform(e, t) {
    var n = t.fork(t.ALL), i = vq(e), r = xq(e), a = Ve(e.field), s = Ve(e.key), o = (e.groupby || []).map(Ve), u = $q(t.source, e.groupby, e.key, e.keyvals), l = [], c = this.value, f = u.domain.length, d, h, p, g, m, y, b, v, x, w;
    for (m = 0, v = u.length; m < v; ++m)
      for (d = u[m], p = d.values, h = NaN, b = 0; b < f; ++b)
        if (d[b] == null) {
          for (g = u.domain[b], w = {
            _impute: !0
          }, y = 0, x = p.length; y < x; ++y)
            w[o[y]] = p[y];
          w[s] = g, w[a] = Number.isNaN(h) ? h = i(d, r) : h, l.push($e(w));
        }
    return l.length && (n.add = n.materialize(n.ADD).add.concat(l)), c.length && (n.rem = n.materialize(n.REM).rem.concat(c)), this.value = l, n;
  }
});
function $q(e, t, n, i) {
  var r = (y) => y(m), a = [], s = i ? i.slice() : [], o = {}, u = {}, l, c, f, d, h, p, g, m;
  for (s.forEach((y, b) => o[y] = b + 1), d = 0, g = e.length; d < g; ++d)
    m = e[d], p = n(m), h = o[p] || (o[p] = s.push(p)), c = (l = t ? t.map(r) : bq) + "", (f = u[c]) || (f = u[c] = [], a.push(f), f.values = l), f[h - 1] = m;
  return a.domain = s, a;
}
function _x(e) {
  ja.call(this, e);
}
_x.Definition = {
  type: "JoinAggregate",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "fields",
    type: "field",
    null: !0,
    array: !0
  }, {
    name: "ops",
    type: "enum",
    array: !0,
    values: Yf
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }, {
    name: "key",
    type: "field"
  }]
};
B(_x, ja, {
  transform(e, t) {
    const n = this, i = e.modified();
    let r;
    return n.value && (i || t.modified(n._inputs, !0)) ? (r = n.value = i ? n.init(e) : {}, t.visit(t.SOURCE, (a) => n.add(a))) : (r = n.value = n.value || this.init(e), t.visit(t.REM, (a) => n.rem(a)), t.visit(t.ADD, (a) => n.add(a))), n.changes(), t.visit(t.SOURCE, (a) => {
      ue(a, r[n.cellkey(a)].tuple);
    }), t.reflow(i).modifies(this._outputs);
  },
  changes() {
    const e = this._adds, t = this._mods;
    let n, i;
    for (n = 0, i = this._alen; n < i; ++n)
      this.celltuple(e[n]), e[n] = null;
    for (n = 0, i = this._mlen; n < i; ++n)
      this.celltuple(t[n]), t[n] = null;
    this._alen = this._mlen = 0;
  }
});
function Fx(e) {
  T.call(this, null, e);
}
Fx.Definition = {
  type: "KDE",
  metadata: {
    generates: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "cumulative",
    type: "boolean",
    default: !1
  }, {
    name: "counts",
    type: "boolean",
    default: !1
  }, {
    name: "bandwidth",
    type: "number",
    default: 0
  }, {
    name: "extent",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "resolve",
    type: "enum",
    values: ["shared", "independent"],
    default: "independent"
  }, {
    name: "steps",
    type: "number"
  }, {
    name: "minsteps",
    type: "number",
    default: 25
  }, {
    name: "maxsteps",
    type: "number",
    default: 200
  }, {
    name: "as",
    type: "string",
    array: !0,
    default: ["value", "density"]
  }]
};
B(Fx, T, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const i = t.materialize(t.SOURCE).source, r = vx(i, e.groupby, e.field), a = (e.groupby || []).map(Ve), s = e.bandwidth, o = e.cumulative ? "cdf" : "pdf", u = e.as || ["value", "density"], l = [];
      let c = e.extent, f = e.steps || e.minsteps || 25, d = e.steps || e.maxsteps || 200;
      o !== "pdf" && o !== "cdf" && D("Invalid density method: " + o), e.resolve === "shared" && (c || (c = Ci(i, e.field)), f = d = e.steps || d), r.forEach((h) => {
        const p = lx(h, s)[o], g = e.counts ? h.length : 1, m = c || Ci(h);
        A0(p, m, f, d).forEach((y) => {
          const b = {};
          for (let v = 0; v < a.length; ++v)
            b[a[v]] = h.dims[v];
          b[u[0]] = y[0], b[u[1]] = y[1] * g, l.push($e(b));
        });
      }), this.value && (n.rem = this.value), this.value = n.add = n.source = l;
    }
    return n;
  }
});
function aC(e) {
  Me.call(this, null, wq, e);
}
B(aC, Me);
function wq(e) {
  return this.value && !e.modified() ? this.value : N2(e.fields, e.flat);
}
function sC(e) {
  T.call(this, [], e), this._pending = null;
}
B(sC, T, {
  transform(e, t) {
    const n = t.dataflow;
    return this._pending ? _1(this, t, this._pending) : Eq(e) ? t.StopPropagation : e.values ? _1(this, t, n.parse(e.values, e.format)) : e.async ? {
      async: n.request(e.url, e.format).then((r) => (this._pending = G(r.data), (a) => a.touch(this)))
    } : n.request(e.url, e.format).then((i) => _1(this, t, G(i.data)));
  }
});
function Eq(e) {
  return e.modified("async") && !(e.modified("values") || e.modified("url") || e.modified("format"));
}
function _1(e, t, n) {
  n.forEach($e);
  const i = t.fork(t.NO_FIELDS & t.NO_SOURCE);
  return i.rem = e.value, e.value = i.source = i.add = n, e._pending = null, i.rem.length && i.clean(!0), i;
}
function Mx(e) {
  T.call(this, {}, e);
}
Mx.Definition = {
  type: "Lookup",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "index",
    type: "index",
    params: [{
      name: "from",
      type: "data",
      required: !0
    }, {
      name: "key",
      type: "field",
      required: !0
    }]
  }, {
    name: "values",
    type: "field",
    array: !0
  }, {
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "as",
    type: "string",
    array: !0
  }, {
    name: "default",
    default: null
  }]
};
B(Mx, T, {
  transform(e, t) {
    const n = e.fields, i = e.index, r = e.values, a = e.default == null ? null : e.default, s = e.modified(), o = n.length;
    let u = s ? t.SOURCE : t.ADD, l = t, c = e.as, f, d, h;
    return r ? (d = r.length, o > 1 && !c && D('Multi-field lookup requires explicit "as" parameter.'), c && c.length !== o * d && D('The "as" parameter has too few output field names.'), c = c || r.map(Ve), f = function(p) {
      for (var g = 0, m = 0, y, b; g < o; ++g)
        if (b = i.get(n[g](p)), b == null)
          for (y = 0; y < d; ++y, ++m)
            p[c[m]] = a;
        else
          for (y = 0; y < d; ++y, ++m)
            p[c[m]] = r[y](b);
    }) : (c || D("Missing output field names."), f = function(p) {
      for (var g = 0, m; g < o; ++g)
        m = i.get(n[g](p)), p[c[g]] = m ?? a;
    }), s ? l = t.reflow(!0) : (h = n.some((p) => t.modified(p.fields)), u |= h ? t.MOD : 0), t.visit(u, f), l.modifies(c);
  }
});
function oC(e) {
  Me.call(this, null, Sq, e);
}
B(oC, Me);
function Sq(e) {
  if (this.value && !e.modified())
    return this.value;
  const t = e.extents, n = t.length;
  let i = 1 / 0, r = -1 / 0, a, s;
  for (a = 0; a < n; ++a)
    s = t[a], s[0] < i && (i = s[0]), s[1] > r && (r = s[1]);
  return [i, r];
}
function uC(e) {
  Me.call(this, null, Aq, e);
}
B(uC, Me);
function Aq(e) {
  return this.value && !e.modified() ? this.value : e.values.reduce((t, n) => t.concat(n), []);
}
function lC(e) {
  T.call(this, null, e);
}
B(lC, T, {
  transform(e, t) {
    return this.modified(e.modified()), this.value = e, t.fork(t.NO_SOURCE | t.NO_FIELDS);
  }
});
function Ox(e) {
  ja.call(this, e);
}
Ox.Definition = {
  type: "Pivot",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "value",
    type: "field",
    required: !0
  }, {
    name: "op",
    type: "enum",
    values: Yf,
    default: "sum"
  }, {
    name: "limit",
    type: "number",
    default: 0
  }, {
    name: "key",
    type: "field"
  }]
};
B(Ox, ja, {
  _transform: ja.prototype.transform,
  transform(e, t) {
    return this._transform(kq(e, t), t);
  }
});
function kq(e, t) {
  const n = e.field, i = e.value, r = (e.op === "count" ? "__count__" : e.op) || "sum", a = Pt(n).concat(Pt(i)), s = _q(n, e.limit || 0, t);
  return t.changed() && e.set("__pivot__", null, null, !0), {
    key: e.key,
    groupby: e.groupby,
    ops: s.map(() => r),
    fields: s.map((o) => Cq(o, n, i, a)),
    as: s.map((o) => o + ""),
    modified: e.modified.bind(e)
  };
}
function Cq(e, t, n, i) {
  return An((r) => t(r) === e ? n(r) : NaN, i, e + "");
}
function _q(e, t, n) {
  const i = {}, r = [];
  return n.visit(n.SOURCE, (a) => {
    const s = e(a);
    i[s] || (i[s] = 1, r.push(s));
  }), r.sort(s0), t ? r.slice(0, t) : r;
}
function cC(e) {
  k0.call(this, e);
}
B(cC, k0, {
  transform(e, t) {
    const n = e.subflow, i = e.field, r = (a) => this.subflow(ee(a), n, t, a);
    return (e.modified("field") || i && t.modified(Pt(i))) && D("PreFacet does not support field modification."), this.initTargets(), i ? (t.visit(t.MOD, (a) => {
      const s = r(a);
      i(a).forEach((o) => s.mod(o));
    }), t.visit(t.ADD, (a) => {
      const s = r(a);
      i(a).forEach((o) => s.add($e(o)));
    }), t.visit(t.REM, (a) => {
      const s = r(a);
      i(a).forEach((o) => s.rem(o));
    })) : (t.visit(t.MOD, (a) => r(a).mod(a)), t.visit(t.ADD, (a) => r(a).add(a)), t.visit(t.REM, (a) => r(a).rem(a))), t.clean() && t.runAfter(() => this.clean()), t;
  }
});
function Rx(e) {
  T.call(this, null, e);
}
Rx.Definition = {
  type: "Project",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "fields",
    type: "field",
    array: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }]
};
B(Rx, T, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), i = e.fields, r = eC(e.fields, e.as || []), a = i ? (o, u) => Fq(o, u, i, r) : d0;
    let s;
    return this.value ? s = this.value : (t = t.addAll(), s = this.value = {}), t.visit(t.REM, (o) => {
      const u = ee(o);
      n.rem.push(s[u]), s[u] = null;
    }), t.visit(t.ADD, (o) => {
      const u = a(o, $e({}));
      s[ee(o)] = u, n.add.push(u);
    }), t.visit(t.MOD, (o) => {
      n.mod.push(a(o, s[ee(o)]));
    }), n;
  }
});
function Fq(e, t, n, i) {
  for (let r = 0, a = n.length; r < a; ++r)
    t[i[r]] = n[r](e);
  return t;
}
function fC(e) {
  T.call(this, null, e);
}
B(fC, T, {
  transform(e, t) {
    return this.value = e.value, e.modified("value") ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation;
  }
});
function Tx(e) {
  T.call(this, null, e);
}
Tx.Definition = {
  type: "Quantile",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "probs",
    type: "number",
    array: !0
  }, {
    name: "step",
    type: "number",
    default: 0.01
  }, {
    name: "as",
    type: "string",
    array: !0,
    default: ["prob", "value"]
  }]
};
const Mq = 1e-14;
B(Tx, T, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = e.as || ["prob", "value"];
    if (this.value && !e.modified() && !t.changed())
      return n.source = this.value, n;
    const r = t.materialize(t.SOURCE).source, a = vx(r, e.groupby, e.field), s = (e.groupby || []).map(Ve), o = [], u = e.step || 0.01, l = e.probs || xt(u / 2, 1 - Mq, u), c = l.length;
    return a.forEach((f) => {
      const d = ax(f, l);
      for (let h = 0; h < c; ++h) {
        const p = {};
        for (let g = 0; g < s.length; ++g)
          p[s[g]] = f.dims[g];
        p[i[0]] = l[h], p[i[1]] = d[h], o.push($e(p));
      }
    }), this.value && (n.rem = this.value), this.value = n.add = n.source = o, n;
  }
});
function dC(e) {
  T.call(this, null, e);
}
B(dC, T, {
  transform(e, t) {
    let n, i;
    return this.value ? i = this.value : (n = t = t.addAll(), i = this.value = {}), e.derive && (n = t.fork(t.NO_SOURCE), t.visit(t.REM, (r) => {
      const a = ee(r);
      n.rem.push(i[a]), i[a] = null;
    }), t.visit(t.ADD, (r) => {
      const a = nx(r);
      i[ee(r)] = a, n.add.push(a);
    }), t.visit(t.MOD, (r) => {
      const a = i[ee(r)];
      for (const s in r)
        a[s] = r[s], n.modifies(s);
      n.mod.push(a);
    })), n;
  }
});
function Dx(e) {
  T.call(this, [], e), this.count = 0;
}
Dx.Definition = {
  type: "Sample",
  metadata: {},
  params: [{
    name: "size",
    type: "number",
    default: 1e3
  }]
};
B(Dx, T, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE), i = e.modified("size"), r = e.size, a = this.value.reduce((c, f) => (c[ee(f)] = 1, c), {});
    let s = this.value, o = this.count, u = 0;
    function l(c) {
      let f, d;
      s.length < r ? s.push(c) : (d = ~~((o + 1) * Pn()), d < s.length && d >= u && (f = s[d], a[ee(f)] && n.rem.push(f), s[d] = c)), ++o;
    }
    if (t.rem.length && (t.visit(t.REM, (c) => {
      const f = ee(c);
      a[f] && (a[f] = -1, n.rem.push(c)), --o;
    }), s = s.filter((c) => a[ee(c)] !== -1)), (t.rem.length || i) && s.length < r && t.source && (u = o = s.length, t.visit(t.SOURCE, (c) => {
      a[ee(c)] || l(c);
    }), u = -1), i && s.length > r) {
      const c = s.length - r;
      for (let f = 0; f < c; ++f)
        a[ee(s[f])] = -1, n.rem.push(s[f]);
      s = s.slice(c);
    }
    return t.mod.length && t.visit(t.MOD, (c) => {
      a[ee(c)] && n.mod.push(c);
    }), t.add.length && t.visit(t.ADD, l), (t.add.length || u < 0) && (n.add = s.filter((c) => !a[ee(c)])), this.count = o, this.value = n.source = s, n;
  }
});
function Nx(e) {
  T.call(this, null, e);
}
Nx.Definition = {
  type: "Sequence",
  metadata: {
    generates: !0,
    changes: !0
  },
  params: [{
    name: "start",
    type: "number",
    required: !0
  }, {
    name: "stop",
    type: "number",
    required: !0
  }, {
    name: "step",
    type: "number",
    default: 1
  }, {
    name: "as",
    type: "string",
    default: "data"
  }]
};
B(Nx, T, {
  transform(e, t) {
    if (this.value && !e.modified())
      return;
    const n = t.materialize().fork(t.MOD), i = e.as || "data";
    return n.rem = this.value ? t.rem.concat(this.value) : t.rem, this.value = xt(e.start, e.stop, e.step || 1).map((r) => {
      const a = {};
      return a[i] = r, $e(a);
    }), n.add = t.add.concat(this.value), n;
  }
});
function hC(e) {
  T.call(this, null, e), this.modified(!0);
}
B(hC, T, {
  transform(e, t) {
    return this.value = t.source, t.changed() ? t.fork(t.NO_SOURCE | t.NO_FIELDS) : t.StopPropagation;
  }
});
function Lx(e) {
  T.call(this, null, e);
}
const pC = ["unit0", "unit1"];
Lx.Definition = {
  type: "TimeUnit",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field",
    required: !0
  }, {
    name: "interval",
    type: "boolean",
    default: !0
  }, {
    name: "units",
    type: "enum",
    values: B2,
    array: !0
  }, {
    name: "step",
    type: "number",
    default: 1
  }, {
    name: "maxbins",
    type: "number",
    default: 40
  }, {
    name: "extent",
    type: "date",
    array: !0
  }, {
    name: "timezone",
    type: "enum",
    default: "local",
    values: ["local", "utc"]
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: pC
  }]
};
B(Lx, T, {
  transform(e, t) {
    const n = e.field, i = e.interval !== !1, r = e.timezone === "utc", a = this._floor(e, t), s = (r ? al : rl)(a.unit).offset, o = e.as || pC, u = o[0], l = o[1], c = a.step;
    let f = a.start || 1 / 0, d = a.stop || -1 / 0, h = t.ADD;
    return (e.modified() || t.changed(t.REM) || t.modified(Pt(n))) && (t = t.reflow(!0), h = t.SOURCE, f = 1 / 0, d = -1 / 0), t.visit(h, (p) => {
      const g = n(p);
      let m, y;
      g == null ? (p[u] = null, i && (p[l] = null)) : (p[u] = m = y = a(g), i && (p[l] = y = s(m, c)), m < f && (f = m), y > d && (d = y));
    }), a.start = f, a.stop = d, t.modifies(i ? o : u);
  },
  _floor(e, t) {
    const n = e.timezone === "utc", {
      units: i,
      step: r
    } = e.units ? {
      units: e.units,
      step: e.step || 1
    } : f8({
      extent: e.extent || Ci(t.materialize(t.SOURCE).source, e.field),
      maxbins: e.maxbins
    }), a = j2(i), s = this.value || {}, o = (n ? s8 : a8)(a, r);
    return o.unit = ae(a), o.units = a, o.step = r, o.start = s.start, o.stop = s.stop, this.value = o;
  }
});
function gC(e) {
  T.call(this, nl(), e);
}
B(gC, T, {
  transform(e, t) {
    const n = t.dataflow, i = e.field, r = this.value, a = (o) => r.set(i(o), o);
    let s = !0;
    return e.modified("field") || t.modified(i.fields) ? (r.clear(), t.visit(t.SOURCE, a)) : t.changed() ? (t.visit(t.REM, (o) => r.delete(i(o))), t.visit(t.ADD, a)) : s = !1, this.modified(s), r.empty > n.cleanThreshold && n.runAfter(r.clean), t.fork();
  }
});
function mC(e) {
  T.call(this, null, e);
}
B(mC, T, {
  transform(e, t) {
    (!this.value || e.modified("field") || e.modified("sort") || t.changed() || e.sort && t.modified(e.sort.fields)) && (this.value = (e.sort ? t.source.slice().sort(Ao(e.sort)) : t.source).map(e.field));
  }
});
function Oq(e, t, n, i) {
  const r = Xc[e](t, n);
  return {
    init: r.init || wa,
    update: function(a, s) {
      s[i] = r.next(a);
    }
  };
}
const Xc = {
  row_number: function() {
    return {
      next: (e) => e.index + 1
    };
  },
  rank: function() {
    let e;
    return {
      init: () => e = 1,
      next: (t) => {
        const n = t.index, i = t.data;
        return n && t.compare(i[n - 1], i[n]) ? e = n + 1 : e;
      }
    };
  },
  dense_rank: function() {
    let e;
    return {
      init: () => e = 1,
      next: (t) => {
        const n = t.index, i = t.data;
        return n && t.compare(i[n - 1], i[n]) ? ++e : e;
      }
    };
  },
  percent_rank: function() {
    const e = Xc.rank(), t = e.next;
    return {
      init: e.init,
      next: (n) => (t(n) - 1) / (n.data.length - 1)
    };
  },
  cume_dist: function() {
    let e;
    return {
      init: () => e = 0,
      next: (t) => {
        const n = t.data, i = t.compare;
        let r = t.index;
        if (e < r) {
          for (; r + 1 < n.length && !i(n[r], n[r + 1]); )
            ++r;
          e = r;
        }
        return (1 + e) / n.length;
      }
    };
  },
  ntile: function(e, t) {
    t = +t, t > 0 || D("ntile num must be greater than zero.");
    const n = Xc.cume_dist(), i = n.next;
    return {
      init: n.init,
      next: (r) => Math.ceil(t * i(r))
    };
  },
  lag: function(e, t) {
    return t = +t || 1, {
      next: (n) => {
        const i = n.index - t;
        return i >= 0 ? e(n.data[i]) : null;
      }
    };
  },
  lead: function(e, t) {
    return t = +t || 1, {
      next: (n) => {
        const i = n.index + t, r = n.data;
        return i < r.length ? e(r[i]) : null;
      }
    };
  },
  first_value: function(e) {
    return {
      next: (t) => e(t.data[t.i0])
    };
  },
  last_value: function(e) {
    return {
      next: (t) => e(t.data[t.i1 - 1])
    };
  },
  nth_value: function(e, t) {
    return t = +t, t > 0 || D("nth_value nth must be greater than zero."), {
      next: (n) => {
        const i = n.i0 + (t - 1);
        return i < n.i1 ? e(n.data[i]) : null;
      }
    };
  },
  prev_value: function(e) {
    let t;
    return {
      init: () => t = null,
      next: (n) => {
        const i = e(n.data[n.index]);
        return i != null ? t = i : t;
      }
    };
  },
  next_value: function(e) {
    let t, n;
    return {
      init: () => (t = null, n = -1),
      next: (i) => {
        const r = i.data;
        return i.index <= n ? t : (n = Rq(e, r, i.index)) < 0 ? (n = r.length, t = null) : t = e(r[n]);
      }
    };
  }
};
function Rq(e, t, n) {
  for (let i = t.length; n < i; ++n)
    if (e(t[n]) != null)
      return n;
  return -1;
}
const Tq = Object.keys(Xc);
function yC(e) {
  const t = G(e.ops), n = G(e.fields), i = G(e.params), r = G(e.aggregate_params), a = G(e.as), s = this.outputs = [], o = this.windows = [], u = {}, l = {}, c = [], f = [];
  let d = !0;
  function h(p) {
    G(Pt(p)).forEach((g) => u[g] = 1);
  }
  h(e.sort), t.forEach((p, g) => {
    const m = n[g], y = i[g], b = r[g] || null, v = Ve(m), x = H8(p, v, a[g]);
    if (h(m), s.push(x), Y(Xc, p))
      o.push(Oq(p, m, y, x));
    else {
      if (m == null && p !== "count" && D("Null aggregate field specified."), p === "count") {
        c.push(x);
        return;
      }
      d = !1;
      let w = l[v];
      w || (w = l[v] = [], w.field = m, f.push(w)), w.push(V8(p, b, x));
    }
  }), (c.length || f.length) && (this.cell = Dq(f, c, d)), this.inputs = Object.keys(u);
}
const bC = yC.prototype;
bC.init = function() {
  this.windows.forEach((e) => e.init()), this.cell && this.cell.init();
};
bC.update = function(e, t) {
  const n = this.cell, i = this.windows, r = e.data, a = i && i.length;
  let s;
  if (n) {
    for (s = e.p0; s < e.i0; ++s)
      n.rem(r[s]);
    for (s = e.p1; s < e.i1; ++s)
      n.add(r[s]);
    n.set(t);
  }
  for (s = 0; s < a; ++s)
    i[s].update(e, t);
};
function Dq(e, t, n) {
  e = e.map((u) => Y8(u, u.field));
  const i = {
    num: 0,
    agg: null,
    store: !1,
    count: t
  };
  if (!n)
    for (var r = e.length, a = i.agg = Array(r), s = 0; s < r; ++s)
      a[s] = new e[s](i);
  if (i.store)
    var o = i.data = new hx();
  return i.add = function(u) {
    if (i.num += 1, !n) {
      o && o.add(u);
      for (let l = 0; l < r; ++l)
        a[l].add(a[l].get(u), u);
    }
  }, i.rem = function(u) {
    if (i.num -= 1, !n) {
      o && o.rem(u);
      for (let l = 0; l < r; ++l)
        a[l].rem(a[l].get(u), u);
    }
  }, i.set = function(u) {
    let l, c;
    for (o && o.values(), l = 0, c = t.length; l < c; ++l)
      u[t[l]] = i.num;
    if (!n)
      for (l = 0, c = a.length; l < c; ++l)
        a[l].set(u);
  }, i.init = function() {
    i.num = 0, o && o.reset();
    for (let u = 0; u < r; ++u)
      a[u].init();
  }, i;
}
function Px(e) {
  T.call(this, {}, e), this._mlen = 0, this._mods = [];
}
Px.Definition = {
  type: "Window",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "sort",
    type: "compare"
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "ops",
    type: "enum",
    array: !0,
    values: Tq.concat(Yf)
  }, {
    name: "params",
    type: "number",
    null: !0,
    array: !0
  }, {
    name: "aggregate_params",
    type: "field",
    null: !0,
    array: !0,
    default: [null]
  }, {
    name: "fields",
    type: "field",
    null: !0,
    array: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    array: !0
  }, {
    name: "frame",
    type: "number",
    null: !0,
    array: !0,
    length: 2,
    default: [null, 0]
  }, {
    name: "ignorePeers",
    type: "boolean",
    default: !1
  }]
};
B(Px, T, {
  transform(e, t) {
    this.stamp = t.stamp;
    const n = e.modified(), i = Ao(e.sort), r = vb(e.groupby), a = (o) => this.group(r(o));
    let s = this.state;
    (!s || n) && (s = this.state = new yC(e)), n || t.modified(s.inputs) ? (this.value = {}, t.visit(t.SOURCE, (o) => a(o).add(o))) : (t.visit(t.REM, (o) => a(o).remove(o)), t.visit(t.ADD, (o) => a(o).add(o)));
    for (let o = 0, u = this._mlen; o < u; ++o)
      Nq(this._mods[o], s, i, e);
    return this._mlen = 0, this._mods = [], t.reflow(n).modifies(s.outputs);
  },
  group(e) {
    let t = this.value[e];
    return t || (t = this.value[e] = K8(ee), t.stamp = -1), t.stamp < this.stamp && (t.stamp = this.stamp, this._mods[this._mlen++] = t), t;
  }
});
function Nq(e, t, n, i) {
  const r = i.sort, a = r && !i.ignorePeers, s = i.frame || [null, 0], o = e.data(n), u = o.length, l = a ? Zv(r) : null, c = {
    i0: 0,
    i1: 0,
    p0: 0,
    p1: 0,
    index: 0,
    data: o,
    compare: r || Ut(-1)
  };
  t.init();
  for (let f = 0; f < u; ++f)
    Lq(c, s, f, u), a && Pq(c, l), t.update(c, o[f]);
}
function Lq(e, t, n, i) {
  e.p0 = e.i0, e.p1 = e.i1, e.i0 = t[0] == null ? 0 : Math.max(0, n - Math.abs(t[0])), e.i1 = t[1] == null ? i : Math.min(i, n + Math.abs(t[1]) + 1), e.index = n;
}
function Pq(e, t) {
  const n = e.i0, i = e.i1 - 1, r = e.compare, a = e.data, s = a.length - 1;
  n > 0 && !r(a[n], a[n - 1]) && (e.i0 = t.left(a, a[n])), i < s && !r(a[i], a[i + 1]) && (e.i1 = t.right(a, a[i]));
}
const zq = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aggregate: ja,
  bin: px,
  collect: gx,
  compare: J8,
  countpattern: mx,
  cross: yx,
  density: bx,
  dotbin: xx,
  expression: nC,
  extent: $x,
  facet: k0,
  field: iC,
  filter: Ex,
  flatten: Sx,
  fold: Ax,
  formula: kx,
  generate: rC,
  impute: Cx,
  joinaggregate: _x,
  kde: Fx,
  key: aC,
  load: sC,
  lookup: Mx,
  multiextent: oC,
  multivalues: uC,
  params: lC,
  pivot: Ox,
  prefacet: cC,
  project: Rx,
  proxy: fC,
  quantile: Tx,
  relay: dC,
  sample: Dx,
  sequence: Nx,
  sieve: hC,
  subflow: wx,
  timeunit: Lx,
  tupleindex: gC,
  values: mC,
  window: Px
}, Symbol.toStringTag, { value: "Module" }));
function Ei(e, t) {
  if (typeof document < "u" && document.createElement) {
    const n = document.createElement("canvas");
    if (n && n.getContext)
      return n.width = e, n.height = t, n;
  }
  return null;
}
const vC = () => typeof Image < "u" ? Image : null;
function C0(e, t, n) {
  const i = e - t + n * 2;
  return e ? i > 0 ? i : 1 : 0;
}
const Iq = "identity", wu = "linear", Yr = "log", Kf = "pow", Jf = "sqrt", _0 = "symlog", io = "time", ro = "utc", ar = "sequential", ll = "diverging", Yc = "quantile", F0 = "quantize", M0 = "threshold", zx = "ordinal", xb = "point", xC = "band", Ix = "bin-ordinal", at = "continuous", Qf = "discrete", Zf = "discretizing", ri = "interpolating", Bx = "temporal";
function Bq(e) {
  return function(t) {
    let n = t[0], i = t[1], r;
    return i < n && (r = n, n = i, i = r), [e.invert(n), e.invert(i)];
  };
}
function jq(e) {
  return function(t) {
    const n = e.range();
    let i = t[0], r = t[1], a = -1, s, o, u, l;
    for (r < i && (o = i, i = r, r = o), u = 0, l = n.length; u < l; ++u)
      n[u] >= i && n[u] <= r && (a < 0 && (a = u), s = u);
    if (!(a < 0))
      return i = e.invertExtent(n[a]), r = e.invertExtent(n[s]), [i[0] === void 0 ? i[1] : i[0], r[1] === void 0 ? r[0] : r[1]];
  };
}
function jx() {
  const e = as().unknown(void 0), t = e.domain, n = e.range;
  let i = [0, 1], r, a, s = !1, o = 0, u = 0, l = 0.5;
  delete e.unknown;
  function c() {
    const f = t().length, d = i[1] < i[0], h = i[1 - d], p = C0(f, o, u);
    let g = i[d - 0];
    r = (h - g) / (p || 1), s && (r = Math.floor(r)), g += (h - g - r * (f - o)) * l, a = r * (1 - o), s && (g = Math.round(g), a = Math.round(a));
    const m = xt(f).map((y) => g + r * y);
    return n(d ? m.reverse() : m);
  }
  return e.domain = function(f) {
    return arguments.length ? (t(f), c()) : t();
  }, e.range = function(f) {
    return arguments.length ? (i = [+f[0], +f[1]], c()) : i.slice();
  }, e.rangeRound = function(f) {
    return i = [+f[0], +f[1]], s = !0, c();
  }, e.bandwidth = function() {
    return a;
  }, e.step = function() {
    return r;
  }, e.round = function(f) {
    return arguments.length ? (s = !!f, c()) : s;
  }, e.padding = function(f) {
    return arguments.length ? (u = Math.max(0, Math.min(1, f)), o = u, c()) : o;
  }, e.paddingInner = function(f) {
    return arguments.length ? (o = Math.max(0, Math.min(1, f)), c()) : o;
  }, e.paddingOuter = function(f) {
    return arguments.length ? (u = Math.max(0, Math.min(1, f)), c()) : u;
  }, e.align = function(f) {
    return arguments.length ? (l = Math.max(0, Math.min(1, f)), c()) : l;
  }, e.invertRange = function(f) {
    if (f[0] == null || f[1] == null)
      return;
    const d = i[1] < i[0], h = d ? n().reverse() : n(), p = h.length - 1;
    let g = +f[0], m = +f[1], y, b, v;
    if (!(g !== g || m !== m) && (m < g && (v = g, g = m, m = v), !(m < h[0] || g > i[1 - d])))
      return y = Math.max(0, Vr(h, g) - 1), b = g === m ? y : Vr(h, m) - 1, g - h[y] > a + 1e-10 && ++y, d && (v = y, y = p - b, b = p - v), y > b ? void 0 : t().slice(y, b + 1);
  }, e.invert = function(f) {
    const d = e.invertRange([f, f]);
    return d && d[0];
  }, e.copy = function() {
    return jx().domain(t()).range(i).round(s).paddingInner(o).paddingOuter(u).align(l);
  }, c();
}
function $C(e) {
  const t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, e.copy = function() {
    return $C(t());
  }, e;
}
function Uq() {
  return $C(jx().paddingInner(1));
}
var qq = Array.prototype.map;
function Gq(e) {
  return qq.call(e, Fe);
}
const Wq = Array.prototype.slice;
function wC() {
  let e = [], t = [];
  function n(i) {
    return i == null || i !== i ? void 0 : t[(Eo(e, i) - 1) % t.length];
  }
  return n.domain = function(i) {
    return arguments.length ? (e = Gq(i), n) : e.slice();
  }, n.range = function(i) {
    return arguments.length ? (t = Wq.call(i), n) : t.slice();
  }, n.tickFormat = function(i, r) {
    return Bg(e[0], ae(e), i ?? 10, r);
  }, n.copy = function() {
    return wC().domain(n.domain()).range(n.range());
  }, n;
}
const Dp = /* @__PURE__ */ new Map(), EC = Symbol("vega_scale");
function SC(e) {
  return e[EC] = !0, e;
}
function AC(e) {
  return e && e[EC] === !0;
}
function Hq(e, t, n) {
  const i = function() {
    const a = t();
    return a.invertRange || (a.invertRange = a.invert ? Bq(a) : a.invertExtent ? jq(a) : void 0), a.type = e, SC(a);
  };
  return i.metadata = an(G(n)), i;
}
function be(e, t, n) {
  return arguments.length > 1 ? (Dp.set(e, Hq(e, t, n)), this) : Vq(e) ? Dp.get(e) : void 0;
}
be(Iq, Rf);
be(wu, Ig, at);
be(Yr, Tf, [at, Yr]);
be(Kf, Ku, at);
be(Jf, Vg, at);
be(_0, Df, at);
be(io, Pg, [at, Bx]);
be(ro, Xg, [at, Bx]);
be(ar, Qr, [at, ri]);
be(`${ar}-${wu}`, Qr, [at, ri]);
be(`${ar}-${Yr}`, zf, [at, ri, Yr]);
be(`${ar}-${Kf}`, Ju, [at, ri]);
be(`${ar}-${Jf}`, Kg, [at, ri]);
be(`${ar}-${_0}`, If, [at, ri]);
be(`${ll}-${wu}`, Bf, [at, ri]);
be(`${ll}-${Yr}`, jf, [at, ri, Yr]);
be(`${ll}-${Kf}`, Qu, [at, ri]);
be(`${ll}-${Jf}`, Qg, [at, ri]);
be(`${ll}-${_0}`, Uf, [at, ri]);
be(Yc, Nf, [Zf, Yc]);
be(F0, Lf, Zf);
be(M0, Pf, Zf);
be(Ix, wC, [Qf, Zf]);
be(zx, as, Qf);
be(xC, jx, Qf);
be(xb, Uq, Qf);
function Vq(e) {
  return Dp.has(e);
}
function cl(e, t) {
  const n = Dp.get(e);
  return n && n.metadata[t];
}
function kC(e) {
  return cl(e, at);
}
function CC(e) {
  return cl(e, Qf);
}
function Xq(e) {
  return cl(e, Zf);
}
function _C(e) {
  return cl(e, Yr);
}
function Yq(e) {
  return cl(e, Bx);
}
function FC(e) {
  return cl(e, ri);
}
const Kq = ["clamp", "base", "constant", "exponent"];
function Jq(e, t) {
  const n = t[0], i = ae(t) - n;
  return function(r) {
    return e(n + r * i);
  };
}
function Ux(e, t, n) {
  return Xu(MC(t || "rgb", n), e);
}
function Qq(e, t) {
  const n = new Array(t), i = t + 1;
  for (let r = 0; r < t; )
    n[r] = e(++r / i);
  return n;
}
function qx(e, t, n) {
  const i = n - t;
  let r, a, s;
  return !i || !Number.isFinite(i) ? Ut(0.5) : (r = (a = e.type).indexOf("-"), a = r < 0 ? a : a.slice(r + 1), s = be(a)().domain([t, n]).range([0, 1]), Kq.forEach((o) => e[o] ? s[o](e[o]()) : 0), s);
}
function MC(e, t) {
  const n = Ug[Zq(e)];
  return t != null && n && n.gamma ? n.gamma(t) : n;
}
function Zq(e) {
  return "interpolate" + e.toLowerCase().split("-").map((t) => t[0].toUpperCase() + t.slice(1)).join("");
}
const eG = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
}, tG = {
  category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
  accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
  dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
  paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
  pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
  pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
  set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
  set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
  set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
};
function OC(e) {
  const t = e.length / 6 | 0, n = new Array(t);
  for (let i = 0; i < t; )
    n[i] = "#" + e.slice(i * 6, ++i * 6);
  return n;
}
function RC(e, t) {
  for (const n in e)
    TC(n, t(e[n]));
}
const jS = {};
RC(tG, OC);
RC(eG, (e) => Ux(OC(e)));
function TC(e, t) {
  return e = e && e.toLowerCase(), arguments.length > 1 ? (jS[e] = t, this) : jS[e];
}
const Oh = "symbol", nG = "discrete", iG = "gradient", rG = (e) => R(e) ? e.map((t) => String(t)) : String(e), aG = (e, t) => e[1] - t[1], sG = (e, t) => t[1] - e[1];
function Gx(e, t, n) {
  let i;
  return ye(t) && (e.bins && (t = Math.max(t, e.bins.length)), n != null && (t = Math.min(t, Math.floor(il(e.domain()) / n || 1)))), X(t) && (i = t.step, t = t.interval), V(t) && (t = e.type === io ? rl(t) : e.type == ro ? al(t) : D("Only time and utc scales accept interval strings."), i && (t = t.every(i))), t;
}
function DC(e, t, n) {
  let i = e.range(), r = i[0], a = ae(i), s = aG;
  if (r > a && (i = a, a = r, r = i, s = sG), r = Math.floor(r), a = Math.ceil(a), t = t.map((o) => [o, e(o)]).filter((o) => r <= o[1] && o[1] <= a).sort(s).map((o) => o[0]), n > 0 && t.length > 1) {
    const o = [t[0], ae(t)];
    for (; t.length > n && t.length >= 3; )
      t = t.filter((u, l) => !(l % 2));
    t.length < 3 && (t = o);
  }
  return t;
}
function Wx(e, t) {
  return e.bins ? DC(e, e.bins) : e.ticks ? e.ticks(t) : e.domain();
}
function NC(e, t, n, i, r, a) {
  const s = t.type;
  let o = rG;
  if (s === io || r === io)
    o = e.timeFormat(i);
  else if (s === ro || r === ro)
    o = e.utcFormat(i);
  else if (_C(s)) {
    const u = e.formatFloat(i);
    if (a || t.bins)
      o = u;
    else {
      const l = LC(t, n, !1);
      o = (c) => l(c) ? u(c) : "";
    }
  } else if (t.tickFormat) {
    const u = t.domain();
    o = e.formatSpan(u[0], u[u.length - 1], n, i);
  } else
    i && (o = e.format(i));
  return o;
}
function LC(e, t, n) {
  const i = Wx(e, t), r = e.base(), a = Math.log(r), s = Math.max(1, r * t / i.length), o = (u) => {
    let l = u / Math.pow(r, Math.round(Math.log(u) / a));
    return l * r < r - 0.5 && (l *= r), l <= s;
  };
  return n ? i.filter(o) : o;
}
const $b = {
  [Yc]: "quantiles",
  [F0]: "thresholds",
  [M0]: "domain"
}, PC = {
  [Yc]: "quantiles",
  [F0]: "domain"
};
function zC(e, t) {
  return e.bins ? lG(e.bins) : e.type === Yr ? LC(e, t, !0) : $b[e.type] ? uG(e[$b[e.type]]()) : Wx(e, t);
}
function oG(e, t, n) {
  const i = t[PC[t.type]](), r = i.length;
  let a = r > 1 ? i[1] - i[0] : i[0], s;
  for (s = 1; s < r; ++s)
    a = Math.min(a, i[s] - i[s - 1]);
  return e.formatSpan(0, a, 3 * 10, n);
}
function uG(e) {
  const t = [-1 / 0].concat(e);
  return t.max = 1 / 0, t;
}
function lG(e) {
  const t = e.slice(0, -1);
  return t.max = ae(e), t;
}
const cG = (e) => $b[e.type] || e.bins;
function IC(e, t, n, i, r, a, s) {
  const o = PC[t.type] && a !== io && a !== ro ? oG(e, t, r) : NC(e, t, n, r, a, s);
  return i === Oh && cG(t) ? fG(o) : i === nG ? dG(o) : hG(o);
}
const fG = (e) => (t, n, i) => {
  const r = US(i[n + 1], US(i.max, 1 / 0)), a = qS(t, e), s = qS(r, e);
  return a && s ? a + "  " + s : s ? "< " + s : " " + a;
}, US = (e, t) => e ?? t, dG = (e) => (t, n) => n ? e(t) : null, hG = (e) => (t) => e(t), qS = (e, t) => Number.isFinite(e) ? t(e) : null;
function pG(e) {
  const t = e.domain(), n = t.length - 1;
  let i = +t[0], r = +ae(t), a = r - i;
  if (e.type === M0) {
    const s = n ? a / n : 0.1;
    i -= s, r += s, a = r - i;
  }
  return (s) => (s - i) / a;
}
function gG(e, t, n, i) {
  const r = i || t.type;
  return V(n) && Yq(r) && (n = n.replace(/%a/g, "%A").replace(/%b/g, "%B")), !n && r === io ? e.timeFormat("%A, %d %B %Y, %X") : !n && r === ro ? e.utcFormat("%A, %d %B %Y, %X UTC") : IC(e, t, 5, null, n, i, !0);
}
function BC(e, t, n) {
  n = n || {};
  const i = Math.max(3, n.maxlen || 7), r = gG(e, t, n.format, n.formatType);
  if (Xq(t.type)) {
    const a = zC(t).slice(1).map(r), s = a.length;
    return `${s} boundar${s === 1 ? "y" : "ies"}: ${a.join(", ")}`;
  } else if (CC(t.type)) {
    const a = t.domain(), s = a.length, o = s > i ? a.slice(0, i - 2).map(r).join(", ") + ", ending with " + a.slice(-1).map(r) : a.map(r).join(", ");
    return `${s} value${s === 1 ? "" : "s"}: ${o}`;
  } else {
    const a = t.domain();
    return `values from ${r(a[0])} to ${r(ae(a))}`;
  }
}
let mG = 0;
const Np = "p_";
function Hx(e) {
  return e && e.gradient;
}
function jC(e, t, n) {
  const i = e.gradient;
  let r = e.id, a = i === "radial" ? Np : "";
  return r || (r = e.id = "gradient_" + mG++, i === "radial" ? (e.x1 = Gi(e.x1, 0.5), e.y1 = Gi(e.y1, 0.5), e.r1 = Gi(e.r1, 0), e.x2 = Gi(e.x2, 0.5), e.y2 = Gi(e.y2, 0.5), e.r2 = Gi(e.r2, 0.5), a = Np) : (e.x1 = Gi(e.x1, 0), e.y1 = Gi(e.y1, 0), e.x2 = Gi(e.x2, 1), e.y2 = Gi(e.y2, 0))), t[r] = e, "url(" + (n || "") + "#" + a + r + ")";
}
function Gi(e, t) {
  return e ?? t;
}
function UC(e, t) {
  var n = [], i;
  return i = {
    gradient: "linear",
    x1: e ? e[0] : 0,
    y1: e ? e[1] : 0,
    x2: t ? t[0] : 1,
    y2: t ? t[1] : 0,
    stops: n,
    stop: function(r, a) {
      return n.push({
        offset: r,
        color: a
      }), i;
    }
  };
}
const GS = {
  basis: {
    curve: dk
  },
  "basis-closed": {
    curve: hk
  },
  "basis-open": {
    curve: pk
  },
  bundle: {
    curve: gk,
    tension: "beta",
    value: 0.85
  },
  cardinal: {
    curve: mk,
    tension: "tension",
    value: 0
  },
  "cardinal-open": {
    curve: yk,
    tension: "tension",
    value: 0
  },
  "cardinal-closed": {
    curve: bk,
    tension: "tension",
    value: 0
  },
  "catmull-rom": {
    curve: vk,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-closed": {
    curve: xk,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-open": {
    curve: $k,
    tension: "alpha",
    value: 0.5
  },
  linear: {
    curve: t2
  },
  "linear-closed": {
    curve: wk
  },
  monotone: {
    horizontal: Ek,
    vertical: Sk
  },
  natural: {
    curve: Ak
  },
  step: {
    curve: kk
  },
  "step-after": {
    curve: Ck
  },
  "step-before": {
    curve: _k
  }
};
function qC(e, t, n) {
  var i = Y(GS, e) && GS[e], r = null;
  return i && (r = i.curve || i[t || "vertical"], i.tension && n != null && (r = r[i.tension](n))), r;
}
const yG = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  z: 0,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
}, bG = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi, vG = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/, xG = /^((\s+,?\s*)|(,\s*))/, $G = /^[01]/;
function O0(e) {
  const t = [];
  return (e.match(bG) || []).forEach((i) => {
    let r = i[0];
    const a = r.toLowerCase(), s = yG[a], o = wG(a, s, i.slice(1).trim()), u = o.length;
    if (u < s || u && u % s !== 0)
      throw Error("Invalid SVG path, incorrect parameter count");
    if (t.push([r, ...o.slice(0, s)]), u !== s) {
      a === "m" && (r = r === "M" ? "L" : "l");
      for (let l = s; l < u; l += s)
        t.push([r, ...o.slice(l, l + s)]);
    }
  }), t;
}
function wG(e, t, n) {
  const i = [];
  for (let r = 0; t && r < n.length; )
    for (let a = 0; a < t; ++a) {
      const s = e === "a" && (a === 3 || a === 4) ? $G : vG, o = n.slice(r).match(s);
      if (o === null)
        throw Error("Invalid SVG path, incorrect parameter type");
      r += o[0].length, i.push(+o[0]);
      const u = n.slice(r).match(xG);
      u !== null && (r += u[0].length);
    }
  return i;
}
const Ua = Math.PI / 180, EG = 1e-14, Rs = Math.PI / 2, tr = Math.PI * 2, Uo = Math.sqrt(3) / 2;
var F1 = {}, M1 = {}, GC = [].join;
function SG(e, t, n, i, r, a, s, o, u) {
  const l = GC.call(arguments);
  if (F1[l])
    return F1[l];
  const c = s * Ua, f = Math.sin(c), d = Math.cos(c);
  n = Math.abs(n), i = Math.abs(i);
  const h = d * (o - e) * 0.5 + f * (u - t) * 0.5, p = d * (u - t) * 0.5 - f * (o - e) * 0.5;
  let g = h * h / (n * n) + p * p / (i * i);
  g > 1 && (g = Math.sqrt(g), n *= g, i *= g);
  const m = d / n, y = f / n, b = -f / i, v = d / i, x = m * o + y * u, w = b * o + v * u, E = m * e + y * t, $ = b * e + v * t;
  let A = 1 / ((E - x) * (E - x) + ($ - w) * ($ - w)) - 0.25;
  A < 0 && (A = 0);
  let k = Math.sqrt(A);
  a == r && (k = -k);
  const _ = 0.5 * (x + E) - k * ($ - w), P = 0.5 * (w + $) + k * (E - x), F = Math.atan2(w - P, x - _);
  let C = Math.atan2($ - P, E - _) - F;
  C < 0 && a === 1 ? C += tr : C > 0 && a === 0 && (C -= tr);
  const O = Math.ceil(Math.abs(C / (Rs + 1e-3))), L = [];
  for (let z = 0; z < O; ++z) {
    const W = F + z * C / O, J = F + (z + 1) * C / O;
    L[z] = [_, P, W, J, n, i, f, d];
  }
  return F1[l] = L;
}
function AG(e) {
  const t = GC.call(e);
  if (M1[t])
    return M1[t];
  var n = e[0], i = e[1], r = e[2], a = e[3], s = e[4], o = e[5], u = e[6], l = e[7];
  const c = l * s, f = -u * o, d = u * s, h = l * o, p = Math.cos(r), g = Math.sin(r), m = Math.cos(a), y = Math.sin(a), b = 0.5 * (a - r), v = Math.sin(b * 0.5), x = 8 / 3 * v * v / Math.sin(b), w = n + p - x * g, E = i + g + x * p, $ = n + m, S = i + y, A = $ + x * y, k = S - x * m;
  return M1[t] = [c * w + f * E, d * w + h * E, c * A + f * k, d * A + h * k, c * $ + f * S, d * $ + h * S];
}
const Un = ["l", 0, 0, 0, 0, 0, 0, 0];
function kG(e, t, n) {
  const i = Un[0] = e[0];
  if (i === "a" || i === "A")
    Un[1] = t * e[1], Un[2] = n * e[2], Un[3] = e[3], Un[4] = e[4], Un[5] = e[5], Un[6] = t * e[6], Un[7] = n * e[7];
  else if (i === "h" || i === "H")
    Un[1] = t * e[1];
  else if (i === "v" || i === "V")
    Un[1] = n * e[1];
  else
    for (var r = 1, a = e.length; r < a; ++r)
      Un[r] = (r % 2 == 1 ? t : n) * e[r];
  return Un;
}
function Kc(e, t, n, i, r, a) {
  var s, o = null, u = 0, l = 0, c = 0, f = 0, d, h, p, g, m = 0, y = 0;
  n == null && (n = 0), i == null && (i = 0), r == null && (r = 1), a == null && (a = r), e.beginPath && e.beginPath();
  for (var b = 0, v = t.length; b < v; ++b) {
    switch (s = t[b], (r !== 1 || a !== 1) && (s = kG(s, r, a)), s[0]) {
      case "l":
        u += s[1], l += s[2], e.lineTo(u + n, l + i);
        break;
      case "L":
        u = s[1], l = s[2], e.lineTo(u + n, l + i);
        break;
      case "h":
        u += s[1], e.lineTo(u + n, l + i);
        break;
      case "H":
        u = s[1], e.lineTo(u + n, l + i);
        break;
      case "v":
        l += s[1], e.lineTo(u + n, l + i);
        break;
      case "V":
        l = s[1], e.lineTo(u + n, l + i);
        break;
      case "m":
        u += s[1], l += s[2], m = u, y = l, e.moveTo(u + n, l + i);
        break;
      case "M":
        u = s[1], l = s[2], m = u, y = l, e.moveTo(u + n, l + i);
        break;
      case "c":
        d = u + s[5], h = l + s[6], c = u + s[3], f = l + s[4], e.bezierCurveTo(
          u + s[1] + n,
          // x1
          l + s[2] + i,
          // y1
          c + n,
          // x2
          f + i,
          // y2
          d + n,
          h + i
        ), u = d, l = h;
        break;
      case "C":
        u = s[5], l = s[6], c = s[3], f = s[4], e.bezierCurveTo(s[1] + n, s[2] + i, c + n, f + i, u + n, l + i);
        break;
      case "s":
        d = u + s[3], h = l + s[4], c = 2 * u - c, f = 2 * l - f, e.bezierCurveTo(c + n, f + i, u + s[1] + n, l + s[2] + i, d + n, h + i), c = u + s[1], f = l + s[2], u = d, l = h;
        break;
      case "S":
        d = s[3], h = s[4], c = 2 * u - c, f = 2 * l - f, e.bezierCurveTo(c + n, f + i, s[1] + n, s[2] + i, d + n, h + i), u = d, l = h, c = s[1], f = s[2];
        break;
      case "q":
        d = u + s[3], h = l + s[4], c = u + s[1], f = l + s[2], e.quadraticCurveTo(c + n, f + i, d + n, h + i), u = d, l = h;
        break;
      case "Q":
        d = s[3], h = s[4], e.quadraticCurveTo(s[1] + n, s[2] + i, d + n, h + i), u = d, l = h, c = s[1], f = s[2];
        break;
      case "t":
        d = u + s[1], h = l + s[2], o[0].match(/[QqTt]/) === null ? (c = u, f = l) : o[0] === "t" ? (c = 2 * u - p, f = 2 * l - g) : o[0] === "q" && (c = 2 * u - c, f = 2 * l - f), p = c, g = f, e.quadraticCurveTo(c + n, f + i, d + n, h + i), u = d, l = h, c = u + s[1], f = l + s[2];
        break;
      case "T":
        d = s[1], h = s[2], c = 2 * u - c, f = 2 * l - f, e.quadraticCurveTo(c + n, f + i, d + n, h + i), u = d, l = h;
        break;
      case "a":
        WS(e, u + n, l + i, [s[1], s[2], s[3], s[4], s[5], s[6] + u + n, s[7] + l + i]), u += s[6], l += s[7];
        break;
      case "A":
        WS(e, u + n, l + i, [s[1], s[2], s[3], s[4], s[5], s[6] + n, s[7] + i]), u = s[6], l = s[7];
        break;
      case "z":
      case "Z":
        u = m, l = y, e.closePath();
        break;
    }
    o = s;
  }
}
function WS(e, t, n, i) {
  const r = SG(
    i[5],
    // end x
    i[6],
    // end y
    i[0],
    // radius x
    i[1],
    // radius y
    i[3],
    // large flag
    i[4],
    // sweep flag
    i[2],
    // rotation
    t,
    n
  );
  for (let a = 0; a < r.length; ++a) {
    const s = AG(r[a]);
    e.bezierCurveTo(s[0], s[1], s[2], s[3], s[4], s[5]);
  }
}
const HS = 0.5773502691896257, VS = {
  circle: {
    draw: function(e, t) {
      const n = Math.sqrt(t) / 2;
      e.moveTo(n, 0), e.arc(0, 0, n, 0, tr);
    }
  },
  cross: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = n / 2.5;
      e.moveTo(-n, -i), e.lineTo(-n, i), e.lineTo(-i, i), e.lineTo(-i, n), e.lineTo(i, n), e.lineTo(i, i), e.lineTo(n, i), e.lineTo(n, -i), e.lineTo(i, -i), e.lineTo(i, -n), e.lineTo(-i, -n), e.lineTo(-i, -i), e.closePath();
    }
  },
  diamond: {
    draw: function(e, t) {
      const n = Math.sqrt(t) / 2;
      e.moveTo(-n, 0), e.lineTo(0, -n), e.lineTo(n, 0), e.lineTo(0, n), e.closePath();
    }
  },
  square: {
    draw: function(e, t) {
      var n = Math.sqrt(t), i = -n / 2;
      e.rect(i, i, n, n);
    }
  },
  arrow: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = n / 7, r = n / 2.5, a = n / 8;
      e.moveTo(-i, n), e.lineTo(i, n), e.lineTo(i, -a), e.lineTo(r, -a), e.lineTo(0, -n), e.lineTo(-r, -a), e.lineTo(-i, -a), e.closePath();
    }
  },
  wedge: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Uo * n, r = i - n * HS, a = n / 4;
      e.moveTo(0, -i - r), e.lineTo(-a, i - r), e.lineTo(a, i - r), e.closePath();
    }
  },
  triangle: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Uo * n, r = i - n * HS;
      e.moveTo(0, -i - r), e.lineTo(-n, i - r), e.lineTo(n, i - r), e.closePath();
    }
  },
  "triangle-up": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Uo * n;
      e.moveTo(0, -i), e.lineTo(-n, i), e.lineTo(n, i), e.closePath();
    }
  },
  "triangle-down": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Uo * n;
      e.moveTo(0, i), e.lineTo(-n, -i), e.lineTo(n, -i), e.closePath();
    }
  },
  "triangle-right": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Uo * n;
      e.moveTo(i, 0), e.lineTo(-i, -n), e.lineTo(-i, n), e.closePath();
    }
  },
  "triangle-left": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Uo * n;
      e.moveTo(-i, 0), e.lineTo(i, -n), e.lineTo(i, n), e.closePath();
    }
  },
  stroke: {
    draw: function(e, t) {
      const n = Math.sqrt(t) / 2;
      e.moveTo(-n, 0), e.lineTo(n, 0);
    }
  }
};
function CG(e) {
  return Y(VS, e) ? VS[e] : _G(e);
}
var O1 = {};
function _G(e) {
  if (!Y(O1, e)) {
    const t = O0(e);
    O1[e] = {
      draw: function(n, i) {
        Kc(n, t, 0, 0, Math.sqrt(i) / 2);
      }
    };
  }
  return O1[e];
}
const fa = 0.448084975506;
function FG(e) {
  return e.x;
}
function MG(e) {
  return e.y;
}
function OG(e) {
  return e.width;
}
function RG(e) {
  return e.height;
}
function _r(e) {
  return typeof e == "function" ? e : () => +e;
}
function th(e, t, n) {
  return Math.max(t, Math.min(e, n));
}
function TG() {
  var e = FG, t = MG, n = OG, i = RG, r = _r(0), a = r, s = r, o = r, u = null;
  function l(c, f, d) {
    var h, p = f ?? +e.call(this, c), g = d ?? +t.call(this, c), m = +n.call(this, c), y = +i.call(this, c), b = Math.min(m, y) / 2, v = th(+r.call(this, c), 0, b), x = th(+a.call(this, c), 0, b), w = th(+s.call(this, c), 0, b), E = th(+o.call(this, c), 0, b);
    if (u || (u = h = Cf()), v <= 0 && x <= 0 && w <= 0 && E <= 0)
      u.rect(p, g, m, y);
    else {
      var $ = p + m, S = g + y;
      u.moveTo(p + v, g), u.lineTo($ - x, g), u.bezierCurveTo($ - fa * x, g, $, g + fa * x, $, g + x), u.lineTo($, S - E), u.bezierCurveTo($, S - fa * E, $ - fa * E, S, $ - E, S), u.lineTo(p + w, S), u.bezierCurveTo(p + fa * w, S, p, S - fa * w, p, S - w), u.lineTo(p, g + v), u.bezierCurveTo(p, g + fa * v, p + fa * v, g, p + v, g), u.closePath();
    }
    if (h)
      return u = null, h + "" || null;
  }
  return l.x = function(c) {
    return arguments.length ? (e = _r(c), l) : e;
  }, l.y = function(c) {
    return arguments.length ? (t = _r(c), l) : t;
  }, l.width = function(c) {
    return arguments.length ? (n = _r(c), l) : n;
  }, l.height = function(c) {
    return arguments.length ? (i = _r(c), l) : i;
  }, l.cornerRadius = function(c, f, d, h) {
    return arguments.length ? (r = _r(c), a = f != null ? _r(f) : r, o = d != null ? _r(d) : r, s = h != null ? _r(h) : a, l) : r;
  }, l.context = function(c) {
    return arguments.length ? (u = c ?? null, l) : u;
  }, l;
}
function DG() {
  var e, t, n, i, r = null, a, s, o, u;
  function l(f, d, h) {
    const p = h / 2;
    if (a) {
      var g = o - d, m = f - s;
      if (g || m) {
        var y = Math.sqrt(g * g + m * m), b = (g /= y) * u, v = (m /= y) * u, x = Math.atan2(m, g);
        r.moveTo(s - b, o - v), r.lineTo(f - g * p, d - m * p), r.arc(f, d, p, x - Math.PI, x), r.lineTo(s + b, o + v), r.arc(s, o, u, x, x + Math.PI);
      } else
        r.arc(f, d, p, 0, tr);
      r.closePath();
    } else
      a = 1;
    s = f, o = d, u = p;
  }
  function c(f) {
    var d, h = f.length, p, g = !1, m;
    for (r == null && (r = m = Cf()), d = 0; d <= h; ++d)
      !(d < h && i(p = f[d], d, f)) === g && (g = !g) && (a = 0), g && l(+e(p, d, f), +t(p, d, f), +n(p, d, f));
    if (m)
      return r = null, m + "" || null;
  }
  return c.x = function(f) {
    return arguments.length ? (e = f, c) : e;
  }, c.y = function(f) {
    return arguments.length ? (t = f, c) : t;
  }, c.size = function(f) {
    return arguments.length ? (n = f, c) : n;
  }, c.defined = function(f) {
    return arguments.length ? (i = f, c) : i;
  }, c.context = function(f) {
    return arguments.length ? (f == null ? r = null : r = f, c) : r;
  }, c;
}
function ed(e, t) {
  return e ?? t;
}
const td = (e) => e.x || 0, nd = (e) => e.y || 0, NG = (e) => e.width || 0, LG = (e) => e.height || 0, PG = (e) => (e.x || 0) + (e.width || 0), zG = (e) => (e.y || 0) + (e.height || 0), IG = (e) => e.startAngle || 0, BG = (e) => e.endAngle || 0, jG = (e) => e.padAngle || 0, UG = (e) => e.innerRadius || 0, qG = (e) => e.outerRadius || 0, GG = (e) => e.cornerRadius || 0, WG = (e) => ed(e.cornerRadiusTopLeft, e.cornerRadius) || 0, HG = (e) => ed(e.cornerRadiusTopRight, e.cornerRadius) || 0, VG = (e) => ed(e.cornerRadiusBottomRight, e.cornerRadius) || 0, XG = (e) => ed(e.cornerRadiusBottomLeft, e.cornerRadius) || 0, YG = (e) => ed(e.size, 64), KG = (e) => e.size || 1, R0 = (e) => e.defined !== !1, JG = (e) => CG(e.shape || "circle"), QG = Fk().startAngle(IG).endAngle(BG).padAngle(jG).innerRadius(UG).outerRadius(qG).cornerRadius(GG), ZG = Zg().x(td).y1(nd).y0(zG).defined(R0), eW = Zg().y(nd).x1(td).x0(PG).defined(R0), tW = n2().x(td).y(nd).defined(R0), nW = TG().x(td).y(nd).width(NG).height(LG).cornerRadius(WG, HG, VG, XG), iW = B9().type(JG).size(YG), rW = DG().x(td).y(nd).defined(R0).size(KG);
function Vx(e) {
  return e.cornerRadius || e.cornerRadiusTopLeft || e.cornerRadiusTopRight || e.cornerRadiusBottomRight || e.cornerRadiusBottomLeft;
}
function aW(e, t) {
  return QG.context(e)(t);
}
function sW(e, t) {
  const n = t[0], i = n.interpolate || "linear";
  return (n.orient === "horizontal" ? eW : ZG).curve(qC(i, n.orient, n.tension)).context(e)(t);
}
function oW(e, t) {
  const n = t[0], i = n.interpolate || "linear";
  return tW.curve(qC(i, n.orient, n.tension)).context(e)(t);
}
function fl(e, t, n, i) {
  return nW.context(e)(t, n, i);
}
function uW(e, t) {
  return (t.mark.shape || t.shape).context(e)(t);
}
function lW(e, t) {
  return iW.context(e)(t);
}
function cW(e, t) {
  return rW.context(e)(t);
}
var fW = 1;
function Xx(e, t, n) {
  var i = t.clip, r = e._defs, a = t.clip_id || (t.clip_id = "clip" + fW++), s = r.clipping[a] || (r.clipping[a] = {
    id: a
  });
  return oe(i) ? s.path = i(null) : Vx(n) ? s.path = fl(null, n, 0, 0) : (s.width = n.width || 0, s.height = n.height || 0), "url(#" + a + ")";
}
function Ye(e) {
  this.clear(), e && this.union(e);
}
Ye.prototype = {
  clone() {
    return new Ye(this);
  },
  clear() {
    return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(e) {
    return this.x1 === e.x1 && this.y1 === e.y1 && this.x2 === e.x2 && this.y2 === e.y2;
  },
  set(e, t, n, i) {
    return n < e ? (this.x2 = e, this.x1 = n) : (this.x1 = e, this.x2 = n), i < t ? (this.y2 = t, this.y1 = i) : (this.y1 = t, this.y2 = i), this;
  },
  add(e, t) {
    return e < this.x1 && (this.x1 = e), t < this.y1 && (this.y1 = t), e > this.x2 && (this.x2 = e), t > this.y2 && (this.y2 = t), this;
  },
  expand(e) {
    return this.x1 -= e, this.y1 -= e, this.x2 += e, this.y2 += e, this;
  },
  round() {
    return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
  },
  scale(e) {
    return this.x1 *= e, this.y1 *= e, this.x2 *= e, this.y2 *= e, this;
  },
  translate(e, t) {
    return this.x1 += e, this.x2 += e, this.y1 += t, this.y2 += t, this;
  },
  rotate(e, t, n) {
    const i = this.rotatedPoints(e, t, n);
    return this.clear().add(i[0], i[1]).add(i[2], i[3]).add(i[4], i[5]).add(i[6], i[7]);
  },
  rotatedPoints(e, t, n) {
    var {
      x1: i,
      y1: r,
      x2: a,
      y2: s
    } = this, o = Math.cos(e), u = Math.sin(e), l = t - t * o + n * u, c = n - t * u - n * o;
    return [o * i - u * r + l, u * i + o * r + c, o * i - u * s + l, u * i + o * s + c, o * a - u * r + l, u * a + o * r + c, o * a - u * s + l, u * a + o * s + c];
  },
  union(e) {
    return e.x1 < this.x1 && (this.x1 = e.x1), e.y1 < this.y1 && (this.y1 = e.y1), e.x2 > this.x2 && (this.x2 = e.x2), e.y2 > this.y2 && (this.y2 = e.y2), this;
  },
  intersect(e) {
    return e.x1 > this.x1 && (this.x1 = e.x1), e.y1 > this.y1 && (this.y1 = e.y1), e.x2 < this.x2 && (this.x2 = e.x2), e.y2 < this.y2 && (this.y2 = e.y2), this;
  },
  encloses(e) {
    return e && this.x1 <= e.x1 && this.x2 >= e.x2 && this.y1 <= e.y1 && this.y2 >= e.y2;
  },
  alignsWith(e) {
    return e && (this.x1 == e.x1 || this.x2 == e.x2 || this.y1 == e.y1 || this.y2 == e.y2);
  },
  intersects(e) {
    return e && !(this.x2 < e.x1 || this.x1 > e.x2 || this.y2 < e.y1 || this.y1 > e.y2);
  },
  contains(e, t) {
    return !(e < this.x1 || e > this.x2 || t < this.y1 || t > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};
function Yx(e) {
  this.mark = e, this.bounds = this.bounds || new Ye();
}
function Kx(e) {
  Yx.call(this, e), this.items = this.items || [];
}
B(Kx, Yx);
function WC(e) {
  this._pending = 0, this._loader = e || sl();
}
function XS(e) {
  e._pending += 1;
}
function Dl(e) {
  e._pending -= 1;
}
WC.prototype = {
  pending() {
    return this._pending;
  },
  sanitizeURL(e) {
    const t = this;
    return XS(t), t._loader.sanitize(e, {
      context: "href"
    }).then((n) => (Dl(t), n)).catch(() => (Dl(t), null));
  },
  loadImage(e) {
    const t = this, n = vC();
    return XS(t), t._loader.sanitize(e, {
      context: "image"
    }).then((i) => {
      const r = i.href;
      if (!r || !n)
        throw {
          url: r
        };
      const a = new n(), s = Y(i, "crossOrigin") ? i.crossOrigin : "anonymous";
      return s != null && (a.crossOrigin = s), a.onload = () => Dl(t), a.onerror = () => Dl(t), a.src = r, a;
    }).catch((i) => (Dl(t), {
      complete: !1,
      width: 0,
      height: 0,
      src: i && i.url || ""
    }));
  },
  ready() {
    const e = this;
    return new Promise((t) => {
      function n(i) {
        e.pending() ? setTimeout(() => {
          n(!0);
        }, 10) : t(i);
      }
      n(!1);
    });
  }
};
function os(e, t, n) {
  if (t.stroke && t.opacity !== 0 && t.strokeOpacity !== 0) {
    const i = t.strokeWidth != null ? +t.strokeWidth : 1;
    e.expand(i + (n ? dW(t, i) : 0));
  }
  return e;
}
function dW(e, t) {
  return e.strokeJoin && e.strokeJoin !== "miter" ? 0 : t;
}
const hW = tr - 1e-8;
let T0, Rh, Th, Bs, wb, Dh, Eb, Sb;
const Aa = (e, t) => T0.add(e, t), Nh = (e, t) => Aa(Rh = e, Th = t), YS = (e) => Aa(e, T0.y1), KS = (e) => Aa(T0.x1, e), Ts = (e, t) => wb * e + Eb * t, Ds = (e, t) => Dh * e + Sb * t, R1 = (e, t) => Aa(Ts(e, t), Ds(e, t)), T1 = (e, t) => Nh(Ts(e, t), Ds(e, t));
function D0(e, t) {
  return T0 = e, t ? (Bs = t * Ua, wb = Sb = Math.cos(Bs), Dh = Math.sin(Bs), Eb = -Dh) : (wb = Sb = 1, Bs = Dh = Eb = 0), pW;
}
const pW = {
  beginPath() {
  },
  closePath() {
  },
  moveTo: T1,
  lineTo: T1,
  rect(e, t, n, i) {
    Bs ? (R1(e + n, t), R1(e + n, t + i), R1(e, t + i), T1(e, t)) : (Aa(e + n, t + i), Nh(e, t));
  },
  quadraticCurveTo(e, t, n, i) {
    const r = Ts(e, t), a = Ds(e, t), s = Ts(n, i), o = Ds(n, i);
    JS(Rh, r, s, YS), JS(Th, a, o, KS), Nh(s, o);
  },
  bezierCurveTo(e, t, n, i, r, a) {
    const s = Ts(e, t), o = Ds(e, t), u = Ts(n, i), l = Ds(n, i), c = Ts(r, a), f = Ds(r, a);
    QS(Rh, s, u, c, YS), QS(Th, o, l, f, KS), Nh(c, f);
  },
  arc(e, t, n, i, r, a) {
    if (i += Bs, r += Bs, Rh = n * Math.cos(r) + e, Th = n * Math.sin(r) + t, Math.abs(r - i) > hW)
      Aa(e - n, t - n), Aa(e + n, t + n);
    else {
      const s = (l) => Aa(n * Math.cos(l) + e, n * Math.sin(l) + t);
      let o, u;
      if (s(i), s(r), r !== i)
        if (i = i % tr, i < 0 && (i += tr), r = r % tr, r < 0 && (r += tr), r < i && (a = !a, o = i, i = r, r = o), a)
          for (r -= tr, o = i - i % Rs, u = 0; u < 4 && o > r; ++u, o -= Rs)
            s(o);
        else
          for (o = i - i % Rs + Rs, u = 0; u < 4 && o < r; ++u, o = o + Rs)
            s(o);
    }
  }
};
function JS(e, t, n, i) {
  const r = (e - t) / (e + n - 2 * t);
  0 < r && r < 1 && i(e + (t - e) * r);
}
function QS(e, t, n, i, r) {
  const a = i - e + 3 * t - 3 * n, s = e + n - 2 * t, o = e - t;
  let u = 0, l = 0, c;
  Math.abs(a) > EG ? (c = s * s + o * a, c >= 0 && (c = Math.sqrt(c), u = (-s + c) / a, l = (-s - c) / a)) : u = 0.5 * o / s, 0 < u && u < 1 && r(ZS(u, e, t, n, i)), 0 < l && l < 1 && r(ZS(l, e, t, n, i));
}
function ZS(e, t, n, i, r) {
  const a = 1 - e, s = a * a, o = e * e;
  return s * a * t + 3 * s * e * n + 3 * a * o * i + o * e * r;
}
var Na = (Na = Ei(1, 1)) ? Na.getContext("2d") : null;
const Ab = new Ye();
function HC(e) {
  return function(t, n) {
    if (!Na)
      return !0;
    e(Na, t), Ab.clear().union(t.bounds).intersect(n).round();
    const {
      x1: i,
      y1: r,
      x2: a,
      y2: s
    } = Ab;
    for (let o = r; o <= s; ++o)
      for (let u = i; u <= a; ++u)
        if (Na.isPointInPath(u, o))
          return !0;
    return !1;
  };
}
function VC(e, t) {
  return t.contains(e.x || 0, e.y || 0);
}
function XC(e, t) {
  const n = e.x || 0, i = e.y || 0, r = e.width || 0, a = e.height || 0;
  return t.intersects(Ab.set(n, i, n + r, i + a));
}
function gW(e, t) {
  const n = e.x || 0, i = e.y || 0, r = e.x2 != null ? e.x2 : n, a = e.y2 != null ? e.y2 : i;
  return dc(t, n, i, r, a);
}
function dc(e, t, n, i, r) {
  const {
    x1: a,
    y1: s,
    x2: o,
    y2: u
  } = e, l = i - t, c = r - n;
  let f = 0, d = 1, h, p, g, m;
  for (m = 0; m < 4; ++m) {
    if (m === 0 && (h = -l, p = -(a - t)), m === 1 && (h = l, p = o - t), m === 2 && (h = -c, p = -(s - n)), m === 3 && (h = c, p = u - n), Math.abs(h) < 1e-10 && p < 0)
      return !1;
    if (g = p / h, h < 0) {
      if (g > d)
        return !1;
      g > f && (f = g);
    } else if (h > 0) {
      if (g < f)
        return !1;
      g < d && (d = g);
    }
  }
  return !0;
}
function Eu(e, t) {
  e.globalCompositeOperation = t.blend || "source-over";
}
function ui(e, t) {
  return e ?? t;
}
function e6(e, t) {
  const n = t.length;
  for (let i = 0; i < n; ++i)
    e.addColorStop(t[i].offset, t[i].color);
  return e;
}
function mW(e, t, n) {
  const i = n.width(), r = n.height();
  let a;
  if (t.gradient === "radial")
    a = e.createRadialGradient(n.x1 + ui(t.x1, 0.5) * i, n.y1 + ui(t.y1, 0.5) * r, Math.max(i, r) * ui(t.r1, 0), n.x1 + ui(t.x2, 0.5) * i, n.y1 + ui(t.y2, 0.5) * r, Math.max(i, r) * ui(t.r2, 0.5));
  else {
    const s = ui(t.x1, 0), o = ui(t.y1, 0), u = ui(t.x2, 1), l = ui(t.y2, 0);
    if (s === u || o === l || i === r)
      a = e.createLinearGradient(n.x1 + s * i, n.y1 + o * r, n.x1 + u * i, n.y1 + l * r);
    else {
      const c = Ei(Math.ceil(i), Math.ceil(r)), f = c.getContext("2d");
      return f.scale(i, r), f.fillStyle = e6(f.createLinearGradient(s, o, u, l), t.stops), f.fillRect(0, 0, i, r), e.createPattern(c, "no-repeat");
    }
  }
  return e6(a, t.stops);
}
function YC(e, t, n) {
  return Hx(n) ? mW(e, n, t.bounds) : n;
}
function Lp(e, t, n) {
  return n *= t.fillOpacity == null ? 1 : t.fillOpacity, n > 0 ? (e.globalAlpha = n, e.fillStyle = YC(e, t, t.fill), !0) : !1;
}
var yW = [];
function Su(e, t, n) {
  var i = (i = t.strokeWidth) != null ? i : 1;
  return i <= 0 ? !1 : (n *= t.strokeOpacity == null ? 1 : t.strokeOpacity, n > 0 ? (e.globalAlpha = n, e.strokeStyle = YC(e, t, t.stroke), e.lineWidth = i, e.lineCap = t.strokeCap || "butt", e.lineJoin = t.strokeJoin || "miter", e.miterLimit = t.strokeMiterLimit || 10, e.setLineDash && (e.setLineDash(t.strokeDash || yW), e.lineDashOffset = t.strokeDashOffset || 0), !0) : !1);
}
function bW(e, t) {
  return e.zindex - t.zindex || e.index - t.index;
}
function KC(e) {
  if (!e.zdirty)
    return e.zitems;
  var t = e.items, n = [], i, r, a;
  for (r = 0, a = t.length; r < a; ++r)
    i = t[r], i.index = r, i.zindex && n.push(i);
  return e.zdirty = !1, e.zitems = n.sort(bW);
}
function dr(e, t) {
  var n = e.items, i, r;
  if (!n || !n.length)
    return;
  const a = KC(e);
  if (a && a.length) {
    for (i = 0, r = n.length; i < r; ++i)
      n[i].zindex || t(n[i]);
    n = a;
  }
  for (i = 0, r = n.length; i < r; ++i)
    t(n[i]);
}
function kb(e, t) {
  var n = e.items, i, r;
  if (!n || !n.length)
    return null;
  const a = KC(e);
  for (a && a.length && (n = a), r = n.length; --r >= 0; )
    if (i = t(n[r]))
      return i;
  if (n === a) {
    for (n = e.items, r = n.length; --r >= 0; )
      if (!n[r].zindex && (i = t(n[r])))
        return i;
  }
  return null;
}
function Jx(e) {
  return function(t, n, i) {
    dr(n, (r) => {
      (!i || i.intersects(r.bounds)) && JC(e, t, r, r);
    });
  };
}
function vW(e) {
  return function(t, n, i) {
    n.items.length && (!i || i.intersects(n.bounds)) && JC(e, t, n.items[0], n.items);
  };
}
function JC(e, t, n, i) {
  var r = n.opacity == null ? 1 : n.opacity;
  r !== 0 && (e(t, i) || (Eu(t, n), n.fill && Lp(t, n, r) && t.fill(), n.stroke && Su(t, n, r) && t.stroke()));
}
function N0(e) {
  return e = e || jt, function(t, n, i, r, a, s) {
    return i *= t.pixelRatio, r *= t.pixelRatio, kb(n, (o) => {
      const u = o.bounds;
      if (!(u && !u.contains(a, s) || !u) && e(t, o, i, r, a, s))
        return o;
    });
  };
}
function id(e, t) {
  return function(n, i, r, a) {
    var s = Array.isArray(i) ? i[0] : i, o = t ?? s.fill, u = s.stroke && n.isPointInStroke, l, c;
    return u && (l = s.strokeWidth, c = s.strokeCap, n.lineWidth = l ?? 1, n.lineCap = c ?? "butt"), e(n, i) ? !1 : o && n.isPointInPath(r, a) || u && n.isPointInStroke(r, a);
  };
}
function Qx(e) {
  return N0(id(e));
}
function Xs(e, t) {
  return "translate(" + e + "," + t + ")";
}
function Zx(e) {
  return "rotate(" + e + ")";
}
function xW(e, t) {
  return "scale(" + e + "," + t + ")";
}
function QC(e) {
  return Xs(e.x || 0, e.y || 0);
}
function $W(e) {
  return Xs(e.x || 0, e.y || 0) + (e.angle ? " " + Zx(e.angle) : "");
}
function wW(e) {
  return Xs(e.x || 0, e.y || 0) + (e.angle ? " " + Zx(e.angle) : "") + (e.scaleX || e.scaleY ? " " + xW(e.scaleX || 1, e.scaleY || 1) : "");
}
function e$(e, t, n) {
  function i(s, o) {
    s("transform", $W(o)), s("d", t(null, o));
  }
  function r(s, o) {
    return t(D0(s, o.angle), o), os(s, o).translate(o.x || 0, o.y || 0);
  }
  function a(s, o) {
    var u = o.x || 0, l = o.y || 0, c = o.angle || 0;
    s.translate(u, l), c && s.rotate(c *= Ua), s.beginPath(), t(s, o), c && s.rotate(-c), s.translate(-u, -l);
  }
  return {
    type: e,
    tag: "path",
    nested: !1,
    attr: i,
    bound: r,
    draw: Jx(a),
    pick: Qx(a),
    isect: n || HC(a)
  };
}
var EW = e$("arc", aW);
function SW(e, t) {
  for (var n = e[0].orient === "horizontal" ? t[1] : t[0], i = e[0].orient === "horizontal" ? "y" : "x", r = e.length, a = 1 / 0, s, o; --r >= 0; )
    e[r].defined !== !1 && (o = Math.abs(e[r][i] - n), o < a && (a = o, s = e[r]));
  return s;
}
function AW(e, t) {
  for (var n = Math.pow(e[0].strokeWidth || 1, 2), i = e.length, r, a, s; --i >= 0; )
    if (e[i].defined !== !1 && (r = e[i].x - t[0], a = e[i].y - t[1], s = r * r + a * a, s < n))
      return e[i];
  return null;
}
function kW(e, t) {
  for (var n = e.length, i, r, a; --n >= 0; )
    if (e[n].defined !== !1 && (i = e[n].x - t[0], r = e[n].y - t[1], a = i * i + r * r, i = e[n].size || 1, a < i * i))
      return e[n];
  return null;
}
function t$(e, t, n) {
  function i(u, l) {
    var c = l.mark.items;
    c.length && u("d", t(null, c));
  }
  function r(u, l) {
    var c = l.items;
    return c.length === 0 ? u : (t(D0(u), c), os(u, c[0]));
  }
  function a(u, l) {
    u.beginPath(), t(u, l);
  }
  const s = id(a);
  function o(u, l, c, f, d, h) {
    var p = l.items, g = l.bounds;
    return !p || !p.length || g && !g.contains(d, h) ? null : (c *= u.pixelRatio, f *= u.pixelRatio, s(u, p, c, f) ? p[0] : null);
  }
  return {
    type: e,
    tag: "path",
    nested: !0,
    attr: i,
    bound: r,
    draw: vW(a),
    pick: o,
    isect: VC,
    tip: n
  };
}
var CW = t$("area", sW, SW);
function _W(e, t) {
  var n = t.clip;
  e.save(), oe(n) ? (e.beginPath(), n(e), e.clip()) : ZC(e, t.group);
}
function ZC(e, t) {
  e.beginPath(), Vx(t) ? fl(e, t, 0, 0) : e.rect(0, 0, t.width || 0, t.height || 0), e.clip();
}
function e_(e) {
  const t = ui(e.strokeWidth, 1);
  return e.strokeOffset != null ? e.strokeOffset : e.stroke && t > 0.5 && t < 1.5 ? 0.5 - Math.abs(t - 1) : 0;
}
function FW(e, t) {
  e("transform", QC(t));
}
function t_(e, t) {
  const n = e_(t);
  e("d", fl(null, t, n, n));
}
function MW(e, t) {
  e("class", "background"), e("aria-hidden", !0), t_(e, t);
}
function OW(e, t) {
  e("class", "foreground"), e("aria-hidden", !0), t.strokeForeground ? t_(e, t) : e("d", "");
}
function RW(e, t, n) {
  const i = t.clip ? Xx(n, t, t) : null;
  e("clip-path", i);
}
function TW(e, t) {
  if (!t.clip && t.items) {
    const n = t.items, i = n.length;
    for (let r = 0; r < i; ++r)
      e.union(n[r].bounds);
  }
  return (t.clip || t.width || t.height) && !t.noBound && e.add(0, 0).add(t.width || 0, t.height || 0), os(e, t), e.translate(t.x || 0, t.y || 0);
}
function Jc(e, t, n, i) {
  const r = e_(t);
  e.beginPath(), fl(e, t, (n || 0) + r, (i || 0) + r);
}
const DW = id(Jc), NW = id(Jc, !1), LW = id(Jc, !0);
function PW(e, t, n) {
  dr(t, (i) => {
    const r = i.x || 0, a = i.y || 0, s = i.strokeForeground, o = i.opacity == null ? 1 : i.opacity;
    (i.stroke || i.fill) && o && (Jc(e, i, r, a), Eu(e, i), i.fill && Lp(e, i, o) && e.fill(), i.stroke && !s && Su(e, i, o) && e.stroke()), e.save(), e.translate(r, a), i.clip && ZC(e, i), n && n.translate(-r, -a), dr(i, (u) => {
      this.draw(e, u, n);
    }), n && n.translate(r, a), e.restore(), s && i.stroke && o && (Jc(e, i, r, a), Eu(e, i), Su(e, i, o) && e.stroke());
  });
}
function zW(e, t, n, i, r, a) {
  if (t.bounds && !t.bounds.contains(r, a) || !t.items)
    return null;
  const s = n * e.pixelRatio, o = i * e.pixelRatio;
  return kb(t, (u) => {
    let l, c, f;
    const d = u.bounds;
    if (d && !d.contains(r, a))
      return;
    c = u.x || 0, f = u.y || 0;
    const h = c + (u.width || 0), p = f + (u.height || 0), g = u.clip;
    if (g && (r < c || r > h || a < f || a > p))
      return;
    if (e.save(), e.translate(c, f), c = r - c, f = a - f, g && Vx(u) && !LW(e, u, s, o))
      return e.restore(), null;
    const m = u.strokeForeground, y = t.interactive !== !1;
    return y && m && u.stroke && NW(e, u, s, o) ? (e.restore(), u) : (l = kb(u, (b) => IW(b, c, f) ? this.pick(b, n, i, c, f) : null), !l && y && (u.fill || !m && u.stroke) && DW(e, u, s, o) && (l = u), e.restore(), l || null);
  });
}
function IW(e, t, n) {
  return (e.interactive !== !1 || e.marktype === "group") && e.bounds && e.bounds.contains(t, n);
}
var BW = {
  type: "group",
  tag: "g",
  nested: !1,
  attr: FW,
  bound: TW,
  draw: PW,
  pick: zW,
  isect: XC,
  content: RW,
  background: MW,
  foreground: OW
}, Qc = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  version: "1.1"
};
function n$(e, t) {
  var n = e.image;
  return (!n || e.url && e.url !== n.url) && (n = {
    complete: !1,
    width: 0,
    height: 0
  }, t.loadImage(e.url).then((i) => {
    e.image = i, e.image.url = e.url;
  })), n;
}
function i$(e, t) {
  return e.width != null ? e.width : !t || !t.width ? 0 : e.aspect !== !1 && e.height ? e.height * t.width / t.height : t.width;
}
function r$(e, t) {
  return e.height != null ? e.height : !t || !t.height ? 0 : e.aspect !== !1 && e.width ? e.width * t.height / t.width : t.height;
}
function L0(e, t) {
  return e === "center" ? t / 2 : e === "right" ? t : 0;
}
function P0(e, t) {
  return e === "middle" ? t / 2 : e === "bottom" ? t : 0;
}
function jW(e, t, n) {
  const i = n$(t, n), r = i$(t, i), a = r$(t, i), s = (t.x || 0) - L0(t.align, r), o = (t.y || 0) - P0(t.baseline, a), u = !i.src && i.toDataURL ? i.toDataURL() : i.src || "";
  e("href", u, Qc["xmlns:xlink"], "xlink:href"), e("transform", Xs(s, o)), e("width", r), e("height", a), e("preserveAspectRatio", t.aspect === !1 ? "none" : "xMidYMid");
}
function UW(e, t) {
  const n = t.image, i = i$(t, n), r = r$(t, n), a = (t.x || 0) - L0(t.align, i), s = (t.y || 0) - P0(t.baseline, r);
  return e.set(a, s, a + i, s + r);
}
function qW(e, t, n) {
  dr(t, (i) => {
    if (n && !n.intersects(i.bounds))
      return;
    const r = n$(i, this);
    let a = i$(i, r), s = r$(i, r);
    if (a === 0 || s === 0)
      return;
    let o = (i.x || 0) - L0(i.align, a), u = (i.y || 0) - P0(i.baseline, s), l, c, f, d;
    i.aspect !== !1 && (c = r.width / r.height, f = i.width / i.height, c === c && f === f && c !== f && (f < c ? (d = a / c, u += (s - d) / 2, s = d) : (d = s * c, o += (a - d) / 2, a = d))), (r.complete || r.toDataURL) && (Eu(e, i), e.globalAlpha = (l = i.opacity) != null ? l : 1, e.imageSmoothingEnabled = i.smooth !== !1, e.drawImage(r, o, u, a, s));
  });
}
var GW = {
  type: "image",
  tag: "image",
  nested: !1,
  attr: jW,
  bound: UW,
  draw: qW,
  pick: N0(),
  isect: jt,
  // bounds check is sufficient
  get: n$,
  xOffset: L0,
  yOffset: P0
}, WW = t$("line", oW, AW);
function HW(e, t) {
  var n = t.scaleX || 1, i = t.scaleY || 1;
  (n !== 1 || i !== 1) && e("vector-effect", "non-scaling-stroke"), e("transform", wW(t)), e("d", t.path);
}
function Lh(e, t) {
  var n = t.path;
  if (n == null)
    return !0;
  var i = t.x || 0, r = t.y || 0, a = t.scaleX || 1, s = t.scaleY || 1, o = (t.angle || 0) * Ua, u = t.pathCache;
  (!u || u.path !== n) && ((t.pathCache = u = O0(n)).path = n), o && e.rotate && e.translate ? (e.translate(i, r), e.rotate(o), Kc(e, u, 0, 0, a, s), e.rotate(-o), e.translate(-i, -r)) : Kc(e, u, i, r, a, s);
}
function VW(e, t) {
  return Lh(D0(e, t.angle), t) ? e.set(0, 0, 0, 0) : os(e, t, !0);
}
var XW = {
  type: "path",
  tag: "path",
  nested: !1,
  attr: HW,
  bound: VW,
  draw: Jx(Lh),
  pick: Qx(Lh),
  isect: HC(Lh)
};
function YW(e, t) {
  e("d", fl(null, t));
}
function KW(e, t) {
  var n, i;
  return os(e.set(n = t.x || 0, i = t.y || 0, n + t.width || 0, i + t.height || 0), t);
}
function t6(e, t) {
  e.beginPath(), fl(e, t);
}
var JW = {
  type: "rect",
  tag: "path",
  nested: !1,
  attr: YW,
  bound: KW,
  draw: Jx(t6),
  pick: Qx(t6),
  isect: XC
};
function QW(e, t) {
  e("transform", QC(t)), e("x2", t.x2 != null ? t.x2 - (t.x || 0) : 0), e("y2", t.y2 != null ? t.y2 - (t.y || 0) : 0);
}
function ZW(e, t) {
  var n, i;
  return os(e.set(n = t.x || 0, i = t.y || 0, t.x2 != null ? t.x2 : n, t.y2 != null ? t.y2 : i), t);
}
function n_(e, t, n) {
  var i, r, a, s;
  return t.stroke && Su(e, t, n) ? (i = t.x || 0, r = t.y || 0, a = t.x2 != null ? t.x2 : i, s = t.y2 != null ? t.y2 : r, e.beginPath(), e.moveTo(i, r), e.lineTo(a, s), !0) : !1;
}
function eH(e, t, n) {
  dr(t, (i) => {
    if (!(n && !n.intersects(i.bounds))) {
      var r = i.opacity == null ? 1 : i.opacity;
      r && n_(e, i, r) && (Eu(e, i), e.stroke());
    }
  });
}
function tH(e, t, n, i) {
  return e.isPointInStroke ? n_(e, t, 1) && e.isPointInStroke(n, i) : !1;
}
var nH = {
  type: "rule",
  tag: "line",
  nested: !1,
  attr: QW,
  bound: ZW,
  draw: eH,
  pick: N0(tH),
  isect: gW
}, iH = e$("shape", uW), rH = e$("symbol", lW, VC);
const n6 = P2();
var sr = {
  height: ea,
  measureWidth: a$,
  estimateWidth: Cb,
  width: Cb,
  canvas: i_
};
i_(!0);
function i_(e) {
  sr.width = e && Na ? a$ : Cb;
}
function Cb(e, t) {
  return r_(qa(e, t), ea(e));
}
function r_(e, t) {
  return ~~(0.8 * e.length * t);
}
function a$(e, t) {
  return ea(e) <= 0 || !(t = qa(e, t)) ? 0 : a_(t, s$(e));
}
function a_(e, t) {
  const n = `(${t}) ${e}`;
  let i = n6.get(n);
  return i === void 0 && (Na.font = t, i = Na.measureText(e).width, n6.set(n, i)), i;
}
function ea(e) {
  return e.fontSize != null ? +e.fontSize || 0 : 11;
}
function ao(e) {
  return e.lineHeight != null ? e.lineHeight : ea(e) + 2;
}
function aH(e) {
  return R(e) ? e.length > 1 ? e : e[0] : e;
}
function rd(e) {
  return aH(e.lineBreak && e.text && !R(e.text) ? e.text.split(e.lineBreak) : e.text);
}
function s_(e) {
  const t = rd(e);
  return (R(t) ? t.length - 1 : 0) * ao(e);
}
function qa(e, t) {
  const n = t == null ? "" : (t + "").trim();
  return e.limit > 0 && n.length ? oH(e, n) : n;
}
function sH(e) {
  if (sr.width === a$) {
    const t = s$(e);
    return (n) => a_(n, t);
  } else {
    const t = ea(e);
    return (n) => r_(n, t);
  }
}
function oH(e, t) {
  var n = +e.limit, i = sH(e);
  if (i(t) < n)
    return t;
  var r = e.ellipsis || "", a = e.dir === "rtl", s = 0, o = t.length, u;
  if (n -= i(r), a) {
    for (; s < o; )
      u = s + o >>> 1, i(t.slice(u)) > n ? s = u + 1 : o = u;
    return r + t.slice(s);
  } else {
    for (; s < o; )
      u = 1 + (s + o >>> 1), i(t.slice(0, u)) < n ? s = u : o = u - 1;
    return t.slice(0, s) + r;
  }
}
function z0(e, t) {
  var n = e.font;
  return (t && n ? String(n).replace(/"/g, "'") : n) || "sans-serif";
}
function s$(e, t) {
  return (e.fontStyle ? e.fontStyle + " " : "") + (e.fontVariant ? e.fontVariant + " " : "") + (e.fontWeight ? e.fontWeight + " " : "") + ea(e) + "px " + z0(e, t);
}
function o$(e) {
  var t = e.baseline, n = ea(e);
  return Math.round(t === "top" ? 0.79 * n : t === "middle" ? 0.3 * n : t === "bottom" ? -0.21 * n : t === "line-top" ? 0.29 * n + 0.5 * ao(e) : t === "line-bottom" ? 0.29 * n - 0.5 * ao(e) : 0);
}
const uH = {
  left: "start",
  center: "middle",
  right: "end"
}, kc = new Ye();
function I0(e) {
  var t = e.x || 0, n = e.y || 0, i = e.radius || 0, r;
  return i && (r = (e.theta || 0) - Rs, t += i * Math.cos(r), n += i * Math.sin(r)), kc.x1 = t, kc.y1 = n, kc;
}
function lH(e, t) {
  var n = t.dx || 0, i = (t.dy || 0) + o$(t), r = I0(t), a = r.x1, s = r.y1, o = t.angle || 0, u;
  e("text-anchor", uH[t.align] || "start"), o ? (u = Xs(a, s) + " " + Zx(o), (n || i) && (u += " " + Xs(n, i))) : u = Xs(a + n, s + i), e("transform", u);
}
function u$(e, t, n) {
  var i = sr.height(t), r = t.align, a = I0(t), s = a.x1, o = a.y1, u = t.dx || 0, l = (t.dy || 0) + o$(t) - Math.round(0.8 * i), c = rd(t), f;
  if (R(c) ? (i += ao(t) * (c.length - 1), f = c.reduce((d, h) => Math.max(d, sr.width(t, h)), 0)) : f = sr.width(t, c), r === "center" ? u -= f / 2 : r === "right" && (u -= f), e.set(u += s, l += o, u + f, l + i), t.angle && !n)
    e.rotate(t.angle * Ua, s, o);
  else if (n === 2)
    return e.rotatedPoints(t.angle * Ua, s, o);
  return e;
}
function cH(e, t, n) {
  dr(t, (i) => {
    var r = i.opacity == null ? 1 : i.opacity, a, s, o, u, l, c, f;
    if (!(n && !n.intersects(i.bounds) || // bounds check
    r === 0 || i.fontSize <= 0 || i.text == null || i.text.length === 0)) {
      if (e.font = s$(i), e.textAlign = i.align || "left", a = I0(i), s = a.x1, o = a.y1, i.angle && (e.save(), e.translate(s, o), e.rotate(i.angle * Ua), s = o = 0), s += i.dx || 0, o += (i.dy || 0) + o$(i), c = rd(i), Eu(e, i), R(c))
        for (l = ao(i), u = 0; u < c.length; ++u)
          f = qa(i, c[u]), i.fill && Lp(e, i, r) && e.fillText(f, s, o), i.stroke && Su(e, i, r) && e.strokeText(f, s, o), o += l;
      else
        f = qa(i, c), i.fill && Lp(e, i, r) && e.fillText(f, s, o), i.stroke && Su(e, i, r) && e.strokeText(f, s, o);
      i.angle && e.restore();
    }
  });
}
function fH(e, t, n, i, r, a) {
  if (t.fontSize <= 0)
    return !1;
  if (!t.angle)
    return !0;
  var s = I0(t), o = s.x1, u = s.y1, l = u$(kc, t, 1), c = -t.angle * Ua, f = Math.cos(c), d = Math.sin(c), h = f * r - d * a + (o - f * o + d * u), p = d * r + f * a + (u - d * o - f * u);
  return l.contains(h, p);
}
function dH(e, t) {
  const n = u$(kc, e, 2);
  return dc(t, n[0], n[1], n[2], n[3]) || dc(t, n[0], n[1], n[4], n[5]) || dc(t, n[4], n[5], n[6], n[7]) || dc(t, n[2], n[3], n[6], n[7]);
}
var hH = {
  type: "text",
  tag: "text",
  nested: !1,
  attr: lH,
  bound: u$,
  draw: cH,
  pick: N0(fH),
  isect: dH
}, pH = t$("trail", cW, kW), ti = {
  arc: EW,
  area: CW,
  group: BW,
  image: GW,
  line: WW,
  path: XW,
  rect: JW,
  rule: nH,
  shape: iH,
  symbol: rH,
  text: hH,
  trail: pH
};
function i6(e, t, n) {
  var i = ti[e.mark.marktype], r = t || i.bound;
  return i.nested && (e = e.mark), r(e.bounds || (e.bounds = new Ye()), e, n);
}
var r6 = {
  mark: null
};
function gH(e, t, n) {
  var i = ti[e.marktype], r = i.bound, a = e.items, s = a && a.length, o, u, l, c;
  if (i.nested)
    return s ? l = a[0] : (r6.mark = e, l = r6), c = i6(l, r, n), t = t && t.union(c) || c, t;
  if (t = t || e.bounds && e.bounds.clear() || new Ye(), s)
    for (o = 0, u = a.length; o < u; ++o)
      t.union(i6(a[o], r, n));
  return e.bounds = t;
}
const mH = [
  "marktype",
  "name",
  "role",
  "interactive",
  "clip",
  "items",
  "zindex",
  "x",
  "y",
  "width",
  "height",
  "align",
  "baseline",
  // layout
  "fill",
  "fillOpacity",
  "opacity",
  "blend",
  // fill
  "stroke",
  "strokeOpacity",
  "strokeWidth",
  "strokeCap",
  // stroke
  "strokeDash",
  "strokeDashOffset",
  // stroke dash
  "strokeForeground",
  "strokeOffset",
  // group
  "startAngle",
  "endAngle",
  "innerRadius",
  "outerRadius",
  // arc
  "cornerRadius",
  "padAngle",
  // arc, rect
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  // rect, group
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight",
  "interpolate",
  "tension",
  "orient",
  "defined",
  // area, line
  "url",
  "aspect",
  "smooth",
  // image
  "path",
  "scaleX",
  "scaleY",
  // path
  "x2",
  "y2",
  // rule
  "size",
  "shape",
  // symbol
  "text",
  "angle",
  "theta",
  "radius",
  "dir",
  "dx",
  "dy",
  // text
  "ellipsis",
  "limit",
  "lineBreak",
  "lineHeight",
  "font",
  "fontSize",
  "fontWeight",
  "fontStyle",
  "fontVariant",
  // font
  "description",
  "aria",
  "ariaRole",
  "ariaRoleDescription"
  // aria
];
function yH(e, t) {
  return JSON.stringify(e, mH, t);
}
function bH(e) {
  const t = typeof e == "string" ? JSON.parse(e) : e;
  return o_(t);
}
function o_(e) {
  var t = e.marktype, n = e.items, i, r, a;
  if (n)
    for (r = 0, a = n.length; r < a; ++r)
      i = t ? "mark" : "group", n[r][i] = e, n[r].zindex && (n[r][i].zdirty = !0), (t || i) === "group" && o_(n[r]);
  return t && gH(e), e;
}
function u_(e) {
  arguments.length ? this.root = bH(e) : (this.root = l_({
    marktype: "group",
    name: "root",
    role: "frame"
  }), this.root.items = [new Kx(this.root)]);
}
u_.prototype = {
  toJSON(e) {
    return yH(this.root, e || 0);
  },
  mark(e, t, n) {
    t = t || this.root.items[0];
    const i = l_(e, t);
    return t.items[n] = i, i.zindex && (i.group.zdirty = !0), i;
  }
};
function l_(e, t) {
  const n = {
    bounds: new Ye(),
    clip: !!e.clip,
    group: t,
    interactive: e.interactive !== !1,
    items: [],
    marktype: e.marktype,
    name: e.name || void 0,
    role: e.role || void 0,
    zindex: e.zindex || 0
  };
  return e.aria != null && (n.aria = e.aria), e.description && (n.description = e.description), n;
}
function js(e, t, n) {
  return !e && typeof document < "u" && document.createElement && (e = document), e ? n ? e.createElementNS(n, t) : e.createElement(t) : null;
}
function c_(e, t) {
  t = t.toLowerCase();
  for (var n = e.childNodes, i = 0, r = n.length; i < r; ++i)
    if (n[i].tagName.toLowerCase() === t)
      return n[i];
}
function Mn(e, t, n, i) {
  var r = e.childNodes[t], a;
  return (!r || r.tagName.toLowerCase() !== n.toLowerCase()) && (a = r || null, r = js(e.ownerDocument, n, i), e.insertBefore(r, a)), r;
}
function nr(e, t) {
  for (var n = e.childNodes, i = n.length; i > t; )
    e.removeChild(n[--i]);
  return e;
}
function f_(e) {
  return "mark-" + e.marktype + (e.role ? " role-" + e.role : "") + (e.name ? " " + e.name : "");
}
function l$(e, t) {
  const n = t.getBoundingClientRect();
  return [e.clientX - n.left - (t.clientLeft || 0), e.clientY - n.top - (t.clientTop || 0)];
}
function vH(e, t, n, i) {
  var r = e && e.mark, a, s;
  if (r && (a = ti[r.marktype]).tip) {
    for (s = l$(t, n), s[0] -= i[0], s[1] -= i[1]; e = e.mark.group; )
      s[0] -= e.x || 0, s[1] -= e.y || 0;
    e = a.tip(r.items, s);
  }
  return e;
}
function so(e, t) {
  this._active = null, this._handlers = {}, this._loader = e || sl(), this._tooltip = t || xH;
}
function xH(e, t, n, i) {
  e.element().setAttribute("title", i || "");
}
so.prototype = {
  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(e, t, n) {
    return this._el = e, this._obj = n || null, this.origin(t);
  },
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },
  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(e) {
    return arguments.length ? (this._origin = e || [0, 0], this) : this._origin.slice();
  },
  /**
   * Get / set the scenegraph root.
   */
  scene(e) {
    return arguments.length ? (this._scene = e, this) : this._scene;
  },
  /**
   * Add an event handler. Subclasses should override this method.
   */
  on() {
  },
  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off() {
  },
  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(e, t, n) {
    for (let i = e ? e.length : 0; --i >= 0; )
      if (e[i].type === t && (!n || e[i].handler === n))
        return i;
    return -1;
  },
  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(e) {
    const t = this._handlers, n = [];
    if (e)
      n.push(...t[this.eventName(e)]);
    else
      for (const i in t)
        n.push(...t[i]);
    return n;
  },
  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(e) {
    const t = e.indexOf(".");
    return t < 0 ? e : e.slice(0, t);
  },
  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(e, t, n) {
    this._loader.sanitize(n, {
      context: "href"
    }).then((i) => {
      const r = new MouseEvent(e.type, e), a = js(null, "a");
      for (const s in i)
        a.setAttribute(s, i[s]);
      a.dispatchEvent(r);
    }).catch(() => {
    });
  },
  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(e, t, n) {
    if (t && t.tooltip != null) {
      t = vH(t, e, this.canvas(), this._origin);
      const i = n && t && t.tooltip || null;
      this._tooltip.call(this._obj, this, e, t, i);
    }
  },
  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(e) {
    const t = this.canvas();
    if (!t)
      return;
    const n = t.getBoundingClientRect(), i = this._origin, r = e.bounds, a = r.width(), s = r.height();
    let o = r.x1 + i[0] + n.left, u = r.y1 + i[1] + n.top;
    for (; e.mark && (e = e.mark.group); )
      o += e.x || 0, u += e.y || 0;
    return {
      x: o,
      y: u,
      width: a,
      height: s,
      left: o,
      top: u,
      right: o + a,
      bottom: u + s
    };
  }
};
function ta(e) {
  this._el = null, this._bgcolor = null, this._loader = new WC(e);
}
ta.prototype = {
  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(e, t, n, i, r) {
    return this._el = e, this.resize(t, n, i, r);
  },
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },
  /**
   * Get / set the background color.
   */
  background(e) {
    return arguments.length === 0 ? this._bgcolor : (this._bgcolor = e, this);
  },
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(e, t, n, i) {
    return this._width = e, this._height = t, this._origin = n || [0, 0], this._scale = i || 1, this;
  },
  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty() {
  },
  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @return {Renderer} - This renderer instance.
   */
  render(e) {
    const t = this;
    return t._call = function() {
      t._render(e);
    }, t._call(), t._call = null, t;
  },
  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render() {
  },
  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(e) {
    const t = this.render(e);
    return this._ready ? this._ready.then(() => t) : Promise.resolve(t);
  },
  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(e, t) {
    var n = this, i = n._loader[e](t);
    if (!n._ready) {
      const r = n._call;
      n._ready = n._loader.ready().then((a) => {
        a && r(), n._ready = null;
      });
    }
    return i;
  },
  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(e) {
    return this._load("sanitizeURL", e);
  },
  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(e) {
    return this._load("loadImage", e);
  }
};
const $H = "keydown", wH = "keypress", EH = "keyup", d_ = "dragenter", Ph = "dragleave", h_ = "dragover", _b = "mousedown", SH = "mouseup", Pp = "mousemove", Cc = "mouseout", p_ = "mouseover", zp = "click", AH = "dblclick", kH = "wheel", g_ = "mousewheel", Ip = "touchstart", Bp = "touchmove", jp = "touchend", CH = [$H, wH, EH, d_, Ph, h_, _b, SH, Pp, Cc, p_, zp, AH, kH, g_, Ip, Bp, jp], Fb = Pp, Zc = Cc, Mb = zp;
function B0(e, t) {
  so.call(this, e, t), this._down = null, this._touch = null, this._first = !0, this._events = {};
}
const _H = (e) => e === Ip || e === Bp || e === jp ? [Ip, Bp, jp] : [e];
function a6(e, t) {
  _H(t).forEach((n) => FH(e, n));
}
function FH(e, t) {
  const n = e.canvas();
  n && !e._events[t] && (e._events[t] = 1, n.addEventListener(t, e[t] ? (i) => e[t](i) : (i) => e.fire(t, i)));
}
function s6(e, t, n) {
  return function(i) {
    const r = this._active, a = this.pickEvent(i);
    a === r ? this.fire(e, i) : ((!r || !r.exit) && this.fire(n, i), this._active = a, this.fire(t, i), this.fire(e, i));
  };
}
function o6(e) {
  return function(t) {
    this.fire(e, t), this._active = null;
  };
}
B(B0, so, {
  initialize(e, t, n) {
    return this._canvas = e && c_(e, "canvas"), [zp, _b, Pp, Cc, Ph].forEach((i) => a6(this, i)), so.prototype.initialize.call(this, e, t, n);
  },
  // return the backing canvas instance
  canvas() {
    return this._canvas;
  },
  // retrieve the current canvas context
  context() {
    return this._canvas.getContext("2d");
  },
  // supported events
  events: CH,
  // to keep old versions of firefox happy
  DOMMouseScroll(e) {
    this.fire(g_, e);
  },
  mousemove: s6(Pp, p_, Cc),
  dragover: s6(h_, d_, Ph),
  mouseout: o6(Cc),
  dragleave: o6(Ph),
  mousedown(e) {
    this._down = this._active, this.fire(_b, e);
  },
  click(e) {
    this._down === this._active && (this.fire(zp, e), this._down = null);
  },
  touchstart(e) {
    this._touch = this.pickEvent(e.changedTouches[0]), this._first && (this._active = this._touch, this._first = !1), this.fire(Ip, e, !0);
  },
  touchmove(e) {
    this.fire(Bp, e, !0);
  },
  touchend(e) {
    this.fire(jp, e, !0), this._touch = null;
  },
  // fire an event
  fire(e, t, n) {
    const i = n ? this._touch : this._active, r = this._handlers[e];
    if (t.vegaType = e, e === Mb && i && i.href ? this.handleHref(t, i, i.href) : (e === Fb || e === Zc) && this.handleTooltip(t, i, e !== Zc), r)
      for (let a = 0, s = r.length; a < s; ++a)
        r[a].handler.call(this._obj, t, i);
  },
  // add an event handler
  on(e, t) {
    const n = this.eventName(e), i = this._handlers;
    return this._handlerIndex(i[n], e, t) < 0 && (a6(this, e), (i[n] || (i[n] = [])).push({
      type: e,
      handler: t
    })), this;
  },
  // remove an event handler
  off(e, t) {
    const n = this.eventName(e), i = this._handlers[n], r = this._handlerIndex(i, e, t);
    return r >= 0 && i.splice(r, 1), this;
  },
  pickEvent(e) {
    const t = l$(e, this._canvas), n = this._origin;
    return this.pick(this._scene, t[0], t[1], t[0] - n[0], t[1] - n[1]);
  },
  // find the scenegraph item at the current mouse position
  // x, y -- the absolute x, y mouse coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(e, t, n, i, r) {
    const a = this.context();
    return ti[e.marktype].pick.call(this, a, e, t, n, i, r);
  }
});
function MH() {
  return typeof window < "u" && window.devicePixelRatio || 1;
}
var OH = MH();
function RH(e, t, n, i, r, a) {
  const s = typeof HTMLElement < "u" && e instanceof HTMLElement && e.parentNode != null, o = e.getContext("2d"), u = s ? OH : r;
  e.width = t * u, e.height = n * u;
  for (const l in a)
    o[l] = a[l];
  return s && u !== 1 && (e.style.width = t + "px", e.style.height = n + "px"), o.pixelRatio = u, o.setTransform(u, 0, 0, u, u * i[0], u * i[1]), e;
}
function Ob(e) {
  ta.call(this, e), this._options = {}, this._redraw = !1, this._dirty = new Ye(), this._tempb = new Ye();
}
const u6 = ta.prototype, TH = (e, t, n) => new Ye().set(0, 0, t, n).translate(-e[0], -e[1]);
function DH(e, t, n) {
  return t.expand(1).round(), e.pixelRatio % 1 && t.scale(e.pixelRatio).round().scale(1 / e.pixelRatio), t.translate(-(n[0] % 1), -(n[1] % 1)), e.beginPath(), e.rect(t.x1, t.y1, t.width(), t.height()), e.clip(), t;
}
B(Ob, ta, {
  initialize(e, t, n, i, r, a) {
    return this._options = a || {}, this._canvas = this._options.externalContext ? null : Ei(1, 1, this._options.type), e && this._canvas && (nr(e, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), u6.initialize.call(this, e, t, n, i, r);
  },
  resize(e, t, n, i) {
    if (u6.resize.call(this, e, t, n, i), this._canvas)
      RH(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    else {
      const r = this._options.externalContext;
      r || D("CanvasRenderer is missing a valid canvas or context"), r.scale(this._scale, this._scale), r.translate(this._origin[0], this._origin[1]);
    }
    return this._redraw = !0, this;
  },
  canvas() {
    return this._canvas;
  },
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
  },
  dirty(e) {
    const t = this._tempb.clear().union(e.bounds);
    let n = e.mark.group;
    for (; n; )
      t.translate(n.x || 0, n.y || 0), n = n.mark.group;
    this._dirty.union(t);
  },
  _render(e) {
    const t = this.context(), n = this._origin, i = this._width, r = this._height, a = this._dirty, s = TH(n, i, r);
    t.save();
    const o = this._redraw || a.empty() ? (this._redraw = !1, s.expand(1)) : DH(t, s.intersect(a), n);
    return this.clear(-n[0], -n[1], i, r), this.draw(t, e, o), t.restore(), a.clear(), this;
  },
  draw(e, t, n) {
    const i = ti[t.marktype];
    t.clip && _W(e, t), i.draw.call(this, e, t, n), t.clip && e.restore();
  },
  clear(e, t, n, i) {
    const r = this._options, a = this.context();
    r.type !== "pdf" && !r.externalContext && a.clearRect(e, t, n, i), this._bgcolor != null && (a.fillStyle = this._bgcolor, a.fillRect(e, t, n, i));
  }
});
function m_(e, t) {
  so.call(this, e, t);
  const n = this;
  n._hrefHandler = Rb(n, (i, r) => {
    r && r.href && n.handleHref(i, r, r.href);
  }), n._tooltipHandler = Rb(n, (i, r) => {
    n.handleTooltip(i, r, i.type !== Zc);
  });
}
const Rb = (e, t) => (n) => {
  let i = n.target.__data__;
  i = Array.isArray(i) ? i[0] : i, n.vegaType = n.type, t.call(e._obj, n, i);
};
B(m_, so, {
  initialize(e, t, n) {
    let i = this._svg;
    return i && (i.removeEventListener(Mb, this._hrefHandler), i.removeEventListener(Fb, this._tooltipHandler), i.removeEventListener(Zc, this._tooltipHandler)), this._svg = i = e && c_(e, "svg"), i && (i.addEventListener(Mb, this._hrefHandler), i.addEventListener(Fb, this._tooltipHandler), i.addEventListener(Zc, this._tooltipHandler)), so.prototype.initialize.call(this, e, t, n);
  },
  canvas() {
    return this._svg;
  },
  // add an event handler
  on(e, t) {
    const n = this.eventName(e), i = this._handlers;
    if (this._handlerIndex(i[n], e, t) < 0) {
      const a = {
        type: e,
        handler: t,
        listener: Rb(this, t)
      };
      (i[n] || (i[n] = [])).push(a), this._svg && this._svg.addEventListener(n, a.listener);
    }
    return this;
  },
  // remove an event handler
  off(e, t) {
    const n = this.eventName(e), i = this._handlers[n], r = this._handlerIndex(i, e, t);
    return r >= 0 && (this._svg && this._svg.removeEventListener(n, i[r].listener), i.splice(r, 1)), this;
  }
});
const y_ = "aria-hidden", c$ = "aria-label", f$ = "role", d$ = "aria-roledescription", b_ = "graphics-object", h$ = "graphics-symbol", v_ = (e, t, n) => ({
  [f$]: e,
  [d$]: t,
  [c$]: n || void 0
}), NH = an(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]), l6 = {
  axis: {
    desc: "axis",
    caption: zH
  },
  legend: {
    desc: "legend",
    caption: IH
  },
  "title-text": {
    desc: "title",
    caption: (e) => `Title text '${f6(e)}'`
  },
  "title-subtitle": {
    desc: "subtitle",
    caption: (e) => `Subtitle text '${f6(e)}'`
  }
}, c6 = {
  ariaRole: f$,
  ariaRoleDescription: d$,
  description: c$
};
function x_(e, t) {
  const n = t.aria === !1;
  if (e(y_, n || void 0), n || t.description == null)
    for (const i in c6)
      e(c6[i], void 0);
  else {
    const i = t.mark.marktype;
    e(c$, t.description), e(f$, t.ariaRole || (i === "group" ? b_ : h$)), e(d$, t.ariaRoleDescription || `${i} mark`);
  }
}
function $_(e) {
  return e.aria === !1 ? {
    [y_]: !0
  } : NH[e.role] ? null : l6[e.role] ? PH(e, l6[e.role]) : LH(e);
}
function LH(e) {
  const t = e.marktype, n = t === "group" || t === "text" || e.items.some((i) => i.description != null && i.aria !== !1);
  return v_(n ? b_ : h$, `${t} mark container`, e.description);
}
function PH(e, t) {
  try {
    const n = e.items[0], i = t.caption || (() => "");
    return v_(t.role || h$, t.desc, n.description || i(n));
  } catch {
    return null;
  }
}
function f6(e) {
  return G(e.text).join(" ");
}
function zH(e) {
  const t = e.datum, n = e.orient, i = t.title ? w_(e) : null, r = e.context, a = r.scales[t.scale].value, s = r.dataflow.locale(), o = a.type;
  return `${n === "left" || n === "right" ? "Y" : "X"}-axis` + (i ? ` titled '${i}'` : "") + ` for a ${CC(o) ? "discrete" : o} scale with ${BC(s, a, e)}`;
}
function IH(e) {
  const t = e.datum, n = t.title ? w_(e) : null, i = `${t.type || ""} legend`.trim(), r = t.scales, a = Object.keys(r), s = e.context, o = s.scales[r[a[0]]].value, u = s.dataflow.locale();
  return jH(i) + (n ? ` titled '${n}'` : "") + ` for ${BH(a)} with ${BC(u, o, e)}`;
}
function w_(e) {
  try {
    return G(ae(e.items).items[0].text).join(" ");
  } catch {
    return null;
  }
}
function BH(e) {
  return e = e.map((t) => t + (t === "fill" || t === "stroke" ? " color" : "")), e.length < 2 ? e[0] : e.slice(0, -1).join(", ") + " and " + ae(e);
}
function jH(e) {
  return e.length ? e[0].toUpperCase() + e.slice(1) : e;
}
const E_ = (e) => (e + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), UH = (e) => E_(e).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function S_() {
  let e = "", t = "", n = "";
  const i = [], r = () => t = n = "", a = (u) => {
    t && (e += `${t}>${n}`, r()), i.push(u);
  }, s = (u, l) => (l != null && (t += ` ${u}="${UH(l)}"`), o), o = {
    open(u) {
      a(u), t = "<" + u;
      for (var l = arguments.length, c = new Array(l > 1 ? l - 1 : 0), f = 1; f < l; f++)
        c[f - 1] = arguments[f];
      for (const d of c)
        for (const h in d)
          s(h, d[h]);
      return o;
    },
    close() {
      const u = i.pop();
      return t ? e += t + (n ? `>${n}</${u}>` : "/>") : e += `</${u}>`, r(), o;
    },
    attr: s,
    text: (u) => (n += E_(u), o),
    toString: () => e
  };
  return o;
}
const qH = (e) => A_(S_(), e) + "";
function A_(e, t) {
  if (e.open(t.tagName), t.hasAttributes()) {
    const n = t.attributes, i = n.length;
    for (let r = 0; r < i; ++r)
      e.attr(n[r].name, n[r].value);
  }
  if (t.hasChildNodes()) {
    const n = t.childNodes;
    for (const i of n)
      i.nodeType === 3 ? e.text(i.nodeValue) : A_(e, i);
  }
  return e.close();
}
const Up = {
  fill: "fill",
  fillOpacity: "fill-opacity",
  stroke: "stroke",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  strokeCap: "stroke-linecap",
  strokeJoin: "stroke-linejoin",
  strokeDash: "stroke-dasharray",
  strokeDashOffset: "stroke-dashoffset",
  strokeMiterLimit: "stroke-miterlimit",
  opacity: "opacity"
}, qp = {
  blend: "mix-blend-mode"
}, k_ = {
  fill: "none",
  "stroke-miterlimit": 10
}, Nl = 0, d6 = "http://www.w3.org/2000/xmlns/", Ze = Qc.xmlns;
function C_(e) {
  ta.call(this, e), this._dirtyID = 0, this._dirty = [], this._svg = null, this._root = null, this._defs = null;
}
const D1 = ta.prototype;
B(C_, ta, {
  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(e, t, n, i, r) {
    return this._defs = {}, this._clearDefs(), e && (this._svg = Mn(e, 0, "svg", Ze), this._svg.setAttributeNS(d6, "xmlns", Ze), this._svg.setAttributeNS(d6, "xmlns:xlink", Qc["xmlns:xlink"]), this._svg.setAttribute("version", Qc.version), this._svg.setAttribute("class", "marks"), nr(e, 1), this._root = Mn(this._svg, Nl, "g", Ze), ka(this._root, k_), nr(this._svg, Nl + 1)), this.background(this._bgcolor), D1.initialize.call(this, e, t, n, i, r);
  },
  /**
   * Get / set the background color.
   */
  background(e) {
    return arguments.length && this._svg && this._svg.style.setProperty("background-color", e), D1.background.apply(this, arguments);
  },
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(e, t, n, i) {
    return D1.resize.call(this, e, t, n, i), this._svg && (ka(this._svg, {
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }), this._root.setAttribute("transform", `translate(${this._origin})`)), this._dirty = [], this;
  },
  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  },
  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const e = this._svg, t = this._bgcolor;
    if (!e)
      return null;
    let n;
    t && (e.removeAttribute("style"), n = Mn(e, Nl, "rect", Ze), ka(n, {
      width: this._width,
      height: this._height,
      fill: t
    }));
    const i = qH(e);
    return t && (e.removeChild(n), this._svg.style.setProperty("background-color", t)), i;
  },
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(e) {
    return this._dirtyCheck() && (this._dirtyAll && this._clearDefs(), this.mark(this._root, e), nr(this._root, 1)), this.defs(), this._dirty = [], ++this._dirtyID, this;
  },
  // -- Manage rendering of items marked as dirty --
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(e) {
    e.dirty !== this._dirtyID && (e.dirty = this._dirtyID, this._dirty.push(e));
  },
  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(e) {
    return this._dirtyAll || !e._svg || !e._svg.ownerSVGElement || e.dirty === this._dirtyID;
  },
  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = !0;
    const e = this._dirty;
    if (!e.length || !this._dirtyID)
      return !0;
    const t = ++this._dirtyID;
    let n, i, r, a, s, o, u;
    for (s = 0, o = e.length; s < o; ++s)
      if (n = e[s], i = n.mark, i.marktype !== r && (r = i.marktype, a = ti[r]), i.zdirty && i.dirty !== t && (this._dirtyAll = !1, h6(n, t), i.items.forEach((l) => {
        l.dirty = t;
      })), !i.zdirty) {
        if (n.exit) {
          a.nested && i.items.length ? (u = i.items[0], u._svg && this._update(a, u._svg, u)) : n._svg && (u = n._svg.parentNode, u && u.removeChild(n._svg)), n._svg = null;
          continue;
        }
        n = a.nested ? i.items[0] : n, n._update !== t && (!n._svg || !n._svg.ownerSVGElement ? (this._dirtyAll = !1, h6(n, t)) : this._update(a, n._svg, n), n._update = t);
      }
    return !this._dirtyAll;
  },
  // -- Construct & maintain scenegraph to SVG mapping ---
  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   */
  mark(e, t, n) {
    if (!this.isDirty(t))
      return t._svg;
    const i = this._svg, r = ti[t.marktype], a = t.interactive === !1 ? "none" : null, s = r.tag === "g", o = p6(t, e, n, "g", i);
    o.setAttribute("class", f_(t));
    const u = $_(t);
    for (const d in u)
      Wt(o, d, u[d]);
    s || Wt(o, "pointer-events", a), Wt(o, "clip-path", t.clip ? Xx(this, t, t.group) : null);
    let l = null, c = 0;
    const f = (d) => {
      const h = this.isDirty(d), p = p6(d, o, l, r.tag, i);
      h && (this._update(r, p, d), s && HH(this, p, d)), l = p, ++c;
    };
    return r.nested ? t.items.length && f(t.items[0]) : dr(t, f), nr(o, c), o;
  },
  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(e, t, n) {
    Ir = t, Rt = t.__values__, x_(_c, n), e.attr(_c, n, this);
    const i = XH[e.type];
    i && i.call(this, e, t, n), Ir && this.style(Ir, n);
  },
  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(e, t) {
    if (t != null) {
      for (const n in Up) {
        let i = n === "font" ? z0(t) : t[n];
        if (i === Rt[n])
          continue;
        const r = Up[n];
        i == null ? e.removeAttribute(r) : (Hx(i) && (i = jC(i, this._defs.gradient, __())), e.setAttribute(r, i + "")), Rt[n] = i;
      }
      for (const n in qp)
        zh(e, qp[n], t[n]);
    }
  },
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const e = this._svg, t = this._defs;
    let n = t.el, i = 0;
    for (const r in t.gradient)
      n || (t.el = n = Mn(e, Nl + 1, "defs", Ze)), i = GH(n, t.gradient[r], i);
    for (const r in t.clipping)
      n || (t.el = n = Mn(e, Nl + 1, "defs", Ze)), i = WH(n, t.clipping[r], i);
    n && (i === 0 ? (e.removeChild(n), t.el = null) : nr(n, i));
  },
  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const e = this._defs;
    e.gradient = {}, e.clipping = {};
  }
});
function h6(e, t) {
  for (; e && e.dirty !== t; e = e.mark.group)
    if (e.dirty = t, e.mark && e.mark.dirty !== t)
      e.mark.dirty = t;
    else
      return;
}
function GH(e, t, n) {
  let i, r, a;
  if (t.gradient === "radial") {
    let s = Mn(e, n++, "pattern", Ze);
    ka(s, {
      id: Np + t.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    }), s = Mn(s, 0, "rect", Ze), ka(s, {
      width: 1,
      height: 1,
      fill: `url(${__()}#${t.id})`
    }), e = Mn(e, n++, "radialGradient", Ze), ka(e, {
      id: t.id,
      fx: t.x1,
      fy: t.y1,
      fr: t.r1,
      cx: t.x2,
      cy: t.y2,
      r: t.r2
    });
  } else
    e = Mn(e, n++, "linearGradient", Ze), ka(e, {
      id: t.id,
      x1: t.x1,
      x2: t.x2,
      y1: t.y1,
      y2: t.y2
    });
  for (i = 0, r = t.stops.length; i < r; ++i)
    a = Mn(e, i, "stop", Ze), a.setAttribute("offset", t.stops[i].offset), a.setAttribute("stop-color", t.stops[i].color);
  return nr(e, i), n;
}
function WH(e, t, n) {
  let i;
  return e = Mn(e, n, "clipPath", Ze), e.setAttribute("id", t.id), t.path ? (i = Mn(e, 0, "path", Ze), i.setAttribute("d", t.path)) : (i = Mn(e, 0, "rect", Ze), ka(i, {
    x: 0,
    y: 0,
    width: t.width,
    height: t.height
  })), nr(e, 1), n + 1;
}
function HH(e, t, n) {
  t = t.lastChild.previousSibling;
  let i, r = 0;
  dr(n, (a) => {
    i = e.mark(t, a, i), ++r;
  }), nr(t, 1 + r);
}
function p6(e, t, n, i, r) {
  let a = e._svg, s;
  if (!a && (s = t.ownerDocument, a = js(s, i, Ze), e._svg = a, e.mark && (a.__data__ = e, a.__values__ = {
    fill: "default"
  }, i === "g"))) {
    const o = js(s, "path", Ze);
    a.appendChild(o), o.__data__ = e;
    const u = js(s, "g", Ze);
    a.appendChild(u), u.__data__ = e;
    const l = js(s, "path", Ze);
    a.appendChild(l), l.__data__ = e, l.__values__ = {
      fill: "default"
    };
  }
  return (a.ownerSVGElement !== r || VH(a, n)) && t.insertBefore(a, n ? n.nextSibling : t.firstChild), a;
}
function VH(e, t) {
  return e.parentNode && e.parentNode.childNodes.length > 1 && e.previousSibling != t;
}
let Ir = null, Rt = null;
const XH = {
  group(e, t, n) {
    const i = Ir = t.childNodes[2];
    Rt = i.__values__, e.foreground(_c, n, this), Rt = t.__values__, Ir = t.childNodes[1], e.content(_c, n, this);
    const r = Ir = t.childNodes[0];
    e.background(_c, n, this);
    const a = n.mark.interactive === !1 ? "none" : null;
    if (a !== Rt.events && (Wt(i, "pointer-events", a), Wt(r, "pointer-events", a), Rt.events = a), n.strokeForeground && n.stroke) {
      const s = n.fill;
      Wt(i, "display", null), this.style(r, n), Wt(r, "stroke", null), s && (n.fill = null), Rt = i.__values__, this.style(i, n), s && (n.fill = s), Ir = null;
    } else
      Wt(i, "display", "none");
  },
  image(e, t, n) {
    n.smooth === !1 ? (zh(t, "image-rendering", "optimizeSpeed"), zh(t, "image-rendering", "pixelated")) : zh(t, "image-rendering", null);
  },
  text(e, t, n) {
    const i = rd(n);
    let r, a, s, o;
    R(i) ? (a = i.map((u) => qa(n, u)), r = a.join(`
`), r !== Rt.text && (nr(t, 0), s = t.ownerDocument, o = ao(n), a.forEach((u, l) => {
      const c = js(s, "tspan", Ze);
      c.__data__ = n, c.textContent = u, l && (c.setAttribute("x", 0), c.setAttribute("dy", o)), t.appendChild(c);
    }), Rt.text = r)) : (a = qa(n, i), a !== Rt.text && (t.textContent = a, Rt.text = a)), Wt(t, "font-family", z0(n)), Wt(t, "font-size", ea(n) + "px"), Wt(t, "font-style", n.fontStyle), Wt(t, "font-variant", n.fontVariant), Wt(t, "font-weight", n.fontWeight);
  }
};
function _c(e, t, n) {
  t !== Rt[e] && (n ? YH(Ir, e, t, n) : Wt(Ir, e, t), Rt[e] = t);
}
function zh(e, t, n) {
  n !== Rt[t] && (n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n + ""), Rt[t] = n);
}
function ka(e, t) {
  for (const n in t)
    Wt(e, n, t[n]);
}
function Wt(e, t, n) {
  n != null ? e.setAttribute(t, n) : e.removeAttribute(t);
}
function YH(e, t, n, i) {
  n != null ? e.setAttributeNS(i, t, n) : e.removeAttributeNS(i, t);
}
function __() {
  let e;
  return typeof window > "u" ? "" : (e = window.location).hash ? e.href.slice(0, -e.hash.length) : e.href;
}
function F_(e) {
  ta.call(this, e), this._text = null, this._defs = {
    gradient: {},
    clipping: {}
  };
}
B(F_, ta, {
  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  },
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(e) {
    const t = S_();
    t.open("svg", ue({}, Qc, {
      class: "marks",
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }));
    const n = this._bgcolor;
    return n && n !== "transparent" && n !== "none" && t.open("rect", {
      width: this._width,
      height: this._height,
      fill: n
    }).close(), t.open("g", k_, {
      transform: "translate(" + this._origin + ")"
    }), this.mark(t, e), t.close(), this.defs(t), this._text = t.close() + "", this;
  },
  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(e, t) {
    const n = ti[t.marktype], i = n.tag, r = [x_, n.attr];
    e.open("g", {
      class: f_(t),
      "clip-path": t.clip ? Xx(this, t, t.group) : null
    }, $_(t), {
      "pointer-events": i !== "g" && t.interactive === !1 ? "none" : null
    });
    const a = (s) => {
      const o = this.href(s);
      if (o && e.open("a", o), e.open(i, this.attr(t, s, r, i !== "g" ? i : null)), i === "text") {
        const u = rd(s);
        if (R(u)) {
          const l = {
            x: 0,
            dy: ao(s)
          };
          for (let c = 0; c < u.length; ++c)
            e.open("tspan", c ? l : null).text(qa(s, u[c])).close();
        } else
          e.text(qa(s, u));
      } else if (i === "g") {
        const u = s.strokeForeground, l = s.fill, c = s.stroke;
        u && c && (s.stroke = null), e.open("path", this.attr(t, s, n.background, "bgrect")).close(), e.open("g", this.attr(t, s, n.content)), dr(s, (f) => this.mark(e, f)), e.close(), u && c ? (l && (s.fill = null), s.stroke = c, e.open("path", this.attr(t, s, n.foreground, "bgrect")).close(), l && (s.fill = l)) : e.open("path", this.attr(t, s, n.foreground, "bgfore")).close();
      }
      e.close(), o && e.close();
    };
    return n.nested ? t.items && t.items.length && a(t.items[0]) : dr(t, a), e.close();
  },
  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(e) {
    const t = e.href;
    let n;
    if (t) {
      if (n = this._hrefs && this._hrefs[t])
        return n;
      this.sanitizeURL(t).then((i) => {
        i["xlink:href"] = i.href, i.href = null, (this._hrefs || (this._hrefs = {}))[t] = i;
      });
    }
    return null;
  },
  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(e, t, n, i) {
    const r = {}, a = (s, o, u, l) => {
      r[l || s] = o;
    };
    return Array.isArray(n) ? n.forEach((s) => s(a, t, this)) : n(a, t, this), i && KH(r, t, e, i, this._defs), r;
  },
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(e) {
    const t = this._defs.gradient, n = this._defs.clipping;
    if (Object.keys(t).length + Object.keys(n).length !== 0) {
      e.open("defs");
      for (const r in t) {
        const a = t[r], s = a.stops;
        a.gradient === "radial" ? (e.open("pattern", {
          id: Np + r,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        }), e.open("rect", {
          width: "1",
          height: "1",
          fill: "url(#" + r + ")"
        }).close(), e.close(), e.open("radialGradient", {
          id: r,
          fx: a.x1,
          fy: a.y1,
          fr: a.r1,
          cx: a.x2,
          cy: a.y2,
          r: a.r2
        })) : e.open("linearGradient", {
          id: r,
          x1: a.x1,
          x2: a.x2,
          y1: a.y1,
          y2: a.y2
        });
        for (let o = 0; o < s.length; ++o)
          e.open("stop", {
            offset: s[o].offset,
            "stop-color": s[o].color
          }).close();
        e.close();
      }
      for (const r in n) {
        const a = n[r];
        e.open("clipPath", {
          id: r
        }), a.path ? e.open("path", {
          d: a.path
        }).close() : e.open("rect", {
          x: 0,
          y: 0,
          width: a.width,
          height: a.height
        }).close(), e.close();
      }
      e.close();
    }
  }
});
function KH(e, t, n, i, r) {
  let a;
  if (t == null || (i === "bgrect" && n.interactive === !1 && (e["pointer-events"] = "none"), i === "bgfore" && (n.interactive === !1 && (e["pointer-events"] = "none"), e.display = "none", t.fill !== null)))
    return e;
  i === "image" && t.smooth === !1 && (a = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"]), i === "text" && (e["font-family"] = z0(t), e["font-size"] = ea(t) + "px", e["font-style"] = t.fontStyle, e["font-variant"] = t.fontVariant, e["font-weight"] = t.fontWeight);
  for (const s in Up) {
    let o = t[s];
    const u = Up[s];
    o === "transparent" && (u === "fill" || u === "stroke") || o != null && (Hx(o) && (o = jC(o, r.gradient, "")), e[u] = o);
  }
  for (const s in qp) {
    const o = t[s];
    o != null && (a = a || [], a.push(`${qp[s]}: ${o};`));
  }
  return a && (e.style = a.join(" ")), e;
}
const M_ = "canvas", O_ = "png", R_ = "svg", T_ = "none", Us = {
  Canvas: M_,
  PNG: O_,
  SVG: R_,
  None: T_
}, Au = {};
Au[M_] = Au[O_] = {
  renderer: Ob,
  headless: Ob,
  handler: B0
};
Au[R_] = {
  renderer: C_,
  headless: F_,
  handler: m_
};
Au[T_] = {};
function p$(e, t) {
  return e = String(e || "").toLowerCase(), arguments.length > 1 ? (Au[e] = t, this) : Au[e];
}
function D_(e, t, n) {
  const i = [], r = new Ye().union(t), a = e.marktype;
  return a ? N_(e, r, n, i) : a === "group" ? L_(e, r, n, i) : D("Intersect scene must be mark node or group item.");
}
function N_(e, t, n, i) {
  if (JH(e, t, n)) {
    const r = e.items, a = e.marktype, s = r.length;
    let o = 0;
    if (a === "group")
      for (; o < s; ++o)
        L_(r[o], t, n, i);
    else
      for (const u = ti[a].isect; o < s; ++o) {
        const l = r[o];
        P_(l, t, u) && i.push(l);
      }
  }
  return i;
}
function JH(e, t, n) {
  return e.bounds && t.intersects(e.bounds) && (e.marktype === "group" || e.interactive !== !1 && (!n || n(e)));
}
function L_(e, t, n, i) {
  n && n(e.mark) && P_(e, t, ti.group.isect) && i.push(e);
  const r = e.items, a = r && r.length;
  if (a) {
    const s = e.x || 0, o = e.y || 0;
    t.translate(-s, -o);
    for (let u = 0; u < a; ++u)
      N_(r[u], t, n, i);
    t.translate(s, o);
  }
  return i;
}
function P_(e, t, n) {
  const i = e.bounds;
  return t.encloses(i) || t.intersects(i) && n(e, t);
}
const N1 = new Ye();
function QH(e) {
  const t = e.clip;
  if (oe(t))
    t(D0(N1.clear()));
  else if (t)
    N1.set(0, 0, e.group.width, e.group.height);
  else
    return;
  e.bounds.intersect(N1);
}
const ku = "top", mi = "left", vi = "right", Ga = "bottom", ZH = "top-left", eV = "top-right", tV = "bottom-left", nV = "bottom-right", g$ = "start", Tb = "middle", Vt = "end", iV = "x", rV = "y", j0 = "group", m$ = "axis", y$ = "title", aV = "frame", sV = "scope", b$ = "legend", z_ = "row-header", I_ = "row-footer", B_ = "row-title", j_ = "column-header", U_ = "column-footer", q_ = "column-title", oV = "padding", uV = "symbol", G_ = "fit", W_ = "fit-x", H_ = "fit-y", lV = "pad", v$ = "none", nh = "all", Db = "each", x$ = "flush", Ca = "column", _a = "row";
function V_(e) {
  T.call(this, null, e);
}
B(V_, T, {
  transform(e, t) {
    const n = t.dataflow, i = e.mark, r = i.marktype, a = ti[r], s = a.bound;
    let o = i.bounds, u;
    if (a.nested)
      i.items.length && n.dirty(i.items[0]), o = ih(i, s), i.items.forEach((l) => {
        l.bounds.clear().union(o);
      });
    else if (r === j0 || e.modified())
      switch (t.visit(t.MOD, (l) => n.dirty(l)), o.clear(), i.items.forEach((l) => o.union(ih(l, s))), i.role) {
        case m$:
        case b$:
        case y$:
          t.reflow();
      }
    else
      u = t.changed(t.REM), t.visit(t.ADD, (l) => {
        o.union(ih(l, s));
      }), t.visit(t.MOD, (l) => {
        u = u || o.alignsWith(l.bounds), n.dirty(l), o.union(ih(l, s));
      }), u && (o.clear(), i.items.forEach((l) => o.union(l.bounds)));
    return QH(i), t.modifies("bounds");
  }
});
function ih(e, t, n) {
  return t(e.bounds.clear(), e, n);
}
const g6 = ":vega_identifier:";
function $$(e) {
  T.call(this, 0, e);
}
$$.Definition = {
  type: "Identifier",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "as",
    type: "string",
    required: !0
  }]
};
B($$, T, {
  transform(e, t) {
    const n = cV(t.dataflow), i = e.as;
    let r = n.value;
    return t.visit(t.ADD, (a) => a[i] = a[i] || ++r), n.set(this.value = r), t;
  }
});
function cV(e) {
  return e._signals[g6] || (e._signals[g6] = e.add(0));
}
function X_(e) {
  T.call(this, null, e);
}
B(X_, T, {
  transform(e, t) {
    let n = this.value;
    n || (n = t.dataflow.scenegraph().mark(e.markdef, fV(e), e.index), n.group.context = e.context, e.context.group || (e.context.group = n.group), n.source = this.source, n.clip = e.clip, n.interactive = e.interactive, this.value = n);
    const i = n.marktype === j0 ? Kx : Yx;
    return t.visit(t.ADD, (r) => i.call(r, n)), (e.modified("clip") || e.modified("interactive")) && (n.clip = e.clip, n.interactive = !!e.interactive, n.zdirty = !0, t.reflow()), n.items = t.source, t;
  }
});
function fV(e) {
  const t = e.groups, n = e.parent;
  return t && t.size === 1 ? t.get(Object.keys(t.object)[0]) : t && n ? t.lookup(n) : null;
}
function Y_(e) {
  T.call(this, null, e);
}
const m6 = {
  parity: (e) => e.filter((t, n) => n % 2 ? t.opacity = 0 : 1),
  greedy: (e, t) => {
    let n;
    return e.filter((i, r) => !r || !K_(n.bounds, i.bounds, t) ? (n = i, 1) : i.opacity = 0);
  }
}, K_ = (e, t, n) => n > Math.max(t.x1 - e.x2, e.x1 - t.x2, t.y1 - e.y2, e.y1 - t.y2), y6 = (e, t) => {
  for (var n = 1, i = e.length, r = e[0].bounds, a; n < i; r = a, ++n)
    if (K_(r, a = e[n].bounds, t))
      return !0;
}, dV = (e) => {
  const t = e.bounds;
  return t.width() > 1 && t.height() > 1;
}, hV = (e, t, n) => {
  var i = e.range(), r = new Ye();
  return t === ku || t === Ga ? r.set(i[0], -1 / 0, i[1], 1 / 0) : r.set(-1 / 0, i[0], 1 / 0, i[1]), r.expand(n || 1), (a) => r.encloses(a.bounds);
}, b6 = (e) => (e.forEach((t) => t.opacity = 1), e), v6 = (e, t) => e.reflow(t.modified()).modifies("opacity");
B(Y_, T, {
  transform(e, t) {
    const n = m6[e.method] || m6.parity, i = e.separation || 0;
    let r = t.materialize(t.SOURCE).source, a, s;
    if (!r || !r.length)
      return;
    if (!e.method)
      return e.modified("method") && (b6(r), t = v6(t, e)), t;
    if (r = r.filter(dV), !r.length)
      return;
    if (e.sort && (r = r.slice().sort(e.sort)), a = b6(r), t = v6(t, e), a.length >= 3 && y6(a, i)) {
      do
        a = n(a, i);
      while (a.length >= 3 && y6(a, i));
      a.length < 3 && !ae(r).opacity && (a.length > 1 && (ae(a).opacity = 0), ae(r).opacity = 1);
    }
    e.boundScale && e.boundTolerance >= 0 && (s = hV(e.boundScale, e.boundOrient, +e.boundTolerance), r.forEach((u) => {
      s(u) || (u.opacity = 0);
    }));
    const o = a[0].mark.bounds.clear();
    return r.forEach((u) => {
      u.opacity && o.union(u.bounds);
    }), t;
  }
});
function J_(e) {
  T.call(this, null, e);
}
B(J_, T, {
  transform(e, t) {
    const n = t.dataflow;
    if (t.visit(t.ALL, (i) => n.dirty(i)), t.fields && t.fields.zindex) {
      const i = t.source && t.source[0];
      i && (i.mark.zdirty = !0);
    }
  }
});
const Mt = new Ye();
function ru(e, t, n) {
  return e[t] === n ? 0 : (e[t] = n, 1);
}
function pV(e) {
  var t = e.items[0].orient;
  return t === mi || t === vi;
}
function gV(e) {
  let t = +e.grid;
  return [
    e.ticks ? t++ : -1,
    // ticks index
    e.labels ? t++ : -1,
    // labels index
    t + +e.domain
    // title index
  ];
}
function mV(e, t, n, i) {
  var r = t.items[0], a = r.datum, s = r.translate != null ? r.translate : 0.5, o = r.orient, u = gV(a), l = r.range, c = r.offset, f = r.position, d = r.minExtent, h = r.maxExtent, p = a.title && r.items[u[2]].items[0], g = r.titlePadding, m = r.bounds, y = p && s_(p), b = 0, v = 0, x, w;
  switch (Mt.clear().union(m), m.clear(), (x = u[0]) > -1 && m.union(r.items[x].bounds), (x = u[1]) > -1 && m.union(r.items[x].bounds), o) {
    case ku:
      b = f || 0, v = -c, w = Math.max(d, Math.min(h, -m.y1)), m.add(0, -w).add(l, 0), p && rh(e, p, w, g, y, 0, -1, m);
      break;
    case mi:
      b = -c, v = f || 0, w = Math.max(d, Math.min(h, -m.x1)), m.add(-w, 0).add(0, l), p && rh(e, p, w, g, y, 1, -1, m);
      break;
    case vi:
      b = n + c, v = f || 0, w = Math.max(d, Math.min(h, m.x2)), m.add(0, 0).add(w, l), p && rh(e, p, w, g, y, 1, 1, m);
      break;
    case Ga:
      b = f || 0, v = i + c, w = Math.max(d, Math.min(h, m.y2)), m.add(0, 0).add(l, w), p && rh(e, p, w, g, 0, 0, 1, m);
      break;
    default:
      b = r.x, v = r.y;
  }
  return os(m.translate(b, v), r), ru(r, "x", b + s) | ru(r, "y", v + s) && (r.bounds = Mt, e.dirty(r), r.bounds = m, e.dirty(r)), r.mark.bounds.clear().union(m);
}
function rh(e, t, n, i, r, a, s, o) {
  const u = t.bounds;
  if (t.auto) {
    const l = s * (n + r + i);
    let c = 0, f = 0;
    e.dirty(t), a ? c = (t.x || 0) - (t.x = l) : f = (t.y || 0) - (t.y = l), t.mark.bounds.clear().union(u.translate(-c, -f)), e.dirty(t);
  }
  o.union(u);
}
const x6 = (e, t) => Math.floor(Math.min(e, t)), $6 = (e, t) => Math.ceil(Math.max(e, t));
function yV(e) {
  var t = e.items, n = t.length, i = 0, r, a;
  const s = {
    marks: [],
    rowheaders: [],
    rowfooters: [],
    colheaders: [],
    colfooters: [],
    rowtitle: null,
    coltitle: null
  };
  for (; i < n; ++i)
    if (r = t[i], a = r.items, r.marktype === j0)
      switch (r.role) {
        case m$:
        case b$:
        case y$:
          break;
        case z_:
          s.rowheaders.push(...a);
          break;
        case I_:
          s.rowfooters.push(...a);
          break;
        case j_:
          s.colheaders.push(...a);
          break;
        case U_:
          s.colfooters.push(...a);
          break;
        case B_:
          s.rowtitle = a[0];
          break;
        case q_:
          s.coltitle = a[0];
          break;
        default:
          s.marks.push(...a);
      }
  return s;
}
function bV(e) {
  return new Ye().set(0, 0, e.width || 0, e.height || 0);
}
function vV(e) {
  const t = e.bounds.clone();
  return t.empty() ? t.set(0, 0, 0, 0) : t.translate(-(e.x || 0), -(e.y || 0));
}
function Ie(e, t, n) {
  const i = X(e) ? e[t] : e;
  return i ?? (n !== void 0 ? n : 0);
}
function w6(e) {
  return e < 0 ? Math.ceil(-e) : 0;
}
function Q_(e, t, n) {
  var i = !n.nodirty, r = n.bounds === x$ ? bV : vV, a = Mt.set(0, 0, 0, 0), s = Ie(n.align, Ca), o = Ie(n.align, _a), u = Ie(n.padding, Ca), l = Ie(n.padding, _a), c = n.columns || t.length, f = c <= 0 ? 1 : Math.ceil(t.length / c), d = t.length, h = Array(d), p = Array(c), g = 0, m = Array(d), y = Array(f), b = 0, v = Array(d), x = Array(d), w = Array(d), E, $, S, A, k, _, P, F, M, C, O;
  for ($ = 0; $ < c; ++$)
    p[$] = 0;
  for ($ = 0; $ < f; ++$)
    y[$] = 0;
  for ($ = 0; $ < d; ++$)
    _ = t[$], k = w[$] = r(_), _.x = _.x || 0, v[$] = 0, _.y = _.y || 0, x[$] = 0, S = $ % c, A = ~~($ / c), g = Math.max(g, P = Math.ceil(k.x2)), b = Math.max(b, F = Math.ceil(k.y2)), p[S] = Math.max(p[S], P), y[A] = Math.max(y[A], F), h[$] = u + w6(k.x1), m[$] = l + w6(k.y1), i && e.dirty(t[$]);
  for ($ = 0; $ < d; ++$)
    $ % c === 0 && (h[$] = 0), $ < c && (m[$] = 0);
  if (s === Db)
    for (S = 1; S < c; ++S) {
      for (O = 0, $ = S; $ < d; $ += c)
        O < h[$] && (O = h[$]);
      for ($ = S; $ < d; $ += c)
        h[$] = O + p[S - 1];
    }
  else if (s === nh) {
    for (O = 0, $ = 0; $ < d; ++$)
      $ % c && O < h[$] && (O = h[$]);
    for ($ = 0; $ < d; ++$)
      $ % c && (h[$] = O + g);
  } else
    for (s = !1, S = 1; S < c; ++S)
      for ($ = S; $ < d; $ += c)
        h[$] += p[S - 1];
  if (o === Db)
    for (A = 1; A < f; ++A) {
      for (O = 0, $ = A * c, E = $ + c; $ < E; ++$)
        O < m[$] && (O = m[$]);
      for ($ = A * c; $ < E; ++$)
        m[$] = O + y[A - 1];
    }
  else if (o === nh) {
    for (O = 0, $ = c; $ < d; ++$)
      O < m[$] && (O = m[$]);
    for ($ = c; $ < d; ++$)
      m[$] = O + b;
  } else
    for (o = !1, A = 1; A < f; ++A)
      for ($ = A * c, E = $ + c; $ < E; ++$)
        m[$] += y[A - 1];
  for (M = 0, $ = 0; $ < d; ++$)
    M = h[$] + ($ % c ? M : 0), v[$] += M - t[$].x;
  for (S = 0; S < c; ++S)
    for (C = 0, $ = S; $ < d; $ += c)
      C += m[$], x[$] += C - t[$].y;
  if (s && Ie(n.center, Ca) && f > 1)
    for ($ = 0; $ < d; ++$)
      k = s === nh ? g : p[$ % c], M = k - w[$].x2 - t[$].x - v[$], M > 0 && (v[$] += M / 2);
  if (o && Ie(n.center, _a) && c !== 1)
    for ($ = 0; $ < d; ++$)
      k = o === nh ? b : y[~~($ / c)], C = k - w[$].y2 - t[$].y - x[$], C > 0 && (x[$] += C / 2);
  for ($ = 0; $ < d; ++$)
    a.union(w[$].translate(v[$], x[$]));
  switch (M = Ie(n.anchor, iV), C = Ie(n.anchor, rV), Ie(n.anchor, Ca)) {
    case Vt:
      M -= a.width();
      break;
    case Tb:
      M -= a.width() / 2;
  }
  switch (Ie(n.anchor, _a)) {
    case Vt:
      C -= a.height();
      break;
    case Tb:
      C -= a.height() / 2;
  }
  for (M = Math.round(M), C = Math.round(C), a.clear(), $ = 0; $ < d; ++$)
    t[$].mark.bounds.clear();
  for ($ = 0; $ < d; ++$)
    _ = t[$], _.x += v[$] += M, _.y += x[$] += C, a.union(_.mark.bounds.union(_.bounds.translate(v[$], x[$]))), i && e.dirty(_);
  return a;
}
function xV(e, t, n) {
  var i = yV(t), r = i.marks, a = n.bounds === x$ ? $V : wV, s = n.offset, o = n.columns || r.length, u = o <= 0 ? 1 : Math.ceil(r.length / o), l = u * o, c, f, d, h, p, g, m;
  const y = Q_(e, r, n);
  y.empty() && y.set(0, 0, 0, 0), i.rowheaders && (g = Ie(n.headerBand, _a, null), c = ah(e, i.rowheaders, r, o, u, -Ie(s, "rowHeader"), x6, 0, a, "x1", 0, o, 1, g)), i.colheaders && (g = Ie(n.headerBand, Ca, null), f = ah(e, i.colheaders, r, o, o, -Ie(s, "columnHeader"), x6, 1, a, "y1", 0, 1, o, g)), i.rowfooters && (g = Ie(n.footerBand, _a, null), d = ah(e, i.rowfooters, r, o, u, Ie(s, "rowFooter"), $6, 0, a, "x2", o - 1, o, 1, g)), i.colfooters && (g = Ie(n.footerBand, Ca, null), h = ah(e, i.colfooters, r, o, o, Ie(s, "columnFooter"), $6, 1, a, "y2", l - o, 1, o, g)), i.rowtitle && (p = Ie(n.titleAnchor, _a), m = Ie(s, "rowTitle"), m = p === Vt ? d + m : c - m, g = Ie(n.titleBand, _a, 0.5), E6(e, i.rowtitle, m, 0, y, g)), i.coltitle && (p = Ie(n.titleAnchor, Ca), m = Ie(s, "columnTitle"), m = p === Vt ? h + m : f - m, g = Ie(n.titleBand, Ca, 0.5), E6(e, i.coltitle, m, 1, y, g));
}
function $V(e, t) {
  return t === "x1" ? e.x || 0 : t === "y1" ? e.y || 0 : t === "x2" ? (e.x || 0) + (e.width || 0) : t === "y2" ? (e.y || 0) + (e.height || 0) : void 0;
}
function wV(e, t) {
  return e.bounds[t];
}
function ah(e, t, n, i, r, a, s, o, u, l, c, f, d, h) {
  var p = n.length, g = 0, m = 0, y, b, v, x, w, E, $, S, A;
  if (!p)
    return g;
  for (y = c; y < p; y += f)
    n[y] && (g = s(g, u(n[y], l)));
  if (!t.length)
    return g;
  for (t.length > r && (e.warn("Grid headers exceed limit: " + r), t = t.slice(0, r)), g += a, b = 0, x = t.length; b < x; ++b)
    e.dirty(t[b]), t[b].mark.bounds.clear();
  for (y = c, b = 0, x = t.length; b < x; ++b, y += f) {
    for (E = t[b], w = E.mark.bounds, v = y; v >= 0 && ($ = n[v]) == null; v -= d)
      ;
    o ? (S = h == null ? $.x : Math.round($.bounds.x1 + h * $.bounds.width()), A = g) : (S = g, A = h == null ? $.y : Math.round($.bounds.y1 + h * $.bounds.height())), w.union(E.bounds.translate(S - (E.x || 0), A - (E.y || 0))), E.x = S, E.y = A, e.dirty(E), m = s(m, w[l]);
  }
  return m;
}
function E6(e, t, n, i, r, a) {
  if (t) {
    e.dirty(t);
    var s = n, o = n;
    i ? s = Math.round(r.x1 + a * r.width()) : o = Math.round(r.y1 + a * r.height()), t.bounds.translate(s - (t.x || 0), o - (t.y || 0)), t.mark.bounds.clear().union(t.bounds), t.x = s, t.y = o, e.dirty(t);
  }
}
function EV(e, t) {
  const n = e[t] || {};
  return (i, r) => n[i] != null ? n[i] : e[i] != null ? e[i] : r;
}
function SV(e, t) {
  let n = -1 / 0;
  return e.forEach((i) => {
    i.offset != null && (n = Math.max(n, i.offset));
  }), n > -1 / 0 ? n : t;
}
function AV(e, t, n, i, r, a, s) {
  const o = EV(n, t), u = SV(e, o("offset", 0)), l = o("anchor", g$), c = l === Vt ? 1 : l === Tb ? 0.5 : 0, f = {
    align: Db,
    bounds: o("bounds", x$),
    columns: o("direction") === "vertical" ? 1 : e.length,
    padding: o("margin", 8),
    center: o("center"),
    nodirty: !0
  };
  switch (t) {
    case mi:
      f.anchor = {
        x: Math.floor(i.x1) - u,
        column: Vt,
        y: c * (s || i.height() + 2 * i.y1),
        row: l
      };
      break;
    case vi:
      f.anchor = {
        x: Math.ceil(i.x2) + u,
        y: c * (s || i.height() + 2 * i.y1),
        row: l
      };
      break;
    case ku:
      f.anchor = {
        y: Math.floor(r.y1) - u,
        row: Vt,
        x: c * (a || r.width() + 2 * r.x1),
        column: l
      };
      break;
    case Ga:
      f.anchor = {
        y: Math.ceil(r.y2) + u,
        x: c * (a || r.width() + 2 * r.x1),
        column: l
      };
      break;
    case ZH:
      f.anchor = {
        x: u,
        y: u
      };
      break;
    case eV:
      f.anchor = {
        x: a - u,
        y: u,
        column: Vt
      };
      break;
    case tV:
      f.anchor = {
        x: u,
        y: s - u,
        row: Vt
      };
      break;
    case nV:
      f.anchor = {
        x: a - u,
        y: s - u,
        column: Vt,
        row: Vt
      };
      break;
  }
  return f;
}
function kV(e, t) {
  var n = t.items[0], i = n.datum, r = n.orient, a = n.bounds, s = n.x, o = n.y, u, l;
  return n._bounds ? n._bounds.clear().union(a) : n._bounds = a.clone(), a.clear(), _V(e, n, n.items[0].items[0]), a = CV(n, a), u = 2 * n.padding, l = 2 * n.padding, a.empty() || (u = Math.ceil(a.width() + u), l = Math.ceil(a.height() + l)), i.type === uV && FV(n.items[0].items[0].items[0].items), r !== v$ && (n.x = s = 0, n.y = o = 0), n.width = u, n.height = l, os(a.set(s, o, s + u, o + l), n), n.mark.bounds.clear().union(a), n;
}
function CV(e, t) {
  return e.items.forEach((n) => t.union(n.bounds)), t.x1 = e.padding, t.y1 = e.padding, t;
}
function _V(e, t, n) {
  var i = t.padding, r = i - n.x, a = i - n.y;
  if (!t.datum.title)
    (r || a) && Ll(e, n, r, a);
  else {
    var s = t.items[1].items[0], o = s.anchor, u = t.titlePadding || 0, l = i - s.x, c = i - s.y;
    switch (s.orient) {
      case mi:
        r += Math.ceil(s.bounds.width()) + u;
        break;
      case vi:
      case Ga:
        break;
      default:
        a += s.bounds.height() + u;
    }
    switch ((r || a) && Ll(e, n, r, a), s.orient) {
      case mi:
        c += qo(t, n, s, o, 1, 1);
        break;
      case vi:
        l += qo(t, n, s, Vt, 0, 0) + u, c += qo(t, n, s, o, 1, 1);
        break;
      case Ga:
        l += qo(t, n, s, o, 0, 0), c += qo(t, n, s, Vt, -1, 0, 1) + u;
        break;
      default:
        l += qo(t, n, s, o, 0, 0);
    }
    (l || c) && Ll(e, s, l, c), (l = Math.round(s.bounds.x1 - i)) < 0 && (Ll(e, n, -l, 0), Ll(e, s, -l, 0));
  }
}
function qo(e, t, n, i, r, a, s) {
  const o = e.datum.type !== "symbol", u = n.datum.vgrad, l = o && (a || !u) && !s ? t.items[0] : t, c = l.bounds[r ? "y2" : "x2"] - e.padding, f = u && a ? c : 0, d = u && a ? 0 : c, h = r <= 0 ? 0 : s_(n);
  return Math.round(i === g$ ? f : i === Vt ? d - h : 0.5 * (c - h));
}
function Ll(e, t, n, i) {
  t.x += n, t.y += i, t.bounds.translate(n, i), t.mark.bounds.translate(n, i), e.dirty(t);
}
function FV(e) {
  const t = e.reduce((n, i) => (n[i.column] = Math.max(i.bounds.x2 - i.x, n[i.column] || 0), n), {});
  e.forEach((n) => {
    n.width = t[n.column], n.height = n.bounds.y2 - n.y;
  });
}
function MV(e, t, n, i, r) {
  var a = t.items[0], s = a.frame, o = a.orient, u = a.anchor, l = a.offset, c = a.padding, f = a.items[0].items[0], d = a.items[1] && a.items[1].items[0], h = o === mi || o === vi ? i : n, p = 0, g = 0, m = 0, y = 0, b = 0, v;
  if (s !== j0 ? o === mi ? (p = r.y2, h = r.y1) : o === vi ? (p = r.y1, h = r.y2) : (p = r.x1, h = r.x2) : o === mi && (p = i, h = 0), v = u === g$ ? p : u === Vt ? h : (p + h) / 2, d && d.text) {
    switch (o) {
      case ku:
      case Ga:
        b = f.bounds.height() + c;
        break;
      case mi:
        y = f.bounds.width() + c;
        break;
      case vi:
        y = -f.bounds.width() - c;
        break;
    }
    Mt.clear().union(d.bounds), Mt.translate(y - (d.x || 0), b - (d.y || 0)), ru(d, "x", y) | ru(d, "y", b) && (e.dirty(d), d.bounds.clear().union(Mt), d.mark.bounds.clear().union(Mt), e.dirty(d)), Mt.clear().union(d.bounds);
  } else
    Mt.clear();
  switch (Mt.union(f.bounds), o) {
    case ku:
      g = v, m = r.y1 - Mt.height() - l;
      break;
    case mi:
      g = r.x1 - Mt.width() - l, m = v;
      break;
    case vi:
      g = r.x2 + Mt.width() + l, m = v;
      break;
    case Ga:
      g = v, m = r.y2 + l;
      break;
    default:
      g = a.x, m = a.y;
  }
  return ru(a, "x", g) | ru(a, "y", m) && (Mt.translate(g, m), e.dirty(a), a.bounds.clear().union(Mt), t.bounds.clear().union(Mt), e.dirty(a)), a.bounds;
}
function Z_(e) {
  T.call(this, null, e);
}
B(Z_, T, {
  transform(e, t) {
    const n = t.dataflow;
    return e.mark.items.forEach((i) => {
      e.layout && xV(n, i, e.layout), RV(n, i, e);
    }), OV(e.mark.group) ? t.reflow() : t;
  }
});
function OV(e) {
  return e && e.mark.role !== "legend-entry";
}
function RV(e, t, n) {
  var i = t.items, r = Math.max(0, t.width || 0), a = Math.max(0, t.height || 0), s = new Ye().set(0, 0, r, a), o = s.clone(), u = s.clone(), l = [], c, f, d, h, p, g;
  for (p = 0, g = i.length; p < g; ++p)
    switch (f = i[p], f.role) {
      case m$:
        h = pV(f) ? o : u, h.union(mV(e, f, r, a));
        break;
      case y$:
        c = f;
        break;
      case b$:
        l.push(kV(e, f));
        break;
      case aV:
      case sV:
      case z_:
      case I_:
      case B_:
      case j_:
      case U_:
      case q_:
        o.union(f.bounds), u.union(f.bounds);
        break;
      default:
        s.union(f.bounds);
    }
  if (l.length) {
    const m = {};
    l.forEach((y) => {
      d = y.orient || vi, d !== v$ && (m[d] || (m[d] = [])).push(y);
    });
    for (const y in m) {
      const b = m[y];
      Q_(e, b, AV(b, y, n.legends, o, u, r, a));
    }
    l.forEach((y) => {
      const b = y.bounds;
      if (b.equals(y._bounds) || (y.bounds = y._bounds, e.dirty(y), y.bounds = b, e.dirty(y)), n.autosize && (n.autosize.type === G_ || n.autosize.type === W_ || n.autosize.type === H_))
        switch (y.orient) {
          case mi:
          case vi:
            s.add(b.x1, 0).add(b.x2, 0);
            break;
          case ku:
          case Ga:
            s.add(0, b.y1).add(0, b.y2);
        }
      else
        s.union(b);
    });
  }
  s.union(o).union(u), c && s.union(MV(e, c, r, a, s)), t.clip && s.set(0, 0, t.width || 0, t.height || 0), TV(e, t, s, n);
}
function TV(e, t, n, i) {
  const r = i.autosize || {}, a = r.type;
  if (e._autosize < 1 || !a)
    return;
  let s = e._width, o = e._height, u = Math.max(0, t.width || 0), l = Math.max(0, Math.ceil(-n.x1)), c = Math.max(0, t.height || 0), f = Math.max(0, Math.ceil(-n.y1));
  const d = Math.max(0, Math.ceil(n.x2 - u)), h = Math.max(0, Math.ceil(n.y2 - c));
  if (r.contains === oV) {
    const p = e.padding();
    s -= p.left + p.right, o -= p.top + p.bottom;
  }
  a === v$ ? (l = 0, f = 0, u = s, c = o) : a === G_ ? (u = Math.max(0, s - l - d), c = Math.max(0, o - f - h)) : a === W_ ? (u = Math.max(0, s - l - d), o = c + f + h) : a === H_ ? (s = u + l + d, c = Math.max(0, o - f - h)) : a === lV && (s = u + l + d, o = c + f + h), e._resizeView(s, o, u, c, [l, f], r.resize);
}
const DV = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bound: V_,
  identifier: $$,
  mark: X_,
  overlap: Y_,
  render: J_,
  viewlayout: Z_
}, Symbol.toStringTag, { value: "Module" }));
function eF(e) {
  T.call(this, null, e);
}
B(eF, T, {
  transform(e, t) {
    if (this.value && !e.modified())
      return t.StopPropagation;
    var n = t.dataflow.locale(), i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = this.value, a = e.scale, s = e.count == null ? e.values ? e.values.length : 10 : e.count, o = Gx(a, s, e.minstep), u = e.format || NC(n, a, o, e.formatSpecifier, e.formatType, !!e.values), l = e.values ? DC(a, e.values, o) : Wx(a, o);
    return r && (i.rem = r), r = l.map((c, f) => $e({
      index: f / (l.length - 1 || 1),
      value: c,
      label: u(c)
    })), e.extra && r.length && r.push($e({
      index: -1,
      extra: {
        value: r[0].value
      },
      label: ""
    })), i.source = r, i.add = r, this.value = r, i;
  }
});
function tF(e) {
  T.call(this, null, e);
}
function NV() {
  return $e({});
}
function LV(e) {
  const t = nl().test((n) => n.exit);
  return t.lookup = (n) => t.get(e(n)), t;
}
B(tF, T, {
  transform(e, t) {
    var n = t.dataflow, i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = e.item || NV, a = e.key || ee, s = this.value;
    return R(i.encode) && (i.encode = null), s && (e.modified("key") || t.modified(a)) && D("DataJoin does not support modified key function or fields."), s || (t = t.addAll(), this.value = s = LV(a)), t.visit(t.ADD, (o) => {
      const u = a(o);
      let l = s.get(u);
      l ? l.exit ? (s.empty--, i.add.push(l)) : i.mod.push(l) : (l = r(o), s.set(u, l), i.add.push(l)), l.datum = o, l.exit = !1;
    }), t.visit(t.MOD, (o) => {
      const u = a(o), l = s.get(u);
      l && (l.datum = o, i.mod.push(l));
    }), t.visit(t.REM, (o) => {
      const u = a(o), l = s.get(u);
      o === l.datum && !l.exit && (i.rem.push(l), l.exit = !0, ++s.empty);
    }), t.changed(t.ADD_MOD) && i.modifies("datum"), (t.clean() || e.clean && s.empty > n.cleanThreshold) && n.runAfter(s.clean), i;
  }
});
function nF(e) {
  T.call(this, null, e);
}
B(nF, T, {
  transform(e, t) {
    var n = t.fork(t.ADD_REM), i = e.mod || !1, r = e.encoders, a = t.encode;
    if (R(a))
      if (n.changed() || a.every((f) => r[f]))
        a = a[0], n.encode = null;
      else
        return t.StopPropagation;
    var s = a === "enter", o = r.update || ha, u = r.enter || ha, l = r.exit || ha, c = (a && !s ? r[a] : o) || ha;
    if (t.changed(t.ADD) && (t.visit(t.ADD, (f) => {
      u(f, e), o(f, e);
    }), n.modifies(u.output), n.modifies(o.output), c !== ha && c !== o && (t.visit(t.ADD, (f) => {
      c(f, e);
    }), n.modifies(c.output))), t.changed(t.REM) && l !== ha && (t.visit(t.REM, (f) => {
      l(f, e);
    }), n.modifies(l.output)), s || c !== ha) {
      const f = t.MOD | (e.modified() ? t.REFLOW : 0);
      s ? (t.visit(f, (d) => {
        const h = u(d, e) || i;
        (c(d, e) || h) && n.mod.push(d);
      }), n.mod.length && n.modifies(u.output)) : t.visit(f, (d) => {
        (c(d, e) || i) && n.mod.push(d);
      }), n.mod.length && n.modifies(c.output);
    }
    return n.changed() ? n : t.StopPropagation;
  }
});
function iF(e) {
  T.call(this, [], e);
}
B(iF, T, {
  transform(e, t) {
    if (this.value != null && !e.modified())
      return t.StopPropagation;
    var n = t.dataflow.locale(), i = t.fork(t.NO_SOURCE | t.NO_FIELDS), r = this.value, a = e.type || Oh, s = e.scale, o = +e.limit, u = Gx(s, e.count == null ? 5 : e.count, e.minstep), l = !!e.values || a === Oh, c = e.format || IC(n, s, u, a, e.formatSpecifier, e.formatType, l), f = e.values || zC(s, u), d, h, p, g, m;
    return r && (i.rem = r), a === Oh ? (o && f.length > o ? (t.dataflow.warn("Symbol legend count exceeds limit, filtering items."), r = f.slice(0, o - 1), m = !0) : r = f, oe(p = e.size) ? (!e.values && s(r[0]) === 0 && (r = r.slice(1)), g = r.reduce((y, b) => Math.max(y, p(b, e)), 0)) : p = Ut(g = p || 8), r = r.map((y, b) => $e({
      index: b,
      label: c(y, b, r),
      value: y,
      offset: g,
      size: p(y, e)
    })), m && (m = f[r.length], r.push($e({
      index: r.length,
      label: `${f.length - r.length} entries`,
      value: m,
      offset: g,
      size: p(m, e)
    })))) : a === iG ? (d = s.domain(), h = qx(s, d[0], ae(d)), f.length < 3 && !e.values && d[0] !== ae(d) && (f = [d[0], ae(d)]), r = f.map((y, b) => $e({
      index: b,
      label: c(y, b, f),
      value: y,
      perc: h(y)
    }))) : (p = f.length - 1, h = pG(s), r = f.map((y, b) => $e({
      index: b,
      label: c(y, b, f),
      value: y,
      perc: b ? h(y) : 0,
      perc2: b === p ? 1 : h(f[b + 1])
    }))), i.source = r, i.add = r, this.value = r, i;
  }
});
const PV = (e) => e.source.x, zV = (e) => e.source.y, IV = (e) => e.target.x, BV = (e) => e.target.y;
function w$(e) {
  T.call(this, {}, e);
}
w$.Definition = {
  type: "LinkPath",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "sourceX",
    type: "field",
    default: "source.x"
  }, {
    name: "sourceY",
    type: "field",
    default: "source.y"
  }, {
    name: "targetX",
    type: "field",
    default: "target.x"
  }, {
    name: "targetY",
    type: "field",
    default: "target.y"
  }, {
    name: "orient",
    type: "enum",
    default: "vertical",
    values: ["horizontal", "vertical", "radial"]
  }, {
    name: "shape",
    type: "enum",
    default: "line",
    values: ["line", "arc", "curve", "diagonal", "orthogonal"]
  }, {
    name: "require",
    type: "signal"
  }, {
    name: "as",
    type: "string",
    default: "path"
  }]
};
B(w$, T, {
  transform(e, t) {
    var n = e.sourceX || PV, i = e.sourceY || zV, r = e.targetX || IV, a = e.targetY || BV, s = e.as || "path", o = e.orient || "vertical", u = e.shape || "line", l = S6.get(u + "-" + o) || S6.get(u);
    return l || D("LinkPath unsupported type: " + e.shape + (e.orient ? "-" + e.orient : "")), t.visit(t.SOURCE, (c) => {
      c[s] = l(n(c), i(c), r(c), a(c));
    }), t.reflow(e.modified()).modifies(s);
  }
});
const rF = (e, t, n, i) => "M" + e + "," + t + "L" + n + "," + i, jV = (e, t, n, i) => rF(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)), aF = (e, t, n, i) => {
  var r = n - e, a = i - t, s = Math.hypot(r, a) / 2, o = 180 * Math.atan2(a, r) / Math.PI;
  return "M" + e + "," + t + "A" + s + "," + s + " " + o + " 0 1 " + n + "," + i;
}, UV = (e, t, n, i) => aF(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)), sF = (e, t, n, i) => {
  const r = n - e, a = i - t, s = 0.2 * (r + a), o = 0.2 * (a - r);
  return "M" + e + "," + t + "C" + (e + s) + "," + (t + o) + " " + (n + o) + "," + (i - s) + " " + n + "," + i;
}, qV = (e, t, n, i) => sF(t * Math.cos(e), t * Math.sin(e), i * Math.cos(n), i * Math.sin(n)), GV = (e, t, n, i) => "M" + e + "," + t + "V" + i + "H" + n, WV = (e, t, n, i) => "M" + e + "," + t + "H" + n + "V" + i, HV = (e, t, n, i) => {
  const r = Math.cos(e), a = Math.sin(e), s = Math.cos(n), o = Math.sin(n), u = Math.abs(n - e) > Math.PI ? n <= e : n > e;
  return "M" + t * r + "," + t * a + "A" + t + "," + t + " 0 0," + (u ? 1 : 0) + " " + t * s + "," + t * o + "L" + i * s + "," + i * o;
}, VV = (e, t, n, i) => {
  const r = (e + n) / 2;
  return "M" + e + "," + t + "C" + r + "," + t + " " + r + "," + i + " " + n + "," + i;
}, XV = (e, t, n, i) => {
  const r = (t + i) / 2;
  return "M" + e + "," + t + "C" + e + "," + r + " " + n + "," + r + " " + n + "," + i;
}, YV = (e, t, n, i) => {
  const r = Math.cos(e), a = Math.sin(e), s = Math.cos(n), o = Math.sin(n), u = (t + i) / 2;
  return "M" + t * r + "," + t * a + "C" + u * r + "," + u * a + " " + u * s + "," + u * o + " " + i * s + "," + i * o;
}, S6 = nl({
  line: rF,
  "line-radial": jV,
  arc: aF,
  "arc-radial": UV,
  curve: sF,
  "curve-radial": qV,
  "orthogonal-horizontal": GV,
  "orthogonal-vertical": WV,
  "orthogonal-radial": HV,
  "diagonal-horizontal": VV,
  "diagonal-vertical": XV,
  "diagonal-radial": YV
});
function E$(e) {
  T.call(this, null, e);
}
E$.Definition = {
  type: "Pie",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "startAngle",
    type: "number",
    default: 0
  }, {
    name: "endAngle",
    type: "number",
    default: 6.283185307179586
  }, {
    name: "sort",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["startAngle", "endAngle"]
  }]
};
B(E$, T, {
  transform(e, t) {
    var n = e.as || ["startAngle", "endAngle"], i = n[0], r = n[1], a = e.field || Zu, s = e.startAngle || 0, o = e.endAngle != null ? e.endAngle : 2 * Math.PI, u = t.source, l = u.map(a), c = l.length, f = s, d = (o - s) / Lk(l), h = xt(c), p, g, m;
    for (e.sort && h.sort((y, b) => l[y] - l[b]), p = 0; p < c; ++p)
      m = l[h[p]], g = u[h[p]], g[i] = f, g[r] = f += m * d;
    return this.value = l, t.reflow(e.modified()).modifies(n);
  }
});
const KV = 5;
function JV(e) {
  const t = e.type;
  return !e.bins && (t === wu || t === Kf || t === Jf);
}
function oF(e) {
  return kC(e) && e !== ar;
}
const QV = an(["set", "modified", "clear", "type", "scheme", "schemeExtent", "schemeCount", "domain", "domainMin", "domainMid", "domainMax", "domainRaw", "domainImplicit", "nice", "zero", "bins", "range", "rangeStep", "round", "reverse", "interpolate", "interpolateGamma"]);
function uF(e) {
  T.call(this, null, e), this.modified(!0);
}
B(uF, T, {
  transform(e, t) {
    var n = t.dataflow, i = this.value, r = ZV(e);
    (!i || r !== i.type) && (this.value = i = be(r)());
    for (r in e)
      if (!QV[r]) {
        if (r === "padding" && oF(i.type))
          continue;
        oe(i[r]) ? i[r](e[r]) : n.warn("Unsupported scale property: " + r);
      }
    return aX(i, e, rX(i, e, tX(i, e, n))), t.fork(t.NO_SOURCE | t.NO_FIELDS);
  }
});
function ZV(e) {
  var t = e.type, n = "", i;
  return t === ar ? ar + "-" + wu : (eX(e) && (i = e.rawDomain ? e.rawDomain.length : e.domain ? e.domain.length + +(e.domainMid != null) : 0, n = i === 2 ? ar + "-" : i === 3 ? ll + "-" : ""), (n + t || wu).toLowerCase());
}
function eX(e) {
  const t = e.type;
  return kC(t) && t !== io && t !== ro && (e.scheme || e.range && e.range.length && e.range.every(V));
}
function tX(e, t, n) {
  const i = nX(e, t.domainRaw, n);
  if (i > -1)
    return i;
  var r = t.domain, a = e.type, s = t.zero || t.zero === void 0 && JV(e), o, u;
  if (!r)
    return 0;
  if (oF(a) && t.padding && r[0] !== ae(r) && (r = iX(a, r, t.range, t.padding, t.exponent, t.constant)), (s || t.domainMin != null || t.domainMax != null || t.domainMid != null) && (o = (r = r.slice()).length - 1 || 1, s && (r[0] > 0 && (r[0] = 0), r[o] < 0 && (r[o] = 0)), t.domainMin != null && (r[0] = t.domainMin), t.domainMax != null && (r[o] = t.domainMax), t.domainMid != null)) {
    u = t.domainMid;
    const l = u > r[o] ? o + 1 : u < r[0] ? 0 : o;
    l !== o && n.warn("Scale domainMid exceeds domain min or max.", u), r.splice(l, 0, u);
  }
  return e.domain(lF(a, r, n)), a === zx && e.unknown(t.domainImplicit ? JL : void 0), t.nice && e.nice && e.nice(t.nice !== !0 && Gx(e, t.nice) || null), r.length;
}
function nX(e, t, n) {
  return t ? (e.domain(lF(e.type, t, n)), t.length) : -1;
}
function iX(e, t, n, i, r, a) {
  var s = Math.abs(ae(n) - n[0]), o = s / (s - 2 * i), u = e === Yr ? r0(t, null, o) : e === Jf ? Wc(t, null, o, 0.5) : e === Kf ? Wc(t, null, o, r || 1) : e === _0 ? a0(t, null, o, a || 1) : i0(t, null, o);
  return t = t.slice(), t[0] = u[0], t[t.length - 1] = u[1], t;
}
function lF(e, t, n) {
  if (_C(e)) {
    var i = Math.abs(t.reduce((r, a) => r + (a < 0 ? -1 : a > 0 ? 1 : 0), 0));
    i !== t.length && n.warn("Log scale domain includes zero: " + U(t));
  }
  return t;
}
function rX(e, t, n) {
  let i = t.bins;
  if (i && !R(i)) {
    const r = e.domain(), a = r[0], s = ae(r), o = i.step;
    let u = i.start == null ? a : i.start, l = i.stop == null ? s : i.stop;
    o || D("Scale bins parameter missing step property."), u < a && (u = o * Math.ceil(a / o)), l > s && (l = o * Math.floor(s / o)), i = xt(u, l + o / 2, o);
  }
  return i ? e.bins = i : e.bins && delete e.bins, e.type === Ix && (i ? !t.domain && !t.domainRaw && (e.domain(i), n = i.length) : e.bins = e.domain()), n;
}
function aX(e, t, n) {
  var i = e.type, r = t.round || !1, a = t.range;
  if (t.rangeStep != null)
    a = sX(i, t, n);
  else if (t.scheme && (a = oX(i, t, n), oe(a))) {
    if (e.interpolator)
      return e.interpolator(a);
    D(`Scale type ${i} does not support interpolating color schemes.`);
  }
  if (a && FC(i))
    return e.interpolator(Ux(Nb(a, t.reverse), t.interpolate, t.interpolateGamma));
  a && t.interpolate && e.interpolate ? e.interpolate(MC(t.interpolate, t.interpolateGamma)) : oe(e.round) ? e.round(r) : oe(e.rangeRound) && e.interpolate(r ? zg : kf), a && e.range(Nb(a, t.reverse));
}
function sX(e, t, n) {
  e !== xC && e !== xb && D("Only band and point scales support rangeStep.");
  var i = (t.paddingOuter != null ? t.paddingOuter : t.padding) || 0, r = e === xb ? 1 : (t.paddingInner != null ? t.paddingInner : t.padding) || 0;
  return [0, t.rangeStep * C0(n, r, i)];
}
function oX(e, t, n) {
  var i = t.schemeExtent, r, a;
  return R(t.scheme) ? a = Ux(t.scheme, t.interpolate, t.interpolateGamma) : (r = t.scheme.toLowerCase(), a = TC(r), a || D(`Unrecognized scheme name: ${t.scheme}`)), n = e === M0 ? n + 1 : e === Ix ? n - 1 : e === Yc || e === F0 ? +t.schemeCount || KV : n, FC(e) ? A6(a, i, t.reverse) : oe(a) ? Qq(A6(a, i), n) : e === zx ? a : a.slice(0, n);
}
function A6(e, t, n) {
  return oe(e) && (t || n) ? Jq(e, Nb(t || [0, 1], n)) : e;
}
function Nb(e, t) {
  return t ? e.slice().reverse() : e;
}
function cF(e) {
  T.call(this, null, e);
}
B(cF, T, {
  transform(e, t) {
    const n = e.modified("sort") || t.changed(t.ADD) || t.modified(e.sort.fields) || t.modified("datum");
    return n && t.source.sort(Ao(e.sort)), this.modified(n), t;
  }
});
const k6 = "zero", fF = "center", dF = "normalize", hF = ["y0", "y1"];
function S$(e) {
  T.call(this, null, e);
}
S$.Definition = {
  type: "Stack",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "offset",
    type: "enum",
    default: k6,
    values: [k6, fF, dF]
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: hF
  }]
};
B(S$, T, {
  transform(e, t) {
    var n = e.as || hF, i = n[0], r = n[1], a = Ao(e.sort), s = e.field || Zu, o = e.offset === fF ? uX : e.offset === dF ? lX : cX, u, l, c, f;
    for (u = fX(t.source, e.groupby, a, s), l = 0, c = u.length, f = u.max; l < c; ++l)
      o(u[l], f, s, i, r);
    return t.reflow(e.modified()).modifies(n);
  }
});
function uX(e, t, n, i, r) {
  for (var a = (t - e.sum) / 2, s = e.length, o = 0, u; o < s; ++o)
    u = e[o], u[i] = a, u[r] = a += Math.abs(n(u));
}
function lX(e, t, n, i, r) {
  for (var a = 1 / e.sum, s = 0, o = e.length, u = 0, l = 0, c; u < o; ++u)
    c = e[u], c[i] = s, c[r] = s = a * (l += Math.abs(n(c)));
}
function cX(e, t, n, i, r) {
  for (var a = 0, s = 0, o = e.length, u = 0, l, c; u < o; ++u)
    c = e[u], l = +n(c), l < 0 ? (c[i] = s, c[r] = s += l) : (c[i] = a, c[r] = a += l);
}
function fX(e, t, n, i) {
  var r = [], a = (g) => g(c), s, o, u, l, c, f, d, h, p;
  if (t == null)
    r.push(e.slice());
  else
    for (s = {}, o = 0, u = e.length; o < u; ++o)
      c = e[o], f = t.map(a), d = s[f], d || (s[f] = d = [], r.push(d)), d.push(c);
  for (f = 0, p = 0, l = r.length; f < l; ++f) {
    for (d = r[f], o = 0, h = 0, u = d.length; o < u; ++o)
      h += Math.abs(i(d[o]));
    d.sum = h, h > p && (p = h), n && d.sort(n);
  }
  return r.max = p, r;
}
const dX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  axisticks: eF,
  datajoin: tF,
  encode: nF,
  legendentries: iF,
  linkpath: w$,
  pie: E$,
  scale: uF,
  sortitems: cF,
  stack: S$
}, Symbol.toStringTag, { value: "Module" }));
var hX = Math.abs, Lb = Math.cos, Gp = Math.sin, pX = 1e-6, pF = Math.PI, Pb = pF / 2, C6 = gX(2);
function _6(e) {
  return e > 1 ? Pb : e < -1 ? -Pb : Math.asin(e);
}
function gX(e) {
  return e > 0 ? Math.sqrt(e) : 0;
}
function mX(e, t) {
  var n = e * Gp(t), i = 30, r;
  do
    t -= r = (t + Gp(t) - n) / (1 + Lb(t));
  while (hX(r) > pX && --i > 0);
  return t / 2;
}
function yX(e, t, n) {
  function i(r, a) {
    return [e * r * Lb(a = mX(n, a)), t * Gp(a)];
  }
  return i.invert = function(r, a) {
    return a = _6(a / t), [r / (e * Lb(a)), _6((2 * a + Gp(2 * a)) / n)];
  }, i;
}
var bX = yX(C6 / Pb, C6, pF);
function vX() {
  return yr(bX).scale(169.529);
}
const xX = v9(), zb = [
  // standard properties in d3-geo
  "clipAngle",
  "clipExtent",
  "scale",
  "translate",
  "center",
  "rotate",
  "parallels",
  "precision",
  "reflectX",
  "reflectY",
  // extended properties in d3-geo-projections
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
function $X(e, t) {
  return function n() {
    const i = t();
    return i.type = e, i.path = v9().projection(i), i.copy = i.copy || function() {
      const r = n();
      return zb.forEach((a) => {
        i[a] && r[a](i[a]());
      }), r.path.pointRadius(i.path.pointRadius()), r;
    }, SC(i);
  };
}
function A$(e, t) {
  if (!e || typeof e != "string")
    throw new Error("Projection type must be a name string.");
  return e = e.toLowerCase(), arguments.length > 1 ? (Wp[e] = $X(e, t), this) : Wp[e] || null;
}
function gF(e) {
  return e && e.path || xX;
}
const Wp = {
  // base d3-geo projection types
  albers: $9,
  albersusa: mI,
  azimuthalequalarea: yI,
  azimuthalequidistant: bI,
  conicconformal: $I,
  conicequalarea: kp,
  conicequidistant: SI,
  equalEarth: kI,
  equirectangular: wI,
  gnomonic: CI,
  identity: _I,
  mercator: vI,
  mollweide: vX,
  naturalEarth1: FI,
  orthographic: MI,
  stereographic: OI,
  transversemercator: RI
};
for (const e in Wp)
  A$(e, Wp[e]);
function wX() {
}
const Fr = [[], [[[1, 1.5], [0.5, 1]]], [[[1.5, 1], [1, 1.5]]], [[[1.5, 1], [0.5, 1]]], [[[1, 0.5], [1.5, 1]]], [[[1, 1.5], [0.5, 1]], [[1, 0.5], [1.5, 1]]], [[[1, 0.5], [1, 1.5]]], [[[1, 0.5], [0.5, 1]]], [[[0.5, 1], [1, 0.5]]], [[[1, 1.5], [1, 0.5]]], [[[0.5, 1], [1, 0.5]], [[1.5, 1], [1, 1.5]]], [[[1.5, 1], [1, 0.5]]], [[[0.5, 1], [1.5, 1]]], [[[1, 1.5], [1.5, 1]]], [[[0.5, 1], [1, 1.5]]], []];
function mF() {
  var e = 1, t = 1, n = o;
  function i(u, l) {
    return l.map((c) => r(u, c));
  }
  function r(u, l) {
    var c = [], f = [];
    return a(u, l, (d) => {
      n(d, u, l), EX(d) > 0 ? c.push([d]) : f.push(d);
    }), f.forEach((d) => {
      for (var h = 0, p = c.length, g; h < p; ++h)
        if (SX((g = c[h])[0], d) !== -1) {
          g.push(d);
          return;
        }
    }), {
      type: "MultiPolygon",
      value: l,
      coordinates: c
    };
  }
  function a(u, l, c) {
    var f = new Array(), d = new Array(), h, p, g, m, y, b;
    for (h = p = -1, m = u[0] >= l, Fr[m << 1].forEach(v); ++h < e - 1; )
      g = m, m = u[h + 1] >= l, Fr[g | m << 1].forEach(v);
    for (Fr[m << 0].forEach(v); ++p < t - 1; ) {
      for (h = -1, m = u[p * e + e] >= l, y = u[p * e] >= l, Fr[m << 1 | y << 2].forEach(v); ++h < e - 1; )
        g = m, m = u[p * e + e + h + 1] >= l, b = y, y = u[p * e + h + 1] >= l, Fr[g | m << 1 | y << 2 | b << 3].forEach(v);
      Fr[m | y << 3].forEach(v);
    }
    for (h = -1, y = u[p * e] >= l, Fr[y << 2].forEach(v); ++h < e - 1; )
      b = y, y = u[p * e + h + 1] >= l, Fr[y << 2 | b << 3].forEach(v);
    Fr[y << 3].forEach(v);
    function v(x) {
      var w = [x[0][0] + h, x[0][1] + p], E = [x[1][0] + h, x[1][1] + p], $ = s(w), S = s(E), A, k;
      (A = d[$]) ? (k = f[S]) ? (delete d[A.end], delete f[k.start], A === k ? (A.ring.push(E), c(A.ring)) : f[A.start] = d[k.end] = {
        start: A.start,
        end: k.end,
        ring: A.ring.concat(k.ring)
      }) : (delete d[A.end], A.ring.push(E), d[A.end = S] = A) : (A = f[S]) ? (k = d[$]) ? (delete f[A.start], delete d[k.end], A === k ? (A.ring.push(E), c(A.ring)) : f[k.start] = d[A.end] = {
        start: k.start,
        end: A.end,
        ring: k.ring.concat(A.ring)
      }) : (delete f[A.start], A.ring.unshift(w), f[A.start = $] = A) : f[$] = d[S] = {
        start: $,
        end: S,
        ring: [w, E]
      };
    }
  }
  function s(u) {
    return u[0] * 2 + u[1] * (e + 1) * 4;
  }
  function o(u, l, c) {
    u.forEach((f) => {
      var d = f[0], h = f[1], p = d | 0, g = h | 0, m, y = l[g * e + p];
      d > 0 && d < e && p === d && (m = l[g * e + p - 1], f[0] = d + (c - m) / (y - m) - 0.5), h > 0 && h < t && g === h && (m = l[(g - 1) * e + p], f[1] = h + (c - m) / (y - m) - 0.5);
    });
  }
  return i.contour = r, i.size = function(u) {
    if (!arguments.length)
      return [e, t];
    var l = Math.floor(u[0]), c = Math.floor(u[1]);
    return l >= 0 && c >= 0 || D("invalid size"), e = l, t = c, i;
  }, i.smooth = function(u) {
    return arguments.length ? (n = u ? o : wX, i) : n === o;
  }, i;
}
function EX(e) {
  for (var t = 0, n = e.length, i = e[n - 1][1] * e[0][0] - e[n - 1][0] * e[0][1]; ++t < n; )
    i += e[t - 1][1] * e[t][0] - e[t - 1][0] * e[t][1];
  return i;
}
function SX(e, t) {
  for (var n = -1, i = t.length, r; ++n < i; )
    if (r = AX(e, t[n]))
      return r;
  return 0;
}
function AX(e, t) {
  for (var n = t[0], i = t[1], r = -1, a = 0, s = e.length, o = s - 1; a < s; o = a++) {
    var u = e[a], l = u[0], c = u[1], f = e[o], d = f[0], h = f[1];
    if (kX(u, f, t))
      return 0;
    c > i != h > i && n < (d - l) * (i - c) / (h - c) + l && (r = -r);
  }
  return r;
}
function kX(e, t, n) {
  var i;
  return CX(e, t, n) && _X(e[i = +(e[0] === t[0])], n[i], t[i]);
}
function CX(e, t, n) {
  return (t[0] - e[0]) * (n[1] - e[1]) === (n[0] - e[0]) * (t[1] - e[1]);
}
function _X(e, t, n) {
  return e <= t && t <= n || n <= t && t <= e;
}
function yF(e, t, n) {
  return function(i) {
    var r = Ci(i), a = n ? Math.min(r[0], 0) : r[0], s = r[1], o = s - a, u = t ? Bc(a, s, e) : o / (e + 1);
    return xt(a + u, s, u);
  };
}
function k$(e) {
  T.call(this, null, e);
}
k$.Definition = {
  type: "Isocontour",
  metadata: {
    generates: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "thresholds",
    type: "number",
    array: !0
  }, {
    name: "levels",
    type: "number"
  }, {
    name: "nice",
    type: "boolean",
    default: !1
  }, {
    name: "resolve",
    type: "enum",
    values: ["shared", "independent"],
    default: "independent"
  }, {
    name: "zero",
    type: "boolean",
    default: !0
  }, {
    name: "smooth",
    type: "boolean",
    default: !0
  }, {
    name: "scale",
    type: "number",
    expr: !0
  }, {
    name: "translate",
    type: "number",
    array: !0,
    expr: !0
  }, {
    name: "as",
    type: "string",
    null: !0,
    default: "contour"
  }]
};
B(k$, T, {
  transform(e, t) {
    if (this.value && !t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = t.materialize(t.SOURCE).source, r = e.field || kt, a = mF().smooth(e.smooth !== !1), s = e.thresholds || FX(i, r, e), o = e.as === null ? null : e.as || "contour", u = [];
    return i.forEach((l) => {
      const c = r(l), f = a.size([c.width, c.height])(c.values, R(s) ? s : s(c.values));
      MX(f, c, l, e), f.forEach((d) => {
        u.push(d0(l, $e(o != null ? {
          [o]: d
        } : d)));
      });
    }), this.value && (n.rem = this.value), this.value = n.source = n.add = u, n;
  }
});
function FX(e, t, n) {
  const i = yF(n.levels || 10, n.nice, n.zero !== !1);
  return n.resolve !== "shared" ? i : i(e.map((r) => Ws(t(r).values)));
}
function MX(e, t, n, i) {
  let r = i.scale || t.scale, a = i.translate || t.translate;
  if (oe(r) && (r = r(n, i)), oe(a) && (a = a(n, i)), (r === 1 || r == null) && !a)
    return;
  const s = (ye(r) ? r : r[0]) || 1, o = (ye(r) ? r : r[1]) || 1, u = a && a[0] || 0, l = a && a[1] || 0;
  e.forEach(bF(t, s, o, u, l));
}
function bF(e, t, n, i, r) {
  const a = e.x1 || 0, s = e.y1 || 0, o = t * n < 0;
  function u(f) {
    f.forEach(l);
  }
  function l(f) {
    o && f.reverse(), f.forEach(c);
  }
  function c(f) {
    f[0] = (f[0] - a) * t + i, f[1] = (f[1] - s) * n + r;
  }
  return function(f) {
    return f.coordinates.forEach(u), f;
  };
}
function F6(e, t, n) {
  const i = e >= 0 ? e : ox(t, n);
  return Math.round((Math.sqrt(4 * i * i + 1) - 1) / 2);
}
function L1(e) {
  return oe(e) ? e : Ut(+e);
}
function vF() {
  var e = (u) => u[0], t = (u) => u[1], n = Zu, i = [-1, -1], r = 960, a = 500, s = 2;
  function o(u, l) {
    const c = F6(i[0], u, e) >> s, f = F6(i[1], u, t) >> s, d = c ? c + 2 : 0, h = f ? f + 2 : 0, p = 2 * d + (r >> s), g = 2 * h + (a >> s), m = new Float32Array(p * g), y = new Float32Array(p * g);
    let b = m;
    u.forEach((x) => {
      const w = d + (+e(x) >> s), E = h + (+t(x) >> s);
      w >= 0 && w < p && E >= 0 && E < g && (m[w + E * p] += +n(x));
    }), c > 0 && f > 0 ? (Go(p, g, m, y, c), Wo(p, g, y, m, f), Go(p, g, m, y, c), Wo(p, g, y, m, f), Go(p, g, m, y, c), Wo(p, g, y, m, f)) : c > 0 ? (Go(p, g, m, y, c), Go(p, g, y, m, c), Go(p, g, m, y, c), b = y) : f > 0 && (Wo(p, g, m, y, f), Wo(p, g, y, m, f), Wo(p, g, m, y, f), b = y);
    const v = l ? Math.pow(2, -2 * s) : 1 / Lk(b);
    for (let x = 0, w = p * g; x < w; ++x)
      b[x] *= v;
    return {
      values: b,
      scale: 1 << s,
      width: p,
      height: g,
      x1: d,
      y1: h,
      x2: d + (r >> s),
      y2: h + (a >> s)
    };
  }
  return o.x = function(u) {
    return arguments.length ? (e = L1(u), o) : e;
  }, o.y = function(u) {
    return arguments.length ? (t = L1(u), o) : t;
  }, o.weight = function(u) {
    return arguments.length ? (n = L1(u), o) : n;
  }, o.size = function(u) {
    if (!arguments.length)
      return [r, a];
    var l = +u[0], c = +u[1];
    return l >= 0 && c >= 0 || D("invalid size"), r = l, a = c, o;
  }, o.cellSize = function(u) {
    return arguments.length ? ((u = +u) >= 1 || D("invalid cell size"), s = Math.floor(Math.log(u) / Math.LN2), o) : 1 << s;
  }, o.bandwidth = function(u) {
    return arguments.length ? (u = G(u), u.length === 1 && (u = [+u[0], +u[0]]), u.length !== 2 && D("invalid bandwidth"), i = u, o) : i;
  }, o;
}
function Go(e, t, n, i, r) {
  const a = (r << 1) + 1;
  for (let s = 0; s < t; ++s)
    for (let o = 0, u = 0; o < e + r; ++o)
      o < e && (u += n[o + s * e]), o >= r && (o >= a && (u -= n[o - a + s * e]), i[o - r + s * e] = u / Math.min(o + 1, e - 1 + a - o, a));
}
function Wo(e, t, n, i, r) {
  const a = (r << 1) + 1;
  for (let s = 0; s < e; ++s)
    for (let o = 0, u = 0; o < t + r; ++o)
      o < t && (u += n[s + o * e]), o >= r && (o >= a && (u -= n[s + (o - a) * e]), i[s + (o - r) * e] = u / Math.min(o + 1, t - 1 + a - o, a));
}
function C$(e) {
  T.call(this, null, e);
}
C$.Definition = {
  type: "KDE2D",
  metadata: {
    generates: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "weight",
    type: "field"
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "cellSize",
    type: "number"
  }, {
    name: "bandwidth",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "counts",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    default: "grid"
  }]
};
const OX = ["x", "y", "weight", "size", "cellSize", "bandwidth"];
function xF(e, t) {
  return OX.forEach((n) => t[n] != null ? e[n](t[n]) : 0), e;
}
B(C$, T, {
  transform(e, t) {
    if (this.value && !t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = t.materialize(t.SOURCE).source, r = RX(i, e.groupby), a = (e.groupby || []).map(Ve), s = xF(vF(), e), o = e.as || "grid", u = [];
    function l(c, f) {
      for (let d = 0; d < a.length; ++d)
        c[a[d]] = f[d];
      return c;
    }
    return u = r.map((c) => $e(l({
      [o]: s(c, e.counts)
    }, c.dims))), this.value && (n.rem = this.value), this.value = n.source = n.add = u, n;
  }
});
function RX(e, t) {
  var n = [], i = (c) => c(o), r, a, s, o, u, l;
  if (t == null)
    n.push(e);
  else
    for (r = {}, a = 0, s = e.length; a < s; ++a)
      o = e[a], u = t.map(i), l = r[u], l || (r[u] = l = [], l.dims = u, n.push(l)), l.push(o);
  return n;
}
function _$(e) {
  T.call(this, null, e);
}
_$.Definition = {
  type: "Contour",
  metadata: {
    generates: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "values",
    type: "number",
    array: !0
  }, {
    name: "x",
    type: "field"
  }, {
    name: "y",
    type: "field"
  }, {
    name: "weight",
    type: "field"
  }, {
    name: "cellSize",
    type: "number"
  }, {
    name: "bandwidth",
    type: "number"
  }, {
    name: "count",
    type: "number"
  }, {
    name: "nice",
    type: "boolean",
    default: !1
  }, {
    name: "thresholds",
    type: "number",
    array: !0
  }, {
    name: "smooth",
    type: "boolean",
    default: !0
  }]
};
B(_$, T, {
  transform(e, t) {
    if (this.value && !t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.fork(t.NO_SOURCE | t.NO_FIELDS), i = mF().smooth(e.smooth !== !1), r = e.values, a = e.thresholds || yF(e.count || 10, e.nice, !!r), s = e.size, o, u;
    return r || (r = t.materialize(t.SOURCE).source, o = xF(vF(), e)(r, !0), u = bF(o, o.scale || 1, o.scale || 1, 0, 0), s = [o.width, o.height], r = o.values), a = R(a) ? a : a(r), r = i.size(s)(r, a), u && r.forEach(u), this.value && (n.rem = this.value), this.value = n.source = n.add = (r || []).map($e), n;
  }
});
const Ib = "Feature", F$ = "FeatureCollection", TX = "MultiPoint";
function M$(e) {
  T.call(this, null, e);
}
M$.Definition = {
  type: "GeoJSON",
  metadata: {},
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    length: 2
  }, {
    name: "geojson",
    type: "field"
  }]
};
B(M$, T, {
  transform(e, t) {
    var n = this._features, i = this._points, r = e.fields, a = r && r[0], s = r && r[1], o = e.geojson || !r && kt, u = t.ADD, l;
    l = e.modified() || t.changed(t.REM) || t.modified(Pt(o)) || a && t.modified(Pt(a)) || s && t.modified(Pt(s)), (!this.value || l) && (u = t.SOURCE, this._features = n = [], this._points = i = []), o && t.visit(u, (c) => n.push(o(c))), a && s && (t.visit(u, (c) => {
      var f = a(c), d = s(c);
      f != null && d != null && (f = +f) === f && (d = +d) === d && i.push([f, d]);
    }), n = n.concat({
      type: Ib,
      geometry: {
        type: TX,
        coordinates: i
      }
    })), this.value = {
      type: F$,
      features: n
    };
  }
});
function O$(e) {
  T.call(this, null, e);
}
O$.Definition = {
  type: "GeoPath",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "projection",
    type: "projection"
  }, {
    name: "field",
    type: "field"
  }, {
    name: "pointRadius",
    type: "number",
    expr: !0
  }, {
    name: "as",
    type: "string",
    default: "path"
  }]
};
B(O$, T, {
  transform(e, t) {
    var n = t.fork(t.ALL), i = this.value, r = e.field || kt, a = e.as || "path", s = n.SOURCE;
    !i || e.modified() ? (this.value = i = gF(e.projection), n.materialize().reflow()) : s = r === kt || t.modified(r.fields) ? n.ADD_MOD : n.ADD;
    const o = DX(i, e.pointRadius);
    return n.visit(s, (u) => u[a] = i(r(u))), i.pointRadius(o), n.modifies(a);
  }
});
function DX(e, t) {
  const n = e.pointRadius();
  return e.context(null), t != null && e.pointRadius(t), n;
}
function R$(e) {
  T.call(this, null, e);
}
R$.Definition = {
  type: "GeoPoint",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "projection",
    type: "projection",
    required: !0
  }, {
    name: "fields",
    type: "field",
    array: !0,
    required: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 2,
    default: ["x", "y"]
  }]
};
B(R$, T, {
  transform(e, t) {
    var n = e.projection, i = e.fields[0], r = e.fields[1], a = e.as || ["x", "y"], s = a[0], o = a[1], u;
    function l(c) {
      const f = n([i(c), r(c)]);
      f ? (c[s] = f[0], c[o] = f[1]) : (c[s] = void 0, c[o] = void 0);
    }
    return e.modified() ? t = t.materialize().reflow(!0).visit(t.SOURCE, l) : (u = t.modified(i.fields) || t.modified(r.fields), t.visit(u ? t.ADD_MOD : t.ADD, l)), t.modifies(a);
  }
});
function T$(e) {
  T.call(this, null, e);
}
T$.Definition = {
  type: "GeoShape",
  metadata: {
    modifies: !0,
    nomod: !0
  },
  params: [{
    name: "projection",
    type: "projection"
  }, {
    name: "field",
    type: "field",
    default: "datum"
  }, {
    name: "pointRadius",
    type: "number",
    expr: !0
  }, {
    name: "as",
    type: "string",
    default: "shape"
  }]
};
B(T$, T, {
  transform(e, t) {
    var n = t.fork(t.ALL), i = this.value, r = e.as || "shape", a = n.ADD;
    return (!i || e.modified()) && (this.value = i = NX(gF(e.projection), e.field || At("datum"), e.pointRadius), n.materialize().reflow(), a = n.SOURCE), n.visit(a, (s) => s[r] = i), n.modifies(r);
  }
});
function NX(e, t, n) {
  const i = n == null ? (r) => e(t(r)) : (r) => {
    var a = e.pointRadius(), s = e.pointRadius(n)(t(r));
    return e.pointRadius(a), s;
  };
  return i.context = (r) => (e.context(r), i), i;
}
function D$(e) {
  T.call(this, [], e), this.generator = Xz();
}
D$.Definition = {
  type: "Graticule",
  metadata: {
    changes: !0,
    generates: !0
  },
  params: [{
    name: "extent",
    type: "array",
    array: !0,
    length: 2,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "extentMajor",
    type: "array",
    array: !0,
    length: 2,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "extentMinor",
    type: "array",
    array: !0,
    length: 2,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "step",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "stepMajor",
    type: "number",
    array: !0,
    length: 2,
    default: [90, 360]
  }, {
    name: "stepMinor",
    type: "number",
    array: !0,
    length: 2,
    default: [10, 10]
  }, {
    name: "precision",
    type: "number",
    default: 2.5
  }]
};
B(D$, T, {
  transform(e, t) {
    var n = this.value, i = this.generator, r;
    if (!n.length || e.modified())
      for (const a in e)
        oe(i[a]) && i[a](e[a]);
    return r = i(), n.length ? t.mod.push(C8(n[0], r)) : t.add.push($e(r)), n[0] = r, t;
  }
});
function N$(e) {
  T.call(this, null, e);
}
N$.Definition = {
  type: "heatmap",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "color",
    type: "string",
    expr: !0
  }, {
    name: "opacity",
    type: "number",
    expr: !0
  }, {
    name: "resolve",
    type: "enum",
    values: ["shared", "independent"],
    default: "independent"
  }, {
    name: "as",
    type: "string",
    default: "image"
  }]
};
B(N$, T, {
  transform(e, t) {
    if (!t.changed() && !e.modified())
      return t.StopPropagation;
    var n = t.materialize(t.SOURCE).source, i = e.resolve === "shared", r = e.field || kt, a = PX(e.opacity, e), s = LX(e.color, e), o = e.as || "image", u = {
      $x: 0,
      $y: 0,
      $value: 0,
      $max: i ? Ws(n.map((l) => Ws(r(l).values))) : 0
    };
    return n.forEach((l) => {
      const c = r(l), f = ue({}, l, u);
      i || (f.$max = Ws(c.values || [])), l[o] = zX(c, f, s.dep ? s : Ut(s(f)), a.dep ? a : Ut(a(f)));
    }), t.reflow(!0).modifies(o);
  }
});
function LX(e, t) {
  let n;
  return oe(e) ? (n = (i) => mu(e(i, t)), n.dep = $F(e)) : n = Ut(mu(e || "#888")), n;
}
function PX(e, t) {
  let n;
  return oe(e) ? (n = (i) => e(i, t), n.dep = $F(e)) : e ? n = Ut(e) : (n = (i) => i.$value / i.$max || 0, n.dep = !0), n;
}
function $F(e) {
  if (!oe(e))
    return !1;
  const t = an(Pt(e));
  return t.$x || t.$y || t.$value || t.$max;
}
function zX(e, t, n, i) {
  const r = e.width, a = e.height, s = e.x1 || 0, o = e.y1 || 0, u = e.x2 || r, l = e.y2 || a, c = e.values, f = c ? (m) => c[m] : wa, d = Ei(u - s, l - o), h = d.getContext("2d"), p = h.getImageData(0, 0, u - s, l - o), g = p.data;
  for (let m = o, y = 0; m < l; ++m) {
    t.$y = m - o;
    for (let b = s, v = m * r; b < u; ++b, y += 4) {
      t.$x = b - s, t.$value = f(b + v);
      const x = n(t);
      g[y + 0] = x.r, g[y + 1] = x.g, g[y + 2] = x.b, g[y + 3] = ~~(255 * i(t));
    }
  }
  return h.putImageData(p, 0, 0), d;
}
function wF(e) {
  T.call(this, null, e), this.modified(!0);
}
B(wF, T, {
  transform(e, t) {
    let n = this.value;
    return !n || e.modified("type") ? (this.value = n = BX(e.type), zb.forEach((i) => {
      e[i] != null && M6(n, i, e[i]);
    })) : zb.forEach((i) => {
      e.modified(i) && M6(n, i, e[i]);
    }), e.pointRadius != null && n.path.pointRadius(e.pointRadius), e.fit && IX(n, e), t.fork(t.NO_SOURCE | t.NO_FIELDS);
  }
});
function IX(e, t) {
  const n = jX(t.fit);
  t.extent ? e.fitExtent(t.extent, n) : t.size && e.fitSize(t.size, n);
}
function BX(e) {
  const t = A$((e || "mercator").toLowerCase());
  return t || D("Unrecognized projection type: " + e), t();
}
function M6(e, t, n) {
  oe(e[t]) && e[t](n);
}
function jX(e) {
  return e = G(e), e.length === 1 ? e[0] : {
    type: F$,
    features: e.reduce((t, n) => t.concat(UX(n)), [])
  };
}
function UX(e) {
  return e.type === F$ ? e.features : G(e).filter((t) => t != null).map((t) => t.type === Ib ? t : {
    type: Ib,
    geometry: t
  });
}
const qX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  contour: _$,
  geojson: M$,
  geopath: O$,
  geopoint: R$,
  geoshape: T$,
  graticule: D$,
  heatmap: N$,
  isocontour: k$,
  kde2d: C$,
  projection: wF
}, Symbol.toStringTag, { value: "Module" })), O6 = {
  center: XP,
  collide: hz,
  nbody: Sz,
  link: gz,
  x: Az,
  y: kz
}, hc = "forces", Bb = ["alpha", "alphaMin", "alphaTarget", "velocityDecay", "forces"], GX = ["static", "iterations"], EF = ["x", "y", "vx", "vy"];
function L$(e) {
  T.call(this, null, e);
}
L$.Definition = {
  type: "Force",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "static",
    type: "boolean",
    default: !1
  }, {
    name: "restart",
    type: "boolean",
    default: !1
  }, {
    name: "iterations",
    type: "number",
    default: 300
  }, {
    name: "alpha",
    type: "number",
    default: 1
  }, {
    name: "alphaMin",
    type: "number",
    default: 1e-3
  }, {
    name: "alphaTarget",
    type: "number",
    default: 0
  }, {
    name: "velocityDecay",
    type: "number",
    default: 0.4
  }, {
    name: "forces",
    type: "param",
    array: !0,
    params: [{
      key: {
        force: "center"
      },
      params: [{
        name: "x",
        type: "number",
        default: 0
      }, {
        name: "y",
        type: "number",
        default: 0
      }]
    }, {
      key: {
        force: "collide"
      },
      params: [{
        name: "radius",
        type: "number",
        expr: !0
      }, {
        name: "strength",
        type: "number",
        default: 0.7
      }, {
        name: "iterations",
        type: "number",
        default: 1
      }]
    }, {
      key: {
        force: "nbody"
      },
      params: [{
        name: "strength",
        type: "number",
        default: -30,
        expr: !0
      }, {
        name: "theta",
        type: "number",
        default: 0.9
      }, {
        name: "distanceMin",
        type: "number",
        default: 1
      }, {
        name: "distanceMax",
        type: "number"
      }]
    }, {
      key: {
        force: "link"
      },
      params: [{
        name: "links",
        type: "data"
      }, {
        name: "id",
        type: "field"
      }, {
        name: "distance",
        type: "number",
        default: 30,
        expr: !0
      }, {
        name: "strength",
        type: "number",
        expr: !0
      }, {
        name: "iterations",
        type: "number",
        default: 1
      }]
    }, {
      key: {
        force: "x"
      },
      params: [{
        name: "strength",
        type: "number",
        default: 0.1
      }, {
        name: "x",
        type: "field"
      }]
    }, {
      key: {
        force: "y"
      },
      params: [{
        name: "strength",
        type: "number",
        default: 0.1
      }, {
        name: "y",
        type: "field"
      }]
    }]
  }, {
    name: "as",
    type: "string",
    array: !0,
    modify: !1,
    default: EF
  }]
};
B(L$, T, {
  transform(e, t) {
    var n = this.value, i = t.changed(t.ADD_REM), r = e.modified(Bb), a = e.iterations || 300;
    if (n ? (i && (t.modifies("index"), n.nodes(t.source)), (r || t.changed(t.MOD)) && SF(n, e, 0, t)) : (this.value = n = HX(t.source, e), n.on("tick", WX(t.dataflow, this)), e.static || (i = !0, n.tick()), t.modifies("index")), r || i || e.modified(GX) || t.changed() && e.restart) {
      if (n.alpha(Math.max(n.alpha(), e.alpha || 1)).alphaDecay(1 - Math.pow(n.alphaMin(), 1 / a)), e.static)
        for (n.stop(); --a >= 0; )
          n.tick();
      else if (n.stopped() && n.restart(), !i)
        return t.StopPropagation;
    }
    return this.finish(e, t);
  },
  finish(e, t) {
    const n = t.dataflow;
    for (let o = this._argops, u = 0, l = o.length, c; u < l; ++u)
      if (c = o[u], !(c.name !== hc || c.op._argval.force !== "link")) {
        for (var i = c.op._argops, r = 0, a = i.length, s; r < a; ++r)
          if (i[r].name === "links" && (s = i[r].op.source)) {
            n.pulse(s, n.changeset().reflow());
            break;
          }
      }
    return t.reflow(e.modified()).modifies(EF);
  }
});
function WX(e, t) {
  return () => e.touch(t).run();
}
function HX(e, t) {
  const n = Ez(e), i = n.stop, r = n.restart;
  let a = !1;
  return n.stopped = () => a, n.restart = () => (a = !1, r()), n.stop = () => (a = !0, i()), SF(n, t, !0).on("end", () => a = !0);
}
function SF(e, t, n, i) {
  var r = G(t.forces), a, s, o, u;
  for (a = 0, s = Bb.length; a < s; ++a)
    o = Bb[a], o !== hc && t.modified(o) && e[o](t[o]);
  for (a = 0, s = r.length; a < s; ++a)
    u = hc + a, o = n || t.modified(hc, a) ? XX(r[a]) : i && VX(r[a], i) ? e.force(u) : null, o && e.force(u, o);
  for (s = e.numForces || 0; a < s; ++a)
    e.force(hc + a, null);
  return e.numForces = r.length, e;
}
function VX(e, t) {
  var n, i;
  for (n in e)
    if (oe(i = e[n]) && t.modified(Pt(i)))
      return 1;
  return 0;
}
function XX(e) {
  var t, n;
  Y(O6, e.force) || D("Unrecognized force: " + e.force), t = O6[e.force]();
  for (n in e)
    oe(t[n]) && YX(t[n], e[n], e);
  return t;
}
function YX(e, t, n) {
  e(oe(t) ? (i) => t(i, n) : t);
}
const KX = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  force: L$
}, Symbol.toStringTag, { value: "Module" }));
function jb(e, t, n) {
  const i = {};
  return e.each((r) => {
    const a = r.data;
    n(a) && (i[t(a)] = r);
  }), e.lookup = i, e;
}
function P$(e) {
  T.call(this, null, e);
}
P$.Definition = {
  type: "Nest",
  metadata: {
    treesource: !0,
    changes: !0
  },
  params: [{
    name: "keys",
    type: "field",
    array: !0
  }, {
    name: "generate",
    type: "boolean"
  }]
};
const JX = (e) => e.values;
B(P$, T, {
  transform(e, t) {
    t.source || D("Nest transform requires an upstream data source.");
    var n = e.generate, i = e.modified(), r = t.clone(), a = this.value;
    return (!a || i || t.changed()) && (a && a.each((s) => {
      s.children && ol(s.data) && r.rem.push(s.data);
    }), this.value = a = g2({
      values: G(e.keys).reduce((s, o) => (s.key(o), s), QX()).entries(r.source)
    }, JX), n && a.each((s) => {
      s.children && (s = $e(s.data), r.add.push(s), r.source.push(s));
    }), jb(a, ee, ee)), r.source.root = a, r;
  }
});
function QX() {
  const e = [], t = {
    entries: (r) => i(n(r, 0), 0),
    key: (r) => (e.push(r), t)
  };
  function n(r, a) {
    if (a >= e.length)
      return r;
    const s = r.length, o = e[a++], u = {}, l = {};
    let c = -1, f, d, h;
    for (; ++c < s; )
      f = o(d = r[c]) + "", (h = u[f]) ? h.push(d) : u[f] = [d];
    for (f in u)
      l[f] = n(u[f], a);
    return l;
  }
  function i(r, a) {
    if (++a > e.length)
      return r;
    const s = [];
    for (const o in r)
      s.push({
        key: o,
        values: i(r[o], a)
      });
    return s;
  }
  return t;
}
function na(e) {
  T.call(this, null, e);
}
const ZX = (e, t) => e.parent === t.parent ? 1 : 2;
B(na, T, {
  transform(e, t) {
    (!t.source || !t.source.root) && D(this.constructor.name + " transform requires a backing tree data source.");
    const n = this.layout(e.method), i = this.fields, r = t.source.root, a = e.as || i;
    e.field ? r.sum(e.field) : r.count(), e.sort && r.sort(Ao(e.sort, (s) => s.data)), eY(n, this.params, e), n.separation && n.separation(e.separation !== !1 ? ZX : Zu);
    try {
      this.value = n(r);
    } catch (s) {
      D(s);
    }
    return r.each((s) => tY(s, i, a)), t.reflow(e.modified()).modifies(a).modifies("leaf");
  }
});
function eY(e, t, n) {
  for (let i, r = 0, a = t.length; r < a; ++r)
    i = t[r], i in n && e[i](n[i]);
}
function tY(e, t, n) {
  const i = e.data, r = t.length - 1;
  for (let a = 0; a < r; ++a)
    i[n[a]] = e[t[a]];
  i[n[r]] = e.children ? e.children.length : 0;
}
const Ub = ["x", "y", "r", "depth", "children"];
function z$(e) {
  na.call(this, e);
}
z$.Definition = {
  type: "Pack",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "radius",
    type: "field",
    default: null
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: Ub.length,
    default: Ub
  }]
};
B(z$, na, {
  layout: yB,
  params: ["radius", "size", "padding"],
  fields: Ub
});
const qb = ["x0", "y0", "x1", "y1", "depth", "children"];
function I$(e) {
  na.call(this, e);
}
I$.Definition = {
  type: "Partition",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "round",
    type: "boolean",
    default: !1
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: qb.length,
    default: qb
  }]
};
B(I$, na, {
  layout: bB,
  params: ["size", "round", "padding"],
  fields: qb
});
function B$(e) {
  T.call(this, null, e);
}
B$.Definition = {
  type: "Stratify",
  metadata: {
    treesource: !0
  },
  params: [{
    name: "key",
    type: "field",
    required: !0
  }, {
    name: "parentKey",
    type: "field",
    required: !0
  }]
};
B(B$, T, {
  transform(e, t) {
    t.source || D("Stratify transform requires an upstream data source.");
    let n = this.value;
    const i = e.modified(), r = t.fork(t.ALL).materialize(t.SOURCE), a = !n || i || t.changed(t.ADD_REM) || t.modified(e.key.fields) || t.modified(e.parentKey.fields);
    return r.source = r.source.slice(), a && (n = r.source.length ? jb(gS().id(e.key).parentId(e.parentKey)(r.source), e.key, jt) : jb(gS()([{}]), e.key, e.key)), r.source.root = this.value = n, r;
  }
});
const R6 = {
  tidy: _B,
  cluster: BI
}, Gb = ["x", "y", "depth", "children"];
function j$(e) {
  na.call(this, e);
}
j$.Definition = {
  type: "Tree",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "method",
    type: "enum",
    default: "tidy",
    values: ["tidy", "cluster"]
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "nodeSize",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "separation",
    type: "boolean",
    default: !0
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: Gb.length,
    default: Gb
  }]
};
B(j$, na, {
  /**
   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.
   */
  layout(e) {
    const t = e || "tidy";
    if (Y(R6, t))
      return R6[t]();
    D("Unrecognized Tree layout method: " + t);
  },
  params: ["size", "nodeSize"],
  fields: Gb
});
function U$(e) {
  T.call(this, [], e);
}
U$.Definition = {
  type: "TreeLinks",
  metadata: {
    tree: !0,
    generates: !0,
    changes: !0
  },
  params: []
};
B(U$, T, {
  transform(e, t) {
    const n = this.value, i = t.source && t.source.root, r = t.fork(t.NO_SOURCE), a = {};
    return i || D("TreeLinks transform requires a tree data source."), t.changed(t.ADD_REM) ? (r.rem = n, t.visit(t.SOURCE, (s) => a[ee(s)] = 1), i.each((s) => {
      const o = s.data, u = s.parent && s.parent.data;
      u && a[ee(o)] && a[ee(u)] && r.add.push($e({
        source: u,
        target: o
      }));
    }), this.value = r.add) : t.changed(t.MOD) && (t.visit(t.MOD, (s) => a[ee(s)] = 1), n.forEach((s) => {
      (a[ee(s.source)] || a[ee(s.target)]) && r.mod.push(s);
    })), r;
  }
});
const T6 = {
  binary: MB,
  dice: Of,
  slice: Hg,
  slicedice: OB,
  squarify: I9,
  resquarify: RB
}, Wb = ["x0", "y0", "x1", "y1", "depth", "children"];
function q$(e) {
  na.call(this, e);
}
q$.Definition = {
  type: "Treemap",
  metadata: {
    tree: !0,
    modifies: !0
  },
  params: [{
    name: "field",
    type: "field"
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "method",
    type: "enum",
    default: "squarify",
    values: ["squarify", "resquarify", "binary", "dice", "slice", "slicedice"]
  }, {
    name: "padding",
    type: "number",
    default: 0
  }, {
    name: "paddingInner",
    type: "number",
    default: 0
  }, {
    name: "paddingOuter",
    type: "number",
    default: 0
  }, {
    name: "paddingTop",
    type: "number",
    default: 0
  }, {
    name: "paddingRight",
    type: "number",
    default: 0
  }, {
    name: "paddingBottom",
    type: "number",
    default: 0
  }, {
    name: "paddingLeft",
    type: "number",
    default: 0
  }, {
    name: "ratio",
    type: "number",
    default: 1.618033988749895
  }, {
    name: "round",
    type: "boolean",
    default: !1
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: Wb.length,
    default: Wb
  }]
};
B(q$, na, {
  /**
   * Treemap layout generator. Adds 'method' and 'ratio' parameters
   * to configure the underlying tile method.
   */
  layout() {
    const e = FB();
    return e.ratio = (t) => {
      const n = e.tile();
      n.ratio && e.tile(n.ratio(t));
    }, e.method = (t) => {
      Y(T6, t) ? e.tile(T6[t]) : D("Unrecognized Treemap layout method: " + t);
    }, e;
  },
  params: ["method", "ratio", "size", "round", "padding", "paddingInner", "paddingOuter", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft"],
  fields: Wb
});
const nY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  nest: P$,
  pack: z$,
  partition: I$,
  stratify: B$,
  tree: j$,
  treelinks: U$,
  treemap: q$
}, Symbol.toStringTag, { value: "Module" })), P1 = 4278190080;
function iY(e, t) {
  const n = e.bitmap();
  return (t || []).forEach((i) => n.set(e(i.boundary[0]), e(i.boundary[3]))), [n, void 0];
}
function rY(e, t, n, i, r) {
  const a = e.width, s = e.height, o = i || r, u = Ei(a, s).getContext("2d"), l = Ei(a, s).getContext("2d"), c = o && Ei(a, s).getContext("2d");
  n.forEach((S) => Ih(u, S, !1)), Ih(l, t, !1), o && Ih(c, t, !0);
  const f = z1(u, a, s), d = z1(l, a, s), h = o && z1(c, a, s), p = e.bitmap(), g = o && e.bitmap();
  let m, y, b, v, x, w, E, $;
  for (y = 0; y < s; ++y)
    for (m = 0; m < a; ++m)
      x = y * a + m, w = f[x] & P1, $ = d[x] & P1, E = o && h[x] & P1, (w || E || $) && (b = e(m), v = e(y), !r && (w || $) && p.set(b, v), o && (w || E) && g.set(b, v));
  return [p, g];
}
function z1(e, t, n) {
  return new Uint32Array(e.getImageData(0, 0, t, n).data.buffer);
}
function Ih(e, t, n) {
  if (!t.length)
    return;
  const i = t[0].mark.marktype;
  i === "group" ? t.forEach((r) => {
    r.items.forEach((a) => Ih(e, a.items, n));
  }) : ti[i].draw(e, {
    items: n ? t.map(aY) : t
  });
}
function aY(e) {
  const t = d0(e, {});
  return t.stroke && t.strokeOpacity !== 0 || t.fill && t.fillOpacity !== 0 ? {
    ...t,
    strokeOpacity: 1,
    stroke: "#000",
    fillOpacity: 0
  } : t;
}
const Mr = 5, Gt = 31, ef = 32, va = new Uint32Array(ef + 1), pi = new Uint32Array(ef + 1);
pi[0] = 0;
va[0] = ~pi[0];
for (let e = 1; e <= ef; ++e)
  pi[e] = pi[e - 1] << 1 | 1, va[e] = ~pi[e];
function sY(e, t) {
  const n = new Uint32Array(~~((e * t + ef) / ef));
  function i(a, s) {
    n[a] |= s;
  }
  function r(a, s) {
    n[a] &= s;
  }
  return {
    array: n,
    get: (a, s) => {
      const o = s * e + a;
      return n[o >>> Mr] & 1 << (o & Gt);
    },
    set: (a, s) => {
      const o = s * e + a;
      i(o >>> Mr, 1 << (o & Gt));
    },
    clear: (a, s) => {
      const o = s * e + a;
      r(o >>> Mr, ~(1 << (o & Gt)));
    },
    getRange: (a, s, o, u) => {
      let l = u, c, f, d, h;
      for (; l >= s; --l)
        if (c = l * e + a, f = l * e + o, d = c >>> Mr, h = f >>> Mr, d === h) {
          if (n[d] & va[c & Gt] & pi[(f & Gt) + 1])
            return !0;
        } else {
          if (n[d] & va[c & Gt] || n[h] & pi[(f & Gt) + 1])
            return !0;
          for (let p = d + 1; p < h; ++p)
            if (n[p])
              return !0;
        }
      return !1;
    },
    setRange: (a, s, o, u) => {
      let l, c, f, d, h;
      for (; s <= u; ++s)
        if (l = s * e + a, c = s * e + o, f = l >>> Mr, d = c >>> Mr, f === d)
          i(f, va[l & Gt] & pi[(c & Gt) + 1]);
        else
          for (i(f, va[l & Gt]), i(d, pi[(c & Gt) + 1]), h = f + 1; h < d; ++h)
            i(h, 4294967295);
    },
    clearRange: (a, s, o, u) => {
      let l, c, f, d, h;
      for (; s <= u; ++s)
        if (l = s * e + a, c = s * e + o, f = l >>> Mr, d = c >>> Mr, f === d)
          r(f, pi[l & Gt] | va[(c & Gt) + 1]);
        else
          for (r(f, pi[l & Gt]), r(d, va[(c & Gt) + 1]), h = f + 1; h < d; ++h)
            r(h, 0);
    },
    outOfBounds: (a, s, o, u) => a < 0 || s < 0 || u >= t || o >= e
  };
}
function oY(e, t, n) {
  const i = Math.max(1, Math.sqrt(e * t / 1e6)), r = ~~((e + 2 * n + i) / i), a = ~~((t + 2 * n + i) / i), s = (o) => ~~((o + n) / i);
  return s.invert = (o) => o * i - n, s.bitmap = () => sY(r, a), s.ratio = i, s.padding = n, s.width = e, s.height = t, s;
}
function uY(e, t, n, i) {
  const r = e.width, a = e.height;
  return function(s) {
    const o = s.datum.datum.items[i].items, u = o.length, l = s.datum.fontSize, c = sr.width(s.datum, s.datum.text);
    let f = 0, d, h, p, g, m, y, b;
    for (let v = 0; v < u; ++v)
      d = o[v].x, p = o[v].y, h = o[v].x2 === void 0 ? d : o[v].x2, g = o[v].y2 === void 0 ? p : o[v].y2, m = (d + h) / 2, y = (p + g) / 2, b = Math.abs(h - d + g - p), b >= f && (f = b, s.x = m, s.y = y);
    return m = c / 2, y = l / 2, d = s.x - m, h = s.x + m, p = s.y - y, g = s.y + y, s.align = "center", d < 0 && h <= r ? s.align = "left" : 0 <= d && r < h && (s.align = "right"), s.baseline = "middle", p < 0 && g <= a ? s.baseline = "top" : 0 <= p && a < g && (s.baseline = "bottom"), !0;
  };
}
function Hp(e, t, n, i, r, a) {
  let s = n / 2;
  return e - s < 0 || e + s > r || t - (s = i / 2) < 0 || t + s > a;
}
function Fa(e, t, n, i, r, a, s, o) {
  const u = r * a / (i * 2), l = e(t - u), c = e(t + u), f = e(n - (a = a / 2)), d = e(n + a);
  return s.outOfBounds(l, f, c, d) || s.getRange(l, f, c, d) || o && o.getRange(l, f, c, d);
}
function lY(e, t, n, i) {
  const r = e.width, a = e.height, s = t[0], o = t[1];
  function u(l, c, f, d, h) {
    const p = e.invert(l), g = e.invert(c);
    let m = f, y = a, b;
    if (!Hp(p, g, d, h, r, a) && !Fa(e, p, g, h, d, m, s, o) && !Fa(e, p, g, h, d, h, s, null)) {
      for (; y - m >= 1; )
        b = (m + y) / 2, Fa(e, p, g, h, d, b, s, o) ? y = b : m = b;
      if (m > f)
        return [p, g, m, !0];
    }
  }
  return function(l) {
    const c = l.datum.datum.items[i].items, f = c.length, d = l.datum.fontSize, h = sr.width(l.datum, l.datum.text);
    let p = n ? d : 0, g = !1, m = !1, y = 0, b, v, x, w, E, $, S, A, k, _, P, F, M, C, O, L, z;
    for (let W = 0; W < f; ++W) {
      for (b = c[W].x, x = c[W].y, v = c[W].x2 === void 0 ? b : c[W].x2, w = c[W].y2 === void 0 ? x : c[W].y2, b > v && (z = b, b = v, v = z), x > w && (z = x, x = w, w = z), k = e(b), P = e(v), _ = ~~((k + P) / 2), F = e(x), C = e(w), M = ~~((F + C) / 2), S = _; S >= k; --S)
        for (A = M; A >= F; --A)
          L = u(S, A, p, h, d), L && ([l.x, l.y, p, g] = L);
      for (S = _; S <= P; ++S)
        for (A = M; A <= C; ++A)
          L = u(S, A, p, h, d), L && ([l.x, l.y, p, g] = L);
      !g && !n && (O = Math.abs(v - b + w - x), E = (b + v) / 2, $ = (x + w) / 2, O >= y && !Hp(E, $, h, d, r, a) && !Fa(e, E, $, d, h, d, s, null) && (y = O, l.x = E, l.y = $, m = !0));
    }
    return g || m ? (E = h / 2, $ = d / 2, s.setRange(e(l.x - E), e(l.y - $), e(l.x + E), e(l.y + $)), l.align = "center", l.baseline = "middle", !0) : !1;
  };
}
const cY = [-1, -1, 1, 1], fY = [-1, 1, -1, 1];
function dY(e, t, n, i) {
  const r = e.width, a = e.height, s = t[0], o = t[1], u = e.bitmap();
  return function(l) {
    const c = l.datum.datum.items[i].items, f = c.length, d = l.datum.fontSize, h = sr.width(l.datum, l.datum.text), p = [];
    let g = n ? d : 0, m = !1, y = !1, b = 0, v, x, w, E, $, S, A, k, _, P, F, M;
    for (let C = 0; C < f; ++C) {
      for (v = c[C].x, w = c[C].y, x = c[C].x2 === void 0 ? v : c[C].x2, E = c[C].y2 === void 0 ? w : c[C].y2, p.push([e((v + x) / 2), e((w + E) / 2)]); p.length; )
        if ([A, k] = p.pop(), !(s.get(A, k) || o.get(A, k) || u.get(A, k))) {
          u.set(A, k);
          for (let O = 0; O < 4; ++O)
            $ = A + cY[O], S = k + fY[O], u.outOfBounds($, S, $, S) || p.push([$, S]);
          if ($ = e.invert(A), S = e.invert(k), _ = g, P = a, !Hp($, S, h, d, r, a) && !Fa(e, $, S, d, h, _, s, o) && !Fa(e, $, S, d, h, d, s, null)) {
            for (; P - _ >= 1; )
              F = (_ + P) / 2, Fa(e, $, S, d, h, F, s, o) ? P = F : _ = F;
            _ > g && (l.x = $, l.y = S, g = _, m = !0);
          }
        }
      !m && !n && (M = Math.abs(x - v + E - w), $ = (v + x) / 2, S = (w + E) / 2, M >= b && !Hp($, S, h, d, r, a) && !Fa(e, $, S, d, h, d, s, null) && (b = M, l.x = $, l.y = S, y = !0));
    }
    return m || y ? ($ = h / 2, S = d / 2, s.setRange(e(l.x - $), e(l.y - S), e(l.x + $), e(l.y + S)), l.align = "center", l.baseline = "middle", !0) : !1;
  };
}
const hY = ["right", "center", "left"], pY = ["bottom", "middle", "top"];
function gY(e, t, n, i) {
  const r = e.width, a = e.height, s = t[0], o = t[1], u = i.length;
  return function(l) {
    const c = l.boundary, f = l.datum.fontSize;
    if (c[2] < 0 || c[5] < 0 || c[0] > r || c[3] > a)
      return !1;
    let d = l.textWidth ?? 0, h, p, g, m, y, b, v, x, w, E, $, S, A, k, _;
    for (let P = 0; P < u; ++P) {
      if (h = (n[P] & 3) - 1, p = (n[P] >>> 2 & 3) - 1, g = h === 0 && p === 0 || i[P] < 0, m = h && p ? Math.SQRT1_2 : 1, y = i[P] < 0 ? -1 : 1, b = c[1 + h] + i[P] * h * m, $ = c[4 + p] + y * f * p / 2 + i[P] * p * m, x = $ - f / 2, w = $ + f / 2, S = e(b), k = e(x), _ = e(w), !d)
        if (D6(S, S, k, _, s, o, b, b, x, w, c, g))
          d = sr.width(l.datum, l.datum.text);
        else
          continue;
      if (E = b + y * d * h / 2, b = E - d / 2, v = E + d / 2, S = e(b), A = e(v), D6(S, A, k, _, s, o, b, v, x, w, c, g))
        return l.x = h ? h * y < 0 ? v : b : E, l.y = p ? p * y < 0 ? w : x : $, l.align = hY[h * y + 1], l.baseline = pY[p * y + 1], s.setRange(S, k, A, _), !0;
    }
    return !1;
  };
}
function D6(e, t, n, i, r, a, s, o, u, l, c, f) {
  return !(r.outOfBounds(e, n, t, i) || (f && a || r).getRange(e, n, t, i));
}
const I1 = 0, B1 = 4, j1 = 8, U1 = 0, q1 = 1, G1 = 2, mY = {
  "top-left": I1 + U1,
  top: I1 + q1,
  "top-right": I1 + G1,
  left: B1 + U1,
  middle: B1 + q1,
  right: B1 + G1,
  "bottom-left": j1 + U1,
  bottom: j1 + q1,
  "bottom-right": j1 + G1
}, yY = {
  naive: uY,
  "reduced-search": lY,
  floodfill: dY
};
function bY(e, t, n, i, r, a, s, o, u, l, c) {
  if (!e.length)
    return e;
  const f = Math.max(i.length, r.length), d = vY(i, f), h = xY(r, f), p = $Y(e[0].datum), g = p === "group" && e[0].datum.items[u].marktype, m = g === "area", y = wY(p, g, o, u), b = l === null || l === 1 / 0, v = m && c === "naive";
  let x = -1, w = -1;
  const E = e.map((k) => {
    const _ = b ? sr.width(k, k.text) : void 0;
    return x = Math.max(x, _), w = Math.max(w, k.fontSize), {
      datum: k,
      opacity: 0,
      x: void 0,
      y: void 0,
      align: void 0,
      baseline: void 0,
      boundary: y(k),
      textWidth: _
    };
  });
  l = l === null || l === 1 / 0 ? Math.max(x, w) + Math.max(...i) : l;
  const $ = oY(t[0], t[1], l);
  let S;
  if (!v) {
    n && E.sort((P, F) => n(P.datum, F.datum));
    let k = !1;
    for (let P = 0; P < h.length && !k; ++P)
      k = h[P] === 5 || d[P] < 0;
    const _ = (p && s || m) && e.map((P) => P.datum);
    S = a.length || _ ? rY($, _ || [], a, k, m) : iY($, s && E);
  }
  const A = m ? yY[c]($, S, s, u) : gY($, S, h, d);
  return E.forEach((k) => k.opacity = +A(k)), E;
}
function vY(e, t) {
  const n = new Float64Array(t), i = e.length;
  for (let r = 0; r < i; ++r)
    n[r] = e[r] || 0;
  for (let r = i; r < t; ++r)
    n[r] = n[i - 1];
  return n;
}
function xY(e, t) {
  const n = new Int8Array(t), i = e.length;
  for (let r = 0; r < i; ++r)
    n[r] |= mY[e[r]];
  for (let r = i; r < t; ++r)
    n[r] = n[i - 1];
  return n;
}
function $Y(e) {
  return e && e.mark && e.mark.marktype;
}
function wY(e, t, n, i) {
  const r = (a) => [a.x, a.x, a.x, a.y, a.y, a.y];
  return e ? e === "line" || e === "area" ? (a) => r(a.datum) : t === "line" ? (a) => {
    const s = a.datum.items[i].items;
    return r(s.length ? s[n === "start" ? 0 : s.length - 1] : {
      x: NaN,
      y: NaN
    });
  } : (a) => {
    const s = a.datum.bounds;
    return [s.x1, (s.x1 + s.x2) / 2, s.x2, s.y1, (s.y1 + s.y2) / 2, s.y2];
  } : r;
}
const Hb = ["x", "y", "opacity", "align", "baseline"], AF = ["top-left", "left", "bottom-left", "top", "bottom", "top-right", "right", "bottom-right"];
function G$(e) {
  T.call(this, null, e);
}
G$.Definition = {
  type: "Label",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2,
    required: !0
  }, {
    name: "sort",
    type: "compare"
  }, {
    name: "anchor",
    type: "string",
    array: !0,
    default: AF
  }, {
    name: "offset",
    type: "number",
    array: !0,
    default: [1]
  }, {
    name: "padding",
    type: "number",
    default: 0,
    null: !0
  }, {
    name: "lineAnchor",
    type: "string",
    values: ["start", "end"],
    default: "end"
  }, {
    name: "markIndex",
    type: "number",
    default: 0
  }, {
    name: "avoidBaseMark",
    type: "boolean",
    default: !0
  }, {
    name: "avoidMarks",
    type: "data",
    array: !0
  }, {
    name: "method",
    type: "string",
    default: "naive"
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: Hb.length,
    default: Hb
  }]
};
B(G$, T, {
  transform(e, t) {
    function n(a) {
      const s = e[a];
      return oe(s) && t.modified(s.fields);
    }
    const i = e.modified();
    if (!(i || t.changed(t.ADD_REM) || n("sort")))
      return;
    (!e.size || e.size.length !== 2) && D("Size parameter should be specified as a [width, height] array.");
    const r = e.as || Hb;
    return bY(t.materialize(t.SOURCE).source || [], e.size, e.sort, G(e.offset == null ? 1 : e.offset), G(e.anchor || AF), e.avoidMarks || [], e.avoidBaseMark !== !1, e.lineAnchor || "end", e.markIndex || 0, e.padding === void 0 ? 0 : e.padding, e.method || "naive").forEach((a) => {
      const s = a.datum;
      s[r[0]] = a.x, s[r[1]] = a.y, s[r[2]] = a.opacity, s[r[3]] = a.align, s[r[4]] = a.baseline;
    }), t.reflow(i).modifies(r);
  }
});
const EY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  label: G$
}, Symbol.toStringTag, { value: "Module" }));
function kF(e, t) {
  var n = [], i = function(c) {
    return c(o);
  }, r, a, s, o, u, l;
  if (t == null)
    n.push(e);
  else
    for (r = {}, a = 0, s = e.length; a < s; ++a)
      o = e[a], u = t.map(i), l = r[u], l || (r[u] = l = [], l.dims = u, n.push(l)), l.push(o);
  return n;
}
function W$(e) {
  T.call(this, null, e);
}
W$.Definition = {
  type: "Loess",
  metadata: {
    generates: !0
  },
  params: [{
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "bandwidth",
    type: "number",
    default: 0.3
  }, {
    name: "as",
    type: "string",
    array: !0
  }]
};
B(W$, T, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const i = t.materialize(t.SOURCE).source, r = kF(i, e.groupby), a = (e.groupby || []).map(Ve), s = a.length, o = e.as || [Ve(e.x), Ve(e.y)], u = [];
      r.forEach((l) => {
        W8(l, e.x, e.y, e.bandwidth || 0.3).forEach((c) => {
          const f = {};
          for (let d = 0; d < s; ++d)
            f[a[d]] = l.dims[d];
          f[o[0]] = c[0], f[o[1]] = c[1], u.push($e(f));
        });
      }), this.value && (n.rem = this.value), this.value = n.add = n.source = u;
    }
    return n;
  }
});
const Vb = {
  constant: cx,
  linear: fx,
  log: j8,
  exp: U8,
  pow: q8,
  quad: dx,
  poly: G8
}, SY = (e, t) => e === "poly" ? t : e === "quad" ? 2 : 1;
function H$(e) {
  T.call(this, null, e);
}
H$.Definition = {
  type: "Regression",
  metadata: {
    generates: !0
  },
  params: [{
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "groupby",
    type: "field",
    array: !0
  }, {
    name: "method",
    type: "string",
    default: "linear",
    values: Object.keys(Vb)
  }, {
    name: "order",
    type: "number",
    default: 3
  }, {
    name: "extent",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "params",
    type: "boolean",
    default: !1
  }, {
    name: "as",
    type: "string",
    array: !0
  }]
};
B(H$, T, {
  transform(e, t) {
    const n = t.fork(t.NO_SOURCE | t.NO_FIELDS);
    if (!this.value || t.changed() || e.modified()) {
      const i = t.materialize(t.SOURCE).source, r = kF(i, e.groupby), a = (e.groupby || []).map(Ve), s = e.method || "linear", o = e.order == null ? 3 : e.order, u = SY(s, o), l = e.as || [Ve(e.x), Ve(e.y)], c = Vb[s], f = [];
      let d = e.extent;
      Y(Vb, s) || D("Invalid regression method: " + s), d != null && s === "log" && d[0] <= 0 && (t.dataflow.warn("Ignoring extent with values <= 0 for log regression."), d = null), r.forEach((h) => {
        if (h.length <= u) {
          t.dataflow.warn("Skipping regression with more parameters than data points.");
          return;
        }
        const g = c(h, e.x, e.y, o);
        if (e.params) {
          f.push($e({
            keys: h.dims,
            coef: g.coef,
            rSquared: g.rSquared
          }));
          return;
        }
        const m = d || Ci(h, e.x), y = (b) => {
          const v = {};
          for (let x = 0; x < a.length; ++x)
            v[a[x]] = h.dims[x];
          v[l[0]] = b[0], v[l[1]] = b[1], f.push($e(v));
        };
        s === "linear" || s === "constant" ? m.forEach((b) => y([b, g.predict(b)])) : A0(g.predict, m, 25, 200).forEach(y);
      }), this.value && (n.rem = this.value), this.value = n.add = n.source = f;
    }
    return n;
  }
});
const AY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  loess: W$,
  regression: H$
}, Symbol.toStringTag, { value: "Module" }));
function V$(e) {
  T.call(this, null, e);
}
V$.Definition = {
  type: "Voronoi",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "x",
    type: "field",
    required: !0
  }, {
    name: "y",
    type: "field",
    required: !0
  }, {
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "extent",
    type: "array",
    array: !0,
    length: 2,
    default: [[-1e5, -1e5], [1e5, 1e5]],
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }, {
    name: "as",
    type: "string",
    default: "path"
  }]
};
const kY = [-1e5, -1e5, 1e5, 1e5];
B(V$, T, {
  transform(e, t) {
    const n = e.as || "path", i = t.source;
    if (!i || !i.length)
      return t;
    let r = e.size;
    r = r ? [0, 0, r[0], r[1]] : (r = e.extent) ? [r[0][0], r[0][1], r[1][0], r[1][1]] : kY;
    const a = this.value = a2.from(i, e.x, e.y).voronoi(r);
    for (let s = 0, o = i.length; s < o; ++s) {
      const u = a.cellPolygon(s);
      i[s][n] = u && !_Y(u) ? CY(u) : null;
    }
    return t.reflow(e.modified()).modifies(n);
  }
});
function CY(e) {
  const t = e[0][0], n = e[0][1];
  let i = e.length - 1;
  for (; e[i][0] === t && e[i][1] === n; --i)
    ;
  return "M" + e.slice(0, i + 1).join("L") + "Z";
}
function _Y(e) {
  return e.length === 2 && e[0][0] === e[1][0] && e[0][1] === e[1][1];
}
const FY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  voronoi: V$
}, Symbol.toStringTag, { value: "Module" }));
var W1 = Math.PI / 180, pc = 64, Bh = 2048;
function MY() {
  var e = [256, 256], t, n, i, r, a, s, o, u = CF, l = [], c = Math.random, f = {};
  f.layout = function() {
    for (var p = d(Ei()), g = LY((e[0] >> 5) * e[1]), m = null, y = l.length, b = -1, v = [], x = l.map((E) => ({
      text: t(E),
      font: n(E),
      style: r(E),
      weight: a(E),
      rotate: s(E),
      size: ~~(i(E) + 1e-14),
      padding: o(E),
      xoff: 0,
      yoff: 0,
      x1: 0,
      y1: 0,
      x0: 0,
      y0: 0,
      hasText: !1,
      sprite: null,
      datum: E
    })).sort((E, $) => $.size - E.size); ++b < y; ) {
      var w = x[b];
      w.x = e[0] * (c() + 0.5) >> 1, w.y = e[1] * (c() + 0.5) >> 1, OY(p, w, x, b), w.hasText && h(g, w, m) && (v.push(w), m ? TY(m, w) : m = [{
        x: w.x + w.x0,
        y: w.y + w.y0
      }, {
        x: w.x + w.x1,
        y: w.y + w.y1
      }], w.x -= e[0] >> 1, w.y -= e[1] >> 1);
    }
    return v;
  };
  function d(p) {
    p.width = p.height = 1;
    var g = Math.sqrt(p.getContext("2d").getImageData(0, 0, 1, 1).data.length >> 2);
    p.width = (pc << 5) / g, p.height = Bh / g;
    var m = p.getContext("2d");
    return m.fillStyle = m.strokeStyle = "red", m.textAlign = "center", {
      context: m,
      ratio: g
    };
  }
  function h(p, g, m) {
    for (var y = g.x, b = g.y, v = Math.sqrt(e[0] * e[0] + e[1] * e[1]), x = u(e), w = c() < 0.5 ? 1 : -1, E = -w, $, S, A; ($ = x(E += w)) && (S = ~~$[0], A = ~~$[1], !(Math.min(Math.abs(S), Math.abs(A)) >= v)); )
      if (g.x = y + S, g.y = b + A, !(g.x + g.x0 < 0 || g.y + g.y0 < 0 || g.x + g.x1 > e[0] || g.y + g.y1 > e[1]) && (!m || !RY(g, p, e[0])) && (!m || DY(g, m))) {
        for (var k = g.sprite, _ = g.width >> 5, P = e[0] >> 5, F = g.x - (_ << 4), M = F & 127, C = 32 - M, O = g.y1 - g.y0, L = (g.y + g.y0) * P + (F >> 5), z, W = 0; W < O; W++) {
          z = 0;
          for (var J = 0; J <= _; J++)
            p[L + J] |= z << C | (J < _ ? (z = k[W * _ + J]) >>> M : 0);
          L += P;
        }
        return g.sprite = null, !0;
      }
    return !1;
  }
  return f.words = function(p) {
    return arguments.length ? (l = p, f) : l;
  }, f.size = function(p) {
    return arguments.length ? (e = [+p[0], +p[1]], f) : e;
  }, f.font = function(p) {
    return arguments.length ? (n = bs(p), f) : n;
  }, f.fontStyle = function(p) {
    return arguments.length ? (r = bs(p), f) : r;
  }, f.fontWeight = function(p) {
    return arguments.length ? (a = bs(p), f) : a;
  }, f.rotate = function(p) {
    return arguments.length ? (s = bs(p), f) : s;
  }, f.text = function(p) {
    return arguments.length ? (t = bs(p), f) : t;
  }, f.spiral = function(p) {
    return arguments.length ? (u = PY[p] || p, f) : u;
  }, f.fontSize = function(p) {
    return arguments.length ? (i = bs(p), f) : i;
  }, f.padding = function(p) {
    return arguments.length ? (o = bs(p), f) : o;
  }, f.random = function(p) {
    return arguments.length ? (c = p, f) : c;
  }, f;
}
function OY(e, t, n, i) {
  if (!t.sprite) {
    var r = e.context, a = e.ratio;
    r.clearRect(0, 0, (pc << 5) / a, Bh / a);
    var s = 0, o = 0, u = 0, l = n.length, c, f, d, h, p;
    for (--i; ++i < l; ) {
      if (t = n[i], r.save(), r.font = t.style + " " + t.weight + " " + ~~((t.size + 1) / a) + "px " + t.font, c = r.measureText(t.text + "m").width * a, d = t.size << 1, t.rotate) {
        var g = Math.sin(t.rotate * W1), m = Math.cos(t.rotate * W1), y = c * m, b = c * g, v = d * m, x = d * g;
        c = Math.max(Math.abs(y + x), Math.abs(y - x)) + 31 >> 5 << 5, d = ~~Math.max(Math.abs(b + v), Math.abs(b - v));
      } else
        c = c + 31 >> 5 << 5;
      if (d > u && (u = d), s + c >= pc << 5 && (s = 0, o += u, u = 0), o + d >= Bh)
        break;
      r.translate((s + (c >> 1)) / a, (o + (d >> 1)) / a), t.rotate && r.rotate(t.rotate * W1), r.fillText(t.text, 0, 0), t.padding && (r.lineWidth = 2 * t.padding, r.strokeText(t.text, 0, 0)), r.restore(), t.width = c, t.height = d, t.xoff = s, t.yoff = o, t.x1 = c >> 1, t.y1 = d >> 1, t.x0 = -t.x1, t.y0 = -t.y1, t.hasText = !0, s += c;
    }
    for (var w = r.getImageData(0, 0, (pc << 5) / a, Bh / a).data, E = []; --i >= 0; )
      if (t = n[i], !!t.hasText) {
        for (c = t.width, f = c >> 5, d = t.y1 - t.y0, h = 0; h < d * f; h++)
          E[h] = 0;
        if (s = t.xoff, s == null)
          return;
        o = t.yoff;
        var $ = 0, S = -1;
        for (p = 0; p < d; p++) {
          for (h = 0; h < c; h++) {
            var A = f * p + (h >> 5), k = w[(o + p) * (pc << 5) + (s + h) << 2] ? 1 << 31 - h % 32 : 0;
            E[A] |= k, $ |= k;
          }
          $ ? S = p : (t.y0++, d--, p--, o++);
        }
        t.y1 = t.y0 + S, t.sprite = E.slice(0, (t.y1 - t.y0) * f);
      }
  }
}
function RY(e, t, n) {
  n >>= 5;
  for (var i = e.sprite, r = e.width >> 5, a = e.x - (r << 4), s = a & 127, o = 32 - s, u = e.y1 - e.y0, l = (e.y + e.y0) * n + (a >> 5), c, f = 0; f < u; f++) {
    c = 0;
    for (var d = 0; d <= r; d++)
      if ((c << o | (d < r ? (c = i[f * r + d]) >>> s : 0)) & t[l + d])
        return !0;
    l += n;
  }
  return !1;
}
function TY(e, t) {
  var n = e[0], i = e[1];
  t.x + t.x0 < n.x && (n.x = t.x + t.x0), t.y + t.y0 < n.y && (n.y = t.y + t.y0), t.x + t.x1 > i.x && (i.x = t.x + t.x1), t.y + t.y1 > i.y && (i.y = t.y + t.y1);
}
function DY(e, t) {
  return e.x + e.x1 > t[0].x && e.x + e.x0 < t[1].x && e.y + e.y1 > t[0].y && e.y + e.y0 < t[1].y;
}
function CF(e) {
  var t = e[0] / e[1];
  return function(n) {
    return [t * (n *= 0.1) * Math.cos(n), n * Math.sin(n)];
  };
}
function NY(e) {
  var t = 4, n = t * e[0] / e[1], i = 0, r = 0;
  return function(a) {
    var s = a < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * s * a) - s & 3) {
      case 0:
        i += n;
        break;
      case 1:
        r += t;
        break;
      case 2:
        i -= n;
        break;
      default:
        r -= t;
        break;
    }
    return [i, r];
  };
}
function LY(e) {
  for (var t = [], n = -1; ++n < e; )
    t[n] = 0;
  return t;
}
function bs(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
var PY = {
  archimedean: CF,
  rectangular: NY
};
const _F = ["x", "y", "font", "fontSize", "fontStyle", "fontWeight", "angle"], zY = ["text", "font", "rotate", "fontSize", "fontStyle", "fontWeight"];
function X$(e) {
  T.call(this, MY(), e);
}
X$.Definition = {
  type: "Wordcloud",
  metadata: {
    modifies: !0
  },
  params: [{
    name: "size",
    type: "number",
    array: !0,
    length: 2
  }, {
    name: "font",
    type: "string",
    expr: !0,
    default: "sans-serif"
  }, {
    name: "fontStyle",
    type: "string",
    expr: !0,
    default: "normal"
  }, {
    name: "fontWeight",
    type: "string",
    expr: !0,
    default: "normal"
  }, {
    name: "fontSize",
    type: "number",
    expr: !0,
    default: 14
  }, {
    name: "fontSizeRange",
    type: "number",
    array: "nullable",
    default: [10, 50]
  }, {
    name: "rotate",
    type: "number",
    expr: !0,
    default: 0
  }, {
    name: "text",
    type: "field"
  }, {
    name: "spiral",
    type: "string",
    values: ["archimedean", "rectangular"]
  }, {
    name: "padding",
    type: "number",
    expr: !0
  }, {
    name: "as",
    type: "string",
    array: !0,
    length: 7,
    default: _F
  }]
};
B(X$, T, {
  transform(e, t) {
    e.size && !(e.size[0] && e.size[1]) && D("Wordcloud size dimensions must be non-zero.");
    function n(p) {
      const g = e[p];
      return oe(g) && t.modified(g.fields);
    }
    const i = e.modified();
    if (!(i || t.changed(t.ADD_REM) || zY.some(n)))
      return;
    const r = t.materialize(t.SOURCE).source, a = this.value, s = e.as || _F;
    let o = e.fontSize || 14, u;
    if (oe(o) ? u = e.fontSizeRange : o = Ut(o), u) {
      const p = o, g = be("sqrt")().domain(Ci(r, p)).range(u);
      o = (m) => g(p(m));
    }
    r.forEach((p) => {
      p[s[0]] = NaN, p[s[1]] = NaN, p[s[3]] = 0;
    });
    const l = a.words(r).text(e.text).size(e.size || [500, 500]).padding(e.padding || 1).spiral(e.spiral || "archimedean").rotate(e.rotate || 0).font(e.font || "sans-serif").fontStyle(e.fontStyle || "normal").fontWeight(e.fontWeight || "normal").fontSize(o).random(Pn).layout(), c = a.size(), f = c[0] >> 1, d = c[1] >> 1, h = l.length;
    for (let p = 0, g, m; p < h; ++p)
      g = l[p], m = g.datum, m[s[0]] = g.x + f, m[s[1]] = g.y + d, m[s[2]] = g.font, m[s[3]] = g.size, m[s[4]] = g.style, m[s[5]] = g.weight, m[s[6]] = g.rotate;
    return t.reflow(i).modifies(s);
  }
});
const IY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  wordcloud: X$
}, Symbol.toStringTag, { value: "Module" })), BY = (e) => new Uint8Array(e), jY = (e) => new Uint16Array(e), Fc = (e) => new Uint32Array(e);
function UY() {
  let e = 8, t = [], n = Fc(0), i = sh(0, e), r = sh(0, e);
  return {
    data: () => t,
    seen: () => n = qY(n, t.length),
    add(a) {
      for (let s = 0, o = t.length, u = a.length, l; s < u; ++s)
        l = a[s], l._index = o++, t.push(l);
    },
    remove(a, s) {
      const o = t.length, u = Array(o - a), l = t;
      let c, f, d;
      for (f = 0; !s[f] && f < o; ++f)
        u[f] = t[f], l[f] = f;
      for (d = f; f < o; ++f)
        c = t[f], s[f] ? l[f] = -1 : (l[f] = d, i[d] = i[f], r[d] = r[f], u[d] = c, c._index = d++), i[f] = 0;
      return t = u, l;
    },
    size: () => t.length,
    curr: () => i,
    prev: () => r,
    reset: (a) => r[a] = i[a],
    all: () => e < 257 ? 255 : e < 65537 ? 65535 : 4294967295,
    set(a, s) {
      i[a] |= s;
    },
    clear(a, s) {
      i[a] &= ~s;
    },
    resize(a, s) {
      const o = i.length;
      (a > o || s > e) && (e = Math.max(s, e), i = sh(a, e, i), r = sh(a, e));
    }
  };
}
function qY(e, t, n) {
  return e.length >= t ? e : (n = n || new e.constructor(t), n.set(e), n);
}
function sh(e, t, n) {
  const i = (t < 257 ? BY : t < 65537 ? jY : Fc)(e);
  return n && i.set(n), i;
}
function N6(e, t, n) {
  const i = 1 << t;
  return {
    one: i,
    zero: ~i,
    range: n.slice(),
    bisect: e.bisect,
    index: e.index,
    size: e.size,
    onAdd(r, a) {
      const s = this, o = s.bisect(s.range, r.value), u = r.index, l = o[0], c = o[1], f = u.length;
      let d;
      for (d = 0; d < l; ++d)
        a[u[d]] |= i;
      for (d = c; d < f; ++d)
        a[u[d]] |= i;
      return s;
    }
  };
}
function L6() {
  let e = Fc(0), t = [], n = 0;
  function i(o, u, l) {
    if (!u.length)
      return [];
    const c = n, f = u.length, d = Fc(f);
    let h = Array(f), p, g, m;
    for (m = 0; m < f; ++m)
      h[m] = o(u[m]), d[m] = m;
    if (h = GY(h, d), c)
      p = t, g = e, t = Array(c + f), e = Fc(c + f), WY(l, p, g, c, h, d, f, t, e);
    else {
      if (l > 0)
        for (m = 0; m < f; ++m)
          d[m] += l;
      t = h, e = d;
    }
    return n = c + f, {
      index: d,
      value: h
    };
  }
  function r(o, u) {
    const l = n;
    let c, f, d;
    for (f = 0; !u[e[f]] && f < l; ++f)
      ;
    for (d = f; f < l; ++f)
      u[c = e[f]] || (e[d] = c, t[d] = t[f], ++d);
    n = l - o;
  }
  function a(o) {
    for (let u = 0, l = n; u < l; ++u)
      e[u] = o[e[u]];
  }
  function s(o, u) {
    let l;
    return u ? l = u.length : (u = t, l = n), [ML(u, o[0], 0, l), Vr(u, o[1], 0, l)];
  }
  return {
    insert: i,
    remove: r,
    bisect: s,
    reindex: a,
    index: () => e,
    size: () => n
  };
}
function GY(e, t) {
  return e.sort.call(t, (n, i) => {
    const r = e[n], a = e[i];
    return r < a ? -1 : r > a ? 1 : 0;
  }), iP(e, t);
}
function WY(e, t, n, i, r, a, s, o, u) {
  let l = 0, c = 0, f;
  for (f = 0; l < i && c < s; ++f)
    t[l] < r[c] ? (o[f] = t[l], u[f] = n[l++]) : (o[f] = r[c], u[f] = a[c++] + e);
  for (; l < i; ++l, ++f)
    o[f] = t[l], u[f] = n[l];
  for (; c < s; ++c, ++f)
    o[f] = r[c], u[f] = a[c] + e;
}
function Y$(e) {
  T.call(this, UY(), e), this._indices = null, this._dims = null;
}
Y$.Definition = {
  type: "CrossFilter",
  metadata: {},
  params: [{
    name: "fields",
    type: "field",
    array: !0,
    required: !0
  }, {
    name: "query",
    type: "array",
    array: !0,
    required: !0,
    content: {
      type: "number",
      array: !0,
      length: 2
    }
  }]
};
B(Y$, T, {
  transform(e, t) {
    if (this._dims) {
      var n = e.modified("fields") || e.fields.some((i) => t.modified(i.fields));
      return n ? this.reinit(e, t) : this.eval(e, t);
    } else
      return this.init(e, t);
  },
  init(e, t) {
    const n = e.fields, i = e.query, r = this._indices = {}, a = this._dims = [], s = i.length;
    let o = 0, u, l;
    for (; o < s; ++o)
      u = n[o].fname, l = r[u] || (r[u] = L6()), a.push(N6(l, o, i[o]));
    return this.eval(e, t);
  },
  reinit(e, t) {
    const n = t.materialize().fork(), i = e.fields, r = e.query, a = this._indices, s = this._dims, o = this.value, u = o.curr(), l = o.prev(), c = o.all(), f = n.rem = n.add, d = n.mod, h = r.length, p = {};
    let g, m, y, b, v, x, w, E, $;
    if (l.set(u), t.rem.length && (v = this.remove(e, t, n)), t.add.length && o.add(t.add), t.mod.length)
      for (x = {}, b = t.mod, w = 0, E = b.length; w < E; ++w)
        x[b[w]._index] = 1;
    for (w = 0; w < h; ++w)
      $ = i[w], (!s[w] || e.modified("fields", w) || t.modified($.fields)) && (y = $.fname, (g = p[y]) || (a[y] = m = L6(), p[y] = g = m.insert($, t.source, 0)), s[w] = N6(m, w, r[w]).onAdd(g, u));
    for (w = 0, E = o.data().length; w < E; ++w)
      v[w] || (l[w] !== u[w] ? f.push(w) : x[w] && u[w] !== c && d.push(w));
    return o.mask = (1 << h) - 1, n;
  },
  eval(e, t) {
    const n = t.materialize().fork(), i = this._dims.length;
    let r = 0;
    return t.rem.length && (this.remove(e, t, n), r |= (1 << i) - 1), e.modified("query") && !e.modified("fields") && (r |= this.update(e, t, n)), t.add.length && (this.insert(e, t, n), r |= (1 << i) - 1), t.mod.length && (this.modify(t, n), r |= (1 << i) - 1), this.value.mask = r, n;
  },
  insert(e, t, n) {
    const i = t.add, r = this.value, a = this._dims, s = this._indices, o = e.fields, u = {}, l = n.add, c = r.size() + i.length, f = a.length;
    let d = r.size(), h, p, g;
    r.resize(c, f), r.add(i);
    const m = r.curr(), y = r.prev(), b = r.all();
    for (h = 0; h < f; ++h)
      p = o[h].fname, g = u[p] || (u[p] = s[p].insert(o[h], i, d)), a[h].onAdd(g, m);
    for (; d < c; ++d)
      y[d] = b, m[d] !== b && l.push(d);
  },
  modify(e, t) {
    const n = t.mod, i = this.value, r = i.curr(), a = i.all(), s = e.mod;
    let o, u, l;
    for (o = 0, u = s.length; o < u; ++o)
      l = s[o]._index, r[l] !== a && n.push(l);
  },
  remove(e, t, n) {
    const i = this._indices, r = this.value, a = r.curr(), s = r.prev(), o = r.all(), u = {}, l = n.rem, c = t.rem;
    let f, d, h, p;
    for (f = 0, d = c.length; f < d; ++f)
      h = c[f]._index, u[h] = 1, s[h] = p = a[h], a[h] = o, p !== o && l.push(h);
    for (h in i)
      i[h].remove(d, u);
    return this.reindex(t, d, u), u;
  },
  // reindex filters and indices after propagation completes
  reindex(e, t, n) {
    const i = this._indices, r = this.value;
    e.runAfter(() => {
      const a = r.remove(t, n);
      for (const s in i)
        i[s].reindex(a);
    });
  },
  update(e, t, n) {
    const i = this._dims, r = e.query, a = t.stamp, s = i.length;
    let o = 0, u, l;
    for (n.filters = 0, l = 0; l < s; ++l)
      e.modified("query", l) && (u = l, ++o);
    if (o === 1)
      o = i[u].one, this.incrementOne(i[u], r[u], n.add, n.rem);
    else
      for (l = 0, o = 0; l < s; ++l)
        e.modified("query", l) && (o |= i[l].one, this.incrementAll(i[l], r[l], a, n.add), n.rem = n.add);
    return o;
  },
  incrementAll(e, t, n, i) {
    const r = this.value, a = r.seen(), s = r.curr(), o = r.prev(), u = e.index(), l = e.bisect(e.range), c = e.bisect(t), f = c[0], d = c[1], h = l[0], p = l[1], g = e.one;
    let m, y, b;
    if (f < h)
      for (m = f, y = Math.min(h, d); m < y; ++m)
        b = u[m], a[b] !== n && (o[b] = s[b], a[b] = n, i.push(b)), s[b] ^= g;
    else if (f > h)
      for (m = h, y = Math.min(f, p); m < y; ++m)
        b = u[m], a[b] !== n && (o[b] = s[b], a[b] = n, i.push(b)), s[b] ^= g;
    if (d > p)
      for (m = Math.max(f, p), y = d; m < y; ++m)
        b = u[m], a[b] !== n && (o[b] = s[b], a[b] = n, i.push(b)), s[b] ^= g;
    else if (d < p)
      for (m = Math.max(h, d), y = p; m < y; ++m)
        b = u[m], a[b] !== n && (o[b] = s[b], a[b] = n, i.push(b)), s[b] ^= g;
    e.range = t.slice();
  },
  incrementOne(e, t, n, i) {
    const r = this.value, a = r.curr(), s = e.index(), o = e.bisect(e.range), u = e.bisect(t), l = u[0], c = u[1], f = o[0], d = o[1], h = e.one;
    let p, g, m;
    if (l < f)
      for (p = l, g = Math.min(f, c); p < g; ++p)
        m = s[p], a[m] ^= h, n.push(m);
    else if (l > f)
      for (p = f, g = Math.min(l, d); p < g; ++p)
        m = s[p], a[m] ^= h, i.push(m);
    if (c > d)
      for (p = Math.max(l, d), g = c; p < g; ++p)
        m = s[p], a[m] ^= h, n.push(m);
    else if (c < d)
      for (p = Math.max(f, c), g = d; p < g; ++p)
        m = s[p], a[m] ^= h, i.push(m);
    e.range = t.slice();
  }
});
function K$(e) {
  T.call(this, null, e);
}
K$.Definition = {
  type: "ResolveFilter",
  metadata: {},
  params: [{
    name: "ignore",
    type: "number",
    required: !0,
    description: "A bit mask indicating which filters to ignore."
  }, {
    name: "filter",
    type: "object",
    required: !0,
    description: "Per-tuple filter bitmaps from a CrossFilter transform."
  }]
};
B(K$, T, {
  transform(e, t) {
    const n = ~(e.ignore || 0), i = e.filter, r = i.mask;
    if (!(r & n))
      return t.StopPropagation;
    const a = t.fork(t.ALL), s = i.data(), o = i.curr(), u = i.prev(), l = (c) => o[c] & n ? null : s[c];
    return a.filter(a.MOD, l), r & r - 1 ? (a.filter(a.ADD, (c) => {
      const f = o[c] & n;
      return !f && f ^ u[c] & n ? s[c] : null;
    }), a.filter(a.REM, (c) => {
      const f = o[c] & n;
      return f && !(f ^ (f ^ u[c] & n)) ? s[c] : null;
    })) : (a.filter(a.ADD, l), a.filter(a.REM, (c) => (o[c] & n) === r ? s[c] : null)), a.filter(a.SOURCE, (c) => l(c._index));
  }
});
const HY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  crossfilter: Y$,
  resolvefilter: K$
}, Symbol.toStringTag, { value: "Module" }));
function VY(e, t, n) {
  const i = e - t + n * 2;
  return e ? i > 0 ? i : 1 : 0;
}
const XY = "identity", J$ = "linear", Wa = "log", Q$ = "pow", Z$ = "sqrt", ew = "symlog", tf = "time", nf = "utc", dl = "sequential", ad = "diverging", Vp = "quantile", tw = "quantize", FF = "threshold", YY = "ordinal", KY = "point", JY = "band", QY = "bin-ordinal", mt = "continuous", sd = "discrete", od = "discretizing", Ti = "interpolating", nw = "temporal";
function ZY(e) {
  return function(t) {
    let n = t[0], i = t[1], r;
    return i < n && (r = n, n = i, i = r), [e.invert(n), e.invert(i)];
  };
}
function eK(e) {
  return function(t) {
    const n = e.range();
    let i = t[0], r = t[1], a = -1, s, o, u, l;
    for (r < i && (o = i, i = r, r = o), u = 0, l = n.length; u < l; ++u)
      n[u] >= i && n[u] <= r && (a < 0 && (a = u), s = u);
    if (!(a < 0))
      return i = e.invertExtent(n[a]), r = e.invertExtent(n[s]), [i[0] === void 0 ? i[1] : i[0], r[1] === void 0 ? r[0] : r[1]];
  };
}
function iw() {
  const e = as().unknown(void 0), t = e.domain, n = e.range;
  let i = [0, 1], r, a, s = !1, o = 0, u = 0, l = 0.5;
  delete e.unknown;
  function c() {
    const f = t().length, d = i[1] < i[0], h = i[1 - d], p = VY(f, o, u);
    let g = i[d - 0];
    r = (h - g) / (p || 1), s && (r = Math.floor(r)), g += (h - g - r * (f - o)) * l, a = r * (1 - o), s && (g = Math.round(g), a = Math.round(a));
    const m = xt(f).map((y) => g + r * y);
    return n(d ? m.reverse() : m);
  }
  return e.domain = function(f) {
    return arguments.length ? (t(f), c()) : t();
  }, e.range = function(f) {
    return arguments.length ? (i = [+f[0], +f[1]], c()) : i.slice();
  }, e.rangeRound = function(f) {
    return i = [+f[0], +f[1]], s = !0, c();
  }, e.bandwidth = function() {
    return a;
  }, e.step = function() {
    return r;
  }, e.round = function(f) {
    return arguments.length ? (s = !!f, c()) : s;
  }, e.padding = function(f) {
    return arguments.length ? (u = Math.max(0, Math.min(1, f)), o = u, c()) : o;
  }, e.paddingInner = function(f) {
    return arguments.length ? (o = Math.max(0, Math.min(1, f)), c()) : o;
  }, e.paddingOuter = function(f) {
    return arguments.length ? (u = Math.max(0, Math.min(1, f)), c()) : u;
  }, e.align = function(f) {
    return arguments.length ? (l = Math.max(0, Math.min(1, f)), c()) : l;
  }, e.invertRange = function(f) {
    if (f[0] == null || f[1] == null)
      return;
    const d = i[1] < i[0], h = d ? n().reverse() : n(), p = h.length - 1;
    let g = +f[0], m = +f[1], y, b, v;
    if (!(g !== g || m !== m) && (m < g && (v = g, g = m, m = v), !(m < h[0] || g > i[1 - d])))
      return y = Math.max(0, Vr(h, g) - 1), b = g === m ? y : Vr(h, m) - 1, g - h[y] > a + 1e-10 && ++y, d && (v = y, y = p - b, b = p - v), y > b ? void 0 : t().slice(y, b + 1);
  }, e.invert = function(f) {
    const d = e.invertRange([f, f]);
    return d && d[0];
  }, e.copy = function() {
    return iw().domain(t()).range(i).round(s).paddingInner(o).paddingOuter(u).align(l);
  }, c();
}
function MF(e) {
  const t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, e.copy = function() {
    return MF(t());
  }, e;
}
function tK() {
  return MF(iw().paddingInner(1));
}
var nK = Array.prototype.map;
function iK(e) {
  return nK.call(e, Fe);
}
const rK = Array.prototype.slice;
function OF() {
  let e = [], t = [];
  function n(i) {
    return i == null || i !== i ? void 0 : t[(Eo(e, i) - 1) % t.length];
  }
  return n.domain = function(i) {
    return arguments.length ? (e = iK(i), n) : e.slice();
  }, n.range = function(i) {
    return arguments.length ? (t = rK.call(i), n) : t.slice();
  }, n.tickFormat = function(i, r) {
    return Bg(e[0], ae(e), i ?? 10, r);
  }, n.copy = function() {
    return OF().domain(n.domain()).range(n.range());
  }, n;
}
const Xp = /* @__PURE__ */ new Map(), aK = Symbol("vega_scale");
function sK(e) {
  return e[aK] = !0, e;
}
function oK(e, t, n) {
  const i = function() {
    const a = t();
    return a.invertRange || (a.invertRange = a.invert ? ZY(a) : a.invertExtent ? eK(a) : void 0), a.type = e, sK(a);
  };
  return i.metadata = an(G(n)), i;
}
function Ne(e, t, n) {
  return arguments.length > 1 ? (Xp.set(e, oK(e, t, n)), this) : uK(e) ? Xp.get(e) : void 0;
}
Ne(XY, Rf);
Ne(J$, Ig, mt);
Ne(Wa, Tf, [mt, Wa]);
Ne(Q$, Ku, mt);
Ne(Z$, Vg, mt);
Ne(ew, Df, mt);
Ne(tf, Pg, [mt, nw]);
Ne(nf, Xg, [mt, nw]);
Ne(dl, Qr, [mt, Ti]);
Ne(`${dl}-${J$}`, Qr, [mt, Ti]);
Ne(`${dl}-${Wa}`, zf, [mt, Ti, Wa]);
Ne(`${dl}-${Q$}`, Ju, [mt, Ti]);
Ne(`${dl}-${Z$}`, Kg, [mt, Ti]);
Ne(`${dl}-${ew}`, If, [mt, Ti]);
Ne(`${ad}-${J$}`, Bf, [mt, Ti]);
Ne(`${ad}-${Wa}`, jf, [mt, Ti, Wa]);
Ne(`${ad}-${Q$}`, Qu, [mt, Ti]);
Ne(`${ad}-${Z$}`, Qg, [mt, Ti]);
Ne(`${ad}-${ew}`, Uf, [mt, Ti]);
Ne(Vp, Nf, [od, Vp]);
Ne(tw, Lf, od);
Ne(FF, Pf, od);
Ne(QY, OF, [sd, od]);
Ne(YY, as, sd);
Ne(JY, iw, sd);
Ne(KY, tK, sd);
function uK(e) {
  return Xp.has(e);
}
function U0(e, t) {
  const n = Xp.get(e);
  return n && n.metadata[t];
}
function RF(e) {
  return U0(e, sd);
}
function lK(e) {
  return U0(e, od);
}
function cK(e) {
  return U0(e, Wa);
}
function fK(e) {
  return U0(e, nw);
}
function dK(e, t, n) {
  return Xu(hK(t || "rgb", n), e);
}
function hK(e, t) {
  const n = Ug[pK(e)];
  return t != null && n && n.gamma ? n.gamma(t) : n;
}
function pK(e) {
  return "interpolate" + e.toLowerCase().split("-").map((t) => t[0].toUpperCase() + t.slice(1)).join("");
}
const gK = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
}, mK = {
  category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
  accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
  dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
  paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
  pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
  pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
  set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
  set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
  set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
};
function TF(e) {
  const t = e.length / 6 | 0, n = new Array(t);
  for (let i = 0; i < t; )
    n[i] = "#" + e.slice(i * 6, ++i * 6);
  return n;
}
function DF(e, t) {
  for (const n in e)
    yK(n, t(e[n]));
}
const P6 = {};
DF(mK, TF);
DF(gK, (e) => dK(TF(e)));
function yK(e, t) {
  return e = e && e.toLowerCase(), arguments.length > 1 ? (P6[e] = t, this) : P6[e];
}
const bK = "symbol", vK = "discrete", xK = (e) => R(e) ? e.map((t) => String(t)) : String(e), $K = (e, t) => e[1] - t[1], wK = (e, t) => t[1] - e[1];
function EK(e, t, n) {
  let i = e.range(), r = i[0], a = ae(i), s = $K;
  if (r > a && (i = a, a = r, r = i, s = wK), r = Math.floor(r), a = Math.ceil(a), t = t.map((o) => [o, e(o)]).filter((o) => r <= o[1] && o[1] <= a).sort(s).map((o) => o[0]), n > 0 && t.length > 1) {
    const o = [t[0], ae(t)];
    for (; t.length > n && t.length >= 3; )
      t = t.filter((u, l) => !(l % 2));
    t.length < 3 && (t = o);
  }
  return t;
}
function NF(e, t) {
  return e.bins ? EK(e, e.bins) : e.ticks ? e.ticks(t) : e.domain();
}
function SK(e, t, n, i, r, a) {
  const s = t.type;
  let o = xK;
  if (s === tf || r === tf)
    o = e.timeFormat(i);
  else if (s === nf || r === nf)
    o = e.utcFormat(i);
  else if (cK(s)) {
    const u = e.formatFloat(i);
    if (a || t.bins)
      o = u;
    else {
      const l = LF(t, n, !1);
      o = (c) => l(c) ? u(c) : "";
    }
  } else if (t.tickFormat) {
    const u = t.domain();
    o = e.formatSpan(u[0], u[u.length - 1], n, i);
  } else
    i && (o = e.format(i));
  return o;
}
function LF(e, t, n) {
  const i = NF(e, t), r = e.base(), a = Math.log(r), s = Math.max(1, r * t / i.length), o = (u) => {
    let l = u / Math.pow(r, Math.round(Math.log(u) / a));
    return l * r < r - 0.5 && (l *= r), l <= s;
  };
  return n ? i.filter(o) : o;
}
const Xb = {
  [Vp]: "quantiles",
  [tw]: "thresholds",
  [FF]: "domain"
}, PF = {
  [Vp]: "quantiles",
  [tw]: "domain"
};
function AK(e, t) {
  return e.bins ? _K(e.bins) : e.type === Wa ? LF(e, t, !0) : Xb[e.type] ? CK(e[Xb[e.type]]()) : NF(e, t);
}
function kK(e, t, n) {
  const i = t[PF[t.type]](), r = i.length;
  let a = r > 1 ? i[1] - i[0] : i[0], s;
  for (s = 1; s < r; ++s)
    a = Math.min(a, i[s] - i[s - 1]);
  return e.formatSpan(0, a, 3 * 10, n);
}
function CK(e) {
  const t = [-1 / 0].concat(e);
  return t.max = 1 / 0, t;
}
function _K(e) {
  const t = e.slice(0, -1);
  return t.max = ae(e), t;
}
const FK = (e) => Xb[e.type] || e.bins;
function MK(e, t, n, i, r, a, s) {
  const o = PF[t.type] && a !== tf && a !== nf ? kK(e, t, r) : SK(e, t, n, r, a, s);
  return i === bK && FK(t) ? OK(o) : i === vK ? RK(o) : TK(o);
}
const OK = (e) => (t, n, i) => {
  const r = z6(i[n + 1], z6(i.max, 1 / 0)), a = I6(t, e), s = I6(r, e);
  return a && s ? a + "  " + s : s ? "< " + s : " " + a;
}, z6 = (e, t) => e ?? t, RK = (e) => (t, n) => n ? e(t) : null, TK = (e) => (t) => e(t), I6 = (e, t) => Number.isFinite(e) ? t(e) : null;
function DK(e, t, n, i) {
  const r = i || t.type;
  return V(n) && fK(r) && (n = n.replace(/%a/g, "%A").replace(/%b/g, "%B")), !n && r === tf ? e.timeFormat("%A, %d %B %Y, %X") : !n && r === nf ? e.utcFormat("%A, %d %B %Y, %X UTC") : MK(e, t, 5, null, n, i, !0);
}
function zF(e, t, n) {
  n = n || {};
  const i = Math.max(3, n.maxlen || 7), r = DK(e, t, n.format, n.formatType);
  if (lK(t.type)) {
    const a = AK(t).slice(1).map(r), s = a.length;
    return `${s} boundar${s === 1 ? "y" : "ies"}: ${a.join(", ")}`;
  } else if (RF(t.type)) {
    const a = t.domain(), s = a.length, o = s > i ? a.slice(0, i - 2).map(r).join(", ") + ", ending with " + a.slice(-1).map(r) : a.map(r).join(", ");
    return `${s} value${s === 1 ? "" : "s"}: ${o}`;
  } else {
    const a = t.domain();
    return `values from ${r(a[0])} to ${r(ae(a))}`;
  }
}
let IF = 0;
function NK() {
  IF = 0;
}
const Yp = "p_";
function rw(e) {
  return e && e.gradient;
}
function BF(e, t, n) {
  const i = e.gradient;
  let r = e.id, a = i === "radial" ? Yp : "";
  return r || (r = e.id = "gradient_" + IF++, i === "radial" ? (e.x1 = Wi(e.x1, 0.5), e.y1 = Wi(e.y1, 0.5), e.r1 = Wi(e.r1, 0), e.x2 = Wi(e.x2, 0.5), e.y2 = Wi(e.y2, 0.5), e.r2 = Wi(e.r2, 0.5), a = Yp) : (e.x1 = Wi(e.x1, 0), e.y1 = Wi(e.y1, 0), e.x2 = Wi(e.x2, 1), e.y2 = Wi(e.y2, 0))), t[r] = e, "url(" + (n || "") + "#" + a + r + ")";
}
function Wi(e, t) {
  return e ?? t;
}
function LK(e, t) {
  var n = [], i;
  return i = {
    gradient: "linear",
    x1: e ? e[0] : 0,
    y1: e ? e[1] : 0,
    x2: t ? t[0] : 1,
    y2: t ? t[1] : 0,
    stops: n,
    stop: function(r, a) {
      return n.push({
        offset: r,
        color: a
      }), i;
    }
  };
}
const B6 = {
  basis: {
    curve: dk
  },
  "basis-closed": {
    curve: hk
  },
  "basis-open": {
    curve: pk
  },
  bundle: {
    curve: gk,
    tension: "beta",
    value: 0.85
  },
  cardinal: {
    curve: mk,
    tension: "tension",
    value: 0
  },
  "cardinal-open": {
    curve: yk,
    tension: "tension",
    value: 0
  },
  "cardinal-closed": {
    curve: bk,
    tension: "tension",
    value: 0
  },
  "catmull-rom": {
    curve: vk,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-closed": {
    curve: xk,
    tension: "alpha",
    value: 0.5
  },
  "catmull-rom-open": {
    curve: $k,
    tension: "alpha",
    value: 0.5
  },
  linear: {
    curve: t2
  },
  "linear-closed": {
    curve: wk
  },
  monotone: {
    horizontal: Ek,
    vertical: Sk
  },
  natural: {
    curve: Ak
  },
  step: {
    curve: kk
  },
  "step-after": {
    curve: Ck
  },
  "step-before": {
    curve: _k
  }
};
function aw(e, t, n) {
  var i = Y(B6, e) && B6[e], r = null;
  return i && (r = i.curve || i[t || "vertical"], i.tension && n != null && (r = r[i.tension](n))), r;
}
const PK = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  z: 0,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
}, zK = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi, IK = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/, BK = /^((\s+,?\s*)|(,\s*))/, jK = /^[01]/;
function rf(e) {
  const t = [];
  return (e.match(zK) || []).forEach((i) => {
    let r = i[0];
    const a = r.toLowerCase(), s = PK[a], o = UK(a, s, i.slice(1).trim()), u = o.length;
    if (u < s || u && u % s !== 0)
      throw Error("Invalid SVG path, incorrect parameter count");
    if (t.push([r, ...o.slice(0, s)]), u !== s) {
      a === "m" && (r = r === "M" ? "L" : "l");
      for (let l = s; l < u; l += s)
        t.push([r, ...o.slice(l, l + s)]);
    }
  }), t;
}
function UK(e, t, n) {
  const i = [];
  for (let r = 0; t && r < n.length; )
    for (let a = 0; a < t; ++a) {
      const s = e === "a" && (a === 3 || a === 4) ? jK : IK, o = n.slice(r).match(s);
      if (o === null)
        throw Error("Invalid SVG path, incorrect parameter type");
      r += o[0].length, i.push(+o[0]);
      const u = n.slice(r).match(BK);
      u !== null && (r += u[0].length);
    }
  return i;
}
const Ha = Math.PI / 180, qK = 1e-14, Ns = Math.PI / 2, ir = Math.PI * 2, Ho = Math.sqrt(3) / 2;
var H1 = {}, V1 = {}, jF = [].join;
function GK(e, t, n, i, r, a, s, o, u) {
  const l = jF.call(arguments);
  if (H1[l])
    return H1[l];
  const c = s * Ha, f = Math.sin(c), d = Math.cos(c);
  n = Math.abs(n), i = Math.abs(i);
  const h = d * (o - e) * 0.5 + f * (u - t) * 0.5, p = d * (u - t) * 0.5 - f * (o - e) * 0.5;
  let g = h * h / (n * n) + p * p / (i * i);
  g > 1 && (g = Math.sqrt(g), n *= g, i *= g);
  const m = d / n, y = f / n, b = -f / i, v = d / i, x = m * o + y * u, w = b * o + v * u, E = m * e + y * t, $ = b * e + v * t;
  let A = 1 / ((E - x) * (E - x) + ($ - w) * ($ - w)) - 0.25;
  A < 0 && (A = 0);
  let k = Math.sqrt(A);
  a == r && (k = -k);
  const _ = 0.5 * (x + E) - k * ($ - w), P = 0.5 * (w + $) + k * (E - x), F = Math.atan2(w - P, x - _);
  let C = Math.atan2($ - P, E - _) - F;
  C < 0 && a === 1 ? C += ir : C > 0 && a === 0 && (C -= ir);
  const O = Math.ceil(Math.abs(C / (Ns + 1e-3))), L = [];
  for (let z = 0; z < O; ++z) {
    const W = F + z * C / O, J = F + (z + 1) * C / O;
    L[z] = [_, P, W, J, n, i, f, d];
  }
  return H1[l] = L;
}
function WK(e) {
  const t = jF.call(e);
  if (V1[t])
    return V1[t];
  var n = e[0], i = e[1], r = e[2], a = e[3], s = e[4], o = e[5], u = e[6], l = e[7];
  const c = l * s, f = -u * o, d = u * s, h = l * o, p = Math.cos(r), g = Math.sin(r), m = Math.cos(a), y = Math.sin(a), b = 0.5 * (a - r), v = Math.sin(b * 0.5), x = 8 / 3 * v * v / Math.sin(b), w = n + p - x * g, E = i + g + x * p, $ = n + m, S = i + y, A = $ + x * y, k = S - x * m;
  return V1[t] = [c * w + f * E, d * w + h * E, c * A + f * k, d * A + h * k, c * $ + f * S, d * $ + h * S];
}
const qn = ["l", 0, 0, 0, 0, 0, 0, 0];
function HK(e, t, n) {
  const i = qn[0] = e[0];
  if (i === "a" || i === "A")
    qn[1] = t * e[1], qn[2] = n * e[2], qn[3] = e[3], qn[4] = e[4], qn[5] = e[5], qn[6] = t * e[6], qn[7] = n * e[7];
  else if (i === "h" || i === "H")
    qn[1] = t * e[1];
  else if (i === "v" || i === "V")
    qn[1] = n * e[1];
  else
    for (var r = 1, a = e.length; r < a; ++r)
      qn[r] = (r % 2 == 1 ? t : n) * e[r];
  return qn;
}
function Kp(e, t, n, i, r, a) {
  var s, o = null, u = 0, l = 0, c = 0, f = 0, d, h, p, g, m = 0, y = 0;
  n == null && (n = 0), i == null && (i = 0), r == null && (r = 1), a == null && (a = r), e.beginPath && e.beginPath();
  for (var b = 0, v = t.length; b < v; ++b) {
    switch (s = t[b], (r !== 1 || a !== 1) && (s = HK(s, r, a)), s[0]) {
      case "l":
        u += s[1], l += s[2], e.lineTo(u + n, l + i);
        break;
      case "L":
        u = s[1], l = s[2], e.lineTo(u + n, l + i);
        break;
      case "h":
        u += s[1], e.lineTo(u + n, l + i);
        break;
      case "H":
        u = s[1], e.lineTo(u + n, l + i);
        break;
      case "v":
        l += s[1], e.lineTo(u + n, l + i);
        break;
      case "V":
        l = s[1], e.lineTo(u + n, l + i);
        break;
      case "m":
        u += s[1], l += s[2], m = u, y = l, e.moveTo(u + n, l + i);
        break;
      case "M":
        u = s[1], l = s[2], m = u, y = l, e.moveTo(u + n, l + i);
        break;
      case "c":
        d = u + s[5], h = l + s[6], c = u + s[3], f = l + s[4], e.bezierCurveTo(
          u + s[1] + n,
          // x1
          l + s[2] + i,
          // y1
          c + n,
          // x2
          f + i,
          // y2
          d + n,
          h + i
        ), u = d, l = h;
        break;
      case "C":
        u = s[5], l = s[6], c = s[3], f = s[4], e.bezierCurveTo(s[1] + n, s[2] + i, c + n, f + i, u + n, l + i);
        break;
      case "s":
        d = u + s[3], h = l + s[4], c = 2 * u - c, f = 2 * l - f, e.bezierCurveTo(c + n, f + i, u + s[1] + n, l + s[2] + i, d + n, h + i), c = u + s[1], f = l + s[2], u = d, l = h;
        break;
      case "S":
        d = s[3], h = s[4], c = 2 * u - c, f = 2 * l - f, e.bezierCurveTo(c + n, f + i, s[1] + n, s[2] + i, d + n, h + i), u = d, l = h, c = s[1], f = s[2];
        break;
      case "q":
        d = u + s[3], h = l + s[4], c = u + s[1], f = l + s[2], e.quadraticCurveTo(c + n, f + i, d + n, h + i), u = d, l = h;
        break;
      case "Q":
        d = s[3], h = s[4], e.quadraticCurveTo(s[1] + n, s[2] + i, d + n, h + i), u = d, l = h, c = s[1], f = s[2];
        break;
      case "t":
        d = u + s[1], h = l + s[2], o[0].match(/[QqTt]/) === null ? (c = u, f = l) : o[0] === "t" ? (c = 2 * u - p, f = 2 * l - g) : o[0] === "q" && (c = 2 * u - c, f = 2 * l - f), p = c, g = f, e.quadraticCurveTo(c + n, f + i, d + n, h + i), u = d, l = h, c = u + s[1], f = l + s[2];
        break;
      case "T":
        d = s[1], h = s[2], c = 2 * u - c, f = 2 * l - f, e.quadraticCurveTo(c + n, f + i, d + n, h + i), u = d, l = h;
        break;
      case "a":
        j6(e, u + n, l + i, [s[1], s[2], s[3], s[4], s[5], s[6] + u + n, s[7] + l + i]), u += s[6], l += s[7];
        break;
      case "A":
        j6(e, u + n, l + i, [s[1], s[2], s[3], s[4], s[5], s[6] + n, s[7] + i]), u = s[6], l = s[7];
        break;
      case "z":
      case "Z":
        u = m, l = y, e.closePath();
        break;
    }
    o = s;
  }
}
function j6(e, t, n, i) {
  const r = GK(
    i[5],
    // end x
    i[6],
    // end y
    i[0],
    // radius x
    i[1],
    // radius y
    i[3],
    // large flag
    i[4],
    // sweep flag
    i[2],
    // rotation
    t,
    n
  );
  for (let a = 0; a < r.length; ++a) {
    const s = WK(r[a]);
    e.bezierCurveTo(s[0], s[1], s[2], s[3], s[4], s[5]);
  }
}
const U6 = 0.5773502691896257, q6 = {
  circle: {
    draw: function(e, t) {
      const n = Math.sqrt(t) / 2;
      e.moveTo(n, 0), e.arc(0, 0, n, 0, ir);
    }
  },
  cross: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = n / 2.5;
      e.moveTo(-n, -i), e.lineTo(-n, i), e.lineTo(-i, i), e.lineTo(-i, n), e.lineTo(i, n), e.lineTo(i, i), e.lineTo(n, i), e.lineTo(n, -i), e.lineTo(i, -i), e.lineTo(i, -n), e.lineTo(-i, -n), e.lineTo(-i, -i), e.closePath();
    }
  },
  diamond: {
    draw: function(e, t) {
      const n = Math.sqrt(t) / 2;
      e.moveTo(-n, 0), e.lineTo(0, -n), e.lineTo(n, 0), e.lineTo(0, n), e.closePath();
    }
  },
  square: {
    draw: function(e, t) {
      var n = Math.sqrt(t), i = -n / 2;
      e.rect(i, i, n, n);
    }
  },
  arrow: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = n / 7, r = n / 2.5, a = n / 8;
      e.moveTo(-i, n), e.lineTo(i, n), e.lineTo(i, -a), e.lineTo(r, -a), e.lineTo(0, -n), e.lineTo(-r, -a), e.lineTo(-i, -a), e.closePath();
    }
  },
  wedge: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Ho * n, r = i - n * U6, a = n / 4;
      e.moveTo(0, -i - r), e.lineTo(-a, i - r), e.lineTo(a, i - r), e.closePath();
    }
  },
  triangle: {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Ho * n, r = i - n * U6;
      e.moveTo(0, -i - r), e.lineTo(-n, i - r), e.lineTo(n, i - r), e.closePath();
    }
  },
  "triangle-up": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Ho * n;
      e.moveTo(0, -i), e.lineTo(-n, i), e.lineTo(n, i), e.closePath();
    }
  },
  "triangle-down": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Ho * n;
      e.moveTo(0, i), e.lineTo(-n, -i), e.lineTo(n, -i), e.closePath();
    }
  },
  "triangle-right": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Ho * n;
      e.moveTo(i, 0), e.lineTo(-i, -n), e.lineTo(-i, n), e.closePath();
    }
  },
  "triangle-left": {
    draw: function(e, t) {
      var n = Math.sqrt(t) / 2, i = Ho * n;
      e.moveTo(-i, 0), e.lineTo(i, -n), e.lineTo(i, n), e.closePath();
    }
  },
  stroke: {
    draw: function(e, t) {
      const n = Math.sqrt(t) / 2;
      e.moveTo(-n, 0), e.lineTo(n, 0);
    }
  }
};
function UF(e) {
  return Y(q6, e) ? q6[e] : VK(e);
}
var X1 = {};
function VK(e) {
  if (!Y(X1, e)) {
    const t = rf(e);
    X1[e] = {
      draw: function(n, i) {
        Kp(n, t, 0, 0, Math.sqrt(i) / 2);
      }
    };
  }
  return X1[e];
}
const da = 0.448084975506;
function XK(e) {
  return e.x;
}
function YK(e) {
  return e.y;
}
function KK(e) {
  return e.width;
}
function JK(e) {
  return e.height;
}
function Or(e) {
  return typeof e == "function" ? e : () => +e;
}
function oh(e, t, n) {
  return Math.max(t, Math.min(e, n));
}
function qF() {
  var e = XK, t = YK, n = KK, i = JK, r = Or(0), a = r, s = r, o = r, u = null;
  function l(c, f, d) {
    var h, p = f ?? +e.call(this, c), g = d ?? +t.call(this, c), m = +n.call(this, c), y = +i.call(this, c), b = Math.min(m, y) / 2, v = oh(+r.call(this, c), 0, b), x = oh(+a.call(this, c), 0, b), w = oh(+s.call(this, c), 0, b), E = oh(+o.call(this, c), 0, b);
    if (u || (u = h = Cf()), v <= 0 && x <= 0 && w <= 0 && E <= 0)
      u.rect(p, g, m, y);
    else {
      var $ = p + m, S = g + y;
      u.moveTo(p + v, g), u.lineTo($ - x, g), u.bezierCurveTo($ - da * x, g, $, g + da * x, $, g + x), u.lineTo($, S - E), u.bezierCurveTo($, S - da * E, $ - da * E, S, $ - E, S), u.lineTo(p + w, S), u.bezierCurveTo(p + da * w, S, p, S - da * w, p, S - w), u.lineTo(p, g + v), u.bezierCurveTo(p, g + da * v, p + da * v, g, p + v, g), u.closePath();
    }
    if (h)
      return u = null, h + "" || null;
  }
  return l.x = function(c) {
    return arguments.length ? (e = Or(c), l) : e;
  }, l.y = function(c) {
    return arguments.length ? (t = Or(c), l) : t;
  }, l.width = function(c) {
    return arguments.length ? (n = Or(c), l) : n;
  }, l.height = function(c) {
    return arguments.length ? (i = Or(c), l) : i;
  }, l.cornerRadius = function(c, f, d, h) {
    return arguments.length ? (r = Or(c), a = f != null ? Or(f) : r, o = d != null ? Or(d) : r, s = h != null ? Or(h) : a, l) : r;
  }, l.context = function(c) {
    return arguments.length ? (u = c ?? null, l) : u;
  }, l;
}
function GF() {
  var e, t, n, i, r = null, a, s, o, u;
  function l(f, d, h) {
    const p = h / 2;
    if (a) {
      var g = o - d, m = f - s;
      if (g || m) {
        var y = Math.hypot(g, m), b = (g /= y) * u, v = (m /= y) * u, x = Math.atan2(m, g);
        r.moveTo(s - b, o - v), r.lineTo(f - g * p, d - m * p), r.arc(f, d, p, x - Math.PI, x), r.lineTo(s + b, o + v), r.arc(s, o, u, x, x + Math.PI);
      } else
        r.arc(f, d, p, 0, ir);
      r.closePath();
    } else
      a = 1;
    s = f, o = d, u = p;
  }
  function c(f) {
    var d, h = f.length, p, g = !1, m;
    for (r == null && (r = m = Cf()), d = 0; d <= h; ++d)
      !(d < h && i(p = f[d], d, f)) === g && (g = !g) && (a = 0), g && l(+e(p, d, f), +t(p, d, f), +n(p, d, f));
    if (m)
      return r = null, m + "" || null;
  }
  return c.x = function(f) {
    return arguments.length ? (e = f, c) : e;
  }, c.y = function(f) {
    return arguments.length ? (t = f, c) : t;
  }, c.size = function(f) {
    return arguments.length ? (n = f, c) : n;
  }, c.defined = function(f) {
    return arguments.length ? (i = f, c) : i;
  }, c.context = function(f) {
    return arguments.length ? (f == null ? r = null : r = f, c) : r;
  }, c;
}
function ud(e, t) {
  return e ?? t;
}
const ld = (e) => e.x || 0, cd = (e) => e.y || 0, QK = (e) => e.width || 0, ZK = (e) => e.height || 0, eJ = (e) => (e.x || 0) + (e.width || 0), tJ = (e) => (e.y || 0) + (e.height || 0), nJ = (e) => e.startAngle || 0, iJ = (e) => e.endAngle || 0, rJ = (e) => e.padAngle || 0, aJ = (e) => e.innerRadius || 0, sJ = (e) => e.outerRadius || 0, oJ = (e) => e.cornerRadius || 0, uJ = (e) => ud(e.cornerRadiusTopLeft, e.cornerRadius) || 0, lJ = (e) => ud(e.cornerRadiusTopRight, e.cornerRadius) || 0, cJ = (e) => ud(e.cornerRadiusBottomRight, e.cornerRadius) || 0, fJ = (e) => ud(e.cornerRadiusBottomLeft, e.cornerRadius) || 0, dJ = (e) => ud(e.size, 64), hJ = (e) => e.size || 1, q0 = (e) => e.defined !== !1, pJ = (e) => UF(e.shape || "circle"), gJ = Fk().startAngle(nJ).endAngle(iJ).padAngle(rJ).innerRadius(aJ).outerRadius(sJ).cornerRadius(oJ), mJ = Zg().x(ld).y1(cd).y0(tJ).defined(q0), yJ = Zg().y(cd).x1(ld).x0(eJ).defined(q0), bJ = n2().x(ld).y(cd).defined(q0), vJ = qF().x(ld).y(cd).width(QK).height(ZK).cornerRadius(uJ, lJ, cJ, fJ), xJ = B9().type(pJ).size(dJ), $J = GF().x(ld).y(cd).defined(q0).size(hJ);
function sw(e) {
  return e.cornerRadius || e.cornerRadiusTopLeft || e.cornerRadiusTopRight || e.cornerRadiusBottomRight || e.cornerRadiusBottomLeft;
}
function wJ(e, t) {
  return gJ.context(e)(t);
}
function EJ(e, t) {
  const n = t[0], i = n.interpolate || "linear";
  return (n.orient === "horizontal" ? yJ : mJ).curve(aw(i, n.orient, n.tension)).context(e)(t);
}
function SJ(e, t) {
  const n = t[0], i = n.interpolate || "linear";
  return bJ.curve(aw(i, n.orient, n.tension)).context(e)(t);
}
function hl(e, t, n, i) {
  return vJ.context(e)(t, n, i);
}
function AJ(e, t) {
  return (t.mark.shape || t.shape).context(e)(t);
}
function kJ(e, t) {
  return xJ.context(e)(t);
}
function CJ(e, t) {
  return $J.context(e)(t);
}
var WF = 1;
function HF() {
  WF = 1;
}
function ow(e, t, n) {
  var i = t.clip, r = e._defs, a = t.clip_id || (t.clip_id = "clip" + WF++), s = r.clipping[a] || (r.clipping[a] = {
    id: a
  });
  return oe(i) ? s.path = i(null) : sw(n) ? s.path = hl(null, n, 0, 0) : (s.width = n.width || 0, s.height = n.height || 0), "url(#" + a + ")";
}
function $n(e) {
  this.clear(), e && this.union(e);
}
$n.prototype = {
  clone() {
    return new $n(this);
  },
  clear() {
    return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(e) {
    return this.x1 === e.x1 && this.y1 === e.y1 && this.x2 === e.x2 && this.y2 === e.y2;
  },
  set(e, t, n, i) {
    return n < e ? (this.x2 = e, this.x1 = n) : (this.x1 = e, this.x2 = n), i < t ? (this.y2 = t, this.y1 = i) : (this.y1 = t, this.y2 = i), this;
  },
  add(e, t) {
    return e < this.x1 && (this.x1 = e), t < this.y1 && (this.y1 = t), e > this.x2 && (this.x2 = e), t > this.y2 && (this.y2 = t), this;
  },
  expand(e) {
    return this.x1 -= e, this.y1 -= e, this.x2 += e, this.y2 += e, this;
  },
  round() {
    return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
  },
  scale(e) {
    return this.x1 *= e, this.y1 *= e, this.x2 *= e, this.y2 *= e, this;
  },
  translate(e, t) {
    return this.x1 += e, this.x2 += e, this.y1 += t, this.y2 += t, this;
  },
  rotate(e, t, n) {
    const i = this.rotatedPoints(e, t, n);
    return this.clear().add(i[0], i[1]).add(i[2], i[3]).add(i[4], i[5]).add(i[6], i[7]);
  },
  rotatedPoints(e, t, n) {
    var {
      x1: i,
      y1: r,
      x2: a,
      y2: s
    } = this, o = Math.cos(e), u = Math.sin(e), l = t - t * o + n * u, c = n - t * u - n * o;
    return [o * i - u * r + l, u * i + o * r + c, o * i - u * s + l, u * i + o * s + c, o * a - u * r + l, u * a + o * r + c, o * a - u * s + l, u * a + o * s + c];
  },
  union(e) {
    return e.x1 < this.x1 && (this.x1 = e.x1), e.y1 < this.y1 && (this.y1 = e.y1), e.x2 > this.x2 && (this.x2 = e.x2), e.y2 > this.y2 && (this.y2 = e.y2), this;
  },
  intersect(e) {
    return e.x1 > this.x1 && (this.x1 = e.x1), e.y1 > this.y1 && (this.y1 = e.y1), e.x2 < this.x2 && (this.x2 = e.x2), e.y2 < this.y2 && (this.y2 = e.y2), this;
  },
  encloses(e) {
    return e && this.x1 <= e.x1 && this.x2 >= e.x2 && this.y1 <= e.y1 && this.y2 >= e.y2;
  },
  alignsWith(e) {
    return e && (this.x1 == e.x1 || this.x2 == e.x2 || this.y1 == e.y1 || this.y2 == e.y2);
  },
  intersects(e) {
    return e && !(this.x2 < e.x1 || this.x1 > e.x2 || this.y2 < e.y1 || this.y1 > e.y2);
  },
  contains(e, t) {
    return !(e < this.x1 || e > this.x2 || t < this.y1 || t > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};
function uw(e) {
  this.mark = e, this.bounds = this.bounds || new $n();
}
function lw(e) {
  uw.call(this, e), this.items = this.items || [];
}
B(lw, uw);
function cw(e) {
  this._pending = 0, this._loader = e || sl();
}
function G6(e) {
  e._pending += 1;
}
function Pl(e) {
  e._pending -= 1;
}
cw.prototype = {
  pending() {
    return this._pending;
  },
  sanitizeURL(e) {
    const t = this;
    return G6(t), t._loader.sanitize(e, {
      context: "href"
    }).then((n) => (Pl(t), n)).catch(() => (Pl(t), null));
  },
  loadImage(e) {
    const t = this, n = vC();
    return G6(t), t._loader.sanitize(e, {
      context: "image"
    }).then((i) => {
      const r = i.href;
      if (!r || !n)
        throw {
          url: r
        };
      const a = new n(), s = Y(i, "crossOrigin") ? i.crossOrigin : "anonymous";
      return s != null && (a.crossOrigin = s), a.onload = () => Pl(t), a.onerror = () => Pl(t), a.src = r, a;
    }).catch((i) => (Pl(t), {
      complete: !1,
      width: 0,
      height: 0,
      src: i && i.url || ""
    }));
  },
  ready() {
    const e = this;
    return new Promise((t) => {
      function n(i) {
        e.pending() ? setTimeout(() => {
          n(!0);
        }, 10) : t(i);
      }
      n(!1);
    });
  }
};
function Co(e, t, n) {
  if (t.stroke && t.opacity !== 0 && t.strokeOpacity !== 0) {
    const i = t.strokeWidth != null ? +t.strokeWidth : 1;
    e.expand(i + (n ? _J(t, i) : 0));
  }
  return e;
}
function _J(e, t) {
  return e.strokeJoin && e.strokeJoin !== "miter" ? 0 : t;
}
const FJ = ir - 1e-8;
let G0, jh, Uh, qs, Yb, qh, Kb, Jb;
const Ma = (e, t) => G0.add(e, t), Gh = (e, t) => Ma(jh = e, Uh = t), W6 = (e) => Ma(e, G0.y1), H6 = (e) => Ma(G0.x1, e), Ls = (e, t) => Yb * e + Kb * t, Ps = (e, t) => qh * e + Jb * t, Y1 = (e, t) => Ma(Ls(e, t), Ps(e, t)), K1 = (e, t) => Gh(Ls(e, t), Ps(e, t));
function fd(e, t) {
  return G0 = e, t ? (qs = t * Ha, Yb = Jb = Math.cos(qs), qh = Math.sin(qs), Kb = -qh) : (Yb = Jb = 1, qs = qh = Kb = 0), MJ;
}
const MJ = {
  beginPath() {
  },
  closePath() {
  },
  moveTo: K1,
  lineTo: K1,
  rect(e, t, n, i) {
    qs ? (Y1(e + n, t), Y1(e + n, t + i), Y1(e, t + i), K1(e, t)) : (Ma(e + n, t + i), Gh(e, t));
  },
  quadraticCurveTo(e, t, n, i) {
    const r = Ls(e, t), a = Ps(e, t), s = Ls(n, i), o = Ps(n, i);
    V6(jh, r, s, W6), V6(Uh, a, o, H6), Gh(s, o);
  },
  bezierCurveTo(e, t, n, i, r, a) {
    const s = Ls(e, t), o = Ps(e, t), u = Ls(n, i), l = Ps(n, i), c = Ls(r, a), f = Ps(r, a);
    X6(jh, s, u, c, W6), X6(Uh, o, l, f, H6), Gh(c, f);
  },
  arc(e, t, n, i, r, a) {
    if (i += qs, r += qs, jh = n * Math.cos(r) + e, Uh = n * Math.sin(r) + t, Math.abs(r - i) > FJ)
      Ma(e - n, t - n), Ma(e + n, t + n);
    else {
      const s = (l) => Ma(n * Math.cos(l) + e, n * Math.sin(l) + t);
      let o, u;
      if (s(i), s(r), r !== i)
        if (i = i % ir, i < 0 && (i += ir), r = r % ir, r < 0 && (r += ir), r < i && (a = !a, o = i, i = r, r = o), a)
          for (r -= ir, o = i - i % Ns, u = 0; u < 4 && o > r; ++u, o -= Ns)
            s(o);
        else
          for (o = i - i % Ns + Ns, u = 0; u < 4 && o < r; ++u, o = o + Ns)
            s(o);
    }
  }
};
function V6(e, t, n, i) {
  const r = (e - t) / (e + n - 2 * t);
  0 < r && r < 1 && i(e + (t - e) * r);
}
function X6(e, t, n, i, r) {
  const a = i - e + 3 * t - 3 * n, s = e + n - 2 * t, o = e - t;
  let u = 0, l = 0, c;
  Math.abs(a) > qK ? (c = s * s + o * a, c >= 0 && (c = Math.sqrt(c), u = (-s + c) / a, l = (-s - c) / a)) : u = 0.5 * o / s, 0 < u && u < 1 && r(Y6(u, e, t, n, i)), 0 < l && l < 1 && r(Y6(l, e, t, n, i));
}
function Y6(e, t, n, i, r) {
  const a = 1 - e, s = a * a, o = e * e;
  return s * a * t + 3 * s * e * n + 3 * a * o * i + o * e * r;
}
var La = (La = Ei(1, 1)) ? La.getContext("2d") : null;
const Qb = new $n();
function fw(e) {
  return function(t, n) {
    if (!La)
      return !0;
    e(La, t), Qb.clear().union(t.bounds).intersect(n).round();
    const {
      x1: i,
      y1: r,
      x2: a,
      y2: s
    } = Qb;
    for (let o = r; o <= s; ++o)
      for (let u = i; u <= a; ++u)
        if (La.isPointInPath(u, o))
          return !0;
    return !1;
  };
}
function dw(e, t) {
  return t.contains(e.x || 0, e.y || 0);
}
function VF(e, t) {
  const n = e.x || 0, i = e.y || 0, r = e.width || 0, a = e.height || 0;
  return t.intersects(Qb.set(n, i, n + r, i + a));
}
function XF(e, t) {
  const n = e.x || 0, i = e.y || 0, r = e.x2 != null ? e.x2 : n, a = e.y2 != null ? e.y2 : i;
  return au(t, n, i, r, a);
}
function au(e, t, n, i, r) {
  const {
    x1: a,
    y1: s,
    x2: o,
    y2: u
  } = e, l = i - t, c = r - n;
  let f = 0, d = 1, h, p, g, m;
  for (m = 0; m < 4; ++m) {
    if (m === 0 && (h = -l, p = -(a - t)), m === 1 && (h = l, p = o - t), m === 2 && (h = -c, p = -(s - n)), m === 3 && (h = c, p = u - n), Math.abs(h) < 1e-10 && p < 0)
      return !1;
    if (g = p / h, h < 0) {
      if (g > d)
        return !1;
      g > f && (f = g);
    } else if (h > 0) {
      if (g < f)
        return !1;
      g < d && (d = g);
    }
  }
  return !0;
}
function Cu(e, t) {
  e.globalCompositeOperation = t.blend || "source-over";
}
function li(e, t) {
  return e ?? t;
}
function K6(e, t) {
  const n = t.length;
  for (let i = 0; i < n; ++i)
    e.addColorStop(t[i].offset, t[i].color);
  return e;
}
function OJ(e, t, n) {
  const i = n.width(), r = n.height();
  let a;
  if (t.gradient === "radial")
    a = e.createRadialGradient(n.x1 + li(t.x1, 0.5) * i, n.y1 + li(t.y1, 0.5) * r, Math.max(i, r) * li(t.r1, 0), n.x1 + li(t.x2, 0.5) * i, n.y1 + li(t.y2, 0.5) * r, Math.max(i, r) * li(t.r2, 0.5));
  else {
    const s = li(t.x1, 0), o = li(t.y1, 0), u = li(t.x2, 1), l = li(t.y2, 0);
    if (s === u || o === l || i === r)
      a = e.createLinearGradient(n.x1 + s * i, n.y1 + o * r, n.x1 + u * i, n.y1 + l * r);
    else {
      const c = Ei(Math.ceil(i), Math.ceil(r)), f = c.getContext("2d");
      return f.scale(i, r), f.fillStyle = K6(f.createLinearGradient(s, o, u, l), t.stops), f.fillRect(0, 0, i, r), e.createPattern(c, "no-repeat");
    }
  }
  return K6(a, t.stops);
}
function YF(e, t, n) {
  return rw(n) ? OJ(e, n, t.bounds) : n;
}
function Jp(e, t, n) {
  return n *= t.fillOpacity == null ? 1 : t.fillOpacity, n > 0 ? (e.globalAlpha = n, e.fillStyle = YF(e, t, t.fill), !0) : !1;
}
var RJ = [];
function _u(e, t, n) {
  var i = (i = t.strokeWidth) != null ? i : 1;
  return i <= 0 ? !1 : (n *= t.strokeOpacity == null ? 1 : t.strokeOpacity, n > 0 ? (e.globalAlpha = n, e.strokeStyle = YF(e, t, t.stroke), e.lineWidth = i, e.lineCap = t.strokeCap || "butt", e.lineJoin = t.strokeJoin || "miter", e.miterLimit = t.strokeMiterLimit || 10, e.setLineDash && (e.setLineDash(t.strokeDash || RJ), e.lineDashOffset = t.strokeDashOffset || 0), !0) : !1);
}
function TJ(e, t) {
  return e.zindex - t.zindex || e.index - t.index;
}
function hw(e) {
  if (!e.zdirty)
    return e.zitems;
  var t = e.items, n = [], i, r, a;
  for (r = 0, a = t.length; r < a; ++r)
    i = t[r], i.index = r, i.zindex && n.push(i);
  return e.zdirty = !1, e.zitems = n.sort(TJ);
}
function Fi(e, t) {
  var n = e.items, i, r;
  if (!n || !n.length)
    return;
  const a = hw(e);
  if (a && a.length) {
    for (i = 0, r = n.length; i < r; ++i)
      n[i].zindex || t(n[i]);
    n = a;
  }
  for (i = 0, r = n.length; i < r; ++i)
    t(n[i]);
}
function Qp(e, t) {
  var n = e.items, i, r;
  if (!n || !n.length)
    return null;
  const a = hw(e);
  for (a && a.length && (n = a), r = n.length; --r >= 0; )
    if (i = t(n[r]))
      return i;
  if (n === a) {
    for (n = e.items, r = n.length; --r >= 0; )
      if (!n[r].zindex && (i = t(n[r])))
        return i;
  }
  return null;
}
function pw(e) {
  return function(t, n, i) {
    Fi(n, (r) => {
      (!i || i.intersects(r.bounds)) && KF(e, t, r, r);
    });
  };
}
function DJ(e) {
  return function(t, n, i) {
    n.items.length && (!i || i.intersects(n.bounds)) && KF(e, t, n.items[0], n.items);
  };
}
function KF(e, t, n, i) {
  var r = n.opacity == null ? 1 : n.opacity;
  r !== 0 && (e(t, i) || (Cu(t, n), n.fill && Jp(t, n, r) && t.fill(), n.stroke && _u(t, n, r) && t.stroke()));
}
function W0(e) {
  return e = e || jt, function(t, n, i, r, a, s) {
    return i *= t.pixelRatio, r *= t.pixelRatio, Qp(n, (o) => {
      const u = o.bounds;
      if (!(u && !u.contains(a, s) || !u) && e(t, o, i, r, a, s))
        return o;
    });
  };
}
function dd(e, t) {
  return function(n, i, r, a) {
    var s = Array.isArray(i) ? i[0] : i, o = t ?? s.fill, u = s.stroke && n.isPointInStroke, l, c;
    return u && (l = s.strokeWidth, c = s.strokeCap, n.lineWidth = l ?? 1, n.lineCap = c ?? "butt"), e(n, i) ? !1 : o && n.isPointInPath(r, a) || u && n.isPointInStroke(r, a);
  };
}
function gw(e) {
  return W0(dd(e));
}
function Ys(e, t) {
  return "translate(" + e + "," + t + ")";
}
function mw(e) {
  return "rotate(" + e + ")";
}
function NJ(e, t) {
  return "scale(" + e + "," + t + ")";
}
function JF(e) {
  return Ys(e.x || 0, e.y || 0);
}
function LJ(e) {
  return Ys(e.x || 0, e.y || 0) + (e.angle ? " " + mw(e.angle) : "");
}
function PJ(e) {
  return Ys(e.x || 0, e.y || 0) + (e.angle ? " " + mw(e.angle) : "") + (e.scaleX || e.scaleY ? " " + NJ(e.scaleX || 1, e.scaleY || 1) : "");
}
function yw(e, t, n) {
  function i(s, o) {
    s("transform", LJ(o)), s("d", t(null, o));
  }
  function r(s, o) {
    return t(fd(s, o.angle), o), Co(s, o).translate(o.x || 0, o.y || 0);
  }
  function a(s, o) {
    var u = o.x || 0, l = o.y || 0, c = o.angle || 0;
    s.translate(u, l), c && s.rotate(c *= Ha), s.beginPath(), t(s, o), c && s.rotate(-c), s.translate(-u, -l);
  }
  return {
    type: e,
    tag: "path",
    nested: !1,
    attr: i,
    bound: r,
    draw: pw(a),
    pick: gw(a),
    isect: n || fw(a)
  };
}
var zJ = yw("arc", wJ);
function IJ(e, t) {
  for (var n = e[0].orient === "horizontal" ? t[1] : t[0], i = e[0].orient === "horizontal" ? "y" : "x", r = e.length, a = 1 / 0, s, o; --r >= 0; )
    e[r].defined !== !1 && (o = Math.abs(e[r][i] - n), o < a && (a = o, s = e[r]));
  return s;
}
function BJ(e, t) {
  for (var n = Math.pow(e[0].strokeWidth || 1, 2), i = e.length, r, a, s; --i >= 0; )
    if (e[i].defined !== !1 && (r = e[i].x - t[0], a = e[i].y - t[1], s = r * r + a * a, s < n))
      return e[i];
  return null;
}
function jJ(e, t) {
  for (var n = e.length, i, r, a; --n >= 0; )
    if (e[n].defined !== !1 && (i = e[n].x - t[0], r = e[n].y - t[1], a = i * i + r * r, i = e[n].size || 1, a < i * i))
      return e[n];
  return null;
}
function bw(e, t, n) {
  function i(u, l) {
    var c = l.mark.items;
    c.length && u("d", t(null, c));
  }
  function r(u, l) {
    var c = l.items;
    return c.length === 0 ? u : (t(fd(u), c), Co(u, c[0]));
  }
  function a(u, l) {
    u.beginPath(), t(u, l);
  }
  const s = dd(a);
  function o(u, l, c, f, d, h) {
    var p = l.items, g = l.bounds;
    return !p || !p.length || g && !g.contains(d, h) ? null : (c *= u.pixelRatio, f *= u.pixelRatio, s(u, p, c, f) ? p[0] : null);
  }
  return {
    type: e,
    tag: "path",
    nested: !0,
    attr: i,
    bound: r,
    draw: DJ(a),
    pick: o,
    isect: dw,
    tip: n
  };
}
var UJ = bw("area", EJ, IJ);
function qJ(e, t) {
  var n = t.clip;
  e.save(), oe(n) ? (e.beginPath(), n(e), e.clip()) : QF(e, t.group);
}
function QF(e, t) {
  e.beginPath(), sw(t) ? hl(e, t, 0, 0) : e.rect(0, 0, t.width || 0, t.height || 0), e.clip();
}
function ZF(e) {
  const t = li(e.strokeWidth, 1);
  return e.strokeOffset != null ? e.strokeOffset : e.stroke && t > 0.5 && t < 1.5 ? 0.5 - Math.abs(t - 1) : 0;
}
function GJ(e, t) {
  e("transform", JF(t));
}
function eM(e, t) {
  const n = ZF(t);
  e("d", hl(null, t, n, n));
}
function WJ(e, t) {
  e("class", "background"), e("aria-hidden", !0), eM(e, t);
}
function HJ(e, t) {
  e("class", "foreground"), e("aria-hidden", !0), t.strokeForeground ? eM(e, t) : e("d", "");
}
function VJ(e, t, n) {
  const i = t.clip ? ow(n, t, t) : null;
  e("clip-path", i);
}
function XJ(e, t) {
  if (!t.clip && t.items) {
    const n = t.items, i = n.length;
    for (let r = 0; r < i; ++r)
      e.union(n[r].bounds);
  }
  return (t.clip || t.width || t.height) && !t.noBound && e.add(0, 0).add(t.width || 0, t.height || 0), Co(e, t), e.translate(t.x || 0, t.y || 0);
}
function af(e, t, n, i) {
  const r = ZF(t);
  e.beginPath(), hl(e, t, (n || 0) + r, (i || 0) + r);
}
const YJ = dd(af), KJ = dd(af, !1), JJ = dd(af, !0);
function QJ(e, t, n, i) {
  Fi(t, (r) => {
    const a = r.x || 0, s = r.y || 0, o = r.strokeForeground, u = r.opacity == null ? 1 : r.opacity;
    (r.stroke || r.fill) && u && (af(e, r, a, s), Cu(e, r), r.fill && Jp(e, r, u) && e.fill(), r.stroke && !o && _u(e, r, u) && e.stroke()), e.save(), e.translate(a, s), r.clip && QF(e, r), n && n.translate(-a, -s), Fi(r, (l) => {
      (l.marktype === "group" || i == null || i.includes(l.marktype)) && this.draw(e, l, n, i);
    }), n && n.translate(a, s), e.restore(), o && r.stroke && u && (af(e, r, a, s), Cu(e, r), _u(e, r, u) && e.stroke());
  });
}
function ZJ(e, t, n, i, r, a) {
  if (t.bounds && !t.bounds.contains(r, a) || !t.items)
    return null;
  const s = n * e.pixelRatio, o = i * e.pixelRatio;
  return Qp(t, (u) => {
    let l, c, f;
    const d = u.bounds;
    if (d && !d.contains(r, a))
      return;
    c = u.x || 0, f = u.y || 0;
    const h = c + (u.width || 0), p = f + (u.height || 0), g = u.clip;
    if (g && (r < c || r > h || a < f || a > p))
      return;
    if (e.save(), e.translate(c, f), c = r - c, f = a - f, g && sw(u) && !JJ(e, u, s, o))
      return e.restore(), null;
    const m = u.strokeForeground, y = t.interactive !== !1;
    return y && m && u.stroke && KJ(e, u, s, o) ? (e.restore(), u) : (l = Qp(u, (b) => eQ(b, c, f) ? this.pick(b, n, i, c, f) : null), !l && y && (u.fill || !m && u.stroke) && YJ(e, u, s, o) && (l = u), e.restore(), l || null);
  });
}
function eQ(e, t, n) {
  return (e.interactive !== !1 || e.marktype === "group") && e.bounds && e.bounds.contains(t, n);
}
var tQ = {
  type: "group",
  tag: "g",
  nested: !1,
  attr: GJ,
  bound: XJ,
  draw: QJ,
  pick: ZJ,
  isect: VF,
  content: VJ,
  background: WJ,
  foreground: HJ
}, sf = {
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  version: "1.1"
};
function vw(e, t) {
  var n = e.image;
  return (!n || e.url && e.url !== n.url) && (n = {
    complete: !1,
    width: 0,
    height: 0
  }, t.loadImage(e.url).then((i) => {
    e.image = i, e.image.url = e.url;
  })), n;
}
function xw(e, t) {
  return e.width != null ? e.width : !t || !t.width ? 0 : e.aspect !== !1 && e.height ? e.height * t.width / t.height : t.width;
}
function $w(e, t) {
  return e.height != null ? e.height : !t || !t.height ? 0 : e.aspect !== !1 && e.width ? e.width * t.height / t.width : t.height;
}
function H0(e, t) {
  return e === "center" ? t / 2 : e === "right" ? t : 0;
}
function V0(e, t) {
  return e === "middle" ? t / 2 : e === "bottom" ? t : 0;
}
function nQ(e, t, n) {
  const i = vw(t, n), r = xw(t, i), a = $w(t, i), s = (t.x || 0) - H0(t.align, r), o = (t.y || 0) - V0(t.baseline, a), u = !i.src && i.toDataURL ? i.toDataURL() : i.src || "";
  e("href", u, sf["xmlns:xlink"], "xlink:href"), e("transform", Ys(s, o)), e("width", r), e("height", a), e("preserveAspectRatio", t.aspect === !1 ? "none" : "xMidYMid");
}
function iQ(e, t) {
  const n = t.image, i = xw(t, n), r = $w(t, n), a = (t.x || 0) - H0(t.align, i), s = (t.y || 0) - V0(t.baseline, r);
  return e.set(a, s, a + i, s + r);
}
function rQ(e, t, n) {
  Fi(t, (i) => {
    if (n && !n.intersects(i.bounds))
      return;
    const r = vw(i, this);
    let a = xw(i, r), s = $w(i, r);
    if (a === 0 || s === 0)
      return;
    let o = (i.x || 0) - H0(i.align, a), u = (i.y || 0) - V0(i.baseline, s), l, c, f, d;
    i.aspect !== !1 && (c = r.width / r.height, f = i.width / i.height, c === c && f === f && c !== f && (f < c ? (d = a / c, u += (s - d) / 2, s = d) : (d = s * c, o += (a - d) / 2, a = d))), (r.complete || r.toDataURL) && (Cu(e, i), e.globalAlpha = (l = i.opacity) != null ? l : 1, e.imageSmoothingEnabled = i.smooth !== !1, e.drawImage(r, o, u, a, s));
  });
}
var aQ = {
  type: "image",
  tag: "image",
  nested: !1,
  attr: nQ,
  bound: iQ,
  draw: rQ,
  pick: W0(),
  isect: jt,
  // bounds check is sufficient
  get: vw,
  xOffset: H0,
  yOffset: V0
}, sQ = bw("line", SJ, BJ);
function oQ(e, t) {
  var n = t.scaleX || 1, i = t.scaleY || 1;
  (n !== 1 || i !== 1) && e("vector-effect", "non-scaling-stroke"), e("transform", PJ(t)), e("d", t.path);
}
function Wh(e, t) {
  var n = t.path;
  if (n == null)
    return !0;
  var i = t.x || 0, r = t.y || 0, a = t.scaleX || 1, s = t.scaleY || 1, o = (t.angle || 0) * Ha, u = t.pathCache;
  (!u || u.path !== n) && ((t.pathCache = u = rf(n)).path = n), o && e.rotate && e.translate ? (e.translate(i, r), e.rotate(o), Kp(e, u, 0, 0, a, s), e.rotate(-o), e.translate(-i, -r)) : Kp(e, u, i, r, a, s);
}
function uQ(e, t) {
  return Wh(fd(e, t.angle), t) ? e.set(0, 0, 0, 0) : Co(e, t, !0);
}
var lQ = {
  type: "path",
  tag: "path",
  nested: !1,
  attr: oQ,
  bound: uQ,
  draw: pw(Wh),
  pick: gw(Wh),
  isect: fw(Wh)
};
function cQ(e, t) {
  e("d", hl(null, t));
}
function fQ(e, t) {
  var n, i;
  return Co(e.set(n = t.x || 0, i = t.y || 0, n + t.width || 0, i + t.height || 0), t);
}
function J6(e, t) {
  e.beginPath(), hl(e, t);
}
var dQ = {
  type: "rect",
  tag: "path",
  nested: !1,
  attr: cQ,
  bound: fQ,
  draw: pw(J6),
  pick: gw(J6),
  isect: VF
};
function hQ(e, t) {
  e("transform", JF(t)), e("x2", t.x2 != null ? t.x2 - (t.x || 0) : 0), e("y2", t.y2 != null ? t.y2 - (t.y || 0) : 0);
}
function pQ(e, t) {
  var n, i;
  return Co(e.set(n = t.x || 0, i = t.y || 0, t.x2 != null ? t.x2 : n, t.y2 != null ? t.y2 : i), t);
}
function tM(e, t, n) {
  var i, r, a, s;
  return t.stroke && _u(e, t, n) ? (i = t.x || 0, r = t.y || 0, a = t.x2 != null ? t.x2 : i, s = t.y2 != null ? t.y2 : r, e.beginPath(), e.moveTo(i, r), e.lineTo(a, s), !0) : !1;
}
function gQ(e, t, n) {
  Fi(t, (i) => {
    if (!(n && !n.intersects(i.bounds))) {
      var r = i.opacity == null ? 1 : i.opacity;
      r && tM(e, i, r) && (Cu(e, i), e.stroke());
    }
  });
}
function mQ(e, t, n, i) {
  return e.isPointInStroke ? tM(e, t, 1) && e.isPointInStroke(n, i) : !1;
}
var yQ = {
  type: "rule",
  tag: "line",
  nested: !1,
  attr: hQ,
  bound: pQ,
  draw: gQ,
  pick: W0(mQ),
  isect: XF
}, bQ = yw("shape", AJ), vQ = yw("symbol", kJ, dw);
const Q6 = P2();
var Pa = {
  height: vr,
  measureWidth: ww,
  estimateWidth: Zp,
  width: Zp,
  canvas: nM
};
nM(!0);
function nM(e) {
  Pa.width = e && La ? ww : Zp;
}
function Zp(e, t) {
  return iM(Xa(e, t), vr(e));
}
function iM(e, t) {
  return ~~(0.8 * e.length * t);
}
function ww(e, t) {
  return vr(e) <= 0 || !(t = Xa(e, t)) ? 0 : rM(t, X0(e));
}
function rM(e, t) {
  const n = `(${t}) ${e}`;
  let i = Q6.get(n);
  return i === void 0 && (La.font = t, i = La.measureText(e).width, Q6.set(n, i)), i;
}
function vr(e) {
  return e.fontSize != null ? +e.fontSize || 0 : 11;
}
function Va(e) {
  return e.lineHeight != null ? e.lineHeight : vr(e) + 2;
}
function xQ(e) {
  return R(e) ? e.length > 1 ? e : e[0] : e;
}
function hd(e) {
  return xQ(e.lineBreak && e.text && !R(e.text) ? e.text.split(e.lineBreak) : e.text);
}
function $Q(e) {
  const t = hd(e);
  return (R(t) ? t.length - 1 : 0) * Va(e);
}
function Xa(e, t) {
  const n = t == null ? "" : (t + "").trim();
  return e.limit > 0 && n.length ? EQ(e, n) : n;
}
function wQ(e) {
  if (Pa.width === ww) {
    const t = X0(e);
    return (n) => rM(n, t);
  } else if (Pa.width === Zp) {
    const t = vr(e);
    return (n) => iM(n, t);
  } else
    return (t) => Pa.width(e, t);
}
function EQ(e, t) {
  var n = +e.limit, i = wQ(e);
  if (i(t) < n)
    return t;
  var r = e.ellipsis || "", a = e.dir === "rtl", s = 0, o = t.length, u;
  if (n -= i(r), a) {
    for (; s < o; )
      u = s + o >>> 1, i(t.slice(u)) > n ? s = u + 1 : o = u;
    return r + t.slice(s);
  } else {
    for (; s < o; )
      u = 1 + (s + o >>> 1), i(t.slice(0, u)) < n ? s = u : o = u - 1;
    return t.slice(0, s) + r;
  }
}
function pd(e, t) {
  var n = e.font;
  return (t && n ? String(n).replace(/"/g, "'") : n) || "sans-serif";
}
function X0(e, t) {
  return (e.fontStyle ? e.fontStyle + " " : "") + (e.fontVariant ? e.fontVariant + " " : "") + (e.fontWeight ? e.fontWeight + " " : "") + vr(e) + "px " + pd(e, t);
}
function Ew(e) {
  var t = e.baseline, n = vr(e);
  return Math.round(t === "top" ? 0.79 * n : t === "middle" ? 0.3 * n : t === "bottom" ? -0.21 * n : t === "line-top" ? 0.29 * n + 0.5 * Va(e) : t === "line-bottom" ? 0.29 * n - 0.5 * Va(e) : 0);
}
const SQ = {
  left: "start",
  center: "middle",
  right: "end"
}, Mc = new $n();
function Y0(e) {
  var t = e.x || 0, n = e.y || 0, i = e.radius || 0, r;
  return i && (r = (e.theta || 0) - Ns, t += i * Math.cos(r), n += i * Math.sin(r)), Mc.x1 = t, Mc.y1 = n, Mc;
}
function AQ(e, t) {
  var n = t.dx || 0, i = (t.dy || 0) + Ew(t), r = Y0(t), a = r.x1, s = r.y1, o = t.angle || 0, u;
  e("text-anchor", SQ[t.align] || "start"), o ? (u = Ys(a, s) + " " + mw(o), (n || i) && (u += " " + Ys(n, i))) : u = Ys(a + n, s + i), e("transform", u);
}
function Sw(e, t, n) {
  var i = Pa.height(t), r = t.align, a = Y0(t), s = a.x1, o = a.y1, u = t.dx || 0, l = (t.dy || 0) + Ew(t) - Math.round(0.8 * i), c = hd(t), f;
  if (R(c) ? (i += Va(t) * (c.length - 1), f = c.reduce((d, h) => Math.max(d, Pa.width(t, h)), 0)) : f = Pa.width(t, c), r === "center" ? u -= f / 2 : r === "right" && (u -= f), e.set(u += s, l += o, u + f, l + i), t.angle && !n)
    e.rotate(t.angle * Ha, s, o);
  else if (n === 2)
    return e.rotatedPoints(t.angle * Ha, s, o);
  return e;
}
function kQ(e, t, n) {
  Fi(t, (i) => {
    var r = i.opacity == null ? 1 : i.opacity, a, s, o, u, l, c, f;
    if (!(n && !n.intersects(i.bounds) || // bounds check
    r === 0 || i.fontSize <= 0 || i.text == null || i.text.length === 0)) {
      if (e.font = X0(i), e.textAlign = i.align || "left", a = Y0(i), s = a.x1, o = a.y1, i.angle && (e.save(), e.translate(s, o), e.rotate(i.angle * Ha), s = o = 0), s += i.dx || 0, o += (i.dy || 0) + Ew(i), c = hd(i), Cu(e, i), R(c))
        for (l = Va(i), u = 0; u < c.length; ++u)
          f = Xa(i, c[u]), i.fill && Jp(e, i, r) && e.fillText(f, s, o), i.stroke && _u(e, i, r) && e.strokeText(f, s, o), o += l;
      else
        f = Xa(i, c), i.fill && Jp(e, i, r) && e.fillText(f, s, o), i.stroke && _u(e, i, r) && e.strokeText(f, s, o);
      i.angle && e.restore();
    }
  });
}
function CQ(e, t, n, i, r, a) {
  if (t.fontSize <= 0)
    return !1;
  if (!t.angle)
    return !0;
  var s = Y0(t), o = s.x1, u = s.y1, l = Sw(Mc, t, 1), c = -t.angle * Ha, f = Math.cos(c), d = Math.sin(c), h = f * r - d * a + (o - f * o + d * u), p = d * r + f * a + (u - d * o - f * u);
  return l.contains(h, p);
}
function _Q(e, t) {
  const n = Sw(Mc, e, 2);
  return au(t, n[0], n[1], n[2], n[3]) || au(t, n[0], n[1], n[4], n[5]) || au(t, n[4], n[5], n[6], n[7]) || au(t, n[2], n[3], n[6], n[7]);
}
var FQ = {
  type: "text",
  tag: "text",
  nested: !1,
  attr: AQ,
  bound: Sw,
  draw: kQ,
  pick: W0(CQ),
  isect: _Q
}, MQ = bw("trail", CJ, jJ), Mi = {
  arc: zJ,
  area: UJ,
  group: tQ,
  image: aQ,
  line: sQ,
  path: lQ,
  rect: dQ,
  rule: yQ,
  shape: bQ,
  symbol: vQ,
  text: FQ,
  trail: MQ
};
function Zb(e, t, n) {
  var i = Mi[e.mark.marktype], r = t || i.bound;
  return i.nested && (e = e.mark), r(e.bounds || (e.bounds = new $n()), e, n);
}
var Z6 = {
  mark: null
};
function aM(e, t, n) {
  var i = Mi[e.marktype], r = i.bound, a = e.items, s = a && a.length, o, u, l, c;
  if (i.nested)
    return s ? l = a[0] : (Z6.mark = e, l = Z6), c = Zb(l, r, n), t = t && t.union(c) || c, t;
  if (t = t || e.bounds && e.bounds.clear() || new $n(), s)
    for (o = 0, u = a.length; o < u; ++o)
      t.union(Zb(a[o], r, n));
  return e.bounds = t;
}
const OQ = [
  "marktype",
  "name",
  "role",
  "interactive",
  "clip",
  "items",
  "zindex",
  "x",
  "y",
  "width",
  "height",
  "align",
  "baseline",
  // layout
  "fill",
  "fillOpacity",
  "opacity",
  "blend",
  // fill
  "stroke",
  "strokeOpacity",
  "strokeWidth",
  "strokeCap",
  // stroke
  "strokeDash",
  "strokeDashOffset",
  // stroke dash
  "strokeForeground",
  "strokeOffset",
  // group
  "startAngle",
  "endAngle",
  "innerRadius",
  "outerRadius",
  // arc
  "cornerRadius",
  "padAngle",
  // arc, rect
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  // rect, group
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight",
  "interpolate",
  "tension",
  "orient",
  "defined",
  // area, line
  "url",
  "aspect",
  "smooth",
  // image
  "path",
  "scaleX",
  "scaleY",
  // path
  "x2",
  "y2",
  // rule
  "size",
  "shape",
  // symbol
  "text",
  "angle",
  "theta",
  "radius",
  "dir",
  "dx",
  "dy",
  // text
  "ellipsis",
  "limit",
  "lineBreak",
  "lineHeight",
  "font",
  "fontSize",
  "fontWeight",
  "fontStyle",
  "fontVariant",
  // font
  "description",
  "aria",
  "ariaRole",
  "ariaRoleDescription"
  // aria
];
function sM(e, t) {
  return JSON.stringify(e, OQ, t);
}
function oM(e) {
  const t = typeof e == "string" ? JSON.parse(e) : e;
  return uM(t);
}
function uM(e) {
  var t = e.marktype, n = e.items, i, r, a;
  if (n)
    for (r = 0, a = n.length; r < a; ++r)
      i = t ? "mark" : "group", n[r][i] = e, n[r].zindex && (n[r][i].zdirty = !0), (t || i) === "group" && uM(n[r]);
  return t && aM(e), e;
}
function lM(e) {
  arguments.length ? this.root = oM(e) : (this.root = cM({
    marktype: "group",
    name: "root",
    role: "frame"
  }), this.root.items = [new lw(this.root)]);
}
lM.prototype = {
  toJSON(e) {
    return sM(this.root, e || 0);
  },
  mark(e, t, n) {
    t = t || this.root.items[0];
    const i = cM(e, t);
    return t.items[n] = i, i.zindex && (i.group.zdirty = !0), i;
  }
};
function cM(e, t) {
  const n = {
    bounds: new $n(),
    clip: !!e.clip,
    group: t,
    interactive: e.interactive !== !1,
    items: [],
    marktype: e.marktype,
    name: e.name || void 0,
    role: e.role || void 0,
    zindex: e.zindex || 0
  };
  return e.aria != null && (n.aria = e.aria), e.description && (n.description = e.description), n;
}
function Oa(e, t, n) {
  return !e && typeof document < "u" && document.createElement && (e = document), e ? n ? e.createElementNS(n, t) : e.createElement(t) : null;
}
function Aw(e, t) {
  t = t.toLowerCase();
  for (var n = e.childNodes, i = 0, r = n.length; i < r; ++i)
    if (n[i].tagName.toLowerCase() === t)
      return n[i];
}
function tt(e, t, n, i) {
  var r = e.childNodes[t], a;
  return (!r || r.tagName.toLowerCase() !== n.toLowerCase()) && (a = r || null, r = Oa(e.ownerDocument, n, i), e.insertBefore(r, a)), r;
}
function Wn(e, t) {
  for (var n = e.childNodes, i = n.length; i > t; )
    e.removeChild(n[--i]);
  return e;
}
function fM(e) {
  return "mark-" + e.marktype + (e.role ? " role-" + e.role : "") + (e.name ? " " + e.name : "");
}
function kw(e, t) {
  const n = t.getBoundingClientRect();
  return [e.clientX - n.left - (t.clientLeft || 0), e.clientY - n.top - (t.clientTop || 0)];
}
function RQ(e, t, n, i) {
  var r = e && e.mark, a, s;
  if (r && (a = Mi[r.marktype]).tip) {
    for (s = kw(t, n), s[0] -= i[0], s[1] -= i[1]; e = e.mark.group; )
      s[0] -= e.x || 0, s[1] -= e.y || 0;
    e = a.tip(r.items, s);
  }
  return e;
}
function Ya(e, t) {
  this._active = null, this._handlers = {}, this._loader = e || sl(), this._tooltip = t || TQ;
}
function TQ(e, t, n, i) {
  e.element().setAttribute("title", i || "");
}
Ya.prototype = {
  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(e, t, n) {
    return this._el = e, this._obj = n || null, this.origin(t);
  },
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },
  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(e) {
    return arguments.length ? (this._origin = e || [0, 0], this) : this._origin.slice();
  },
  /**
   * Get / set the scenegraph root.
   */
  scene(e) {
    return arguments.length ? (this._scene = e, this) : this._scene;
  },
  /**
   * Add an event handler. Subclasses should override this method.
   */
  on() {
  },
  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off() {
  },
  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(e, t, n) {
    for (let i = e ? e.length : 0; --i >= 0; )
      if (e[i].type === t && (!n || e[i].handler === n))
        return i;
    return -1;
  },
  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(e) {
    const t = this._handlers, n = [];
    if (e)
      n.push(...t[this.eventName(e)]);
    else
      for (const i in t)
        n.push(...t[i]);
    return n;
  },
  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(e) {
    const t = e.indexOf(".");
    return t < 0 ? e : e.slice(0, t);
  },
  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(e, t, n) {
    this._loader.sanitize(n, {
      context: "href"
    }).then((i) => {
      const r = new MouseEvent(e.type, e), a = Oa(null, "a");
      for (const s in i)
        a.setAttribute(s, i[s]);
      a.dispatchEvent(r);
    }).catch(() => {
    });
  },
  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(e, t, n) {
    if (t && t.tooltip != null) {
      t = RQ(t, e, this.canvas(), this._origin);
      const i = n && t && t.tooltip || null;
      this._tooltip.call(this._obj, this, e, t, i);
    }
  },
  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(e) {
    const t = this.canvas();
    if (!t)
      return;
    const n = t.getBoundingClientRect(), i = this._origin, r = e.bounds, a = r.width(), s = r.height();
    let o = r.x1 + i[0] + n.left, u = r.y1 + i[1] + n.top;
    for (; e.mark && (e = e.mark.group); )
      o += e.x || 0, u += e.y || 0;
    return {
      x: o,
      y: u,
      width: a,
      height: s,
      left: o,
      top: u,
      right: o + a,
      bottom: u + s
    };
  }
};
function jn(e) {
  this._el = null, this._bgcolor = null, this._loader = new cw(e);
}
jn.prototype = {
  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(e, t, n, i, r) {
    return this._el = e, this.resize(t, n, i, r);
  },
  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  },
  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  },
  /**
   * Get / set the background color.
   */
  background(e) {
    return arguments.length === 0 ? this._bgcolor : (this._bgcolor = e, this);
  },
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(e, t, n, i) {
    return this._width = e, this._height = t, this._origin = n || [0, 0], this._scale = i || 1, this;
  },
  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty() {
  },
  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Renderer} - This renderer instance.
   */
  render(e, t) {
    const n = this;
    return n._call = function() {
      n._render(e, t);
    }, n._call(), n._call = null, n;
  },
  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render() {
  },
  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(e, t) {
    const n = this.render(e, t);
    return this._ready ? this._ready.then(() => n) : Promise.resolve(n);
  },
  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(e, t) {
    var n = this, i = n._loader[e](t);
    if (!n._ready) {
      const r = n._call;
      n._ready = n._loader.ready().then((a) => {
        a && r(), n._ready = null;
      });
    }
    return i;
  },
  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(e) {
    return this._load("sanitizeURL", e);
  },
  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(e) {
    return this._load("loadImage", e);
  }
};
const DQ = "keydown", NQ = "keypress", LQ = "keyup", dM = "dragenter", Hh = "dragleave", hM = "dragover", ev = "pointerdown", PQ = "pointerup", eg = "pointermove", Oc = "pointerout", pM = "pointerover", tv = "mousedown", zQ = "mouseup", gM = "mousemove", nv = "mouseout", mM = "mouseover", tg = "click", IQ = "dblclick", BQ = "wheel", yM = "mousewheel", ng = "touchstart", ig = "touchmove", rg = "touchend", jQ = [DQ, NQ, LQ, dM, Hh, hM, ev, PQ, eg, Oc, pM, tv, zQ, gM, nv, mM, tg, IQ, BQ, yM, ng, ig, rg], iv = eg, of = Oc, rv = tg;
function Fu(e, t) {
  Ya.call(this, e, t), this._down = null, this._touch = null, this._first = !0, this._events = {};
}
const UQ = (e) => e === ng || e === ig || e === rg ? [ng, ig, rg] : [e];
function eA(e, t) {
  UQ(t).forEach((n) => qQ(e, n));
}
function qQ(e, t) {
  const n = e.canvas();
  n && !e._events[t] && (e._events[t] = 1, n.addEventListener(t, e[t] ? (i) => e[t](i) : (i) => e.fire(t, i)));
}
function gc(e, t, n) {
  t.forEach((i) => e.fire(i, n));
}
function tA(e, t, n) {
  return function(i) {
    const r = this._active, a = this.pickEvent(i);
    a === r ? gc(this, e, i) : ((!r || !r.exit) && gc(this, n, i), this._active = a, gc(this, t, i), gc(this, e, i));
  };
}
function nA(e) {
  return function(t) {
    gc(this, e, t), this._active = null;
  };
}
B(Fu, Ya, {
  initialize(e, t, n) {
    return this._canvas = e && Aw(e, "canvas"), [tg, tv, ev, eg, Oc, Hh].forEach((i) => eA(this, i)), Ya.prototype.initialize.call(this, e, t, n);
  },
  // return the backing canvas instance
  canvas() {
    return this._canvas;
  },
  // retrieve the current canvas context
  context() {
    return this._canvas.getContext("2d");
  },
  // supported events
  events: jQ,
  // to keep old versions of firefox happy
  DOMMouseScroll(e) {
    this.fire(yM, e);
  },
  pointermove: tA([eg, gM], [pM, mM], [Oc, nv]),
  dragover: tA([hM], [dM], [Hh]),
  pointerout: nA([Oc, nv]),
  dragleave: nA([Hh]),
  pointerdown(e) {
    this._down = this._active, this.fire(ev, e);
  },
  mousedown(e) {
    this._down = this._active, this.fire(tv, e);
  },
  click(e) {
    this._down === this._active && (this.fire(tg, e), this._down = null);
  },
  touchstart(e) {
    this._touch = this.pickEvent(e.changedTouches[0]), this._first && (this._active = this._touch, this._first = !1), this.fire(ng, e, !0);
  },
  touchmove(e) {
    this.fire(ig, e, !0);
  },
  touchend(e) {
    this.fire(rg, e, !0), this._touch = null;
  },
  // fire an event
  fire(e, t, n) {
    const i = n ? this._touch : this._active, r = this._handlers[e];
    if (t.vegaType = e, e === rv && i && i.href ? this.handleHref(t, i, i.href) : (e === iv || e === of) && this.handleTooltip(t, i, e !== of), r)
      for (let a = 0, s = r.length; a < s; ++a)
        r[a].handler.call(this._obj, t, i);
  },
  // add an event handler
  on(e, t) {
    const n = this.eventName(e), i = this._handlers;
    return this._handlerIndex(i[n], e, t) < 0 && (eA(this, e), (i[n] || (i[n] = [])).push({
      type: e,
      handler: t
    })), this;
  },
  // remove an event handler
  off(e, t) {
    const n = this.eventName(e), i = this._handlers[n], r = this._handlerIndex(i, e, t);
    return r >= 0 && i.splice(r, 1), this;
  },
  pickEvent(e) {
    const t = kw(e, this._canvas), n = this._origin;
    return this.pick(this._scene, t[0], t[1], t[0] - n[0], t[1] - n[1]);
  },
  // find the scenegraph item at the current pointer position
  // x, y -- the absolute x, y pointer coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(e, t, n, i, r) {
    const a = this.context();
    return Mi[e.marktype].pick.call(this, a, e, t, n, i, r);
  }
});
function GQ() {
  return typeof window < "u" && window.devicePixelRatio || 1;
}
var WQ = GQ();
function HQ(e, t, n, i, r, a) {
  const s = typeof HTMLElement < "u" && e instanceof HTMLElement && e.parentNode != null, o = e.getContext("2d"), u = s ? WQ : r;
  e.width = t * u, e.height = n * u;
  for (const l in a)
    o[l] = a[l];
  return s && u !== 1 && (e.style.width = t + "px", e.style.height = n + "px"), o.pixelRatio = u, o.setTransform(u, 0, 0, u, u * i[0], u * i[1]), e;
}
function uf(e) {
  jn.call(this, e), this._options = {}, this._redraw = !1, this._dirty = new $n(), this._tempb = new $n();
}
const iA = jn.prototype, VQ = (e, t, n) => new $n().set(0, 0, t, n).translate(-e[0], -e[1]);
function XQ(e, t, n) {
  return t.expand(1).round(), e.pixelRatio % 1 && t.scale(e.pixelRatio).round().scale(1 / e.pixelRatio), t.translate(-(n[0] % 1), -(n[1] % 1)), e.beginPath(), e.rect(t.x1, t.y1, t.width(), t.height()), e.clip(), t;
}
B(uf, jn, {
  initialize(e, t, n, i, r, a) {
    return this._options = a || {}, this._canvas = this._options.externalContext ? null : Ei(1, 1, this._options.type), e && this._canvas && (Wn(e, 0).appendChild(this._canvas), this._canvas.setAttribute("class", "marks")), iA.initialize.call(this, e, t, n, i, r);
  },
  resize(e, t, n, i) {
    if (iA.resize.call(this, e, t, n, i), this._canvas)
      HQ(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    else {
      const r = this._options.externalContext;
      r || D("CanvasRenderer is missing a valid canvas or context"), r.scale(this._scale, this._scale), r.translate(this._origin[0], this._origin[1]);
    }
    return this._redraw = !0, this;
  },
  canvas() {
    return this._canvas;
  },
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext("2d") : null);
  },
  dirty(e) {
    const t = this._tempb.clear().union(e.bounds);
    let n = e.mark.group;
    for (; n; )
      t.translate(n.x || 0, n.y || 0), n = n.mark.group;
    this._dirty.union(t);
  },
  _render(e, t) {
    const n = this.context(), i = this._origin, r = this._width, a = this._height, s = this._dirty, o = VQ(i, r, a);
    n.save();
    const u = this._redraw || s.empty() ? (this._redraw = !1, o.expand(1)) : XQ(n, o.intersect(s), i);
    return this.clear(-i[0], -i[1], r, a), this.draw(n, e, u, t), n.restore(), s.clear(), this;
  },
  draw(e, t, n, i) {
    if (t.marktype !== "group" && i != null && !i.includes(t.marktype))
      return;
    const r = Mi[t.marktype];
    t.clip && qJ(e, t), r.draw.call(this, e, t, n, i), t.clip && e.restore();
  },
  clear(e, t, n, i) {
    const r = this._options, a = this.context();
    r.type !== "pdf" && !r.externalContext && a.clearRect(e, t, n, i), this._bgcolor != null && (a.fillStyle = this._bgcolor, a.fillRect(e, t, n, i));
  }
});
function Cw(e, t) {
  Ya.call(this, e, t);
  const n = this;
  n._hrefHandler = av(n, (i, r) => {
    r && r.href && n.handleHref(i, r, r.href);
  }), n._tooltipHandler = av(n, (i, r) => {
    n.handleTooltip(i, r, i.type !== of);
  });
}
const av = (e, t) => (n) => {
  let i = n.target.__data__;
  i = Array.isArray(i) ? i[0] : i, n.vegaType = n.type, t.call(e._obj, n, i);
};
B(Cw, Ya, {
  initialize(e, t, n) {
    let i = this._svg;
    return i && (i.removeEventListener(rv, this._hrefHandler), i.removeEventListener(iv, this._tooltipHandler), i.removeEventListener(of, this._tooltipHandler)), this._svg = i = e && Aw(e, "svg"), i && (i.addEventListener(rv, this._hrefHandler), i.addEventListener(iv, this._tooltipHandler), i.addEventListener(of, this._tooltipHandler)), Ya.prototype.initialize.call(this, e, t, n);
  },
  canvas() {
    return this._svg;
  },
  // add an event handler
  on(e, t) {
    const n = this.eventName(e), i = this._handlers;
    if (this._handlerIndex(i[n], e, t) < 0) {
      const a = {
        type: e,
        handler: t,
        listener: av(this, t)
      };
      (i[n] || (i[n] = [])).push(a), this._svg && this._svg.addEventListener(n, a.listener);
    }
    return this;
  },
  // remove an event handler
  off(e, t) {
    const n = this.eventName(e), i = this._handlers[n], r = this._handlerIndex(i, e, t);
    return r >= 0 && (this._svg && this._svg.removeEventListener(n, i[r].listener), i.splice(r, 1)), this;
  }
});
const bM = "aria-hidden", _w = "aria-label", Fw = "role", Mw = "aria-roledescription", vM = "graphics-object", Ow = "graphics-symbol", xM = (e, t, n) => ({
  [Fw]: e,
  [Mw]: t,
  [_w]: n || void 0
}), YQ = an(["axis-domain", "axis-grid", "axis-label", "axis-tick", "axis-title", "legend-band", "legend-entry", "legend-gradient", "legend-label", "legend-title", "legend-symbol", "title"]), rA = {
  axis: {
    desc: "axis",
    caption: QQ
  },
  legend: {
    desc: "legend",
    caption: ZQ
  },
  "title-text": {
    desc: "title",
    caption: (e) => `Title text '${sA(e)}'`
  },
  "title-subtitle": {
    desc: "subtitle",
    caption: (e) => `Subtitle text '${sA(e)}'`
  }
}, aA = {
  ariaRole: Fw,
  ariaRoleDescription: Mw,
  description: _w
};
function $M(e, t) {
  const n = t.aria === !1;
  if (e(bM, n || void 0), n || t.description == null)
    for (const i in aA)
      e(aA[i], void 0);
  else {
    const i = t.mark.marktype;
    e(_w, t.description), e(Fw, t.ariaRole || (i === "group" ? vM : Ow)), e(Mw, t.ariaRoleDescription || `${i} mark`);
  }
}
function wM(e) {
  return e.aria === !1 ? {
    [bM]: !0
  } : YQ[e.role] ? null : rA[e.role] ? JQ(e, rA[e.role]) : KQ(e);
}
function KQ(e) {
  const t = e.marktype, n = t === "group" || t === "text" || e.items.some((i) => i.description != null && i.aria !== !1);
  return xM(n ? vM : Ow, `${t} mark container`, e.description);
}
function JQ(e, t) {
  try {
    const n = e.items[0], i = t.caption || (() => "");
    return xM(t.role || Ow, t.desc, n.description || i(n));
  } catch {
    return null;
  }
}
function sA(e) {
  return G(e.text).join(" ");
}
function QQ(e) {
  const t = e.datum, n = e.orient, i = t.title ? EM(e) : null, r = e.context, a = r.scales[t.scale].value, s = r.dataflow.locale(), o = a.type;
  return `${n === "left" || n === "right" ? "Y" : "X"}-axis` + (i ? ` titled '${i}'` : "") + ` for a ${RF(o) ? "discrete" : o} scale with ${zF(s, a, e)}`;
}
function ZQ(e) {
  const t = e.datum, n = t.title ? EM(e) : null, i = `${t.type || ""} legend`.trim(), r = t.scales, a = Object.keys(r), s = e.context, o = s.scales[r[a[0]]].value, u = s.dataflow.locale();
  return tZ(i) + (n ? ` titled '${n}'` : "") + ` for ${eZ(a)} with ${zF(u, o, e)}`;
}
function EM(e) {
  try {
    return G(ae(e.items).items[0].text).join(" ");
  } catch {
    return null;
  }
}
function eZ(e) {
  return e = e.map((t) => t + (t === "fill" || t === "stroke" ? " color" : "")), e.length < 2 ? e[0] : e.slice(0, -1).join(", ") + " and " + ae(e);
}
function tZ(e) {
  return e.length ? e[0].toUpperCase() + e.slice(1) : e;
}
const SM = (e) => (e + "").replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), nZ = (e) => SM(e).replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
function Rw() {
  let e = "", t = "", n = "";
  const i = [], r = () => t = n = "", a = (u) => {
    t && (e += `${t}>${n}`, r()), i.push(u);
  }, s = (u, l) => (l != null && (t += ` ${u}="${nZ(l)}"`), o), o = {
    open(u) {
      a(u), t = "<" + u;
      for (var l = arguments.length, c = new Array(l > 1 ? l - 1 : 0), f = 1; f < l; f++)
        c[f - 1] = arguments[f];
      for (const d of c)
        for (const h in d)
          s(h, d[h]);
      return o;
    },
    close() {
      const u = i.pop();
      return t ? e += t + (n ? `>${n}</${u}>` : "/>") : e += `</${u}>`, r(), o;
    },
    attr: s,
    text: (u) => (n += SM(u), o),
    toString: () => e
  };
  return o;
}
const AM = (e) => kM(Rw(), e) + "";
function kM(e, t) {
  if (e.open(t.tagName), t.hasAttributes()) {
    const n = t.attributes, i = n.length;
    for (let r = 0; r < i; ++r)
      e.attr(n[r].name, n[r].value);
  }
  if (t.hasChildNodes()) {
    const n = t.childNodes;
    for (const i of n)
      i.nodeType === 3 ? e.text(i.nodeValue) : kM(e, i);
  }
  return e.close();
}
const ag = {
  fill: "fill",
  fillOpacity: "fill-opacity",
  stroke: "stroke",
  strokeOpacity: "stroke-opacity",
  strokeWidth: "stroke-width",
  strokeCap: "stroke-linecap",
  strokeJoin: "stroke-linejoin",
  strokeDash: "stroke-dasharray",
  strokeDashOffset: "stroke-dashoffset",
  strokeMiterLimit: "stroke-miterlimit",
  opacity: "opacity"
}, sg = {
  blend: "mix-blend-mode"
}, CM = {
  fill: "none",
  "stroke-miterlimit": 10
}, zl = 0, oA = "http://www.w3.org/2000/xmlns/", et = sf.xmlns;
function K0(e) {
  jn.call(this, e), this._dirtyID = 0, this._dirty = [], this._svg = null, this._root = null, this._defs = null;
}
const J1 = jn.prototype;
B(K0, jn, {
  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(e, t, n, i, r) {
    return this._defs = {}, this._clearDefs(), e && (this._svg = tt(e, 0, "svg", et), this._svg.setAttributeNS(oA, "xmlns", et), this._svg.setAttributeNS(oA, "xmlns:xlink", sf["xmlns:xlink"]), this._svg.setAttribute("version", sf.version), this._svg.setAttribute("class", "marks"), Wn(e, 1), this._root = tt(this._svg, zl, "g", et), Ra(this._root, CM), Wn(this._svg, zl + 1)), this.background(this._bgcolor), J1.initialize.call(this, e, t, n, i, r);
  },
  /**
   * Get / set the background color.
   */
  background(e) {
    return arguments.length && this._svg && this._svg.style.setProperty("background-color", e), J1.background.apply(this, arguments);
  },
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(e, t, n, i) {
    return J1.resize.call(this, e, t, n, i), this._svg && (Ra(this._svg, {
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }), this._root.setAttribute("transform", `translate(${this._origin})`)), this._dirty = [], this;
  },
  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  },
  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const e = this._svg, t = this._bgcolor;
    if (!e)
      return null;
    let n;
    t && (e.removeAttribute("style"), n = tt(e, zl, "rect", et), Ra(n, {
      width: this._width,
      height: this._height,
      fill: t
    }));
    const i = AM(e);
    return t && (e.removeChild(n), this._svg.style.setProperty("background-color", t)), i;
  },
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(e, t) {
    return this._dirtyCheck() && (this._dirtyAll && this._clearDefs(), this.mark(this._root, e, void 0, t), Wn(this._root, 1)), this.defs(), this._dirty = [], ++this._dirtyID, this;
  },
  // -- Manage rendering of items marked as dirty --
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(e) {
    e.dirty !== this._dirtyID && (e.dirty = this._dirtyID, this._dirty.push(e));
  },
  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(e) {
    return this._dirtyAll || !e._svg || !e._svg.ownerSVGElement || e.dirty === this._dirtyID;
  },
  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = !0;
    const e = this._dirty;
    if (!e.length || !this._dirtyID)
      return !0;
    const t = ++this._dirtyID;
    let n, i, r, a, s, o, u;
    for (s = 0, o = e.length; s < o; ++s)
      if (n = e[s], i = n.mark, i.marktype !== r && (r = i.marktype, a = Mi[r]), i.zdirty && i.dirty !== t && (this._dirtyAll = !1, uA(n, t), i.items.forEach((l) => {
        l.dirty = t;
      })), !i.zdirty) {
        if (n.exit) {
          a.nested && i.items.length ? (u = i.items[0], u._svg && this._update(a, u._svg, u)) : n._svg && (u = n._svg.parentNode, u && u.removeChild(n._svg)), n._svg = null;
          continue;
        }
        n = a.nested ? i.items[0] : n, n._update !== t && (!n._svg || !n._svg.ownerSVGElement ? (this._dirtyAll = !1, uA(n, t)) : this._update(a, n._svg, n), n._update = t);
      }
    return !this._dirtyAll;
  },
  // -- Construct & maintain scenegraph to SVG mapping ---
  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  mark(e, t, n, i) {
    if (!this.isDirty(t))
      return t._svg;
    const r = this._svg, a = t.marktype, s = Mi[a], o = t.interactive === !1 ? "none" : null, u = s.tag === "g", l = lA(t, e, n, "g", r);
    if (a !== "group" && i != null && !i.includes(a))
      return Wn(l, 0), t._svg;
    l.setAttribute("class", fM(t));
    const c = wM(t);
    for (const p in c)
      Ht(l, p, c[p]);
    u || Ht(l, "pointer-events", o), Ht(l, "clip-path", t.clip ? ow(this, t, t.group) : null);
    let f = null, d = 0;
    const h = (p) => {
      const g = this.isDirty(p), m = lA(p, l, f, s.tag, r);
      g && (this._update(s, m, p), u && aZ(this, m, p, i)), f = m, ++d;
    };
    return s.nested ? t.items.length && h(t.items[0]) : Fi(t, h), Wn(l, d), l;
  },
  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(e, t, n) {
    Br = t, Tt = t.__values__, $M(Rc, n), e.attr(Rc, n, this);
    const i = oZ[e.type];
    i && i.call(this, e, t, n), Br && this.style(Br, n);
  },
  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(e, t) {
    if (t != null) {
      for (const n in ag) {
        let i = n === "font" ? pd(t) : t[n];
        if (i === Tt[n])
          continue;
        const r = ag[n];
        i == null ? e.removeAttribute(r) : (rw(i) && (i = BF(i, this._defs.gradient, _M())), e.setAttribute(r, i + "")), Tt[n] = i;
      }
      for (const n in sg)
        Vh(e, sg[n], t[n]);
    }
  },
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const e = this._svg, t = this._defs;
    let n = t.el, i = 0;
    for (const r in t.gradient)
      n || (t.el = n = tt(e, zl + 1, "defs", et)), i = iZ(n, t.gradient[r], i);
    for (const r in t.clipping)
      n || (t.el = n = tt(e, zl + 1, "defs", et)), i = rZ(n, t.clipping[r], i);
    n && (i === 0 ? (e.removeChild(n), t.el = null) : Wn(n, i));
  },
  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const e = this._defs;
    e.gradient = {}, e.clipping = {};
  }
});
function uA(e, t) {
  for (; e && e.dirty !== t; e = e.mark.group)
    if (e.dirty = t, e.mark && e.mark.dirty !== t)
      e.mark.dirty = t;
    else
      return;
}
function iZ(e, t, n) {
  let i, r, a;
  if (t.gradient === "radial") {
    let s = tt(e, n++, "pattern", et);
    Ra(s, {
      id: Yp + t.id,
      viewBox: "0,0,1,1",
      width: "100%",
      height: "100%",
      preserveAspectRatio: "xMidYMid slice"
    }), s = tt(s, 0, "rect", et), Ra(s, {
      width: 1,
      height: 1,
      fill: `url(${_M()}#${t.id})`
    }), e = tt(e, n++, "radialGradient", et), Ra(e, {
      id: t.id,
      fx: t.x1,
      fy: t.y1,
      fr: t.r1,
      cx: t.x2,
      cy: t.y2,
      r: t.r2
    });
  } else
    e = tt(e, n++, "linearGradient", et), Ra(e, {
      id: t.id,
      x1: t.x1,
      x2: t.x2,
      y1: t.y1,
      y2: t.y2
    });
  for (i = 0, r = t.stops.length; i < r; ++i)
    a = tt(e, i, "stop", et), a.setAttribute("offset", t.stops[i].offset), a.setAttribute("stop-color", t.stops[i].color);
  return Wn(e, i), n;
}
function rZ(e, t, n) {
  let i;
  return e = tt(e, n, "clipPath", et), e.setAttribute("id", t.id), t.path ? (i = tt(e, 0, "path", et), i.setAttribute("d", t.path)) : (i = tt(e, 0, "rect", et), Ra(i, {
    x: 0,
    y: 0,
    width: t.width,
    height: t.height
  })), Wn(e, 1), n + 1;
}
function aZ(e, t, n, i) {
  t = t.lastChild.previousSibling;
  let r, a = 0;
  Fi(n, (s) => {
    r = e.mark(t, s, r, i), ++a;
  }), Wn(t, 1 + a);
}
function lA(e, t, n, i, r) {
  let a = e._svg, s;
  if (!a && (s = t.ownerDocument, a = Oa(s, i, et), e._svg = a, e.mark && (a.__data__ = e, a.__values__ = {
    fill: "default"
  }, i === "g"))) {
    const o = Oa(s, "path", et);
    a.appendChild(o), o.__data__ = e;
    const u = Oa(s, "g", et);
    a.appendChild(u), u.__data__ = e;
    const l = Oa(s, "path", et);
    a.appendChild(l), l.__data__ = e, l.__values__ = {
      fill: "default"
    };
  }
  return (a.ownerSVGElement !== r || sZ(a, n)) && t.insertBefore(a, n ? n.nextSibling : t.firstChild), a;
}
function sZ(e, t) {
  return e.parentNode && e.parentNode.childNodes.length > 1 && e.previousSibling != t;
}
let Br = null, Tt = null;
const oZ = {
  group(e, t, n) {
    const i = Br = t.childNodes[2];
    Tt = i.__values__, e.foreground(Rc, n, this), Tt = t.__values__, Br = t.childNodes[1], e.content(Rc, n, this);
    const r = Br = t.childNodes[0];
    e.background(Rc, n, this);
    const a = n.mark.interactive === !1 ? "none" : null;
    if (a !== Tt.events && (Ht(i, "pointer-events", a), Ht(r, "pointer-events", a), Tt.events = a), n.strokeForeground && n.stroke) {
      const s = n.fill;
      Ht(i, "display", null), this.style(r, n), Ht(r, "stroke", null), s && (n.fill = null), Tt = i.__values__, this.style(i, n), s && (n.fill = s), Br = null;
    } else
      Ht(i, "display", "none");
  },
  image(e, t, n) {
    n.smooth === !1 ? (Vh(t, "image-rendering", "optimizeSpeed"), Vh(t, "image-rendering", "pixelated")) : Vh(t, "image-rendering", null);
  },
  text(e, t, n) {
    const i = hd(n);
    let r, a, s, o;
    R(i) ? (a = i.map((u) => Xa(n, u)), r = a.join(`
`), r !== Tt.text && (Wn(t, 0), s = t.ownerDocument, o = Va(n), a.forEach((u, l) => {
      const c = Oa(s, "tspan", et);
      c.__data__ = n, c.textContent = u, l && (c.setAttribute("x", 0), c.setAttribute("dy", o)), t.appendChild(c);
    }), Tt.text = r)) : (a = Xa(n, i), a !== Tt.text && (t.textContent = a, Tt.text = a)), Ht(t, "font-family", pd(n)), Ht(t, "font-size", vr(n) + "px"), Ht(t, "font-style", n.fontStyle), Ht(t, "font-variant", n.fontVariant), Ht(t, "font-weight", n.fontWeight);
  }
};
function Rc(e, t, n) {
  t !== Tt[e] && (n ? uZ(Br, e, t, n) : Ht(Br, e, t), Tt[e] = t);
}
function Vh(e, t, n) {
  n !== Tt[t] && (n == null ? e.style.removeProperty(t) : e.style.setProperty(t, n + ""), Tt[t] = n);
}
function Ra(e, t) {
  for (const n in t)
    Ht(e, n, t[n]);
}
function Ht(e, t, n) {
  n != null ? e.setAttribute(t, n) : e.removeAttribute(t);
}
function uZ(e, t, n, i) {
  n != null ? e.setAttributeNS(i, t, n) : e.removeAttributeNS(i, t);
}
function _M() {
  let e;
  return typeof window > "u" ? "" : (e = window.location).hash ? e.href.slice(0, -e.hash.length) : e.href;
}
function Tw(e) {
  jn.call(this, e), this._text = null, this._defs = {
    gradient: {},
    clipping: {}
  };
}
B(Tw, jn, {
  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  },
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(e) {
    const t = Rw();
    t.open("svg", ue({}, sf, {
      class: "marks",
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }));
    const n = this._bgcolor;
    return n && n !== "transparent" && n !== "none" && t.open("rect", {
      width: this._width,
      height: this._height,
      fill: n
    }).close(), t.open("g", CM, {
      transform: "translate(" + this._origin + ")"
    }), this.mark(t, e), t.close(), this.defs(t), this._text = t.close() + "", this;
  },
  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(e, t) {
    const n = Mi[t.marktype], i = n.tag, r = [$M, n.attr];
    e.open("g", {
      class: fM(t),
      "clip-path": t.clip ? ow(this, t, t.group) : null
    }, wM(t), {
      "pointer-events": i !== "g" && t.interactive === !1 ? "none" : null
    });
    const a = (s) => {
      const o = this.href(s);
      if (o && e.open("a", o), e.open(i, this.attr(t, s, r, i !== "g" ? i : null)), i === "text") {
        const u = hd(s);
        if (R(u)) {
          const l = {
            x: 0,
            dy: Va(s)
          };
          for (let c = 0; c < u.length; ++c)
            e.open("tspan", c ? l : null).text(Xa(s, u[c])).close();
        } else
          e.text(Xa(s, u));
      } else if (i === "g") {
        const u = s.strokeForeground, l = s.fill, c = s.stroke;
        u && c && (s.stroke = null), e.open("path", this.attr(t, s, n.background, "bgrect")).close(), e.open("g", this.attr(t, s, n.content)), Fi(s, (f) => this.mark(e, f)), e.close(), u && c ? (l && (s.fill = null), s.stroke = c, e.open("path", this.attr(t, s, n.foreground, "bgrect")).close(), l && (s.fill = l)) : e.open("path", this.attr(t, s, n.foreground, "bgfore")).close();
      }
      e.close(), o && e.close();
    };
    return n.nested ? t.items && t.items.length && a(t.items[0]) : Fi(t, a), e.close();
  },
  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(e) {
    const t = e.href;
    let n;
    if (t) {
      if (n = this._hrefs && this._hrefs[t])
        return n;
      this.sanitizeURL(t).then((i) => {
        i["xlink:href"] = i.href, i.href = null, (this._hrefs || (this._hrefs = {}))[t] = i;
      });
    }
    return null;
  },
  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(e, t, n, i) {
    const r = {}, a = (s, o, u, l) => {
      r[l || s] = o;
    };
    return Array.isArray(n) ? n.forEach((s) => s(a, t, this)) : n(a, t, this), i && lZ(r, t, e, i, this._defs), r;
  },
  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(e) {
    const t = this._defs.gradient, n = this._defs.clipping;
    if (Object.keys(t).length + Object.keys(n).length !== 0) {
      e.open("defs");
      for (const r in t) {
        const a = t[r], s = a.stops;
        a.gradient === "radial" ? (e.open("pattern", {
          id: Yp + r,
          viewBox: "0,0,1,1",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid slice"
        }), e.open("rect", {
          width: "1",
          height: "1",
          fill: "url(#" + r + ")"
        }).close(), e.close(), e.open("radialGradient", {
          id: r,
          fx: a.x1,
          fy: a.y1,
          fr: a.r1,
          cx: a.x2,
          cy: a.y2,
          r: a.r2
        })) : e.open("linearGradient", {
          id: r,
          x1: a.x1,
          x2: a.x2,
          y1: a.y1,
          y2: a.y2
        });
        for (let o = 0; o < s.length; ++o)
          e.open("stop", {
            offset: s[o].offset,
            "stop-color": s[o].color
          }).close();
        e.close();
      }
      for (const r in n) {
        const a = n[r];
        e.open("clipPath", {
          id: r
        }), a.path ? e.open("path", {
          d: a.path
        }).close() : e.open("rect", {
          x: 0,
          y: 0,
          width: a.width,
          height: a.height
        }).close(), e.close();
      }
      e.close();
    }
  }
});
function lZ(e, t, n, i, r) {
  let a;
  if (t == null || (i === "bgrect" && n.interactive === !1 && (e["pointer-events"] = "none"), i === "bgfore" && (n.interactive === !1 && (e["pointer-events"] = "none"), e.display = "none", t.fill !== null)))
    return e;
  i === "image" && t.smooth === !1 && (a = ["image-rendering: optimizeSpeed;", "image-rendering: pixelated;"]), i === "text" && (e["font-family"] = pd(t), e["font-size"] = vr(t) + "px", e["font-style"] = t.fontStyle, e["font-variant"] = t.fontVariant, e["font-weight"] = t.fontWeight);
  for (const s in ag) {
    let o = t[s];
    const u = ag[s];
    o === "transparent" && (u === "fill" || u === "stroke") || o != null && (rw(o) && (o = BF(o, r.gradient, "")), e[u] = o);
  }
  for (const s in sg) {
    const o = t[s];
    o != null && (a = a || [], a.push(`${sg[s]}: ${o};`));
  }
  return a && (e.style = a.join(" ")), e;
}
const di = {
  svgMarkTypes: ["text"],
  svgOnTop: !0,
  debug: !1
};
function cZ(e) {
  di.svgMarkTypes = e.svgMarkTypes ?? ["text"], di.svgOnTop = e.svgOnTop ?? !0, di.debug = e.debug ?? !1;
}
function og(e) {
  jn.call(this, e), this._svgRenderer = new K0(e), this._canvasRenderer = new uf(e);
}
const cA = jn.prototype;
B(og, jn, {
  /**
   * Initialize a new HybridRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {HybridRenderer} - This renderer instance.
   */
  initialize(e, t, n, i, r) {
    this._root_el = tt(e, 0, "div");
    const a = tt(this._root_el, 0, "div"), s = tt(this._root_el, 1, "div");
    return this._root_el.style.position = "relative", di.debug || (a.style.height = "100%", s.style.position = "absolute", s.style.top = "0", s.style.left = "0", s.style.height = "100%", s.style.width = "100%"), this._svgEl = di.svgOnTop ? s : a, this._canvasEl = di.svgOnTop ? a : s, this._svgEl.style.pointerEvents = "none", this._canvasRenderer.initialize(this._canvasEl, t, n, i, r), this._svgRenderer.initialize(this._svgEl, t, n, i, r), cA.initialize.call(this, e, t, n, i, r);
  },
  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(e) {
    return di.svgMarkTypes.includes(e.mark.marktype) ? this._svgRenderer.dirty(e) : this._canvasRenderer.dirty(e), this;
  },
  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(e, t) {
    const i = (t ?? ["arc", "area", "image", "line", "path", "rect", "rule", "shape", "symbol", "text", "trail"]).filter((r) => !di.svgMarkTypes.includes(r));
    this._svgRenderer.render(e, di.svgMarkTypes), this._canvasRenderer.render(e, i);
  },
  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(e, t, n, i) {
    return cA.resize.call(this, e, t, n, i), this._svgRenderer.resize(e, t, n, i), this._canvasRenderer.resize(e, t, n, i), this;
  },
  background(e) {
    return di.svgOnTop ? this._canvasRenderer.background(e) : this._svgRenderer.background(e), this;
  }
});
function Dw(e, t) {
  Fu.call(this, e, t);
}
B(Dw, Fu, {
  initialize(e, t, n) {
    const i = tt(tt(e, 0, "div"), di.svgOnTop ? 0 : 1, "div");
    return Fu.prototype.initialize.call(this, i, t, n);
  }
});
const FM = "canvas", MM = "hybrid", OM = "png", RM = "svg", TM = "none", fZ = {
  Canvas: FM,
  PNG: OM,
  SVG: RM,
  Hybrid: MM,
  None: TM
}, oo = {};
oo[FM] = oo[OM] = {
  renderer: uf,
  headless: uf,
  handler: Fu
};
oo[RM] = {
  renderer: K0,
  headless: Tw,
  handler: Cw
};
oo[MM] = {
  renderer: og,
  headless: og,
  handler: Dw
};
oo[TM] = {};
function dZ(e, t) {
  return e = String(e || "").toLowerCase(), arguments.length > 1 ? (oo[e] = t, this) : oo[e];
}
function hZ(e, t, n) {
  const i = [], r = new $n().union(t), a = e.marktype;
  return a ? DM(e, r, n, i) : a === "group" ? NM(e, r, n, i) : D("Intersect scene must be mark node or group item.");
}
function DM(e, t, n, i) {
  if (pZ(e, t, n)) {
    const r = e.items, a = e.marktype, s = r.length;
    let o = 0;
    if (a === "group")
      for (; o < s; ++o)
        NM(r[o], t, n, i);
    else
      for (const u = Mi[a].isect; o < s; ++o) {
        const l = r[o];
        LM(l, t, u) && i.push(l);
      }
  }
  return i;
}
function pZ(e, t, n) {
  return e.bounds && t.intersects(e.bounds) && (e.marktype === "group" || e.interactive !== !1 && (!n || n(e)));
}
function NM(e, t, n, i) {
  n && n(e.mark) && LM(e, t, Mi.group.isect) && i.push(e);
  const r = e.items, a = r && r.length;
  if (a) {
    const s = e.x || 0, o = e.y || 0;
    t.translate(-s, -o);
    for (let u = 0; u < a; ++u)
      DM(r[u], t, n, i);
    t.translate(s, o);
  }
  return i;
}
function LM(e, t, n) {
  const i = e.bounds;
  return t.encloses(i) || t.intersects(i) && n(e, t);
}
const Q1 = new $n();
function gZ(e) {
  const t = e.clip;
  if (oe(t))
    t(fd(Q1.clear()));
  else if (t)
    Q1.set(0, 0, e.group.width, e.group.height);
  else
    return;
  e.bounds.intersect(Q1);
}
const mZ = 1e-9;
function Nw(e, t, n) {
  return e === t ? !0 : n === "path" ? PM(e, t) : e instanceof Date && t instanceof Date ? +e == +t : ye(e) && ye(t) ? Math.abs(e - t) <= mZ : !e || !t || !X(e) && !X(t) ? e == t : yZ(e, t);
}
function PM(e, t) {
  return Nw(rf(e), rf(t));
}
function yZ(e, t) {
  var n = Object.keys(e), i = Object.keys(t), r, a;
  if (n.length !== i.length)
    return !1;
  for (n.sort(), i.sort(), a = n.length - 1; a >= 0; a--)
    if (n[a] != i[a])
      return !1;
  for (a = n.length - 1; a >= 0; a--)
    if (r = n[a], !Nw(e[r], t[r], r))
      return !1;
  return typeof e == typeof t;
}
function bZ() {
  HF(), NK();
}
function vZ(e, t, n) {
  const i = e - t + n * 2;
  return e ? i > 0 ? i : 1 : 0;
}
const xZ = "identity", Lw = "linear", Mu = "log", Pw = "pow", zw = "sqrt", Iw = "symlog", $Z = "time", wZ = "utc", pl = "sequential", gd = "diverging", fA = "quantile", EZ = "quantize", SZ = "threshold", AZ = "ordinal", kZ = "point", CZ = "band", _Z = "bin-ordinal", yt = "continuous", J0 = "discrete", Q0 = "discretizing", Di = "interpolating", zM = "temporal";
function FZ(e) {
  return function(t) {
    let n = t[0], i = t[1], r;
    return i < n && (r = n, n = i, i = r), [e.invert(n), e.invert(i)];
  };
}
function MZ(e) {
  return function(t) {
    const n = e.range();
    let i = t[0], r = t[1], a = -1, s, o, u, l;
    for (r < i && (o = i, i = r, r = o), u = 0, l = n.length; u < l; ++u)
      n[u] >= i && n[u] <= r && (a < 0 && (a = u), s = u);
    if (!(a < 0))
      return i = e.invertExtent(n[a]), r = e.invertExtent(n[s]), [i[0] === void 0 ? i[1] : i[0], r[1] === void 0 ? r[0] : r[1]];
  };
}
function Bw() {
  const e = as().unknown(void 0), t = e.domain, n = e.range;
  let i = [0, 1], r, a, s = !1, o = 0, u = 0, l = 0.5;
  delete e.unknown;
  function c() {
    const f = t().length, d = i[1] < i[0], h = i[1 - d], p = vZ(f, o, u);
    let g = i[d - 0];
    r = (h - g) / (p || 1), s && (r = Math.floor(r)), g += (h - g - r * (f - o)) * l, a = r * (1 - o), s && (g = Math.round(g), a = Math.round(a));
    const m = xt(f).map((y) => g + r * y);
    return n(d ? m.reverse() : m);
  }
  return e.domain = function(f) {
    return arguments.length ? (t(f), c()) : t();
  }, e.range = function(f) {
    return arguments.length ? (i = [+f[0], +f[1]], c()) : i.slice();
  }, e.rangeRound = function(f) {
    return i = [+f[0], +f[1]], s = !0, c();
  }, e.bandwidth = function() {
    return a;
  }, e.step = function() {
    return r;
  }, e.round = function(f) {
    return arguments.length ? (s = !!f, c()) : s;
  }, e.padding = function(f) {
    return arguments.length ? (u = Math.max(0, Math.min(1, f)), o = u, c()) : o;
  }, e.paddingInner = function(f) {
    return arguments.length ? (o = Math.max(0, Math.min(1, f)), c()) : o;
  }, e.paddingOuter = function(f) {
    return arguments.length ? (u = Math.max(0, Math.min(1, f)), c()) : u;
  }, e.align = function(f) {
    return arguments.length ? (l = Math.max(0, Math.min(1, f)), c()) : l;
  }, e.invertRange = function(f) {
    if (f[0] == null || f[1] == null)
      return;
    const d = i[1] < i[0], h = d ? n().reverse() : n(), p = h.length - 1;
    let g = +f[0], m = +f[1], y, b, v;
    if (!(g !== g || m !== m) && (m < g && (v = g, g = m, m = v), !(m < h[0] || g > i[1 - d])))
      return y = Math.max(0, Vr(h, g) - 1), b = g === m ? y : Vr(h, m) - 1, g - h[y] > a + 1e-10 && ++y, d && (v = y, y = p - b, b = p - v), y > b ? void 0 : t().slice(y, b + 1);
  }, e.invert = function(f) {
    const d = e.invertRange([f, f]);
    return d && d[0];
  }, e.copy = function() {
    return Bw().domain(t()).range(i).round(s).paddingInner(o).paddingOuter(u).align(l);
  }, c();
}
function IM(e) {
  const t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, e.copy = function() {
    return IM(t());
  }, e;
}
function OZ() {
  return IM(Bw().paddingInner(1));
}
var RZ = Array.prototype.map;
function TZ(e) {
  return RZ.call(e, Fe);
}
const DZ = Array.prototype.slice;
function BM() {
  let e = [], t = [];
  function n(i) {
    return i == null || i !== i ? void 0 : t[(Eo(e, i) - 1) % t.length];
  }
  return n.domain = function(i) {
    return arguments.length ? (e = TZ(i), n) : e.slice();
  }, n.range = function(i) {
    return arguments.length ? (t = DZ.call(i), n) : t.slice();
  }, n.tickFormat = function(i, r) {
    return Bg(e[0], ae(e), i ?? 10, r);
  }, n.copy = function() {
    return BM().domain(n.domain()).range(n.range());
  }, n;
}
const sv = /* @__PURE__ */ new Map(), NZ = Symbol("vega_scale");
function LZ(e) {
  return e[NZ] = !0, e;
}
function PZ(e, t, n) {
  const i = function() {
    const a = t();
    return a.invertRange || (a.invertRange = a.invert ? FZ(a) : a.invertExtent ? MZ(a) : void 0), a.type = e, LZ(a);
  };
  return i.metadata = an(G(n)), i;
}
function Oe(e, t, n) {
  return arguments.length > 1 ? (sv.set(e, PZ(e, t, n)), this) : zZ(e) ? sv.get(e) : void 0;
}
Oe(xZ, Rf);
Oe(Lw, Ig, yt);
Oe(Mu, Tf, [yt, Mu]);
Oe(Pw, Ku, yt);
Oe(zw, Vg, yt);
Oe(Iw, Df, yt);
Oe($Z, Pg, [yt, zM]);
Oe(wZ, Xg, [yt, zM]);
Oe(pl, Qr, [yt, Di]);
Oe(`${pl}-${Lw}`, Qr, [yt, Di]);
Oe(`${pl}-${Mu}`, zf, [yt, Di, Mu]);
Oe(`${pl}-${Pw}`, Ju, [yt, Di]);
Oe(`${pl}-${zw}`, Kg, [yt, Di]);
Oe(`${pl}-${Iw}`, If, [yt, Di]);
Oe(`${gd}-${Lw}`, Bf, [yt, Di]);
Oe(`${gd}-${Mu}`, jf, [yt, Di, Mu]);
Oe(`${gd}-${Pw}`, Qu, [yt, Di]);
Oe(`${gd}-${zw}`, Qg, [yt, Di]);
Oe(`${gd}-${Iw}`, Uf, [yt, Di]);
Oe(fA, Nf, [Q0, fA]);
Oe(EZ, Lf, Q0);
Oe(SZ, Pf, Q0);
Oe(_Z, BM, [J0, Q0]);
Oe(AZ, as, J0);
Oe(CZ, Bw, J0);
Oe(kZ, OZ, J0);
function zZ(e) {
  return sv.has(e);
}
function IZ(e, t) {
  const n = t[0], i = ae(t) - n;
  return function(r) {
    return e(n + r * i);
  };
}
function jM(e, t, n) {
  return Xu(UM(t || "rgb", n), e);
}
function BZ(e, t) {
  const n = new Array(t), i = t + 1;
  for (let r = 0; r < t; )
    n[r] = e(++r / i);
  return n;
}
function UM(e, t) {
  const n = Ug[jZ(e)];
  return t != null && n && n.gamma ? n.gamma(t) : n;
}
function jZ(e) {
  return "interpolate" + e.toLowerCase().split("-").map((t) => t[0].toUpperCase() + t.slice(1)).join("");
}
const UZ = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
}, qZ = {
  category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
  accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
  dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
  paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
  pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
  pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
  set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
  set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
  set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
};
function qM(e) {
  const t = e.length / 6 | 0, n = new Array(t);
  for (let i = 0; i < t; )
    n[i] = "#" + e.slice(i * 6, ++i * 6);
  return n;
}
function GM(e, t) {
  for (const n in e)
    WM(n, t(e[n]));
}
const dA = {};
GM(qZ, qM);
GM(UZ, (e) => jM(qM(e)));
function WM(e, t) {
  return e = e && e.toLowerCase(), arguments.length > 1 ? (dA[e] = t, this) : dA[e];
}
const GZ = "RawCode", zn = "Literal", WZ = "Property", HZ = "Identifier", VZ = "ArrayExpression", XZ = "BinaryExpression", HM = "CallExpression", YZ = "ConditionalExpression", KZ = "LogicalExpression", JZ = "MemberExpression", QZ = "ObjectExpression", ZZ = "UnaryExpression";
function Ni(e) {
  this.type = e;
}
Ni.prototype.visit = function(e) {
  let t, n, i;
  if (e(this))
    return 1;
  for (t = eee(this), n = 0, i = t.length; n < i; ++n)
    if (t[n].visit(e))
      return 1;
};
function eee(e) {
  switch (e.type) {
    case VZ:
      return e.elements;
    case XZ:
    case KZ:
      return [e.left, e.right];
    case HM:
      return [e.callee].concat(e.arguments);
    case YZ:
      return [e.test, e.consequent, e.alternate];
    case JZ:
      return [e.object, e.property];
    case QZ:
      return e.properties;
    case WZ:
      return [e.key, e.value];
    case ZZ:
      return [e.argument];
    case HZ:
    case zn:
    case GZ:
    default:
      return [];
  }
}
var xr, K, N, It, Se, Z0 = 1, md = 2, uo = 3, us = 4, em = 5, _o = 6, fn = 7, yd = 8, tee = 9;
xr = {};
xr[Z0] = "Boolean";
xr[md] = "<end>";
xr[uo] = "Identifier";
xr[us] = "Keyword";
xr[em] = "Null";
xr[_o] = "Numeric";
xr[fn] = "Punctuator";
xr[yd] = "String";
xr[tee] = "RegularExpression";
var nee = "ArrayExpression", iee = "BinaryExpression", ree = "CallExpression", aee = "ConditionalExpression", VM = "Identifier", see = "Literal", oee = "LogicalExpression", uee = "MemberExpression", lee = "ObjectExpression", cee = "Property", fee = "UnaryExpression", ft = "Unexpected token %0", dee = "Unexpected number", hee = "Unexpected string", pee = "Unexpected identifier", gee = "Unexpected reserved word", mee = "Unexpected end of input", ov = "Invalid regular expression", Z1 = "Invalid regular expression: missing /", XM = "Octal literals are not allowed in strict mode.", yee = "Duplicate data property in object literal not allowed in strict mode", wt = "ILLEGAL", lf = "Disabled.", bee = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]"), vee = new RegExp("[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]");
function tm(e, t) {
  if (!e)
    throw new Error("ASSERT: " + t);
}
function Lr(e) {
  return e >= 48 && e <= 57;
}
function jw(e) {
  return "0123456789abcdefABCDEF".indexOf(e) >= 0;
}
function Tc(e) {
  return "01234567".indexOf(e) >= 0;
}
function xee(e) {
  return e === 32 || e === 9 || e === 11 || e === 12 || e === 160 || e >= 5760 && [5760, 6158, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(e) >= 0;
}
function cf(e) {
  return e === 10 || e === 13 || e === 8232 || e === 8233;
}
function bd(e) {
  return e === 36 || e === 95 || // $ (dollar) and _ (underscore)
  e >= 65 && e <= 90 || // A..Z
  e >= 97 && e <= 122 || // a..z
  e === 92 || // \ (backslash)
  e >= 128 && bee.test(String.fromCharCode(e));
}
function ug(e) {
  return e === 36 || e === 95 || // $ (dollar) and _ (underscore)
  e >= 65 && e <= 90 || // A..Z
  e >= 97 && e <= 122 || // a..z
  e >= 48 && e <= 57 || // 0..9
  e === 92 || // \ (backslash)
  e >= 128 && vee.test(String.fromCharCode(e));
}
const $ee = {
  if: 1,
  in: 1,
  do: 1,
  var: 1,
  for: 1,
  new: 1,
  try: 1,
  let: 1,
  this: 1,
  else: 1,
  case: 1,
  void: 1,
  with: 1,
  enum: 1,
  while: 1,
  break: 1,
  catch: 1,
  throw: 1,
  const: 1,
  yield: 1,
  class: 1,
  super: 1,
  return: 1,
  typeof: 1,
  delete: 1,
  switch: 1,
  export: 1,
  import: 1,
  public: 1,
  static: 1,
  default: 1,
  finally: 1,
  extends: 1,
  package: 1,
  private: 1,
  function: 1,
  continue: 1,
  debugger: 1,
  interface: 1,
  protected: 1,
  instanceof: 1,
  implements: 1
};
function YM() {
  for (; N < It; ) {
    const e = K.charCodeAt(N);
    if (xee(e) || cf(e))
      ++N;
    else
      break;
  }
}
function uv(e) {
  var t, n, i, r = 0;
  for (n = e === "u" ? 4 : 2, t = 0; t < n; ++t)
    N < It && jw(K[N]) ? (i = K[N++], r = r * 16 + "0123456789abcdef".indexOf(i.toLowerCase())) : ve({}, ft, wt);
  return String.fromCharCode(r);
}
function wee() {
  var e, t, n, i;
  for (e = K[N], t = 0, e === "}" && ve({}, ft, wt); N < It && (e = K[N++], !!jw(e)); )
    t = t * 16 + "0123456789abcdef".indexOf(e.toLowerCase());
  return (t > 1114111 || e !== "}") && ve({}, ft, wt), t <= 65535 ? String.fromCharCode(t) : (n = (t - 65536 >> 10) + 55296, i = (t - 65536 & 1023) + 56320, String.fromCharCode(n, i));
}
function KM() {
  var e, t;
  for (e = K.charCodeAt(N++), t = String.fromCharCode(e), e === 92 && (K.charCodeAt(N) !== 117 && ve({}, ft, wt), ++N, e = uv("u"), (!e || e === "\\" || !bd(e.charCodeAt(0))) && ve({}, ft, wt), t = e); N < It && (e = K.charCodeAt(N), !!ug(e)); )
    ++N, t += String.fromCharCode(e), e === 92 && (t = t.substr(0, t.length - 1), K.charCodeAt(N) !== 117 && ve({}, ft, wt), ++N, e = uv("u"), (!e || e === "\\" || !ug(e.charCodeAt(0))) && ve({}, ft, wt), t += e);
  return t;
}
function Eee() {
  var e, t;
  for (e = N++; N < It; ) {
    if (t = K.charCodeAt(N), t === 92)
      return N = e, KM();
    if (ug(t))
      ++N;
    else
      break;
  }
  return K.slice(e, N);
}
function See() {
  var e, t, n;
  return e = N, t = K.charCodeAt(N) === 92 ? KM() : Eee(), t.length === 1 ? n = uo : $ee.hasOwnProperty(t) ? n = us : t === "null" ? n = em : t === "true" || t === "false" ? n = Z0 : n = uo, {
    type: n,
    value: t,
    start: e,
    end: N
  };
}
function ey() {
  var e = N, t = K.charCodeAt(N), n, i = K[N], r, a, s;
  switch (t) {
    case 46:
    case 40:
    case 41:
    case 59:
    case 44:
    case 123:
    case 125:
    case 91:
    case 93:
    case 58:
    case 63:
    case 126:
      return ++N, {
        type: fn,
        value: String.fromCharCode(t),
        start: e,
        end: N
      };
    default:
      if (n = K.charCodeAt(N + 1), n === 61)
        switch (t) {
          case 43:
          case 45:
          case 47:
          case 60:
          case 62:
          case 94:
          case 124:
          case 37:
          case 38:
          case 42:
            return N += 2, {
              type: fn,
              value: String.fromCharCode(t) + String.fromCharCode(n),
              start: e,
              end: N
            };
          case 33:
          case 61:
            return N += 2, K.charCodeAt(N) === 61 && ++N, {
              type: fn,
              value: K.slice(e, N),
              start: e,
              end: N
            };
        }
  }
  if (s = K.substr(N, 4), s === ">>>=")
    return N += 4, {
      type: fn,
      value: s,
      start: e,
      end: N
    };
  if (a = s.substr(0, 3), a === ">>>" || a === "<<=" || a === ">>=")
    return N += 3, {
      type: fn,
      value: a,
      start: e,
      end: N
    };
  if (r = a.substr(0, 2), i === r[1] && "+-<>&|".indexOf(i) >= 0 || r === "=>")
    return N += 2, {
      type: fn,
      value: r,
      start: e,
      end: N
    };
  if (r === "//" && ve({}, ft, wt), "<>=!+-*%&|^/".indexOf(i) >= 0)
    return ++N, {
      type: fn,
      value: i,
      start: e,
      end: N
    };
  ve({}, ft, wt);
}
function Aee(e) {
  let t = "";
  for (; N < It && jw(K[N]); )
    t += K[N++];
  return t.length === 0 && ve({}, ft, wt), bd(K.charCodeAt(N)) && ve({}, ft, wt), {
    type: _o,
    value: parseInt("0x" + t, 16),
    start: e,
    end: N
  };
}
function kee(e) {
  let t = "0" + K[N++];
  for (; N < It && Tc(K[N]); )
    t += K[N++];
  return (bd(K.charCodeAt(N)) || Lr(K.charCodeAt(N))) && ve({}, ft, wt), {
    type: _o,
    value: parseInt(t, 8),
    octal: !0,
    start: e,
    end: N
  };
}
function hA() {
  var e, t, n;
  if (n = K[N], tm(Lr(n.charCodeAt(0)) || n === ".", "Numeric literal must start with a decimal digit or a decimal point"), t = N, e = "", n !== ".") {
    if (e = K[N++], n = K[N], e === "0") {
      if (n === "x" || n === "X")
        return ++N, Aee(t);
      if (Tc(n))
        return kee(t);
      n && Lr(n.charCodeAt(0)) && ve({}, ft, wt);
    }
    for (; Lr(K.charCodeAt(N)); )
      e += K[N++];
    n = K[N];
  }
  if (n === ".") {
    for (e += K[N++]; Lr(K.charCodeAt(N)); )
      e += K[N++];
    n = K[N];
  }
  if (n === "e" || n === "E")
    if (e += K[N++], n = K[N], (n === "+" || n === "-") && (e += K[N++]), Lr(K.charCodeAt(N)))
      for (; Lr(K.charCodeAt(N)); )
        e += K[N++];
    else
      ve({}, ft, wt);
  return bd(K.charCodeAt(N)) && ve({}, ft, wt), {
    type: _o,
    value: parseFloat(e),
    start: t,
    end: N
  };
}
function Cee() {
  var e = "", t, n, i, r, a = !1;
  for (t = K[N], tm(t === "'" || t === '"', "String literal must starts with a quote"), n = N, ++N; N < It; )
    if (i = K[N++], i === t) {
      t = "";
      break;
    } else if (i === "\\")
      if (i = K[N++], !i || !cf(i.charCodeAt(0)))
        switch (i) {
          case "u":
          case "x":
            K[N] === "{" ? (++N, e += wee()) : e += uv(i);
            break;
          case "n":
            e += `
`;
            break;
          case "r":
            e += "\r";
            break;
          case "t":
            e += "	";
            break;
          case "b":
            e += "\b";
            break;
          case "f":
            e += "\f";
            break;
          case "v":
            e += "\v";
            break;
          default:
            Tc(i) ? (r = "01234567".indexOf(i), r !== 0 && (a = !0), N < It && Tc(K[N]) && (a = !0, r = r * 8 + "01234567".indexOf(K[N++]), "0123".indexOf(i) >= 0 && N < It && Tc(K[N]) && (r = r * 8 + "01234567".indexOf(K[N++]))), e += String.fromCharCode(r)) : e += i;
            break;
        }
      else
        i === "\r" && K[N] === `
` && ++N;
    else {
      if (cf(i.charCodeAt(0)))
        break;
      e += i;
    }
  return t !== "" && ve({}, ft, wt), {
    type: yd,
    value: e,
    octal: a,
    start: n,
    end: N
  };
}
function _ee(e, t) {
  let n = e;
  t.indexOf("u") >= 0 && (n = n.replace(/\\u\{([0-9a-fA-F]+)\}/g, (i, r) => {
    if (parseInt(r, 16) <= 1114111)
      return "x";
    ve({}, ov);
  }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, "x"));
  try {
    new RegExp(n);
  } catch {
    ve({}, ov);
  }
  try {
    return new RegExp(e, t);
  } catch {
    return null;
  }
}
function Fee() {
  var e, t, n, i, r;
  for (e = K[N], tm(e === "/", "Regular expression literal must start with a slash"), t = K[N++], n = !1, i = !1; N < It; )
    if (e = K[N++], t += e, e === "\\")
      e = K[N++], cf(e.charCodeAt(0)) && ve({}, Z1), t += e;
    else if (cf(e.charCodeAt(0)))
      ve({}, Z1);
    else if (n)
      e === "]" && (n = !1);
    else if (e === "/") {
      i = !0;
      break;
    } else
      e === "[" && (n = !0);
  return i || ve({}, Z1), r = t.substr(1, t.length - 2), {
    value: r,
    literal: t
  };
}
function Mee() {
  var e, t, n;
  for (t = "", n = ""; N < It && (e = K[N], !!ug(e.charCodeAt(0))); )
    ++N, e === "\\" && N < It ? ve({}, ft, wt) : (n += e, t += e);
  return n.search(/[^gimuy]/g) >= 0 && ve({}, ov, n), {
    value: n,
    literal: t
  };
}
function Oee() {
  var e, t, n, i;
  return Se = null, YM(), e = N, t = Fee(), n = Mee(), i = _ee(t.value, n.value), {
    literal: t.literal + n.literal,
    value: i,
    regex: {
      pattern: t.value,
      flags: n.value
    },
    start: e,
    end: N
  };
}
function Ree(e) {
  return e.type === uo || e.type === us || e.type === Z0 || e.type === em;
}
function JM() {
  if (YM(), N >= It)
    return {
      type: md,
      start: N,
      end: N
    };
  const e = K.charCodeAt(N);
  return bd(e) ? See() : e === 40 || e === 41 || e === 59 ? ey() : e === 39 || e === 34 ? Cee() : e === 46 ? Lr(K.charCodeAt(N + 1)) ? hA() : ey() : Lr(e) ? hA() : ey();
}
function pn() {
  const e = Se;
  return N = e.end, Se = JM(), N = e.end, e;
}
function QM() {
  const e = N;
  Se = JM(), N = e;
}
function Tee(e) {
  const t = new Ni(nee);
  return t.elements = e, t;
}
function pA(e, t, n) {
  const i = new Ni(e === "||" || e === "&&" ? oee : iee);
  return i.operator = e, i.left = t, i.right = n, i;
}
function Dee(e, t) {
  const n = new Ni(ree);
  return n.callee = e, n.arguments = t, n;
}
function Nee(e, t, n) {
  const i = new Ni(aee);
  return i.test = e, i.consequent = t, i.alternate = n, i;
}
function Uw(e) {
  const t = new Ni(VM);
  return t.name = e, t;
}
function mc(e) {
  const t = new Ni(see);
  return t.value = e.value, t.raw = K.slice(e.start, e.end), e.regex && (t.raw === "//" && (t.raw = "/(?:)/"), t.regex = e.regex), t;
}
function gA(e, t, n) {
  const i = new Ni(uee);
  return i.computed = e === "[", i.object = t, i.property = n, i.computed || (n.member = !0), i;
}
function Lee(e) {
  const t = new Ni(lee);
  return t.properties = e, t;
}
function mA(e, t, n) {
  const i = new Ni(cee);
  return i.key = t, i.value = n, i.kind = e, i;
}
function Pee(e, t) {
  const n = new Ni(fee);
  return n.operator = e, n.argument = t, n.prefix = !0, n;
}
function ve(e, t) {
  var n, i = Array.prototype.slice.call(arguments, 2), r = t.replace(/%(\d)/g, (a, s) => (tm(s < i.length, "Message reference must be in range"), i[s]));
  throw n = new Error(r), n.index = N, n.description = r, n;
}
function nm(e) {
  e.type === md && ve(e, mee), e.type === _o && ve(e, dee), e.type === yd && ve(e, hee), e.type === uo && ve(e, pee), e.type === us && ve(e, gee), ve(e, ft, e.value);
}
function Bt(e) {
  const t = pn();
  (t.type !== fn || t.value !== e) && nm(t);
}
function Pe(e) {
  return Se.type === fn && Se.value === e;
}
function ty(e) {
  return Se.type === us && Se.value === e;
}
function zee() {
  const e = [];
  for (N = Se.start, Bt("["); !Pe("]"); )
    Pe(",") ? (pn(), e.push(null)) : (e.push(lo()), Pe("]") || Bt(","));
  return pn(), Tee(e);
}
function yA() {
  N = Se.start;
  const e = pn();
  return e.type === yd || e.type === _o ? (e.octal && ve(e, XM), mc(e)) : Uw(e.value);
}
function Iee() {
  var e, t, n, i;
  if (N = Se.start, e = Se, e.type === uo)
    return n = yA(), Bt(":"), i = lo(), mA("init", n, i);
  if (e.type === md || e.type === fn)
    nm(e);
  else
    return t = yA(), Bt(":"), i = lo(), mA("init", t, i);
}
function Bee() {
  var e = [], t, n, i, r = {}, a = String;
  for (N = Se.start, Bt("{"); !Pe("}"); )
    t = Iee(), t.key.type === VM ? n = t.key.name : n = a(t.key.value), i = "$" + n, Object.prototype.hasOwnProperty.call(r, i) ? ve({}, yee) : r[i] = !0, e.push(t), Pe("}") || Bt(",");
  return Bt("}"), Lee(e);
}
function jee() {
  Bt("(");
  const e = qw();
  return Bt(")"), e;
}
const Uee = {
  if: 1
};
function qee() {
  var e, t, n;
  if (Pe("("))
    return jee();
  if (Pe("["))
    return zee();
  if (Pe("{"))
    return Bee();
  if (e = Se.type, N = Se.start, e === uo || Uee[Se.value])
    n = Uw(pn().value);
  else if (e === yd || e === _o)
    Se.octal && ve(Se, XM), n = mc(pn());
  else {
    if (e === us)
      throw new Error(lf);
    e === Z0 ? (t = pn(), t.value = t.value === "true", n = mc(t)) : e === em ? (t = pn(), t.value = null, n = mc(t)) : Pe("/") || Pe("/=") ? (n = mc(Oee()), QM()) : nm(pn());
  }
  return n;
}
function Gee() {
  const e = [];
  if (Bt("("), !Pe(")"))
    for (; N < It && (e.push(lo()), !Pe(")")); )
      Bt(",");
  return Bt(")"), e;
}
function Wee() {
  N = Se.start;
  const e = pn();
  return Ree(e) || nm(e), Uw(e.value);
}
function Hee() {
  return Bt("."), Wee();
}
function Vee() {
  Bt("[");
  const e = qw();
  return Bt("]"), e;
}
function Xee() {
  var e, t, n;
  for (e = qee(); ; )
    if (Pe("."))
      n = Hee(), e = gA(".", e, n);
    else if (Pe("("))
      t = Gee(), e = Dee(e, t);
    else if (Pe("["))
      n = Vee(), e = gA("[", e, n);
    else
      break;
  return e;
}
function bA() {
  const e = Xee();
  if (Se.type === fn && (Pe("++") || Pe("--")))
    throw new Error(lf);
  return e;
}
function Xh() {
  var e, t;
  if (Se.type !== fn && Se.type !== us)
    t = bA();
  else {
    if (Pe("++") || Pe("--"))
      throw new Error(lf);
    if (Pe("+") || Pe("-") || Pe("~") || Pe("!"))
      e = pn(), t = Xh(), t = Pee(e.value, t);
    else {
      if (ty("delete") || ty("void") || ty("typeof"))
        throw new Error(lf);
      t = bA();
    }
  }
  return t;
}
function vA(e) {
  let t = 0;
  if (e.type !== fn && e.type !== us)
    return 0;
  switch (e.value) {
    case "||":
      t = 1;
      break;
    case "&&":
      t = 2;
      break;
    case "|":
      t = 3;
      break;
    case "^":
      t = 4;
      break;
    case "&":
      t = 5;
      break;
    case "==":
    case "!=":
    case "===":
    case "!==":
      t = 6;
      break;
    case "<":
    case ">":
    case "<=":
    case ">=":
    case "instanceof":
    case "in":
      t = 7;
      break;
    case "<<":
    case ">>":
    case ">>>":
      t = 8;
      break;
    case "+":
    case "-":
      t = 9;
      break;
    case "*":
    case "/":
    case "%":
      t = 11;
      break;
  }
  return t;
}
function Yee() {
  var e, t, n, i, r, a, s, o, u, l;
  if (e = Se, u = Xh(), i = Se, r = vA(i), r === 0)
    return u;
  for (i.prec = r, pn(), t = [e, Se], s = Xh(), a = [u, i, s]; (r = vA(Se)) > 0; ) {
    for (; a.length > 2 && r <= a[a.length - 2].prec; )
      s = a.pop(), o = a.pop().value, u = a.pop(), t.pop(), n = pA(o, u, s), a.push(n);
    i = pn(), i.prec = r, a.push(i), t.push(Se), n = Xh(), a.push(n);
  }
  for (l = a.length - 1, n = a[l], t.pop(); l > 1; )
    t.pop(), n = pA(a[l - 1].value, a[l - 2], n), l -= 2;
  return n;
}
function lo() {
  var e, t, n;
  return e = Yee(), Pe("?") && (pn(), t = lo(), Bt(":"), n = lo(), e = Nee(e, t, n)), e;
}
function qw() {
  const e = lo();
  if (Pe(","))
    throw new Error(lf);
  return e;
}
function Gw(e) {
  K = e, N = 0, It = K.length, Se = null, QM();
  const t = qw();
  if (Se.type !== md)
    throw new Error("Unexpect token after expression.");
  return t;
}
var Ww = {
  NaN: "NaN",
  E: "Math.E",
  LN2: "Math.LN2",
  LN10: "Math.LN10",
  LOG2E: "Math.LOG2E",
  LOG10E: "Math.LOG10E",
  PI: "Math.PI",
  SQRT1_2: "Math.SQRT1_2",
  SQRT2: "Math.SQRT2",
  MIN_VALUE: "Number.MIN_VALUE",
  MAX_VALUE: "Number.MAX_VALUE"
};
function Hw(e) {
  function t(s, o, u, l) {
    let c = e(o[0]);
    return u && (c = u + "(" + c + ")", u.lastIndexOf("new ", 0) === 0 && (c = "(" + c + ")")), c + "." + s + (l < 0 ? "" : l === 0 ? "()" : "(" + o.slice(1).map(e).join(",") + ")");
  }
  function n(s, o, u) {
    return (l) => t(s, l, o, u);
  }
  const i = "new Date", r = "String", a = "RegExp";
  return {
    // MATH functions
    isNaN: "Number.isNaN",
    isFinite: "Number.isFinite",
    abs: "Math.abs",
    acos: "Math.acos",
    asin: "Math.asin",
    atan: "Math.atan",
    atan2: "Math.atan2",
    ceil: "Math.ceil",
    cos: "Math.cos",
    exp: "Math.exp",
    floor: "Math.floor",
    hypot: "Math.hypot",
    log: "Math.log",
    max: "Math.max",
    min: "Math.min",
    pow: "Math.pow",
    random: "Math.random",
    round: "Math.round",
    sin: "Math.sin",
    sqrt: "Math.sqrt",
    tan: "Math.tan",
    clamp: function(s) {
      s.length < 3 && D("Missing arguments to clamp function."), s.length > 3 && D("Too many arguments to clamp function.");
      const o = s.map(e);
      return "Math.max(" + o[1] + ", Math.min(" + o[2] + "," + o[0] + "))";
    },
    // DATE functions
    now: "Date.now",
    utc: "Date.UTC",
    datetime: i,
    date: n("getDate", i, 0),
    day: n("getDay", i, 0),
    year: n("getFullYear", i, 0),
    month: n("getMonth", i, 0),
    hours: n("getHours", i, 0),
    minutes: n("getMinutes", i, 0),
    seconds: n("getSeconds", i, 0),
    milliseconds: n("getMilliseconds", i, 0),
    time: n("getTime", i, 0),
    timezoneoffset: n("getTimezoneOffset", i, 0),
    utcdate: n("getUTCDate", i, 0),
    utcday: n("getUTCDay", i, 0),
    utcyear: n("getUTCFullYear", i, 0),
    utcmonth: n("getUTCMonth", i, 0),
    utchours: n("getUTCHours", i, 0),
    utcminutes: n("getUTCMinutes", i, 0),
    utcseconds: n("getUTCSeconds", i, 0),
    utcmilliseconds: n("getUTCMilliseconds", i, 0),
    // sequence functions
    length: n("length", null, -1),
    // STRING functions
    parseFloat: "parseFloat",
    parseInt: "parseInt",
    upper: n("toUpperCase", r, 0),
    lower: n("toLowerCase", r, 0),
    substring: n("substring", r),
    split: n("split", r),
    trim: n("trim", r, 0),
    // REGEXP functions
    regexp: a,
    test: n("test", a),
    // Control Flow functions
    if: function(s) {
      s.length < 3 && D("Missing arguments to if function."), s.length > 3 && D("Too many arguments to if function.");
      const o = s.map(e);
      return "(" + o[0] + "?" + o[1] + ":" + o[2] + ")";
    }
  };
}
function Kee(e) {
  const t = e && e.length - 1;
  return t && (e[0] === '"' && e[t] === '"' || e[0] === "'" && e[t] === "'") ? e.slice(1, -1) : e;
}
function Vw(e) {
  e = e || {};
  const t = e.allowed ? an(e.allowed) : {}, n = e.forbidden ? an(e.forbidden) : {}, i = e.constants || Ww, r = (e.functions || Hw)(f), a = e.globalvar, s = e.fieldvar, o = oe(a) ? a : (p) => `${a}["${p}"]`;
  let u = {}, l = {}, c = 0;
  function f(p) {
    if (V(p))
      return p;
    const g = d[p.type];
    return g == null && D("Unsupported type: " + p.type), g(p);
  }
  const d = {
    Literal: (p) => p.raw,
    Identifier: (p) => {
      const g = p.name;
      return c > 0 ? g : Y(n, g) ? D("Illegal identifier: " + g) : Y(i, g) ? i[g] : Y(t, g) ? g : (u[g] = 1, o(g));
    },
    MemberExpression: (p) => {
      const g = !p.computed, m = f(p.object);
      g && (c += 1);
      const y = f(p.property);
      return m === s && (l[Kee(y)] = 1), g && (c -= 1), m + (g ? "." + y : "[" + y + "]");
    },
    CallExpression: (p) => {
      p.callee.type !== "Identifier" && D("Illegal callee type: " + p.callee.type);
      const g = p.callee.name, m = p.arguments, y = Y(r, g) && r[g];
      return y || D("Unrecognized function: " + g), oe(y) ? y(m) : y + "(" + m.map(f).join(",") + ")";
    },
    ArrayExpression: (p) => "[" + p.elements.map(f).join(",") + "]",
    BinaryExpression: (p) => "(" + f(p.left) + " " + p.operator + " " + f(p.right) + ")",
    UnaryExpression: (p) => "(" + p.operator + f(p.argument) + ")",
    ConditionalExpression: (p) => "(" + f(p.test) + "?" + f(p.consequent) + ":" + f(p.alternate) + ")",
    LogicalExpression: (p) => "(" + f(p.left) + p.operator + f(p.right) + ")",
    ObjectExpression: (p) => "{" + p.properties.map(f).join(",") + "}",
    Property: (p) => {
      c += 1;
      const g = f(p.key);
      return c -= 1, g + ":" + f(p.value);
    }
  };
  function h(p) {
    const g = {
      code: f(p),
      globals: Object.keys(u),
      fields: Object.keys(l)
    };
    return u = {}, l = {}, g;
  }
  return h.functions = r, h.constants = i, h;
}
function ny(e, t) {
  return e == null || t == null ? NaN : e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function Jee(e, t) {
  return e == null || t == null ? NaN : t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
}
function Qee(e) {
  let t, n, i;
  e.length !== 2 ? (t = ny, n = (o, u) => ny(e(o), u), i = (o, u) => e(o) - u) : (t = e === ny || e === Jee ? e : Zee, n = e, i = e);
  function r(o, u, l = 0, c = o.length) {
    if (l < c) {
      if (t(u, u) !== 0)
        return c;
      do {
        const f = l + c >>> 1;
        n(o[f], u) < 0 ? l = f + 1 : c = f;
      } while (l < c);
    }
    return l;
  }
  function a(o, u, l = 0, c = o.length) {
    if (l < c) {
      if (t(u, u) !== 0)
        return c;
      do {
        const f = l + c >>> 1;
        n(o[f], u) <= 0 ? l = f + 1 : c = f;
      } while (l < c);
    }
    return l;
  }
  function s(o, u, l = 0, c = o.length) {
    const f = r(o, u, l, c - 1);
    return f > l && i(o[f - 1], u) > -i(o[f], u) ? f - 1 : f;
  }
  return { left: r, center: s, right: a };
}
function Zee() {
  return 0;
}
function ete(e, ...t) {
  e = new Ba(e), t = t.map(tte);
  e:
    for (const n of e)
      for (const i of t)
        if (!i.has(n)) {
          e.delete(n);
          continue e;
        }
  return e;
}
function tte(e) {
  return e instanceof Ba ? e : new Ba(e);
}
function nte(...e) {
  const t = new Ba();
  for (const n of e)
    for (const i of n)
      t.add(i);
  return t;
}
const Xw = "intersect", xA = "union", ite = "vlMulti", rte = "vlPoint", $A = "or", ate = "and", Ji = "_vgsid_", ff = At(Ji), ste = "E", ote = "R", ute = "R-E", lte = "R-LE", cte = "R-RE", lg = "index:unit";
function wA(e, t) {
  for (var n = t.fields, i = t.values, r = n.length, a = 0, s, o; a < r; ++a)
    if (o = n[a], o.getter = At.getter || At(o.field), s = o.getter(e), Kn(s) && (s = Fe(s)), Kn(i[a]) && (i[a] = Fe(i[a])), Kn(i[a][0]) && (i[a] = i[a].map(Fe)), o.type === ste) {
      if (R(i[a]) ? i[a].indexOf(s) < 0 : s !== i[a])
        return !1;
    } else if (o.type === ote) {
      if (!bi(s, i[a]))
        return !1;
    } else if (o.type === cte) {
      if (!bi(s, i[a], !0, !1))
        return !1;
    } else if (o.type === ute) {
      if (!bi(s, i[a], !1, !1))
        return !1;
    } else if (o.type === lte && !bi(s, i[a], !1, !0))
      return !1;
  return !0;
}
function fte(e, t, n) {
  for (var i = this.context.data[e], r = i ? i.values.value : [], a = i ? i[lg] && i[lg].value : void 0, s = n === Xw, o = r.length, u = 0, l, c, f, d, h; u < o; ++u)
    if (l = r[u], a && s) {
      if (c = c || {}, f = c[d = l.unit] || 0, f === -1)
        continue;
      if (h = wA(t, l), c[d] = h ? -1 : ++f, h && a.size === 1)
        return !0;
      if (!h && f === a.get(d).count)
        return !1;
    } else if (h = wA(t, l), s ^ h)
      return h;
  return o && s;
}
const ZM = Qee(ff), dte = ZM.left, hte = ZM.right;
function pte(e, t, n) {
  const i = this.context.data[e], r = i ? i.values.value : [], a = i ? i[lg] && i[lg].value : void 0, s = n === Xw, o = ff(t), u = dte(r, o);
  if (u === r.length || ff(r[u]) !== o)
    return !1;
  if (a && s) {
    if (a.size === 1)
      return !0;
    if (hte(r, o) - u < a.size)
      return !1;
  }
  return !0;
}
function gte(e, t) {
  return e.map((n) => ue(t.fields ? {
    values: t.fields.map((i) => (i.getter || (i.getter = At(i.field)))(n.datum))
  } : {
    [Ji]: ff(n.datum)
  }, t));
}
function mte(e, t, n, i) {
  for (var r = this.context.data[e], a = r ? r.values.value : [], s = {}, o = {}, u = {}, l, c, f, d, h, p, g, m, y, b, v = a.length, x = 0, w, E; x < v; ++x)
    if (l = a[x], d = l.unit, c = l.fields, f = l.values, c && f) {
      for (w = 0, E = c.length; w < E; ++w)
        h = c[w], g = s[h.field] || (s[h.field] = {}), m = g[d] || (g[d] = []), u[h.field] = y = h.type.charAt(0), b = iy[`${y}_union`], g[d] = b(m, G(f[w]));
      n && (m = o[d] || (o[d] = []), m.push(G(f).reduce(($, S, A) => ($[c[A].field] = S, $), {})));
    } else
      h = Ji, p = ff(l), g = s[h] || (s[h] = {}), m = g[d] || (g[d] = []), m.push(p), n && (m = o[d] || (o[d] = []), m.push({
        [Ji]: p
      }));
  if (t = t || xA, s[Ji] ? s[Ji] = iy[`${Ji}_${t}`](...Object.values(s[Ji])) : Object.keys(s).forEach(($) => {
    s[$] = Object.keys(s[$]).map((S) => s[$][S]).reduce((S, A) => S === void 0 ? A : iy[`${u[$]}_${t}`](S, A));
  }), a = Object.keys(o), n && a.length) {
    const $ = i ? rte : ite;
    s[$] = t === xA ? {
      [$A]: a.reduce((S, A) => (S.push(...o[A]), S), [])
    } : {
      [ate]: a.map((S) => ({
        [$A]: o[S]
      }))
    };
  }
  return s;
}
var iy = {
  [`${Ji}_union`]: nte,
  [`${Ji}_intersect`]: ete,
  E_union: function(e, t) {
    if (!e.length)
      return t;
    for (var n = 0, i = t.length; n < i; ++n)
      e.indexOf(t[n]) < 0 && e.push(t[n]);
    return e;
  },
  E_intersect: function(e, t) {
    return e.length ? e.filter((n) => t.indexOf(n) >= 0) : t;
  },
  R_union: function(e, t) {
    var n = Fe(t[0]), i = Fe(t[1]);
    return n > i && (n = t[1], i = t[0]), e.length ? (e[0] > n && (e[0] = n), e[1] < i && (e[1] = i), e) : [n, i];
  },
  R_intersect: function(e, t) {
    var n = Fe(t[0]), i = Fe(t[1]);
    return n > i && (n = t[1], i = t[0]), e.length ? i < e[0] || e[1] < n ? [] : (e[0] < n && (e[0] = n), e[1] > i && (e[1] = i), e) : [n, i];
  }
};
const yte = ":", bte = "@";
function Yw(e, t, n, i) {
  t[0].type !== zn && D("First argument to selection functions must be a string literal.");
  const r = t[0].value, a = t.length >= 2 && ae(t).value, s = "unit", o = bte + s, u = yte + r;
  a === Xw && !Y(i, o) && (i[o] = n.getData(r).indataRef(n, s)), Y(i, u) || (i[u] = n.getData(r).tuplesRef());
}
function eO(e) {
  const t = this.context.data[e];
  return t ? t.values.value : [];
}
function vte(e, t, n) {
  const i = this.context.data[e]["index:" + t], r = i ? i.value.get(n) : void 0;
  return r && r.count;
}
function xte(e, t) {
  const n = this.context.dataflow, i = this.context.data[e], r = i.input;
  return n.pulse(r, n.changeset().remove(jt).insert(t)), 1;
}
function $te(e, t, n) {
  if (e) {
    const i = this.context.dataflow, r = e.mark.source;
    i.pulse(r, i.changeset().encode(e, t));
  }
  return n !== void 0 ? n : e;
}
const vd = (e) => function(t, n) {
  return this.context.dataflow.locale()[e](n)(t);
}, wte = vd("format"), tO = vd("timeFormat"), Ete = vd("utcFormat"), Ste = vd("timeParse"), Ate = vd("utcParse"), uh = new Date(2e3, 0, 1);
function im(e, t, n) {
  return !Number.isInteger(e) || !Number.isInteger(t) ? "" : (uh.setYear(2e3), uh.setMonth(e), uh.setDate(t), tO.call(this, uh, n));
}
function kte(e) {
  return im.call(this, e, 1, "%B");
}
function Cte(e) {
  return im.call(this, e, 1, "%b");
}
function _te(e) {
  return im.call(this, 0, 2 + e, "%A");
}
function Fte(e) {
  return im.call(this, 0, 2 + e, "%a");
}
const Mte = ":", Ote = "@", lv = "%", Rte = "$";
function Kw(e, t, n, i) {
  t[0].type !== zn && D("First argument to data functions must be a string literal.");
  const r = t[0].value, a = Mte + r;
  if (!Y(a, i))
    try {
      i[a] = n.getData(r).tuplesRef();
    } catch {
    }
}
function Tte(e, t, n, i) {
  t[0].type !== zn && D("First argument to indata must be a string literal."), t[1].type !== zn && D("Second argument to indata must be a string literal.");
  const r = t[0].value, a = t[1].value, s = Ote + a;
  Y(s, i) || (i[s] = n.getData(r).indataRef(n, a));
}
function gn(e, t, n, i) {
  if (t[0].type === zn)
    EA(n, i, t[0].value);
  else
    for (e in n.scales)
      EA(n, i, e);
}
function EA(e, t, n) {
  const i = lv + n;
  if (!Y(t, i))
    try {
      t[i] = e.scaleRef(n);
    } catch {
    }
}
function ia(e, t) {
  if (oe(e))
    return e;
  if (V(e)) {
    const n = t.scales[e];
    return n && AC(n.value) ? n.value : void 0;
  }
}
function Dte(e, t, n) {
  t.__bandwidth = (r) => r && r.bandwidth ? r.bandwidth() : 0, n._bandwidth = gn, n._range = gn, n._scale = gn;
  const i = (r) => "_[" + (r.type === zn ? U(lv + r.value) : U(lv) + "+" + e(r)) + "]";
  return {
    _bandwidth: (r) => `this.__bandwidth(${i(r[0])})`,
    _range: (r) => `${i(r[0])}.range()`,
    _scale: (r) => `${i(r[0])}(${e(r[1])})`
  };
}
function Jw(e, t) {
  return function(n, i, r) {
    if (n) {
      const a = ia(n, (r || this).context);
      return a && a.path[e](i);
    } else
      return t(i);
  };
}
const Nte = Jw("area", Vk), Lte = Jw("bounds", Qk), Pte = Jw("centroid", n9);
function zte(e) {
  const t = this.context.group;
  let n = !1;
  if (t)
    for (; e; ) {
      if (e === t) {
        n = !0;
        break;
      }
      e = e.mark.group;
    }
  return n;
}
function Qw(e, t, n) {
  try {
    e[t].apply(e, ["EXPRESSION"].concat([].slice.call(n)));
  } catch (i) {
    e.warn(i);
  }
  return n[n.length - 1];
}
function Ite() {
  return Qw(this.context.dataflow, "warn", arguments);
}
function Bte() {
  return Qw(this.context.dataflow, "info", arguments);
}
function jte() {
  return Qw(this.context.dataflow, "debug", arguments);
}
function ry(e) {
  const t = e / 255;
  return t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
}
function cv(e) {
  const t = mu(e), n = ry(t.r), i = ry(t.g), r = ry(t.b);
  return 0.2126 * n + 0.7152 * i + 0.0722 * r;
}
function Ute(e, t) {
  const n = cv(e), i = cv(t), r = Math.max(n, i), a = Math.min(n, i);
  return (r + 0.05) / (a + 0.05);
}
function qte() {
  const e = [].slice.call(arguments);
  return e.unshift({}), ue(...e);
}
function nO(e, t) {
  return e === t || e !== e && t !== t ? !0 : R(e) ? R(t) && e.length === t.length ? Gte(e, t) : !1 : X(e) && X(t) ? iO(e, t) : !1;
}
function Gte(e, t) {
  for (let n = 0, i = e.length; n < i; ++n)
    if (!nO(e[n], t[n]))
      return !1;
  return !0;
}
function iO(e, t) {
  for (const n in e)
    if (!nO(e[n], t[n]))
      return !1;
  return !0;
}
function SA(e) {
  return (t) => iO(e, t);
}
function Wte(e, t, n, i, r, a) {
  const s = this.context.dataflow, o = this.context.data[e], u = o.input, l = s.stamp();
  let c = o.changes, f, d;
  if (s._trigger === !1 || !(u.value.length || t || i))
    return 0;
  if ((!c || c.stamp < l) && (o.changes = c = s.changeset(), c.stamp = l, s.runAfter(() => {
    o.modified = !0, s.pulse(u, c).run();
  }, !0, 1)), n && (f = n === !0 ? jt : R(n) || ol(n) ? n : SA(n), c.remove(f)), t && c.insert(t), i && (f = SA(i), u.value.some(f) ? c.remove(f) : c.insert(i)), r)
    for (d in a)
      c.modify(r, d, a[d]);
  return 1;
}
function Hte(e) {
  const t = e.touches, n = t[0].clientX - t[1].clientX, i = t[0].clientY - t[1].clientY;
  return Math.hypot(n, i);
}
function Vte(e) {
  const t = e.touches;
  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
}
const AA = {};
function Xte(e, t) {
  const n = AA[t] || (AA[t] = At(t));
  return R(e) ? e.map(n) : n(e);
}
function Zw(e) {
  return R(e) || ArrayBuffer.isView(e) ? e : null;
}
function eE(e) {
  return Zw(e) || (V(e) ? e : null);
}
function Yte(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return Zw(e).join(...n);
}
function Kte(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return eE(e).indexOf(...n);
}
function Jte(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return eE(e).lastIndexOf(...n);
}
function Qte(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return eE(e).slice(...n);
}
function Zte(e, t, n) {
  return oe(n) && D("Function argument passed to replace."), String(e).replace(t, n);
}
function ene(e) {
  return Zw(e).slice().reverse();
}
function tne(e, t, n) {
  return C0(e || 0, t || 0, n || 0);
}
function nne(e, t) {
  const n = ia(e, (t || this).context);
  return n && n.bandwidth ? n.bandwidth() : 0;
}
function ine(e, t) {
  const n = ia(e, (t || this).context);
  return n ? n.copy() : void 0;
}
function rne(e, t) {
  const n = ia(e, (t || this).context);
  return n ? n.domain() : [];
}
function ane(e, t, n) {
  const i = ia(e, (n || this).context);
  return i ? R(t) ? (i.invertRange || i.invert)(t) : (i.invert || i.invertExtent)(t) : void 0;
}
function sne(e, t) {
  const n = ia(e, (t || this).context);
  return n && n.range ? n.range() : [];
}
function one(e, t, n) {
  const i = ia(e, (n || this).context);
  return i ? i(t) : void 0;
}
function une(e, t, n, i, r) {
  e = ia(e, (r || this).context);
  const a = UC(t, n);
  let s = e.domain(), o = s[0], u = ae(s), l = kt;
  return u - o ? l = qx(e, o, u) : e = (e.interpolator ? be("sequential")().interpolator(e.interpolator()) : be("linear")().interpolate(e.interpolate()).range(e.range())).domain([o = 0, u = 1]), e.ticks && (s = e.ticks(+i || 15), o !== s[0] && s.unshift(o), u !== ae(s) && s.push(u)), s.forEach((c) => a.stop(l(c), e(c))), a;
}
function lne(e, t, n) {
  const i = ia(e, (n || this).context);
  return function(r) {
    return i ? i.path.context(r)(t) : "";
  };
}
function cne(e) {
  let t = null;
  return function(n) {
    return n ? Kc(n, t = t || O0(e)) : e;
  };
}
const rO = (e) => e.data;
function aO(e, t) {
  const n = eO.call(t, e);
  return n.root && n.root.lookup || {};
}
function fne(e, t, n) {
  const i = aO(e, this), r = i[t], a = i[n];
  return r && a ? r.path(a).map(rO) : void 0;
}
function dne(e, t) {
  const n = aO(e, this)[t];
  return n ? n.ancestors().map(rO) : void 0;
}
const sO = () => typeof window < "u" && window || null;
function hne() {
  const e = sO();
  return e ? e.screen : {};
}
function pne() {
  const e = sO();
  return e ? [e.innerWidth, e.innerHeight] : [void 0, void 0];
}
function gne() {
  const e = this.context.dataflow, t = e.container && e.container();
  return t ? [t.clientWidth, t.clientHeight] : [void 0, void 0];
}
function oO(e, t, n) {
  if (!e)
    return [];
  const [i, r] = e, a = new Ye().set(i[0], i[1], r[0], r[1]), s = n || this.context.dataflow.scenegraph().root;
  return D_(s, a, mne(t));
}
function mne(e) {
  let t = null;
  if (e) {
    const n = G(e.marktype), i = G(e.markname);
    t = (r) => (!n.length || n.some((a) => r.marktype === a)) && (!i.length || i.some((a) => r.name === a));
  }
  return t;
}
function yne(e, t, n) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5;
  e = G(e);
  const r = e[e.length - 1];
  return r === void 0 || Math.hypot(r[0] - t, r[1] - n) > i ? [...e, [t, n]] : e;
}
function bne(e) {
  return G(e).reduce((t, n, i) => {
    let [r, a] = n;
    return t += i == 0 ? `M ${r},${a} ` : i === e.length - 1 ? " Z" : `L ${r},${a} `;
  }, "");
}
function vne(e, t, n) {
  const {
    x: i,
    y: r,
    mark: a
  } = n, s = new Ye().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
  for (const [u, l] of t)
    u < s.x1 && (s.x1 = u), u > s.x2 && (s.x2 = u), l < s.y1 && (s.y1 = l), l > s.y2 && (s.y2 = l);
  return s.translate(i, r), oO([[s.x1, s.y1], [s.x2, s.y2]], e, a).filter((u) => xne(u.x, u.y, t));
}
function xne(e, t, n) {
  let i = 0;
  for (let r = 0, a = n.length - 1; r < n.length; a = r++) {
    const [s, o] = n[a], [u, l] = n[r];
    l > t != o > t && e < (s - u) * (t - l) / (o - l) + u && i++;
  }
  return i & 1;
}
const df = {
  random() {
    return Pn();
  },
  // override default
  cumulativeNormal: Wf,
  cumulativeLogNormal: b0,
  cumulativeUniform: w0,
  densityNormal: g0,
  densityLogNormal: y0,
  densityUniform: $0,
  quantileNormal: Hf,
  quantileLogNormal: v0,
  quantileUniform: E0,
  sampleNormal: Gf,
  sampleLogNormal: m0,
  sampleUniform: x0,
  isArray: R,
  isBoolean: Zr,
  isDate: Kn,
  isDefined(e) {
    return e !== void 0;
  },
  isNumber: ye,
  isObject: X,
  isRegExp: D2,
  isString: V,
  isTuple: ol,
  isValid(e) {
    return e != null && e === e;
  },
  toBoolean: o0,
  toDate(e) {
    return u0(e);
  },
  // suppress extra arguments
  toNumber: Fe,
  toString: l0,
  indexof: Kte,
  join: Yte,
  lastindexof: Jte,
  replace: Zte,
  reverse: ene,
  slice: Qte,
  flush: T2,
  lerp: L2,
  merge: qte,
  pad: z2,
  peek: ae,
  pluck: Xte,
  span: il,
  inrange: bi,
  truncate: I2,
  rgb: mu,
  lab: tp,
  hcl: lk,
  hsl: np,
  luminance: cv,
  contrast: Ute,
  sequence: xt,
  format: wte,
  utcFormat: Ete,
  utcParse: Ate,
  utcOffset: Y2,
  utcSequence: J2,
  timeFormat: tO,
  timeParse: Ste,
  timeOffset: X2,
  timeSequence: K2,
  timeUnitSpecifier: U2,
  monthFormat: kte,
  monthAbbrevFormat: Cte,
  dayFormat: _te,
  dayAbbrevFormat: Fte,
  quarter: _2,
  utcquarter: F2,
  week: W2,
  utcweek: V2,
  dayofyear: G2,
  utcdayofyear: H2,
  warn: Ite,
  info: Bte,
  debug: jte,
  extent(e) {
    return Ci(e);
  },
  // suppress extra arguments
  inScope: zte,
  intersect: oO,
  clampRange: M2,
  pinchDistance: Hte,
  pinchAngle: Vte,
  screen: hne,
  containerSize: gne,
  windowSize: pne,
  bandspace: tne,
  setdata: xte,
  pathShape: cne,
  panLinear: S2,
  panLog: A2,
  panPow: k2,
  panSymlog: C2,
  zoomLinear: i0,
  zoomLog: r0,
  zoomPow: Wc,
  zoomSymlog: a0,
  encode: $te,
  modify: Wte,
  lassoAppend: yne,
  lassoPath: bne,
  intersectLasso: vne
}, $ne = ["view", "item", "group", "xy", "x", "y"], wne = "event.vega.", uO = "this.", tE = {}, Ene = {
  forbidden: ["_"],
  allowed: ["datum", "event", "item"],
  fieldvar: "datum",
  globalvar: (e) => `_[${U(Rte + e)}]`,
  functions: Sne,
  constants: Ww,
  visitors: tE
}, kA = Vw(Ene);
function Sne(e) {
  const t = Hw(e);
  $ne.forEach((n) => t[n] = wne + n);
  for (const n in df)
    t[n] = uO + n;
  return ue(t, Dte(e, df, tE)), t;
}
function st(e, t, n) {
  return arguments.length === 1 ? df[e] : (df[e] = t, n && (tE[e] = n), kA && (kA.functions[e] = uO + e), this);
}
st("bandwidth", nne, gn);
st("copy", ine, gn);
st("domain", rne, gn);
st("range", sne, gn);
st("invert", ane, gn);
st("scale", one, gn);
st("gradient", une, gn);
st("geoArea", Nte, gn);
st("geoBounds", Lte, gn);
st("geoCentroid", Pte, gn);
st("geoShape", lne, gn);
st("indata", vte, Tte);
st("data", eO, Kw);
st("treePath", fne, Kw);
st("treeAncestors", dne, Kw);
st("vlSelectionTest", fte, Yw);
st("vlSelectionIdTest", pte, Yw);
st("vlSelectionResolve", mte, Yw);
st("vlSelectionTuples", gte);
function Ane(e) {
  const t = this, n = e.operators || [];
  return e.background && (t.background = e.background), e.eventConfig && (t.eventConfig = e.eventConfig), e.locale && (t.locale = e.locale), n.forEach((i) => t.parseOperator(i)), n.forEach((i) => t.parseOperatorParameters(i)), (e.streams || []).forEach((i) => t.parseStream(i)), (e.updates || []).forEach((i) => t.parseUpdate(i)), t.resolve();
}
const kne = an(["rule"]), CA = an(["group", "image", "rect"]);
function Cne(e, t) {
  let n = "";
  return kne[t] || (e.x2 && (e.x ? (CA[t] && (n += "if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;"), n += "o.width=o.x2-o.x;") : n += "o.x=o.x2-(o.width||0);"), e.xc && (n += "o.x=o.xc-(o.width||0)/2;"), e.y2 && (e.y ? (CA[t] && (n += "if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;"), n += "o.height=o.y2-o.y;") : n += "o.y=o.y2-(o.height||0);"), e.yc && (n += "o.y=o.yc-(o.height||0)/2;")), n;
}
function nE(e) {
  return (e + "").toLowerCase();
}
function _ne(e) {
  return nE(e) === "operator";
}
function Fne(e) {
  return nE(e) === "collect";
}
function Il(e, t, n) {
  n.endsWith(";") || (n = "return(" + n + ");");
  const i = Function(...t.concat(n));
  return e && e.functions ? i.bind(e.functions) : i;
}
function Mne(e, t, n, i) {
  return `((u = ${e}) < (v = ${t}) || u == null) && v != null ? ${n}
  : (u > v || v == null) && u != null ? ${i}
  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${n}
  : v !== v && u === u ? ${i} : `;
}
var One = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator: (e, t) => Il(e, ["_"], t.code),
  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter: (e, t) => Il(e, ["datum", "_"], t.code),
  /**
   * Parse an expression applied to an event stream.
   */
  event: (e, t) => Il(e, ["event"], t.code),
  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler: (e, t) => {
    const n = `var datum=event.item&&event.item.datum;return ${t.code};`;
    return Il(e, ["_", "event"], n);
  },
  /**
   * Parse an expression that performs visual encoding.
   */
  encode: (e, t) => {
    const {
      marktype: n,
      channels: i
    } = t;
    let r = "var o=item,datum=o.datum,m=0,$;";
    for (const a in i) {
      const s = "o[" + U(a) + "]";
      r += `$=${i[a].code};if(${s}!==$)${s}=$,m=1;`;
    }
    return r += Cne(i, n), r += "return m;", Il(e, ["item", "_"], r);
  },
  /**
   * Optimized code generators for access and comparison.
   */
  codegen: {
    get(e) {
      const t = `[${e.map(U).join("][")}]`, n = Function("_", `return _${t};`);
      return n.path = t, n;
    },
    comparator(e, t) {
      let n;
      const i = (a, s) => {
        const o = t[s];
        let u, l;
        return a.path ? (u = `a${a.path}`, l = `b${a.path}`) : ((n = n || {})["f" + s] = a, u = `this.f${s}(a)`, l = `this.f${s}(b)`), Mne(u, l, -o, o);
      }, r = Function("a", "b", "var u, v; return " + e.map(i).join("") + "0;");
      return n ? r.bind(n) : r;
    }
  }
};
function Rne(e) {
  const t = this;
  _ne(e.type) || !e.type ? t.operator(e, e.update ? t.operatorExpression(e.update) : null) : t.transform(e, e.type);
}
function Tne(e) {
  const t = this;
  if (e.params) {
    const n = t.get(e.id);
    n || D("Invalid operator id: " + e.id), t.dataflow.connect(n, n.parameters(t.parseParameters(e.params), e.react, e.initonly));
  }
}
function Dne(e, t) {
  t = t || {};
  const n = this;
  for (const i in e) {
    const r = e[i];
    t[i] = R(r) ? r.map((a) => _A(a, n, t)) : _A(r, n, t);
  }
  return t;
}
function _A(e, t, n) {
  if (!e || !X(e))
    return e;
  for (let i = 0, r = FA.length, a; i < r; ++i)
    if (a = FA[i], Y(e, a.key))
      return a.parse(e, t, n);
  return e;
}
var FA = [{
  key: "$ref",
  parse: Nne
}, {
  key: "$key",
  parse: Pne
}, {
  key: "$expr",
  parse: Lne
}, {
  key: "$field",
  parse: zne
}, {
  key: "$encode",
  parse: Bne
}, {
  key: "$compare",
  parse: Ine
}, {
  key: "$context",
  parse: jne
}, {
  key: "$subflow",
  parse: Une
}, {
  key: "$tupleid",
  parse: qne
}];
function Nne(e, t) {
  return t.get(e.$ref) || D("Operator not defined: " + e.$ref);
}
function Lne(e, t, n) {
  e.$params && t.parseParameters(e.$params, n);
  const i = "e:" + e.$expr.code;
  return t.fn[i] || (t.fn[i] = An(t.parameterExpression(e.$expr), e.$fields));
}
function Pne(e, t) {
  const n = "k:" + e.$key + "_" + !!e.$flat;
  return t.fn[n] || (t.fn[n] = N2(e.$key, e.$flat, t.expr.codegen));
}
function zne(e, t) {
  if (!e.$field)
    return null;
  const n = "f:" + e.$field + "_" + e.$name;
  return t.fn[n] || (t.fn[n] = At(e.$field, e.$name, t.expr.codegen));
}
function Ine(e, t) {
  const n = "c:" + e.$compare + "_" + e.$order, i = G(e.$compare).map((r) => r && r.$tupleid ? ee : r);
  return t.fn[n] || (t.fn[n] = O2(i, e.$order, t.expr.codegen));
}
function Bne(e, t) {
  const n = e.$encode, i = {};
  for (const r in n) {
    const a = n[r];
    i[r] = An(t.encodeExpression(a.$expr), a.$fields), i[r].output = a.$output;
  }
  return i;
}
function jne(e, t) {
  return t;
}
function Une(e, t) {
  const n = e.$subflow;
  return function(i, r, a) {
    const s = t.fork().parse(n), o = s.get(n.operators[0].id), u = s.signals.parent;
    return u && u.set(a), o.detachSubflow = () => t.detach(s), o;
  };
}
function qne() {
  return ee;
}
function Gne(e) {
  var t = this, n = e.filter != null ? t.eventExpression(e.filter) : void 0, i = e.stream != null ? t.get(e.stream) : void 0, r;
  e.source ? i = t.events(e.source, e.type, n) : e.merge && (r = e.merge.map((a) => t.get(a)), i = r[0].merge.apply(r[0], r.slice(1))), e.between && (r = e.between.map((a) => t.get(a)), i = i.between(r[0], r[1])), e.filter && (i = i.filter(n)), e.throttle != null && (i = i.throttle(+e.throttle)), e.debounce != null && (i = i.debounce(+e.debounce)), i == null && D("Invalid stream definition: " + JSON.stringify(e)), e.consume && i.consume(!0), t.stream(e, i);
}
function Wne(e) {
  var t = this, n = X(n = e.source) ? n.$ref : n, i = t.get(n), r = null, a = e.update, s = void 0;
  i || D("Source not defined: " + e.source), r = e.target && e.target.$expr ? t.eventExpression(e.target.$expr) : t.get(e.target), a && a.$expr && (a.$params && (s = t.parseParameters(a.$params)), a = t.handlerExpression(a.$expr)), t.update(e, i, r, a, s);
}
const Hne = {
  skip: !0
};
function Vne(e) {
  var t = this, n = {};
  if (e.signals) {
    var i = n.signals = {};
    Object.keys(t.signals).forEach((a) => {
      const s = t.signals[a];
      e.signals(a, s) && (i[a] = s.value);
    });
  }
  if (e.data) {
    var r = n.data = {};
    Object.keys(t.data).forEach((a) => {
      const s = t.data[a];
      e.data(a, s) && (r[a] = s.input.value);
    });
  }
  return t.subcontext && e.recurse !== !1 && (n.subcontext = t.subcontext.map((a) => a.getState(e))), n;
}
function Xne(e) {
  var t = this, n = t.dataflow, i = e.data, r = e.signals;
  Object.keys(r || {}).forEach((a) => {
    n.update(t.signals[a], r[a], Hne);
  }), Object.keys(i || {}).forEach((a) => {
    n.pulse(t.data[a].input, n.changeset().remove(jt).insert(i[a]));
  }), (e.subcontext || []).forEach((a, s) => {
    const o = t.subcontext[s];
    o && o.setState(a);
  });
}
function lO(e, t, n, i) {
  return new cO(e, t, n, i);
}
function cO(e, t, n, i) {
  this.dataflow = e, this.transforms = t, this.events = e.events.bind(e), this.expr = i || One, this.signals = {}, this.scales = {}, this.nodes = {}, this.data = {}, this.fn = {}, n && (this.functions = Object.create(n), this.functions.context = this);
}
function MA(e) {
  this.dataflow = e.dataflow, this.transforms = e.transforms, this.events = e.events, this.expr = e.expr, this.signals = Object.create(e.signals), this.scales = Object.create(e.scales), this.nodes = Object.create(e.nodes), this.data = Object.create(e.data), this.fn = Object.create(e.fn), e.functions && (this.functions = Object.create(e.functions), this.functions.context = this);
}
cO.prototype = MA.prototype = {
  fork() {
    const e = new MA(this);
    return (this.subcontext || (this.subcontext = [])).push(e), e;
  },
  detach(e) {
    this.subcontext = this.subcontext.filter((n) => n !== e);
    const t = Object.keys(e.nodes);
    for (const n of t)
      e.nodes[n]._targets = null;
    for (const n of t)
      e.nodes[n].detach();
    e.nodes = null;
  },
  get(e) {
    return this.nodes[e];
  },
  set(e, t) {
    return this.nodes[e] = t;
  },
  add(e, t) {
    const n = this, i = n.dataflow, r = e.value;
    if (n.set(e.id, t), Fne(e.type) && r && (r.$ingest ? i.ingest(t, r.$ingest, r.$format) : r.$request ? i.preload(t, r.$request, r.$format) : i.pulse(t, i.changeset().insert(r))), e.root && (n.root = t), e.parent) {
      let a = n.get(e.parent.$ref);
      a ? (i.connect(a, [t]), t.targets().add(a)) : (n.unresolved = n.unresolved || []).push(() => {
        a = n.get(e.parent.$ref), i.connect(a, [t]), t.targets().add(a);
      });
    }
    if (e.signal && (n.signals[e.signal] = t), e.scale && (n.scales[e.scale] = t), e.data)
      for (const a in e.data) {
        const s = n.data[a] || (n.data[a] = {});
        e.data[a].forEach((o) => s[o] = t);
      }
  },
  resolve() {
    return (this.unresolved || []).forEach((e) => e()), delete this.unresolved, this;
  },
  operator(e, t) {
    this.add(e, this.dataflow.add(e.value, t));
  },
  transform(e, t) {
    this.add(e, this.dataflow.add(this.transforms[nE(t)]));
  },
  stream(e, t) {
    this.set(e.id, t);
  },
  update(e, t, n, i, r) {
    this.dataflow.on(t, n, i, r, e.options);
  },
  // expression parsing
  operatorExpression(e) {
    return this.expr.operator(this, e);
  },
  parameterExpression(e) {
    return this.expr.parameter(this, e);
  },
  eventExpression(e) {
    return this.expr.event(this, e);
  },
  handlerExpression(e) {
    return this.expr.handler(this, e);
  },
  encodeExpression(e) {
    return this.expr.encode(this, e);
  },
  // parse methods
  parse: Ane,
  parseOperator: Rne,
  parseOperatorParameters: Tne,
  parseParameters: Dne,
  parseStream: Gne,
  parseUpdate: Wne,
  // state methods
  getState: Vne,
  setState: Xne
};
function Yne(e) {
  const t = e.container();
  t && (t.setAttribute("role", "graphics-document"), t.setAttribute("aria-roleDescription", "visualization"), fO(t, e.description()));
}
function fO(e, t) {
  e && (t == null ? e.removeAttribute("aria-label") : e.setAttribute("aria-label", t));
}
function Kne(e) {
  e.add(null, (t) => (e._background = t.bg, e._resize = 1, t.bg), {
    bg: e._signals.background
  });
}
const ay = "default";
function Jne(e) {
  const t = e._signals.cursor || (e._signals.cursor = e.add({
    user: ay,
    item: null
  }));
  e.on(e.events("view", "mousemove"), t, (n, i) => {
    const r = t.value, a = r ? V(r) ? r : r.user : ay, s = i.item && i.item.cursor || null;
    return r && a === r.user && s == r.item ? r : {
      user: a,
      item: s
    };
  }), e.add(null, function(n) {
    let i = n.cursor, r = this.value;
    return V(i) || (r = i.item, i = i.user), fv(e, i && i !== ay ? i : r || i), r;
  }, {
    cursor: t
  });
}
function fv(e, t) {
  const n = e.globalCursor() ? typeof document < "u" && document.body : e.container();
  if (n)
    return t == null ? n.style.removeProperty("cursor") : n.style.cursor = t;
}
function cg(e, t) {
  var n = e._runtime.data;
  return Y(n, t) || D("Unrecognized data set: " + t), n[t];
}
function Qne(e, t) {
  return arguments.length < 2 ? cg(this, e).values.value : rm.call(this, e, ko().remove(jt).insert(t));
}
function rm(e, t) {
  _8(t) || D("Second argument to changes must be a changeset.");
  const n = cg(this, e);
  return n.modified = !0, this.pulse(n.input, t);
}
function Zne(e, t) {
  return rm.call(this, e, ko().insert(t));
}
function eie(e, t) {
  return rm.call(this, e, ko().remove(t));
}
function dO(e) {
  var t = e.padding();
  return Math.max(0, e._viewWidth + t.left + t.right);
}
function hO(e) {
  var t = e.padding();
  return Math.max(0, e._viewHeight + t.top + t.bottom);
}
function am(e) {
  var t = e.padding(), n = e._origin;
  return [t.left + n[0], t.top + n[1]];
}
function tie(e) {
  var t = am(e), n = dO(e), i = hO(e);
  e._renderer.background(e.background()), e._renderer.resize(n, i, t), e._handler.origin(t), e._resizeListeners.forEach((r) => {
    try {
      r(n, i);
    } catch (a) {
      e.error(a);
    }
  });
}
function nie(e, t, n) {
  var i = e._renderer, r = i && i.canvas(), a, s, o;
  return r && (o = am(e), s = t.changedTouches ? t.changedTouches[0] : t, a = l$(s, r), a[0] -= o[0], a[1] -= o[1]), t.dataflow = e, t.item = n, t.vega = iie(e, n, a), t;
}
function iie(e, t, n) {
  const i = t ? t.mark.marktype === "group" ? t : t.mark.group : null;
  function r(s) {
    var o = i, u;
    if (s) {
      for (u = t; u; u = u.mark.group)
        if (u.mark.name === s) {
          o = u;
          break;
        }
    }
    return o && o.mark && o.mark.interactive ? o : {};
  }
  function a(s) {
    if (!s)
      return n;
    V(s) && (s = r(s));
    const o = n.slice();
    for (; s; )
      o[0] -= s.x || 0, o[1] -= s.y || 0, s = s.mark && s.mark.group;
    return o;
  }
  return {
    view: Ut(e),
    item: Ut(t || {}),
    group: r,
    xy: a,
    x: (s) => a(s)[0],
    y: (s) => a(s)[1]
  };
}
const OA = "view", rie = "timer", aie = "window", sie = {
  trap: !1
};
function oie(e) {
  const t = ue({
    defaults: {}
  }, e), n = (i, r) => {
    r.forEach((a) => {
      R(i[a]) && (i[a] = an(i[a]));
    });
  };
  return n(t.defaults, ["prevent", "allow"]), n(t, ["view", "window", "selector"]), t;
}
function pO(e, t, n, i) {
  e._eventListeners.push({
    type: n,
    sources: G(t),
    handler: i
  });
}
function uie(e, t) {
  var n = e._eventConfig.defaults, i = n.prevent, r = n.allow;
  return i === !1 || r === !0 ? !1 : i === !0 || r === !1 ? !0 : i ? i[t] : r ? !r[t] : e.preventDefault();
}
function lh(e, t, n) {
  const i = e._eventConfig && e._eventConfig[t];
  return i === !1 || X(i) && !i[n] ? (e.warn(`Blocked ${t} ${n} event listener.`), !1) : !0;
}
function lie(e, t, n) {
  var i = this, r = new p0(n), a = function(l, c) {
    i.runAsync(null, () => {
      e === OA && uie(i, t) && l.preventDefault(), r.receive(nie(i, l, c));
    });
  }, s;
  if (e === rie)
    lh(i, "timer", t) && i.timer(a, t);
  else if (e === OA)
    lh(i, "view", t) && i.addEventListener(t, a, sie);
  else if (e === aie ? lh(i, "window", t) && typeof window < "u" && (s = [window]) : typeof document < "u" && lh(i, "selector", t) && (s = Array.from(document.querySelectorAll(e))), !s)
    i.warn("Can not resolve event source: " + e);
  else {
    for (var o = 0, u = s.length; o < u; ++o)
      s[o].addEventListener(t, a);
    pO(i, s, t, a);
  }
  return r;
}
function RA(e) {
  return e.item;
}
function TA(e) {
  return e.item.mark.source;
}
function DA(e) {
  return function(t, n) {
    return n.vega.view().changeset().encode(n.item, e);
  };
}
function cie(e, t) {
  return e = [e || "hover"], t = [t || "update", e[0]], this.on(this.events("view", "mouseover", RA), TA, DA(e)), this.on(this.events("view", "mouseout", RA), TA, DA(t)), this;
}
function fie() {
  var e = this._tooltip, t = this._timers, n = this._eventListeners, i, r, a;
  for (i = t.length; --i >= 0; )
    t[i].stop();
  for (i = n.length; --i >= 0; )
    for (a = n[i], r = a.sources.length; --r >= 0; )
      a.sources[r].removeEventListener(a.type, a.handler);
  return e && e.call(this, this._handler, null, null, null), this;
}
function Dn(e, t, n) {
  const i = document.createElement(e);
  for (const r in t)
    i.setAttribute(r, t[r]);
  return n != null && (i.textContent = n), i;
}
const die = "vega-bind", hie = "vega-bind-name", pie = "vega-bind-radio";
function gie(e, t, n) {
  if (!t)
    return;
  const i = n.param;
  let r = n.state;
  return r || (r = n.state = {
    elements: null,
    active: !1,
    set: null,
    update: (s) => {
      s != e.signal(i.signal) && e.runAsync(null, () => {
        r.source = !0, e.signal(i.signal, s);
      });
    }
  }, i.debounce && (r.update = R2(i.debounce, r.update))), (i.input == null && i.element ? mie : bie)(r, t, i, e), r.active || (e.on(e._signals[i.signal], null, () => {
    r.source ? r.source = !1 : r.set(e.signal(i.signal));
  }), r.active = !0), r;
}
function mie(e, t, n, i) {
  const r = n.event || "input", a = () => e.update(t.value);
  i.signal(n.signal, t.value), t.addEventListener(r, a), pO(i, t, r, a), e.set = (s) => {
    t.value = s, t.dispatchEvent(yie(r));
  };
}
function yie(e) {
  return typeof Event < "u" ? new Event(e) : {
    type: e
  };
}
function bie(e, t, n, i) {
  const r = i.signal(n.signal), a = Dn("div", {
    class: die
  }), s = n.input === "radio" ? a : a.appendChild(Dn("label"));
  s.appendChild(Dn("span", {
    class: hie
  }, n.name || n.signal)), t.appendChild(a);
  let o = vie;
  switch (n.input) {
    case "checkbox":
      o = xie;
      break;
    case "select":
      o = $ie;
      break;
    case "radio":
      o = wie;
      break;
    case "range":
      o = Eie;
      break;
  }
  o(e, s, n, r);
}
function vie(e, t, n, i) {
  const r = Dn("input");
  for (const a in n)
    a !== "signal" && a !== "element" && r.setAttribute(a === "input" ? "type" : a, n[a]);
  r.setAttribute("name", n.signal), r.value = i, t.appendChild(r), r.addEventListener("input", () => e.update(r.value)), e.elements = [r], e.set = (a) => r.value = a;
}
function xie(e, t, n, i) {
  const r = {
    type: "checkbox",
    name: n.signal
  };
  i && (r.checked = !0);
  const a = Dn("input", r);
  t.appendChild(a), a.addEventListener("change", () => e.update(a.checked)), e.elements = [a], e.set = (s) => a.checked = !!s || null;
}
function $ie(e, t, n, i) {
  const r = Dn("select", {
    name: n.signal
  }), a = n.labels || [];
  n.options.forEach((s, o) => {
    const u = {
      value: s
    };
    fg(s, i) && (u.selected = !0), r.appendChild(Dn("option", u, (a[o] || s) + ""));
  }), t.appendChild(r), r.addEventListener("change", () => {
    e.update(n.options[r.selectedIndex]);
  }), e.elements = [r], e.set = (s) => {
    for (let o = 0, u = n.options.length; o < u; ++o)
      if (fg(n.options[o], s)) {
        r.selectedIndex = o;
        return;
      }
  };
}
function wie(e, t, n, i) {
  const r = Dn("span", {
    class: pie
  }), a = n.labels || [];
  t.appendChild(r), e.elements = n.options.map((s, o) => {
    const u = {
      type: "radio",
      name: n.signal,
      value: s
    };
    fg(s, i) && (u.checked = !0);
    const l = Dn("input", u);
    l.addEventListener("change", () => e.update(s));
    const c = Dn("label", {}, (a[o] || s) + "");
    return c.prepend(l), r.appendChild(c), l;
  }), e.set = (s) => {
    const o = e.elements, u = o.length;
    for (let l = 0; l < u; ++l)
      fg(o[l].value, s) && (o[l].checked = !0);
  };
}
function Eie(e, t, n, i) {
  i = i !== void 0 ? i : (+n.max + +n.min) / 2;
  const r = n.max != null ? n.max : Math.max(100, +i) || 100, a = n.min || Math.min(0, r, +i) || 0, s = n.step || Bc(a, r, 100), o = Dn("input", {
    type: "range",
    name: n.signal,
    min: a,
    max: r,
    step: s
  });
  o.value = i;
  const u = Dn("span", {}, +i);
  t.appendChild(o), t.appendChild(u);
  const l = () => {
    u.textContent = o.value, e.update(+o.value);
  };
  o.addEventListener("input", l), o.addEventListener("change", l), e.elements = [o], e.set = (c) => {
    o.value = c, u.textContent = c;
  };
}
function fg(e, t) {
  return e === t || e + "" == t + "";
}
function gO(e, t, n, i, r, a) {
  return t = t || new i(e.loader()), t.initialize(n, dO(e), hO(e), am(e), r, a).background(e.background());
}
function iE(e, t) {
  return t ? function() {
    try {
      t.apply(this, arguments);
    } catch (n) {
      e.error(n);
    }
  } : null;
}
function Sie(e, t, n, i) {
  const r = new i(e.loader(), iE(e, e.tooltip())).scene(e.scenegraph().root).initialize(n, am(e), e);
  return t && t.handlers().forEach((a) => {
    r.on(a.type, a.handler);
  }), r;
}
function Aie(e, t) {
  const n = this, i = n._renderType, r = n._eventConfig.bind, a = p$(i);
  e = n._el = e ? sy(n, e, !0) : null, Yne(n), a || n.error("Unrecognized renderer type: " + i);
  const s = a.handler || B0, o = e ? a.renderer : a.headless;
  return n._renderer = o ? gO(n, n._renderer, e, o) : null, n._handler = Sie(n, n._handler, e, s), n._redraw = !0, e && r !== "none" && (t = t ? n._elBind = sy(n, t, !0) : e.appendChild(Dn("form", {
    class: "vega-bindings"
  })), n._bind.forEach((u) => {
    u.param.element && r !== "container" && (u.element = sy(n, u.param.element, !!u.param.input));
  }), n._bind.forEach((u) => {
    gie(n, u.element || t, u);
  })), n;
}
function sy(e, t, n) {
  if (typeof t == "string")
    if (typeof document < "u") {
      if (t = document.querySelector(t), !t)
        return e.error("Signal bind element not found: " + t), null;
    } else
      return e.error("DOM document instance not found."), null;
  if (t && n)
    try {
      t.textContent = "";
    } catch (i) {
      t = null, e.error(i);
    }
  return t;
}
const Bl = (e) => +e || 0, kie = (e) => ({
  top: e,
  bottom: e,
  left: e,
  right: e
});
function NA(e) {
  return X(e) ? {
    top: Bl(e.top),
    bottom: Bl(e.bottom),
    left: Bl(e.left),
    right: Bl(e.right)
  } : kie(Bl(e));
}
async function rE(e, t, n, i) {
  const r = p$(t), a = r && r.headless;
  return a || D("Unrecognized renderer type: " + t), await e.runAsync(), gO(e, null, null, a, n, i).renderAsync(e._scenegraph.root);
}
async function Cie(e, t) {
  e !== Us.Canvas && e !== Us.SVG && e !== Us.PNG && D("Unrecognized image type: " + e);
  const n = await rE(this, e, t);
  return e === Us.SVG ? _ie(n.svg(), "image/svg+xml") : n.canvas().toDataURL("image/png");
}
function _ie(e, t) {
  const n = new Blob([e], {
    type: t
  });
  return window.URL.createObjectURL(n);
}
async function Fie(e, t) {
  return (await rE(this, Us.Canvas, e, t)).canvas();
}
async function Mie(e) {
  return (await rE(this, Us.SVG, e)).svg();
}
function Oie(e, t, n) {
  return lO(e, $u, df, n).parse(t);
}
function Rie(e) {
  var t = this._runtime.scales;
  return Y(t, e) || D("Unrecognized scale or projection: " + e), t[e].value;
}
var mO = "width", yO = "height", aE = "padding", LA = {
  skip: !0
};
function bO(e, t) {
  var n = e.autosize(), i = e.padding();
  return t - (n && n.contains === aE ? i.left + i.right : 0);
}
function vO(e, t) {
  var n = e.autosize(), i = e.padding();
  return t - (n && n.contains === aE ? i.top + i.bottom : 0);
}
function Tie(e) {
  var t = e._signals, n = t[mO], i = t[yO], r = t[aE];
  function a() {
    e._autosize = e._resize = 1;
  }
  e._resizeWidth = e.add(null, (o) => {
    e._width = o.size, e._viewWidth = bO(e, o.size), a();
  }, {
    size: n
  }), e._resizeHeight = e.add(null, (o) => {
    e._height = o.size, e._viewHeight = vO(e, o.size), a();
  }, {
    size: i
  });
  const s = e.add(null, a, {
    pad: r
  });
  e._resizeWidth.rank = n.rank + 1, e._resizeHeight.rank = i.rank + 1, s.rank = r.rank + 1;
}
function Die(e, t, n, i, r, a) {
  this.runAfter((s) => {
    let o = 0;
    s._autosize = 0, s.width() !== n && (o = 1, s.signal(mO, n, LA), s._resizeWidth.skip(!0)), s.height() !== i && (o = 1, s.signal(yO, i, LA), s._resizeHeight.skip(!0)), s._viewWidth !== e && (s._resize = 1, s._viewWidth = e), s._viewHeight !== t && (s._resize = 1, s._viewHeight = t), (s._origin[0] !== r[0] || s._origin[1] !== r[1]) && (s._resize = 1, s._origin = r), o && s.run("enter"), a && s.runAfter((u) => u.resize());
  }, !1, 1);
}
function Nie(e) {
  return this._runtime.getState(e || {
    data: Lie,
    signals: Pie,
    recurse: !0
  });
}
function Lie(e, t) {
  return t.modified && R(t.input.value) && e.indexOf("_:vega:_");
}
function Pie(e, t) {
  return !(e === "parent" || t instanceof $u.proxy);
}
function zie(e) {
  return this.runAsync(null, (t) => {
    t._trigger = !1, t._runtime.setState(e);
  }, (t) => {
    t._trigger = !0;
  }), this;
}
function Iie(e, t) {
  function n(i) {
    e({
      timestamp: Date.now(),
      elapsed: i
    });
  }
  this._timers.push(EP(n, t));
}
function Bie(e, t, n, i) {
  const r = e.element();
  r && r.setAttribute("title", jie(i));
}
function jie(e) {
  return e == null ? "" : R(e) ? xO(e) : X(e) && !Kn(e) ? Uie(e) : e + "";
}
function Uie(e) {
  return Object.keys(e).map((t) => {
    const n = e[t];
    return t + ": " + (R(n) ? xO(n) : $O(n));
  }).join(`
`);
}
function xO(e) {
  return "[" + e.map($O).join(", ") + "]";
}
function $O(e) {
  return R(e) ? "[]" : X(e) && !Kn(e) ? "{}" : e;
}
function wO(e, t) {
  const n = this;
  if (t = t || {}, uu.call(n), t.loader && n.loader(t.loader), t.logger && n.logger(t.logger), t.logLevel != null && n.logLevel(t.logLevel), t.locale || e.locale) {
    const a = ue({}, e.locale, t.locale);
    n.locale(b8(a.number, a.time));
  }
  n._el = null, n._elBind = null, n._renderType = t.renderer || Us.Canvas, n._scenegraph = new u_();
  const i = n._scenegraph.root;
  n._renderer = null, n._tooltip = t.tooltip || Bie, n._redraw = !0, n._handler = new B0().scene(i), n._globalCursor = !1, n._preventDefault = !1, n._timers = [], n._eventListeners = [], n._resizeListeners = [], n._eventConfig = oie(e.eventConfig), n.globalCursor(n._eventConfig.globalCursor);
  const r = Oie(n, e, t.expr);
  n._runtime = r, n._signals = r.signals, n._bind = (e.bindings || []).map((a) => ({
    state: null,
    param: ue({}, a)
  })), r.root && r.root.set(i), i.source = r.data.root.input, n.pulse(r.data.root.input, n.changeset().insert(i.items)), n._width = n.width(), n._height = n.height(), n._viewWidth = bO(n, n._width), n._viewHeight = vO(n, n._height), n._origin = [0, 0], n._resize = 0, n._autosize = 1, Tie(n), Kne(n), Jne(n), n.description(e.description), t.hover && n.hover(), t.container && n.initialize(t.container, t.bind);
}
function ch(e, t) {
  return Y(e._signals, t) ? e._signals[t] : D("Unrecognized signal name: " + U(t));
}
function EO(e, t) {
  const n = (e._targets || []).filter((i) => i._update && i._update.handler === t);
  return n.length ? n[0] : null;
}
function PA(e, t, n, i) {
  let r = EO(n, i);
  return r || (r = iE(e, () => i(t, n.value)), r.handler = i, e.on(n, null, r)), e;
}
function zA(e, t, n) {
  const i = EO(t, n);
  return i && t._targets.remove(i), e;
}
B(wO, uu, {
  // -- DATAFLOW / RENDERING ----
  async evaluate(e, t, n) {
    if (await uu.prototype.evaluate.call(this, e, t), this._redraw || this._resize)
      try {
        this._renderer && (this._resize && (this._resize = 0, tie(this)), await this._renderer.renderAsync(this._scenegraph.root)), this._redraw = !1;
      } catch (i) {
        this.error(i);
      }
    return n && Fh(this, n), this;
  },
  dirty(e) {
    this._redraw = !0, this._renderer && this._renderer.dirty(e);
  },
  // -- GET / SET ----
  description(e) {
    if (arguments.length) {
      const t = e != null ? e + "" : null;
      return t !== this._desc && fO(this._el, this._desc = t), this;
    }
    return this._desc;
  },
  container() {
    return this._el;
  },
  scenegraph() {
    return this._scenegraph;
  },
  origin() {
    return this._origin.slice();
  },
  signal(e, t, n) {
    const i = ch(this, e);
    return arguments.length === 1 ? i.value : this.update(i, t, n);
  },
  width(e) {
    return arguments.length ? this.signal("width", e) : this.signal("width");
  },
  height(e) {
    return arguments.length ? this.signal("height", e) : this.signal("height");
  },
  padding(e) {
    return arguments.length ? this.signal("padding", NA(e)) : NA(this.signal("padding"));
  },
  autosize(e) {
    return arguments.length ? this.signal("autosize", e) : this.signal("autosize");
  },
  background(e) {
    return arguments.length ? this.signal("background", e) : this.signal("background");
  },
  renderer(e) {
    return arguments.length ? (p$(e) || D("Unrecognized renderer type: " + e), e !== this._renderType && (this._renderType = e, this._resetRenderer()), this) : this._renderType;
  },
  tooltip(e) {
    return arguments.length ? (e !== this._tooltip && (this._tooltip = e, this._resetRenderer()), this) : this._tooltip;
  },
  loader(e) {
    return arguments.length ? (e !== this._loader && (uu.prototype.loader.call(this, e), this._resetRenderer()), this) : this._loader;
  },
  resize() {
    return this._autosize = 1, this.touch(ch(this, "autosize"));
  },
  _resetRenderer() {
    this._renderer && (this._renderer = null, this.initialize(this._el, this._elBind));
  },
  // -- SIZING ----
  _resizeView: Die,
  // -- EVENT HANDLING ----
  addEventListener(e, t, n) {
    let i = t;
    return n && n.trap === !1 || (i = iE(this, t), i.raw = t), this._handler.on(e, i), this;
  },
  removeEventListener(e, t) {
    for (var n = this._handler.handlers(e), i = n.length, r, a; --i >= 0; )
      if (a = n[i].type, r = n[i].handler, e === a && (t === r || t === r.raw)) {
        this._handler.off(a, r);
        break;
      }
    return this;
  },
  addResizeListener(e) {
    const t = this._resizeListeners;
    return t.indexOf(e) < 0 && t.push(e), this;
  },
  removeResizeListener(e) {
    var t = this._resizeListeners, n = t.indexOf(e);
    return n >= 0 && t.splice(n, 1), this;
  },
  addSignalListener(e, t) {
    return PA(this, e, ch(this, e), t);
  },
  removeSignalListener(e, t) {
    return zA(this, ch(this, e), t);
  },
  addDataListener(e, t) {
    return PA(this, e, cg(this, e).values, t);
  },
  removeDataListener(e, t) {
    return zA(this, cg(this, e).values, t);
  },
  globalCursor(e) {
    if (arguments.length) {
      if (this._globalCursor !== !!e) {
        const t = fv(this, null);
        this._globalCursor = !!e, t && fv(this, t);
      }
      return this;
    } else
      return this._globalCursor;
  },
  preventDefault(e) {
    return arguments.length ? (this._preventDefault = e, this) : this._preventDefault;
  },
  timer: Iie,
  events: lie,
  finalize: fie,
  hover: cie,
  // -- DATA ----
  data: Qne,
  change: rm,
  insert: Zne,
  remove: eie,
  // -- SCALES --
  scale: Rie,
  // -- INITIALIZATION ----
  initialize: Aie,
  // -- HEADLESS RENDERING ----
  toImageURL: Cie,
  toCanvas: Fie,
  toSVG: Mie,
  // -- SAVE / RESTORE STATE ----
  getState: Nie,
  setState: zie
});
const IA = Symbol("vega_selection_getter");
function SO(e) {
  return (!e.getter || !e.getter[IA]) && (e.getter = At(e.field), e.getter[IA] = !0), e.getter;
}
const sE = "intersect", BA = "union", qie = "vlMulti", Gie = "vlPoint", jA = "or", Wie = "and", Qi = "_vgsid_", hf = At(Qi), Hie = "E", Vie = "R", Xie = "R-E", Yie = "R-LE", Kie = "R-RE", dg = "index:unit";
function UA(e, t) {
  for (var n = t.fields, i = t.values, r = n.length, a = 0, s, o; a < r; ++a)
    if (o = n[a], s = SO(o)(e), Kn(s) && (s = Fe(s)), Kn(i[a]) && (i[a] = Fe(i[a])), R(i[a]) && Kn(i[a][0]) && (i[a] = i[a].map(Fe)), o.type === Hie) {
      if (R(i[a]) ? i[a].indexOf(s) < 0 : s !== i[a])
        return !1;
    } else if (o.type === Vie) {
      if (!bi(s, i[a]))
        return !1;
    } else if (o.type === Kie) {
      if (!bi(s, i[a], !0, !1))
        return !1;
    } else if (o.type === Xie) {
      if (!bi(s, i[a], !1, !1))
        return !1;
    } else if (o.type === Yie && !bi(s, i[a], !1, !0))
      return !1;
  return !0;
}
function Jie(e, t, n) {
  for (var i = this.context.data[e], r = i ? i.values.value : [], a = i ? i[dg] && i[dg].value : void 0, s = n === sE, o = r.length, u = 0, l, c, f, d, h; u < o; ++u)
    if (l = r[u], a && s) {
      if (c = c || {}, f = c[d = l.unit] || 0, f === -1)
        continue;
      if (h = UA(t, l), c[d] = h ? -1 : ++f, h && a.size === 1)
        return !0;
      if (!h && f === a.get(d).count)
        return !1;
    } else if (h = UA(t, l), s ^ h)
      return h;
  return o && s;
}
const AO = Zv(hf), Qie = AO.left, Zie = AO.right;
function ere(e, t, n) {
  const i = this.context.data[e], r = i ? i.values.value : [], a = i ? i[dg] && i[dg].value : void 0, s = n === sE, o = hf(t), u = Qie(r, o);
  if (u === r.length || hf(r[u]) !== o)
    return !1;
  if (a && s) {
    if (a.size === 1)
      return !0;
    if (Zie(r, o) - u < a.size)
      return !1;
  }
  return !0;
}
function tre(e, t) {
  return e.map((n) => ue(t.fields ? {
    values: t.fields.map((i) => SO(i)(n.datum))
  } : {
    [Qi]: hf(n.datum)
  }, t));
}
function nre(e, t, n, i) {
  for (var r = this.context.data[e], a = r ? r.values.value : [], s = {}, o = {}, u = {}, l, c, f, d, h, p, g, m, y, b, v = a.length, x = 0, w, E; x < v; ++x)
    if (l = a[x], d = l.unit, c = l.fields, f = l.values, c && f) {
      for (w = 0, E = c.length; w < E; ++w)
        h = c[w], g = s[h.field] || (s[h.field] = {}), m = g[d] || (g[d] = []), u[h.field] = y = h.type.charAt(0), b = oy[`${y}_union`], g[d] = b(m, G(f[w]));
      n && (m = o[d] || (o[d] = []), m.push(G(f).reduce(($, S, A) => ($[c[A].field] = S, $), {})));
    } else
      h = Qi, p = hf(l), g = s[h] || (s[h] = {}), m = g[d] || (g[d] = []), m.push(p), n && (m = o[d] || (o[d] = []), m.push({
        [Qi]: p
      }));
  if (t = t || BA, s[Qi] ? s[Qi] = oy[`${Qi}_${t}`](...Object.values(s[Qi])) : Object.keys(s).forEach(($) => {
    s[$] = Object.keys(s[$]).map((S) => s[$][S]).reduce((S, A) => S === void 0 ? A : oy[`${u[$]}_${t}`](S, A));
  }), a = Object.keys(o), n && a.length) {
    const $ = i ? Gie : qie;
    s[$] = t === BA ? {
      [jA]: a.reduce((S, A) => (S.push(...o[A]), S), [])
    } : {
      [Wie]: a.map((S) => ({
        [jA]: o[S]
      }))
    };
  }
  return s;
}
var oy = {
  [`${Qi}_union`]: lP,
  [`${Qi}_intersect`]: oP,
  E_union: function(e, t) {
    if (!e.length)
      return t;
    for (var n = 0, i = t.length; n < i; ++n)
      e.indexOf(t[n]) < 0 && e.push(t[n]);
    return e;
  },
  E_intersect: function(e, t) {
    return e.length ? e.filter((n) => t.indexOf(n) >= 0) : t;
  },
  R_union: function(e, t) {
    var n = Fe(t[0]), i = Fe(t[1]);
    return n > i && (n = t[1], i = t[0]), e.length ? (e[0] > n && (e[0] = n), e[1] < i && (e[1] = i), e) : [n, i];
  },
  R_intersect: function(e, t) {
    var n = Fe(t[0]), i = Fe(t[1]);
    return n > i && (n = t[1], i = t[0]), e.length ? i < e[0] || e[1] < n ? [] : (e[0] < n && (e[0] = n), e[1] > i && (e[1] = i), e) : [n, i];
  }
};
const ire = ":", rre = "@";
function oE(e, t, n, i) {
  t[0].type !== zn && D("First argument to selection functions must be a string literal.");
  const r = t[0].value, a = t.length >= 2 && ae(t).value, s = "unit", o = rre + s, u = ire + r;
  a === sE && !Y(i, o) && (i[o] = n.getData(r).indataRef(n, s)), Y(i, u) || (i[u] = n.getData(r).tuplesRef());
}
function kO(e) {
  const t = this.context.data[e];
  return t ? t.values.value : [];
}
function are(e, t, n) {
  const i = this.context.data[e]["index:" + t], r = i ? i.value.get(n) : void 0;
  return r && r.count;
}
function sre(e, t) {
  const n = this.context.dataflow, i = this.context.data[e], r = i.input;
  return n.pulse(r, n.changeset().remove(jt).insert(t)), 1;
}
function ore(e, t, n) {
  if (e) {
    const i = this.context.dataflow, r = e.mark.source;
    i.pulse(r, i.changeset().encode(e, t));
  }
  return n !== void 0 ? n : e;
}
const xd = (e) => function(t, n) {
  return this.context.dataflow.locale()[e](n)(t);
}, ure = xd("format"), CO = xd("timeFormat"), lre = xd("utcFormat"), cre = xd("timeParse"), fre = xd("utcParse"), fh = new Date(2e3, 0, 1);
function sm(e, t, n) {
  return !Number.isInteger(e) || !Number.isInteger(t) ? "" : (fh.setYear(2e3), fh.setMonth(e), fh.setDate(t), CO.call(this, fh, n));
}
function dre(e) {
  return sm.call(this, e, 1, "%B");
}
function hre(e) {
  return sm.call(this, e, 1, "%b");
}
function pre(e) {
  return sm.call(this, 0, 2 + e, "%A");
}
function gre(e) {
  return sm.call(this, 0, 2 + e, "%a");
}
const mre = ":", yre = "@", dv = "%", _O = "$";
function uE(e, t, n, i) {
  t[0].type !== zn && D("First argument to data functions must be a string literal.");
  const r = t[0].value, a = mre + r;
  if (!Y(a, i))
    try {
      i[a] = n.getData(r).tuplesRef();
    } catch {
    }
}
function bre(e, t, n, i) {
  t[0].type !== zn && D("First argument to indata must be a string literal."), t[1].type !== zn && D("Second argument to indata must be a string literal.");
  const r = t[0].value, a = t[1].value, s = yre + a;
  Y(s, i) || (i[s] = n.getData(r).indataRef(n, a));
}
function en(e, t, n, i) {
  if (t[0].type === zn)
    qA(n, i, t[0].value);
  else
    for (e in n.scales)
      qA(n, i, e);
}
function qA(e, t, n) {
  const i = dv + n;
  if (!Y(t, i))
    try {
      t[i] = e.scaleRef(n);
    } catch {
    }
}
function $r(e, t) {
  if (oe(e))
    return e;
  if (V(e)) {
    const n = t.scales[e];
    return n && AC(n.value) ? n.value : void 0;
  }
}
function vre(e, t, n) {
  t.__bandwidth = (r) => r && r.bandwidth ? r.bandwidth() : 0, n._bandwidth = en, n._range = en, n._scale = en;
  const i = (r) => "_[" + (r.type === zn ? U(dv + r.value) : U(dv) + "+" + e(r)) + "]";
  return {
    _bandwidth: (r) => `this.__bandwidth(${i(r[0])})`,
    _range: (r) => `${i(r[0])}.range()`,
    _scale: (r) => `${i(r[0])}(${e(r[1])})`
  };
}
function lE(e, t) {
  return function(n, i, r) {
    if (n) {
      const a = $r(n, (r || this).context);
      return a && a.path[e](i);
    } else
      return t(i);
  };
}
const xre = lE("area", Vk), $re = lE("bounds", Qk), wre = lE("centroid", n9);
function Ere(e, t) {
  const n = $r(e, (t || this).context);
  return n && n.scale();
}
function Sre(e) {
  const t = this.context.group;
  let n = !1;
  if (t)
    for (; e; ) {
      if (e === t) {
        n = !0;
        break;
      }
      e = e.mark.group;
    }
  return n;
}
function cE(e, t, n) {
  try {
    e[t].apply(e, ["EXPRESSION"].concat([].slice.call(n)));
  } catch (i) {
    e.warn(i);
  }
  return n[n.length - 1];
}
function Are() {
  return cE(this.context.dataflow, "warn", arguments);
}
function kre() {
  return cE(this.context.dataflow, "info", arguments);
}
function Cre() {
  return cE(this.context.dataflow, "debug", arguments);
}
function uy(e) {
  const t = e / 255;
  return t <= 0.03928 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
}
function hv(e) {
  const t = mu(e), n = uy(t.r), i = uy(t.g), r = uy(t.b);
  return 0.2126 * n + 0.7152 * i + 0.0722 * r;
}
function _re(e, t) {
  const n = hv(e), i = hv(t), r = Math.max(n, i), a = Math.min(n, i);
  return (r + 0.05) / (a + 0.05);
}
function Fre() {
  const e = [].slice.call(arguments);
  return e.unshift({}), ue(...e);
}
function FO(e, t) {
  return e === t || e !== e && t !== t ? !0 : R(e) ? R(t) && e.length === t.length ? Mre(e, t) : !1 : X(e) && X(t) ? MO(e, t) : !1;
}
function Mre(e, t) {
  for (let n = 0, i = e.length; n < i; ++n)
    if (!FO(e[n], t[n]))
      return !1;
  return !0;
}
function MO(e, t) {
  for (const n in e)
    if (!FO(e[n], t[n]))
      return !1;
  return !0;
}
function GA(e) {
  return (t) => MO(e, t);
}
function Ore(e, t, n, i, r, a) {
  const s = this.context.dataflow, o = this.context.data[e], u = o.input, l = s.stamp();
  let c = o.changes, f, d;
  if (s._trigger === !1 || !(u.value.length || t || i))
    return 0;
  if ((!c || c.stamp < l) && (o.changes = c = s.changeset(), c.stamp = l, s.runAfter(() => {
    o.modified = !0, s.pulse(u, c).run();
  }, !0, 1)), n && (f = n === !0 ? jt : R(n) || ol(n) ? n : GA(n), c.remove(f)), t && c.insert(t), i && (f = GA(i), u.value.some(f) ? c.remove(f) : c.insert(i)), r)
    for (d in a)
      c.modify(r, d, a[d]);
  return 1;
}
function Rre(e) {
  const t = e.touches, n = t[0].clientX - t[1].clientX, i = t[0].clientY - t[1].clientY;
  return Math.hypot(n, i);
}
function Tre(e) {
  const t = e.touches;
  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
}
const WA = {};
function Dre(e, t) {
  const n = WA[t] || (WA[t] = At(t));
  return R(e) ? e.map(n) : n(e);
}
function fE(e) {
  return R(e) || ArrayBuffer.isView(e) ? e : null;
}
function dE(e) {
  return fE(e) || (V(e) ? e : null);
}
function Nre(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return fE(e).join(...n);
}
function Lre(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return dE(e).indexOf(...n);
}
function Pre(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return dE(e).lastIndexOf(...n);
}
function zre(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
    n[i - 1] = arguments[i];
  return dE(e).slice(...n);
}
function Ire(e, t, n) {
  return oe(n) && D("Function argument passed to replace."), String(e).replace(t, n);
}
function Bre(e) {
  return fE(e).slice().reverse();
}
function jre(e, t, n) {
  return C0(e || 0, t || 0, n || 0);
}
function Ure(e, t) {
  const n = $r(e, (t || this).context);
  return n && n.bandwidth ? n.bandwidth() : 0;
}
function qre(e, t) {
  const n = $r(e, (t || this).context);
  return n ? n.copy() : void 0;
}
function Gre(e, t) {
  const n = $r(e, (t || this).context);
  return n ? n.domain() : [];
}
function Wre(e, t, n) {
  const i = $r(e, (n || this).context);
  return i ? R(t) ? (i.invertRange || i.invert)(t) : (i.invert || i.invertExtent)(t) : void 0;
}
function Hre(e, t) {
  const n = $r(e, (t || this).context);
  return n && n.range ? n.range() : [];
}
function Vre(e, t, n) {
  const i = $r(e, (n || this).context);
  return i ? i(t) : void 0;
}
function Xre(e, t, n, i, r) {
  e = $r(e, (r || this).context);
  const a = UC(t, n);
  let s = e.domain(), o = s[0], u = ae(s), l = kt;
  return u - o ? l = qx(e, o, u) : e = (e.interpolator ? be("sequential")().interpolator(e.interpolator()) : be("linear")().interpolate(e.interpolate()).range(e.range())).domain([o = 0, u = 1]), e.ticks && (s = e.ticks(+i || 15), o !== s[0] && s.unshift(o), u !== ae(s) && s.push(u)), s.forEach((c) => a.stop(l(c), e(c))), a;
}
function Yre(e, t, n) {
  const i = $r(e, (n || this).context);
  return function(r) {
    return i ? i.path.context(r)(t) : "";
  };
}
function Kre(e) {
  let t = null;
  return function(n) {
    return n ? Kc(n, t = t || O0(e)) : e;
  };
}
const OO = (e) => e.data;
function RO(e, t) {
  const n = kO.call(t, e);
  return n.root && n.root.lookup || {};
}
function Jre(e, t, n) {
  const i = RO(e, this), r = i[t], a = i[n];
  return r && a ? r.path(a).map(OO) : void 0;
}
function Qre(e, t) {
  const n = RO(e, this)[t];
  return n ? n.ancestors().map(OO) : void 0;
}
const TO = () => typeof window < "u" && window || null;
function Zre() {
  const e = TO();
  return e ? e.screen : {};
}
function eae() {
  const e = TO();
  return e ? [e.innerWidth, e.innerHeight] : [void 0, void 0];
}
function tae() {
  const e = this.context.dataflow, t = e.container && e.container();
  return t ? [t.clientWidth, t.clientHeight] : [void 0, void 0];
}
function DO(e, t, n) {
  if (!e)
    return [];
  const [i, r] = e, a = new Ye().set(i[0], i[1], r[0], r[1]), s = n || this.context.dataflow.scenegraph().root;
  return D_(s, a, nae(t));
}
function nae(e) {
  let t = null;
  if (e) {
    const n = G(e.marktype), i = G(e.markname);
    t = (r) => (!n.length || n.some((a) => r.marktype === a)) && (!i.length || i.some((a) => r.name === a));
  }
  return t;
}
function iae(e, t, n) {
  let i = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 5;
  e = G(e);
  const r = e[e.length - 1];
  return r === void 0 || Math.hypot(r[0] - t, r[1] - n) > i ? [...e, [t, n]] : e;
}
function rae(e) {
  return G(e).reduce((t, n, i) => {
    let [r, a] = n;
    return t += i == 0 ? `M ${r},${a} ` : i === e.length - 1 ? " Z" : `L ${r},${a} `;
  }, "");
}
function aae(e, t, n) {
  const {
    x: i,
    y: r,
    mark: a
  } = n, s = new Ye().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);
  for (const [u, l] of t)
    u < s.x1 && (s.x1 = u), u > s.x2 && (s.x2 = u), l < s.y1 && (s.y1 = l), l > s.y2 && (s.y2 = l);
  return s.translate(i, r), DO([[s.x1, s.y1], [s.x2, s.y2]], e, a).filter((u) => sae(u.x, u.y, t));
}
function sae(e, t, n) {
  let i = 0;
  for (let r = 0, a = n.length - 1; r < n.length; a = r++) {
    const [s, o] = n[a], [u, l] = n[r];
    l > t != o > t && e < (s - u) * (t - l) / (o - l) + u && i++;
  }
  return i & 1;
}
const hg = {
  random() {
    return Pn();
  },
  // override default
  cumulativeNormal: Wf,
  cumulativeLogNormal: b0,
  cumulativeUniform: w0,
  densityNormal: g0,
  densityLogNormal: y0,
  densityUniform: $0,
  quantileNormal: Hf,
  quantileLogNormal: v0,
  quantileUniform: E0,
  sampleNormal: Gf,
  sampleLogNormal: m0,
  sampleUniform: x0,
  isArray: R,
  isBoolean: Zr,
  isDate: Kn,
  isDefined(e) {
    return e !== void 0;
  },
  isNumber: ye,
  isObject: X,
  isRegExp: D2,
  isString: V,
  isTuple: ol,
  isValid(e) {
    return e != null && e === e;
  },
  toBoolean: o0,
  toDate(e) {
    return u0(e);
  },
  // suppress extra arguments
  toNumber: Fe,
  toString: l0,
  indexof: Lre,
  join: Nre,
  lastindexof: Pre,
  replace: Ire,
  reverse: Bre,
  slice: zre,
  flush: T2,
  lerp: L2,
  merge: Fre,
  pad: z2,
  peek: ae,
  pluck: Dre,
  span: il,
  inrange: bi,
  truncate: I2,
  rgb: mu,
  lab: tp,
  hcl: lk,
  hsl: np,
  luminance: hv,
  contrast: _re,
  sequence: xt,
  format: ure,
  utcFormat: lre,
  utcParse: fre,
  utcOffset: Y2,
  utcSequence: J2,
  timeFormat: CO,
  timeParse: cre,
  timeOffset: X2,
  timeSequence: K2,
  timeUnitSpecifier: U2,
  monthFormat: dre,
  monthAbbrevFormat: hre,
  dayFormat: pre,
  dayAbbrevFormat: gre,
  quarter: _2,
  utcquarter: F2,
  week: W2,
  utcweek: V2,
  dayofyear: G2,
  utcdayofyear: H2,
  warn: Are,
  info: kre,
  debug: Cre,
  extent(e) {
    return Ci(e);
  },
  // suppress extra arguments
  inScope: Sre,
  intersect: DO,
  clampRange: M2,
  pinchDistance: Rre,
  pinchAngle: Tre,
  screen: Zre,
  containerSize: tae,
  windowSize: eae,
  bandspace: jre,
  setdata: sre,
  pathShape: Kre,
  panLinear: S2,
  panLog: A2,
  panPow: k2,
  panSymlog: C2,
  zoomLinear: i0,
  zoomLog: r0,
  zoomPow: Wc,
  zoomSymlog: a0,
  encode: ore,
  modify: Ore,
  lassoAppend: iae,
  lassoPath: rae,
  intersectLasso: aae
}, oae = ["view", "item", "group", "xy", "x", "y"], uae = "event.vega.", NO = "this.", hE = {}, LO = {
  forbidden: ["_"],
  allowed: ["datum", "event", "item"],
  fieldvar: "datum",
  globalvar: (e) => `_[${U(_O + e)}]`,
  functions: lae,
  constants: Ww,
  visitors: hE
}, pv = Vw(LO);
function lae(e) {
  const t = Hw(e);
  oae.forEach((n) => t[n] = uae + n);
  for (const n in hg)
    t[n] = NO + n;
  return ue(t, vre(e, hg, hE)), t;
}
function Qe(e, t, n) {
  return arguments.length === 1 ? hg[e] : (hg[e] = t, n && (hE[e] = n), pv && (pv.functions[e] = NO + e), this);
}
Qe("bandwidth", Ure, en);
Qe("copy", qre, en);
Qe("domain", Gre, en);
Qe("range", Hre, en);
Qe("invert", Wre, en);
Qe("scale", Vre, en);
Qe("gradient", Xre, en);
Qe("geoArea", xre, en);
Qe("geoBounds", $re, en);
Qe("geoCentroid", wre, en);
Qe("geoShape", Yre, en);
Qe("geoScale", Ere, en);
Qe("indata", are, bre);
Qe("data", kO, uE);
Qe("treePath", Jre, uE);
Qe("treeAncestors", Qre, uE);
Qe("vlSelectionTest", Jie, oE);
Qe("vlSelectionIdTest", ere, oE);
Qe("vlSelectionResolve", nre, oE);
Qe("vlSelectionTuples", tre);
function hr(e, t) {
  const n = {};
  let i;
  try {
    e = V(e) ? e : U(e) + "", i = Gw(e);
  } catch {
    D("Expression parse error: " + e);
  }
  i.visit((a) => {
    if (a.type !== HM)
      return;
    const s = a.callee.name, o = LO.visitors[s];
    o && o(s, a.arguments, t, n);
  });
  const r = pv(i);
  return r.globals.forEach((a) => {
    const s = _O + a;
    !Y(n, s) && t.getSignal(a) && (n[s] = t.signalRef(a));
  }), {
    $expr: ue({
      code: r.code
    }, t.options.ast ? {
      ast: i
    } : null),
    $fields: r.fields,
    $params: n
  };
}
const cae = "view", pg = "[", gg = "]", PO = "{", zO = "}", fae = ":", IO = ",", dae = "@", hae = ">", pae = /[[\]{}]/, gae = {
  "*": 1,
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
};
let BO, jO;
function ls(e, t, n) {
  return BO = t || cae, jO = n || gae, UO(e.trim()).map(gv);
}
function mae(e) {
  return jO[e];
}
function Dc(e, t, n, i, r) {
  const a = e.length;
  let s = 0, o;
  for (; t < a; ++t) {
    if (o = e[t], !s && o === n)
      return t;
    r && r.indexOf(o) >= 0 ? --s : i && i.indexOf(o) >= 0 && ++s;
  }
  return t;
}
function UO(e) {
  const t = [], n = e.length;
  let i = 0, r = 0;
  for (; r < n; )
    r = Dc(e, r, IO, pg + PO, gg + zO), t.push(e.substring(i, r).trim()), i = ++r;
  if (t.length === 0)
    throw "Empty event selector: " + e;
  return t;
}
function gv(e) {
  return e[0] === "[" ? yae(e) : bae(e);
}
function yae(e) {
  const t = e.length;
  let n = 1, i;
  if (n = Dc(e, n, gg, pg, gg), n === t)
    throw "Empty between selector: " + e;
  if (i = UO(e.substring(1, n)), i.length !== 2)
    throw "Between selector must have two elements: " + e;
  if (e = e.slice(n + 1).trim(), e[0] !== hae)
    throw "Expected '>' after between selector: " + e;
  i = i.map(gv);
  const r = gv(e.slice(1).trim());
  return r.between ? {
    between: i,
    stream: r
  } : (r.between = i, r);
}
function bae(e) {
  const t = {
    source: BO
  }, n = [];
  let i = [0, 0], r = 0, a = 0, s = e.length, o = 0, u, l;
  if (e[s - 1] === zO) {
    if (o = e.lastIndexOf(PO), o >= 0) {
      try {
        i = vae(e.substring(o + 1, s - 1));
      } catch {
        throw "Invalid throttle specification: " + e;
      }
      e = e.slice(0, o).trim(), s = e.length;
    } else
      throw "Unmatched right brace: " + e;
    o = 0;
  }
  if (!s)
    throw e;
  if (e[0] === dae && (r = ++o), u = Dc(e, o, fae), u < s && (n.push(e.substring(a, u).trim()), a = o = ++u), o = Dc(e, o, pg), o === s)
    n.push(e.substring(a, s).trim());
  else if (n.push(e.substring(a, o).trim()), l = [], a = ++o, a === s)
    throw "Unmatched left bracket: " + e;
  for (; o < s; ) {
    if (o = Dc(e, o, gg), o === s)
      throw "Unmatched left bracket: " + e;
    if (l.push(e.substring(a, o).trim()), o < s - 1 && e[++o] !== pg)
      throw "Expected left bracket: " + e;
    a = ++o;
  }
  if (!(s = n.length) || pae.test(n[s - 1]))
    throw "Invalid event selector: " + e;
  return s > 1 ? (t.type = n[1], r ? t.markname = n[0].slice(1) : mae(n[0]) ? t.marktype = n[0] : t.source = n[0]) : t.type = n[0], t.type.slice(-1) === "!" && (t.consume = !0, t.type = t.type.slice(0, -1)), l != null && (t.filter = l), i[0] && (t.throttle = i[0]), i[1] && (t.debounce = i[1]), t;
}
function vae(e) {
  const t = e.split(IO);
  if (!e.length || t.length > 2)
    throw e;
  return t.map((n) => {
    const i = +n;
    if (i !== i)
      throw e;
    return i;
  });
}
function xae(e, t, n) {
  const i = e - t + n * 2;
  return e ? i > 0 ? i : 1 : 0;
}
const $ae = "identity", pE = "linear", Ou = "log", gE = "pow", mE = "sqrt", yE = "symlog", wae = "time", Eae = "utc", gl = "sequential", $d = "diverging", mv = "quantile", Sae = "quantize", Aae = "threshold", kae = "ordinal", Cae = "point", _ae = "band", Fae = "bin-ordinal", ot = "continuous", wd = "discrete", Ed = "discretizing", Li = "interpolating", qO = "temporal";
function Mae(e) {
  return function(t) {
    let n = t[0], i = t[1], r;
    return i < n && (r = n, n = i, i = r), [e.invert(n), e.invert(i)];
  };
}
function Oae(e) {
  return function(t) {
    const n = e.range();
    let i = t[0], r = t[1], a = -1, s, o, u, l;
    for (r < i && (o = i, i = r, r = o), u = 0, l = n.length; u < l; ++u)
      n[u] >= i && n[u] <= r && (a < 0 && (a = u), s = u);
    if (!(a < 0))
      return i = e.invertExtent(n[a]), r = e.invertExtent(n[s]), [i[0] === void 0 ? i[1] : i[0], r[1] === void 0 ? r[0] : r[1]];
  };
}
function bE() {
  const e = as().unknown(void 0), t = e.domain, n = e.range;
  let i = [0, 1], r, a, s = !1, o = 0, u = 0, l = 0.5;
  delete e.unknown;
  function c() {
    const f = t().length, d = i[1] < i[0], h = i[1 - d], p = xae(f, o, u);
    let g = i[d - 0];
    r = (h - g) / (p || 1), s && (r = Math.floor(r)), g += (h - g - r * (f - o)) * l, a = r * (1 - o), s && (g = Math.round(g), a = Math.round(a));
    const m = xt(f).map((y) => g + r * y);
    return n(d ? m.reverse() : m);
  }
  return e.domain = function(f) {
    return arguments.length ? (t(f), c()) : t();
  }, e.range = function(f) {
    return arguments.length ? (i = [+f[0], +f[1]], c()) : i.slice();
  }, e.rangeRound = function(f) {
    return i = [+f[0], +f[1]], s = !0, c();
  }, e.bandwidth = function() {
    return a;
  }, e.step = function() {
    return r;
  }, e.round = function(f) {
    return arguments.length ? (s = !!f, c()) : s;
  }, e.padding = function(f) {
    return arguments.length ? (u = Math.max(0, Math.min(1, f)), o = u, c()) : o;
  }, e.paddingInner = function(f) {
    return arguments.length ? (o = Math.max(0, Math.min(1, f)), c()) : o;
  }, e.paddingOuter = function(f) {
    return arguments.length ? (u = Math.max(0, Math.min(1, f)), c()) : u;
  }, e.align = function(f) {
    return arguments.length ? (l = Math.max(0, Math.min(1, f)), c()) : l;
  }, e.invertRange = function(f) {
    if (f[0] == null || f[1] == null)
      return;
    const d = i[1] < i[0], h = d ? n().reverse() : n(), p = h.length - 1;
    let g = +f[0], m = +f[1], y, b, v;
    if (!(g !== g || m !== m) && (m < g && (v = g, g = m, m = v), !(m < h[0] || g > i[1 - d])))
      return y = Math.max(0, Vr(h, g) - 1), b = g === m ? y : Vr(h, m) - 1, g - h[y] > a + 1e-10 && ++y, d && (v = y, y = p - b, b = p - v), y > b ? void 0 : t().slice(y, b + 1);
  }, e.invert = function(f) {
    const d = e.invertRange([f, f]);
    return d && d[0];
  }, e.copy = function() {
    return bE().domain(t()).range(i).round(s).paddingInner(o).paddingOuter(u).align(l);
  }, c();
}
function GO(e) {
  const t = e.copy;
  return e.padding = e.paddingOuter, delete e.paddingInner, e.copy = function() {
    return GO(t());
  }, e;
}
function Rae() {
  return GO(bE().paddingInner(1));
}
var Tae = Array.prototype.map;
function Dae(e) {
  return Tae.call(e, Fe);
}
const Nae = Array.prototype.slice;
function WO() {
  let e = [], t = [];
  function n(i) {
    return i == null || i !== i ? void 0 : t[(Eo(e, i) - 1) % t.length];
  }
  return n.domain = function(i) {
    return arguments.length ? (e = Dae(i), n) : e.slice();
  }, n.range = function(i) {
    return arguments.length ? (t = Nae.call(i), n) : t.slice();
  }, n.tickFormat = function(i, r) {
    return Bg(e[0], ae(e), i ?? 10, r);
  }, n.copy = function() {
    return WO().domain(n.domain()).range(n.range());
  }, n;
}
const mg = /* @__PURE__ */ new Map(), Lae = Symbol("vega_scale");
function Pae(e) {
  return e[Lae] = !0, e;
}
function zae(e, t, n) {
  const i = function() {
    const a = t();
    return a.invertRange || (a.invertRange = a.invert ? Mae(a) : a.invertExtent ? Oae(a) : void 0), a.type = e, Pae(a);
  };
  return i.metadata = an(G(n)), i;
}
function Le(e, t, n) {
  return arguments.length > 1 ? (mg.set(e, zae(e, t, n)), this) : HO(e) ? mg.get(e) : void 0;
}
Le($ae, Rf);
Le(pE, Ig, ot);
Le(Ou, Tf, [ot, Ou]);
Le(gE, Ku, ot);
Le(mE, Vg, ot);
Le(yE, Df, ot);
Le(wae, Pg, [ot, qO]);
Le(Eae, Xg, [ot, qO]);
Le(gl, Qr, [ot, Li]);
Le(`${gl}-${pE}`, Qr, [ot, Li]);
Le(`${gl}-${Ou}`, zf, [ot, Li, Ou]);
Le(`${gl}-${gE}`, Ju, [ot, Li]);
Le(`${gl}-${mE}`, Kg, [ot, Li]);
Le(`${gl}-${yE}`, If, [ot, Li]);
Le(`${$d}-${pE}`, Bf, [ot, Li]);
Le(`${$d}-${Ou}`, jf, [ot, Li, Ou]);
Le(`${$d}-${gE}`, Qu, [ot, Li]);
Le(`${$d}-${mE}`, Qg, [ot, Li]);
Le(`${$d}-${yE}`, Uf, [ot, Li]);
Le(mv, Nf, [Ed, mv]);
Le(Sae, Lf, Ed);
Le(Aae, Pf, Ed);
Le(Fae, WO, [wd, Ed]);
Le(kae, as, wd);
Le(_ae, bE, wd);
Le(Cae, Rae, wd);
function HO(e) {
  return mg.has(e);
}
function om(e, t) {
  const n = mg.get(e);
  return n && n.metadata[t];
}
function Iae(e) {
  return om(e, ot);
}
function yg(e) {
  return om(e, wd);
}
function HA(e) {
  return om(e, Ed);
}
function VO(e) {
  return om(e, mv);
}
function Bae(e, t, n) {
  return Xu(jae(t || "rgb", n), e);
}
function jae(e, t) {
  const n = Ug[Uae(e)];
  return t != null && n && n.gamma ? n.gamma(t) : n;
}
function Uae(e) {
  return "interpolate" + e.toLowerCase().split("-").map((t) => t[0].toUpperCase() + t.slice(1)).join("");
}
const qae = {
  blues: "cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90",
  greens: "d3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429",
  greys: "e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e",
  oranges: "fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303",
  purples: "e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c",
  reds: "fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13",
  blueGreen: "d5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429",
  bluePurple: "ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71",
  greenBlue: "d3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1",
  orangeRed: "fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403",
  purpleBlue: "dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281",
  purpleBlueGreen: "dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353",
  purpleRed: "dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a",
  redPurple: "fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174",
  yellowGreen: "e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034",
  yellowOrangeBrown: "feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204",
  yellowOrangeRed: "fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225",
  blueOrange: "134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07",
  brownBlueGreen: "704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147",
  purpleGreen: "5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29",
  purpleOrange: "4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07",
  redBlue: "8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85",
  redGrey: "8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434",
  yellowGreenBlue: "eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185",
  redYellowBlue: "a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695",
  redYellowGreen: "a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837",
  pinkYellowGreen: "8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419",
  spectral: "9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2",
  viridis: "440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725",
  magma: "0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf",
  inferno: "0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4",
  plasma: "0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921",
  cividis: "00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647",
  rainbow: "6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa",
  sinebow: "ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040",
  turbo: "23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00",
  browns: "eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632",
  tealBlues: "bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985",
  teals: "bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667",
  warmGreys: "dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e",
  goldGreen: "f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36",
  goldOrange: "f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26",
  goldRed: "f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e",
  lightGreyRed: "efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b",
  lightGreyTeal: "e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc",
  lightMulti: "e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c",
  lightOrange: "f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b",
  lightTealBlue: "e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988",
  darkBlue: "3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff",
  darkGold: "3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff",
  darkGreen: "3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa",
  darkMulti: "3737371f5287197d8c29a86995ce3fffe800ffffff",
  darkRed: "3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c"
}, Gae = {
  category10: "1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf",
  category20: "1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5",
  category20b: "393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6",
  category20c: "3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9",
  tableau10: "4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac",
  tableau20: "4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5",
  accent: "7fc97fbeaed4fdc086ffff99386cb0f0027fbf5b17666666",
  dark2: "1b9e77d95f027570b3e7298a66a61ee6ab02a6761d666666",
  paired: "a6cee31f78b4b2df8a33a02cfb9a99e31a1cfdbf6fff7f00cab2d66a3d9affff99b15928",
  pastel1: "fbb4aeb3cde3ccebc5decbe4fed9a6ffffcce5d8bdfddaecf2f2f2",
  pastel2: "b3e2cdfdcdaccbd5e8f4cae4e6f5c9fff2aef1e2cccccccc",
  set1: "e41a1c377eb84daf4a984ea3ff7f00ffff33a65628f781bf999999",
  set2: "66c2a5fc8d628da0cbe78ac3a6d854ffd92fe5c494b3b3b3",
  set3: "8dd3c7ffffb3bebadafb807280b1d3fdb462b3de69fccde5d9d9d9bc80bdccebc5ffed6f"
};
function XO(e) {
  const t = e.length / 6 | 0, n = new Array(t);
  for (let i = 0; i < t; )
    n[i] = "#" + e.slice(i * 6, ++i * 6);
  return n;
}
function YO(e, t) {
  for (const n in e)
    Wae(n, t(e[n]));
}
const VA = {};
YO(Gae, XO);
YO(qae, (e) => Bae(XO(e)));
function Wae(e, t) {
  return e = e && e.toLowerCase(), arguments.length > 1 ? (VA[e] = t, this) : VA[e];
}
function Hae(e) {
  return X(e) ? e : {
    type: e || "pad"
  };
}
const jl = (e) => +e || 0, Vae = (e) => ({
  top: e,
  bottom: e,
  left: e,
  right: e
});
function Xae(e) {
  return X(e) ? e.signal ? e : {
    top: jl(e.top),
    bottom: jl(e.bottom),
    left: jl(e.left),
    right: jl(e.right)
  } : Vae(jl(e));
}
const dt = (e) => X(e) && !R(e) ? ue({}, e) : {
  value: e
};
function XA(e, t, n, i) {
  return n != null ? (X(n) && !R(n) || R(n) && n.length && X(n[0]) ? e.update[t] = n : e[i || "enter"][t] = {
    value: n
  }, 1) : 0;
}
function Ct(e, t, n) {
  for (const i in t)
    XA(e, i, t[i]);
  for (const i in n)
    XA(e, i, n[i], "update");
}
function ml(e, t, n) {
  for (const i in t)
    n && Y(n, i) || (e[i] = ue(e[i] || {}, t[i]));
  return e;
}
function eu(e, t) {
  return t && (t.enter && t.enter[e] || t.update && t.update[e]);
}
const vE = "mark", xE = "frame", $E = "scope", Yae = "axis", Kae = "axis-domain", Jae = "axis-grid", Qae = "axis-label", Zae = "axis-tick", ese = "axis-title", tse = "legend", nse = "legend-band", ise = "legend-entry", rse = "legend-gradient", KO = "legend-label", ase = "legend-symbol", sse = "legend-title", ose = "title", use = "title-text", lse = "title-subtitle";
function cse(e, t, n, i, r) {
  const a = {}, s = {};
  let o, u, l, c;
  u = "lineBreak", t === "text" && r[u] != null && !eu(u, e) && ly(a, u, r[u]), (n == "legend" || String(n).startsWith("axis")) && (n = null), c = n === xE ? r.group : n === vE ? ue({}, r.mark, r[t]) : null;
  for (u in c)
    l = eu(u, e) || (u === "fill" || u === "stroke") && (eu("fill", e) || eu("stroke", e)), l || ly(a, u, c[u]);
  G(i).forEach((f) => {
    const d = r.style && r.style[f];
    for (const h in d)
      eu(h, e) || ly(a, h, d[h]);
  }), e = ue({}, e);
  for (u in a)
    c = a[u], c.signal ? (o = o || {})[u] = c : s[u] = c;
  return e.enter = ue(s, e.enter), o && (e.update = ue(o, e.update)), e;
}
function ly(e, t, n) {
  e[t] = n && n.signal ? {
    signal: n.signal
  } : {
    value: n
  };
}
const JO = (e) => V(e) ? U(e) : e.signal ? `(${e.signal})` : QO(e);
function um(e) {
  if (e.gradient != null)
    return dse(e);
  let t = e.signal ? `(${e.signal})` : e.color ? fse(e.color) : e.field != null ? QO(e.field) : e.value !== void 0 ? U(e.value) : void 0;
  return e.scale != null && (t = hse(e, t)), t === void 0 && (t = null), e.exponent != null && (t = `pow(${t},${Yh(e.exponent)})`), e.mult != null && (t += `*${Yh(e.mult)}`), e.offset != null && (t += `+${Yh(e.offset)}`), e.round && (t = `round(${t})`), t;
}
const dh = (e, t, n, i) => `(${e}(${[t, n, i].map(um).join(",")})+'')`;
function fse(e) {
  return e.c ? dh("hcl", e.h, e.c, e.l) : e.h || e.s ? dh("hsl", e.h, e.s, e.l) : e.l || e.a ? dh("lab", e.l, e.a, e.b) : e.r || e.g || e.b ? dh("rgb", e.r, e.g, e.b) : null;
}
function dse(e) {
  const t = [e.start, e.stop, e.count].map((n) => n == null ? null : U(n));
  for (; t.length && ae(t) == null; )
    t.pop();
  return t.unshift(JO(e.gradient)), `gradient(${t.join(",")})`;
}
function Yh(e) {
  return X(e) ? "(" + um(e) + ")" : e;
}
function QO(e) {
  return ZO(X(e) ? e : {
    datum: e
  });
}
function ZO(e) {
  let t, n, i;
  if (e.signal)
    t = "datum", i = e.signal;
  else if (e.group || e.parent) {
    for (n = Math.max(1, e.level || 1), t = "item"; n-- > 0; )
      t += ".mark.group";
    e.parent ? (i = e.parent, t += ".datum") : i = e.group;
  } else
    e.datum ? (t = "datum", i = e.datum) : D("Invalid field reference: " + U(e));
  return e.signal || (i = V(i) ? br(i).map(U).join("][") : ZO(i)), t + "[" + i + "]";
}
function hse(e, t) {
  const n = JO(e.scale);
  return e.range != null ? t = `lerp(_range(${n}), ${+e.range})` : (t !== void 0 && (t = `_scale(${n}, ${t})`), e.band && (t = (t ? t + "+" : "") + `_bandwidth(${n})` + (+e.band == 1 ? "" : "*" + Yh(e.band)), e.extra && (t = `(datum.extra ? _scale(${n}, datum.extra.value) : ${t})`)), t == null && (t = "0")), t;
}
function pse(e) {
  let t = "";
  return e.forEach((n) => {
    const i = um(n);
    t += n.test ? `(${n.test})?${i}:` : i;
  }), ae(t) === ":" && (t += "null"), t;
}
function eR(e, t, n, i, r, a) {
  const s = {};
  a = a || {}, a.encoders = {
    $encode: s
  }, e = cse(e, t, n, i, r.config);
  for (const o in e)
    s[o] = gse(e[o], t, a, r);
  return a;
}
function gse(e, t, n, i) {
  const r = {}, a = {};
  for (const s in e)
    e[s] != null && (r[s] = yse(mse(e[s]), i, n, a));
  return {
    $expr: {
      marktype: t,
      channels: r
    },
    $fields: Object.keys(a),
    $output: Object.keys(e)
  };
}
function mse(e) {
  return R(e) ? pse(e) : um(e);
}
function yse(e, t, n, i) {
  const r = hr(e, t);
  return r.$fields.forEach((a) => i[a] = 1), ue(n, r.$params), r.$expr;
}
const bse = "outer", vse = ["value", "update", "init", "react", "bind"];
function YA(e, t) {
  D(e + ' for "outer" push: ' + U(t));
}
function tR(e, t) {
  const n = e.name;
  if (e.push === bse)
    t.signals[n] || YA("No prior signal definition", n), vse.forEach((i) => {
      e[i] !== void 0 && YA("Invalid property ", i);
    });
  else {
    const i = t.addSignal(n, e.value);
    e.react === !1 && (i.react = !1), e.bind && t.addBinding(n, e.bind);
  }
}
function yv(e, t, n, i) {
  this.id = -1, this.type = e, this.value = t, this.params = n, i && (this.parent = i);
}
function lm(e, t, n, i) {
  return new yv(e, t, n, i);
}
function bg(e, t) {
  return lm("operator", e, t);
}
function Z(e) {
  const t = {
    $ref: e.id
  };
  return e.id < 0 && (e.refs = e.refs || []).push(t), t;
}
function pf(e, t) {
  return t ? {
    $field: e,
    $name: t
  } : {
    $field: e
  };
}
const bv = pf("key");
function KA(e, t) {
  return {
    $compare: e,
    $order: t
  };
}
function xse(e, t) {
  const n = {
    $key: e
  };
  return t && (n.$flat = !0), n;
}
const $se = "ascending", wse = "descending";
function Ese(e) {
  return X(e) ? (e.order === wse ? "-" : "+") + cm(e.op, e.field) : "";
}
function cm(e, t) {
  return (e && e.signal ? "$" + e.signal : e || "") + (e && t ? "_" : "") + (t && t.signal ? "$" + t.signal : t || "");
}
const wE = "scope", vv = "view";
function rt(e) {
  return e && e.signal;
}
function Sse(e) {
  return e && e.expr;
}
function Kh(e) {
  if (rt(e))
    return !0;
  if (X(e)) {
    for (const t in e)
      if (Kh(e[t]))
        return !0;
  }
  return !1;
}
function hi(e, t) {
  return e ?? t;
}
function Ks(e) {
  return e && e.signal || e;
}
const JA = "timer";
function gf(e, t) {
  return (e.merge ? kse : e.stream ? Cse : e.type ? _se : D("Invalid stream specification: " + U(e)))(e, t);
}
function Ase(e) {
  return e === wE ? vv : e || vv;
}
function kse(e, t) {
  const n = e.merge.map((r) => gf(r, t)), i = EE({
    merge: n
  }, e, t);
  return t.addStream(i).id;
}
function Cse(e, t) {
  const n = gf(e.stream, t), i = EE({
    stream: n
  }, e, t);
  return t.addStream(i).id;
}
function _se(e, t) {
  let n;
  e.type === JA ? (n = t.event(JA, e.throttle), e = {
    between: e.between,
    filter: e.filter
  }) : n = t.event(Ase(e.source), e.type);
  const i = EE({
    stream: n
  }, e, t);
  return Object.keys(i).length === 1 ? n : t.addStream(i).id;
}
function EE(e, t, n) {
  let i = t.between;
  return i && (i.length !== 2 && D('Stream "between" parameter must have 2 entries: ' + U(t)), e.between = [gf(i[0], n), gf(i[1], n)]), i = t.filter ? [].concat(t.filter) : [], (t.marktype || t.markname || t.markrole) && i.push(Fse(t.marktype, t.markname, t.markrole)), t.source === wE && i.push("inScope(event.item)"), i.length && (e.filter = hr("(" + i.join(")&&(") + ")", n).$expr), (i = t.throttle) != null && (e.throttle = +i), (i = t.debounce) != null && (e.debounce = +i), t.consume && (e.consume = !0), e;
}
function Fse(e, t, n) {
  const i = "event.item";
  return i + (e && e !== "*" ? "&&" + i + ".mark.marktype==='" + e + "'" : "") + (n ? "&&" + i + ".mark.role==='" + n + "'" : "") + (t ? "&&" + i + ".mark.name==='" + t + "'" : "");
}
const Mse = {
  code: "_.$value",
  ast: {
    type: "Identifier",
    value: "value"
  }
};
function Ose(e, t, n) {
  const i = e.encode, r = {
    target: n
  };
  let a = e.events, s = e.update, o = [];
  a || D("Signal update missing events specification."), V(a) && (a = ls(a, t.isSubscope() ? wE : vv)), a = G(a).filter((u) => u.signal || u.scale ? (o.push(u), 0) : 1), o.length > 1 && (o = [Tse(o)]), a.length && o.push(a.length > 1 ? {
    merge: a
  } : a[0]), i != null && (s && D("Signal encode and update are mutually exclusive."), s = "encode(item()," + U(i) + ")"), r.update = V(s) ? hr(s, t) : s.expr != null ? hr(s.expr, t) : s.value != null ? s.value : s.signal != null ? {
    $expr: Mse,
    $params: {
      $value: t.signalRef(s.signal)
    }
  } : D("Invalid signal update specification."), e.force && (r.options = {
    force: !0
  }), o.forEach((u) => t.addUpdate(ue(Rse(u, t), r)));
}
function Rse(e, t) {
  return {
    source: e.signal ? t.signalRef(e.signal) : e.scale ? t.scaleRef(e.scale) : gf(e, t)
  };
}
function Tse(e) {
  return {
    signal: "[" + e.map((t) => t.scale ? 'scale("' + t.scale + '")' : t.signal) + "]"
  };
}
function Dse(e, t) {
  const n = t.getSignal(e.name);
  let i = e.update;
  e.init && (i ? D("Signals can not include both init and update expressions.") : (i = e.init, n.initonly = !0)), i && (i = hr(i, t), n.update = i.$expr, n.params = i.$params), e.on && e.on.forEach((r) => Ose(r, t, n.id));
}
const _e = (e) => (t, n, i) => lm(e, n, t || void 0, i), nR = _e("aggregate"), Nse = _e("axisticks"), iR = _e("bound"), Pi = _e("collect"), QA = _e("compare"), Lse = _e("datajoin"), rR = _e("encode"), Pse = _e("expression"), zse = _e("facet"), Ise = _e("field"), Bse = _e("key"), jse = _e("legendentries"), Use = _e("load"), qse = _e("mark"), Gse = _e("multiextent"), Wse = _e("multivalues"), Hse = _e("overlap"), Vse = _e("params"), aR = _e("prefacet"), Xse = _e("projection"), Yse = _e("proxy"), Kse = _e("relay"), sR = _e("render"), Jse = _e("scale"), Fo = _e("sieve"), Qse = _e("sortitems"), oR = _e("viewlayout"), Zse = _e("values");
let eoe = 0;
const uR = {
  min: "min",
  max: "max",
  count: "sum"
};
function toe(e, t) {
  const n = e.type || "linear";
  HO(n) || D("Unrecognized scale type: " + U(n)), t.addScale(e.name, {
    type: n,
    domain: void 0
  });
}
function noe(e, t) {
  const n = t.getScale(e.name).params;
  let i;
  n.domain = lR(e.domain, e, t), e.range != null && (n.range = fR(e, t, n)), e.interpolate != null && doe(e.interpolate, n), e.nice != null && (n.nice = foe(e.nice)), e.bins != null && (n.bins = coe(e.bins, t));
  for (i in e)
    Y(n, i) || i === "name" || (n[i] = Xn(e[i], t));
}
function Xn(e, t) {
  return X(e) ? e.signal ? t.signalRef(e.signal) : D("Unsupported object: " + U(e)) : e;
}
function Jh(e, t) {
  return e.signal ? t.signalRef(e.signal) : e.map((n) => Xn(n, t));
}
function fm(e) {
  D("Can not find data set: " + U(e));
}
function lR(e, t, n) {
  if (!e) {
    (t.domainMin != null || t.domainMax != null) && D("No scale domain defined for domainMin/domainMax to override.");
    return;
  }
  return e.signal ? n.signalRef(e.signal) : (R(e) ? ioe : e.fields ? aoe : roe)(e, t, n);
}
function ioe(e, t, n) {
  return e.map((i) => Xn(i, n));
}
function roe(e, t, n) {
  const i = n.getData(e.data);
  return i || fm(e.data), yg(t.type) ? i.valuesRef(n, e.field, cR(e.sort, !1)) : VO(t.type) ? i.domainRef(n, e.field) : i.extentRef(n, e.field);
}
function aoe(e, t, n) {
  const i = e.data, r = e.fields.reduce((a, s) => (s = V(s) ? {
    data: i,
    field: s
  } : R(s) || s.signal ? soe(s, n) : s, a.push(s), a), []);
  return (yg(t.type) ? ooe : VO(t.type) ? uoe : loe)(e, n, r);
}
function soe(e, t) {
  const n = "_:vega:_" + eoe++, i = Pi({});
  if (R(e))
    i.value = {
      $ingest: e
    };
  else if (e.signal) {
    const r = "setdata(" + U(n) + "," + e.signal + ")";
    i.params.input = t.signalRef(r);
  }
  return t.addDataPipeline(n, [i, Fo({})]), {
    data: n,
    field: "data"
  };
}
function ooe(e, t, n) {
  const i = cR(e.sort, !0);
  let r, a;
  const s = n.map((l) => {
    const c = t.getData(l.data);
    return c || fm(l.data), c.countsRef(t, l.field, i);
  }), o = {
    groupby: bv,
    pulse: s
  };
  i && (r = i.op || "count", a = i.field ? cm(r, i.field) : "count", o.ops = [uR[r]], o.fields = [t.fieldRef(a)], o.as = [a]), r = t.add(nR(o));
  const u = t.add(Pi({
    pulse: Z(r)
  }));
  return a = t.add(Zse({
    field: bv,
    sort: t.sortRef(i),
    pulse: Z(u)
  })), Z(a);
}
function cR(e, t) {
  return e && (!e.field && !e.op ? X(e) ? e.field = "key" : e = {
    field: "key"
  } : !e.field && e.op !== "count" ? D("No field provided for sort aggregate op: " + e.op) : t && e.field && e.op && !uR[e.op] && D("Multiple domain scales can not be sorted using " + e.op)), e;
}
function uoe(e, t, n) {
  const i = n.map((r) => {
    const a = t.getData(r.data);
    return a || fm(r.data), a.domainRef(t, r.field);
  });
  return Z(t.add(Wse({
    values: i
  })));
}
function loe(e, t, n) {
  const i = n.map((r) => {
    const a = t.getData(r.data);
    return a || fm(r.data), a.extentRef(t, r.field);
  });
  return Z(t.add(Gse({
    extents: i
  })));
}
function coe(e, t) {
  return e.signal || R(e) ? Jh(e, t) : t.objectProperty(e);
}
function foe(e) {
  return X(e) ? {
    interval: Xn(e.interval),
    step: Xn(e.step)
  } : Xn(e);
}
function doe(e, t) {
  t.interpolate = Xn(e.type || e), e.gamma != null && (t.interpolateGamma = Xn(e.gamma));
}
function fR(e, t, n) {
  const i = t.config.range;
  let r = e.range;
  if (r.signal)
    return t.signalRef(r.signal);
  if (V(r)) {
    if (i && Y(i, r))
      return e = ue({}, e, {
        range: i[r]
      }), fR(e, t, n);
    r === "width" ? r = [0, {
      signal: "width"
    }] : r === "height" ? r = yg(e.type) ? [0, {
      signal: "height"
    }] : [{
      signal: "height"
    }, 0] : D("Unrecognized scale range value: " + U(r));
  } else if (r.scheme) {
    n.scheme = R(r.scheme) ? Jh(r.scheme, t) : Xn(r.scheme, t), r.extent && (n.schemeExtent = Jh(r.extent, t)), r.count && (n.schemeCount = Xn(r.count, t));
    return;
  } else if (r.step) {
    n.rangeStep = Xn(r.step, t);
    return;
  } else {
    if (yg(e.type) && !R(r))
      return lR(r, e, t);
    R(r) || D("Unsupported range type: " + U(r));
  }
  return r.map((a) => (R(a) ? Jh : Xn)(a, t));
}
function hoe(e, t) {
  const n = t.config.projection || {}, i = {};
  for (const r in e)
    r !== "name" && (i[r] = xv(e[r], r, t));
  for (const r in n)
    i[r] == null && (i[r] = xv(n[r], r, t));
  t.addProjection(e.name, i);
}
function xv(e, t, n) {
  return R(e) ? e.map((i) => xv(i, t, n)) : X(e) ? e.signal ? n.signalRef(e.signal) : t === "fit" ? e : D("Unsupported parameter object: " + U(e)) : e;
}
const zi = "top", yl = "left", bl = "right", Ka = "bottom", dR = "center", poe = "vertical", goe = "start", moe = "middle", yoe = "end", $v = "index", SE = "label", boe = "offset", Ru = "perc", voe = "perc2", Jn = "value", Sd = "guide-label", AE = "guide-title", xoe = "group-title", $oe = "group-subtitle", ZA = "symbol", Qh = "gradient", wv = "discrete", Ev = "size", woe = "shape", Eoe = "fill", Soe = "stroke", Aoe = "strokeWidth", koe = "strokeDash", Coe = "opacity", kE = [Ev, woe, Eoe, Soe, Aoe, koe, Coe], Ad = {
  name: 1,
  style: 1,
  interactive: 1
}, me = {
  value: 0
}, Qn = {
  value: 1
}, dm = "group", hR = "rect", CE = "rule", _oe = "symbol", Mo = "text";
function mf(e) {
  return e.type = dm, e.interactive = e.interactive || !1, e;
}
function kn(e, t) {
  const n = (i, r) => hi(e[i], hi(t[i], r));
  return n.isVertical = (i) => poe === hi(e.direction, t.direction || (i ? t.symbolDirection : t.gradientDirection)), n.gradientLength = () => hi(e.gradientLength, t.gradientLength || t.gradientWidth), n.gradientThickness = () => hi(e.gradientThickness, t.gradientThickness || t.gradientHeight), n.entryColumns = () => hi(e.columns, hi(t.columns, +n.isVertical(!0))), n;
}
function pR(e, t) {
  const n = t && (t.update && t.update[e] || t.enter && t.enter[e]);
  return n && n.signal ? n : n ? n.value : null;
}
function Foe(e, t, n) {
  const i = t.config.style[n];
  return i && i[e];
}
function hm(e, t, n) {
  return `item.anchor === '${goe}' ? ${e} : item.anchor === '${yoe}' ? ${t} : ${n}`;
}
const _E = hm(U(yl), U(bl), U(dR));
function Moe(e) {
  const t = e("tickBand");
  let n = e("tickOffset"), i, r;
  return t ? t.signal ? (i = {
    signal: `(${t.signal}) === 'extent' ? 1 : 0.5`
  }, r = {
    signal: `(${t.signal}) === 'extent'`
  }, X(n) || (n = {
    signal: `(${t.signal}) === 'extent' ? 0 : ${n}`
  })) : t === "extent" ? (i = 1, r = !0, n = 0) : (i = 0.5, r = !1) : (i = e("bandPosition"), r = e("tickExtra")), {
    extra: r,
    band: i,
    offset: n
  };
}
function gR(e, t) {
  return t ? e ? X(e) ? Object.assign({}, e, {
    offset: gR(e.offset, t)
  }) : {
    value: e,
    offset: t
  } : t : e;
}
function In(e, t) {
  return t ? (e.name = t.name, e.style = t.style || e.style, e.interactive = !!t.interactive, e.encode = ml(e.encode, t, Ad)) : e.interactive = !1, e;
}
function Ooe(e, t, n, i) {
  const r = kn(e, n), a = r.isVertical(), s = r.gradientThickness(), o = r.gradientLength();
  let u, l, c, f, d;
  a ? (l = [0, 1], c = [0, 0], f = s, d = o) : (l = [0, 0], c = [1, 0], f = o, d = s);
  const h = {
    enter: u = {
      opacity: me,
      x: me,
      y: me,
      width: dt(f),
      height: dt(d)
    },
    update: ue({}, u, {
      opacity: Qn,
      fill: {
        gradient: t,
        start: l,
        stop: c
      }
    }),
    exit: {
      opacity: me
    }
  };
  return Ct(h, {
    stroke: r("gradientStrokeColor"),
    strokeWidth: r("gradientStrokeWidth")
  }, {
    // update
    opacity: r("gradientOpacity")
  }), In({
    type: hR,
    role: rse,
    encode: h
  }, i);
}
function Roe(e, t, n, i, r) {
  const a = kn(e, n), s = a.isVertical(), o = a.gradientThickness(), u = a.gradientLength();
  let l, c, f, d, h = "";
  s ? (l = "y", f = "y2", c = "x", d = "width", h = "1-") : (l = "x", f = "x2", c = "y", d = "height");
  const p = {
    opacity: me,
    fill: {
      scale: t,
      field: Jn
    }
  };
  p[l] = {
    signal: h + "datum." + Ru,
    mult: u
  }, p[c] = me, p[f] = {
    signal: h + "datum." + voe,
    mult: u
  }, p[d] = dt(o);
  const g = {
    enter: p,
    update: ue({}, p, {
      opacity: Qn
    }),
    exit: {
      opacity: me
    }
  };
  return Ct(g, {
    stroke: a("gradientStrokeColor"),
    strokeWidth: a("gradientStrokeWidth")
  }, {
    // update
    opacity: a("gradientOpacity")
  }), In({
    type: hR,
    role: nse,
    key: Jn,
    from: r,
    encode: g
  }, i);
}
const Toe = `datum.${Ru}<=0?"${yl}":datum.${Ru}>=1?"${bl}":"${dR}"`, Doe = `datum.${Ru}<=0?"${Ka}":datum.${Ru}>=1?"${zi}":"${moe}"`;
function e4(e, t, n, i) {
  const r = kn(e, t), a = r.isVertical(), s = dt(r.gradientThickness()), o = r.gradientLength();
  let u = r("labelOverlap"), l, c, f, d, h = "";
  const p = {
    enter: l = {
      opacity: me
    },
    update: c = {
      opacity: Qn,
      text: {
        field: SE
      }
    },
    exit: {
      opacity: me
    }
  };
  return Ct(p, {
    fill: r("labelColor"),
    fillOpacity: r("labelOpacity"),
    font: r("labelFont"),
    fontSize: r("labelFontSize"),
    fontStyle: r("labelFontStyle"),
    fontWeight: r("labelFontWeight"),
    limit: hi(e.labelLimit, t.gradientLabelLimit)
  }), a ? (l.align = {
    value: "left"
  }, l.baseline = c.baseline = {
    signal: Doe
  }, f = "y", d = "x", h = "1-") : (l.align = c.align = {
    signal: Toe
  }, l.baseline = {
    value: "top"
  }, f = "x", d = "y"), l[f] = c[f] = {
    signal: h + "datum." + Ru,
    mult: o
  }, l[d] = c[d] = s, s.offset = hi(e.labelOffset, t.gradientLabelOffset) || 0, u = u ? {
    separation: r("labelSeparation"),
    method: u,
    order: "datum." + $v
  } : void 0, In({
    type: Mo,
    role: KO,
    style: Sd,
    key: Jn,
    from: i,
    encode: p,
    overlap: u
  }, n);
}
function Noe(e, t, n, i, r) {
  const a = kn(e, t), s = n.entries, o = !!(s && s.interactive), u = s ? s.name : void 0, l = a("clipHeight"), c = a("symbolOffset"), f = {
    data: "value"
  }, d = `(${r}) ? datum.${boe} : datum.${Ev}`, h = l ? dt(l) : {
    field: Ev
  }, p = `datum.${$v}`, g = `max(1, ${r})`;
  let m, y, b, v, x;
  h.mult = 0.5, m = {
    enter: y = {
      opacity: me,
      x: {
        signal: d,
        mult: 0.5,
        offset: c
      },
      y: h
    },
    update: b = {
      opacity: Qn,
      x: y.x,
      y: y.y
    },
    exit: {
      opacity: me
    }
  };
  let w = null, E = null;
  e.fill || (w = t.symbolBaseFillColor, E = t.symbolBaseStrokeColor), Ct(m, {
    fill: a("symbolFillColor", w),
    shape: a("symbolType"),
    size: a("symbolSize"),
    stroke: a("symbolStrokeColor", E),
    strokeDash: a("symbolDash"),
    strokeDashOffset: a("symbolDashOffset"),
    strokeWidth: a("symbolStrokeWidth")
  }, {
    // update
    opacity: a("symbolOpacity")
  }), kE.forEach((k) => {
    e[k] && (b[k] = y[k] = {
      scale: e[k],
      field: Jn
    });
  });
  const $ = In({
    type: _oe,
    role: ase,
    key: Jn,
    from: f,
    clip: l ? !0 : void 0,
    encode: m
  }, n.symbols), S = dt(c);
  S.offset = a("labelOffset"), m = {
    enter: y = {
      opacity: me,
      x: {
        signal: d,
        offset: S
      },
      y: h
    },
    update: b = {
      opacity: Qn,
      text: {
        field: SE
      },
      x: y.x,
      y: y.y
    },
    exit: {
      opacity: me
    }
  }, Ct(m, {
    align: a("labelAlign"),
    baseline: a("labelBaseline"),
    fill: a("labelColor"),
    fillOpacity: a("labelOpacity"),
    font: a("labelFont"),
    fontSize: a("labelFontSize"),
    fontStyle: a("labelFontStyle"),
    fontWeight: a("labelFontWeight"),
    limit: a("labelLimit")
  });
  const A = In({
    type: Mo,
    role: KO,
    style: Sd,
    key: Jn,
    from: f,
    encode: m
  }, n.labels);
  return m = {
    enter: {
      noBound: {
        value: !l
      },
      // ignore width/height in bounds calc
      width: me,
      height: l ? dt(l) : me,
      opacity: me
    },
    exit: {
      opacity: me
    },
    update: b = {
      opacity: Qn,
      row: {
        signal: null
      },
      column: {
        signal: null
      }
    }
  }, a.isVertical(!0) ? (v = `ceil(item.mark.items.length / ${g})`, b.row.signal = `${p}%${v}`, b.column.signal = `floor(${p} / ${v})`, x = {
    field: ["row", p]
  }) : (b.row.signal = `floor(${p} / ${g})`, b.column.signal = `${p} % ${g}`, x = {
    field: p
  }), b.column.signal = `(${r})?${b.column.signal}:${p}`, i = {
    facet: {
      data: i,
      name: "value",
      groupby: $v
    }
  }, mf({
    role: $E,
    from: i,
    encode: ml(m, s, Ad),
    marks: [$, A],
    name: u,
    interactive: o,
    sort: x
  });
}
function Loe(e, t) {
  const n = kn(e, t);
  return {
    align: n("gridAlign"),
    columns: n.entryColumns(),
    center: {
      row: !0,
      column: !1
    },
    padding: {
      row: n("rowPadding"),
      column: n("columnPadding")
    }
  };
}
const FE = 'item.orient === "left"', ME = 'item.orient === "right"', pm = `(${FE} || ${ME})`, Poe = `datum.vgrad && ${pm}`, zoe = hm('"top"', '"bottom"', '"middle"'), Ioe = hm('"right"', '"left"', '"center"'), Boe = `datum.vgrad && ${ME} ? (${Ioe}) : (${pm} && !(datum.vgrad && ${FE})) ? "left" : ${_E}`, joe = `item._anchor || (${pm} ? "middle" : "start")`, Uoe = `${Poe} ? (${FE} ? -90 : 90) : 0`, qoe = `${pm} ? (datum.vgrad ? (${ME} ? "bottom" : "top") : ${zoe}) : "top"`;
function Goe(e, t, n, i) {
  const r = kn(e, t), a = {
    enter: {
      opacity: me
    },
    update: {
      opacity: Qn,
      x: {
        field: {
          group: "padding"
        }
      },
      y: {
        field: {
          group: "padding"
        }
      }
    },
    exit: {
      opacity: me
    }
  };
  return Ct(a, {
    orient: r("titleOrient"),
    _anchor: r("titleAnchor"),
    anchor: {
      signal: joe
    },
    angle: {
      signal: Uoe
    },
    align: {
      signal: Boe
    },
    baseline: {
      signal: qoe
    },
    text: e.title,
    fill: r("titleColor"),
    fillOpacity: r("titleOpacity"),
    font: r("titleFont"),
    fontSize: r("titleFontSize"),
    fontStyle: r("titleFontStyle"),
    fontWeight: r("titleFontWeight"),
    limit: r("titleLimit"),
    lineHeight: r("titleLineHeight")
  }, {
    // require update
    align: r("titleAlign"),
    baseline: r("titleBaseline")
  }), In({
    type: Mo,
    role: sse,
    style: AE,
    from: i,
    encode: a
  }, n);
}
function Woe(e, t) {
  let n;
  return X(e) && (e.signal ? n = e.signal : e.path ? n = "pathShape(" + t4(e.path) + ")" : e.sphere && (n = "geoShape(" + t4(e.sphere) + ', {type: "Sphere"})')), n ? t.signalRef(n) : !!e;
}
function t4(e) {
  return X(e) && e.signal ? e.signal : U(e);
}
function mR(e) {
  const t = e.role || "";
  return !t.indexOf("axis") || !t.indexOf("legend") || !t.indexOf("title") ? t : e.type === dm ? $E : t || vE;
}
function Hoe(e) {
  return {
    marktype: e.type,
    name: e.name || void 0,
    role: e.role || mR(e),
    zindex: +e.zindex || void 0,
    aria: e.aria,
    description: e.description
  };
}
function Voe(e, t) {
  return e && e.signal ? t.signalRef(e.signal) : e !== !1;
}
function OE(e, t) {
  const n = O8(e.type);
  n || D("Unrecognized transform type: " + U(e.type));
  const i = lm(n.type.toLowerCase(), null, yR(n, e, t));
  return e.signal && t.addSignal(e.signal, t.proxy(i)), i.metadata = n.metadata || {}, i;
}
function yR(e, t, n) {
  const i = {}, r = e.params.length;
  for (let a = 0; a < r; ++a) {
    const s = e.params[a];
    i[s.name] = Xoe(s, t, n);
  }
  return i;
}
function Xoe(e, t, n) {
  const i = e.type, r = t[e.name];
  if (i === "index")
    return Yoe(e, t, n);
  if (r === void 0) {
    e.required && D("Missing required " + U(t.type) + " parameter: " + U(e.name));
    return;
  } else {
    if (i === "param")
      return Koe(e, t, n);
    if (i === "projection")
      return n.projectionRef(t[e.name]);
  }
  return e.array && !rt(r) ? r.map((a) => n4(e, a, n)) : n4(e, r, n);
}
function n4(e, t, n) {
  const i = e.type;
  if (rt(t))
    return r4(i) ? D("Expression references can not be signals.") : cy(i) ? n.fieldRef(t) : a4(i) ? n.compareRef(t) : n.signalRef(t.signal);
  {
    const r = e.expr || cy(i);
    return r && Joe(t) ? n.exprRef(t.expr, t.as) : r && Qoe(t) ? pf(t.field, t.as) : r4(i) ? hr(t, n) : Zoe(i) ? Z(n.getData(t).values) : cy(i) ? pf(t) : a4(i) ? n.compareRef(t) : t;
  }
}
function Yoe(e, t, n) {
  return V(t.from) || D('Lookup "from" parameter must be a string literal.'), n.getData(t.from).lookupRef(n, t.key);
}
function Koe(e, t, n) {
  const i = t[e.name];
  return e.array ? (R(i) || D("Expected an array of sub-parameters. Instead: " + U(i)), i.map((r) => i4(e, r, n))) : i4(e, i, n);
}
function i4(e, t, n) {
  const i = e.params.length;
  let r;
  for (let s = 0; s < i; ++s) {
    r = e.params[s];
    for (const o in r.key)
      if (r.key[o] !== t[o]) {
        r = null;
        break;
      }
    if (r)
      break;
  }
  r || D("Unsupported parameter: " + U(t));
  const a = ue(yR(r, t, n), r.key);
  return Z(n.add(Vse(a)));
}
const Joe = (e) => e && e.expr, Qoe = (e) => e && e.field, Zoe = (e) => e === "data", r4 = (e) => e === "expr", cy = (e) => e === "field", a4 = (e) => e === "compare";
function eue(e, t, n) {
  let i, r, a, s, o;
  return e ? (i = e.facet) && (t || D("Only group marks can be faceted."), i.field != null ? s = o = Zh(i, n) : (e.data ? o = Z(n.getData(e.data).aggregate) : (a = OE(ue({
    type: "aggregate",
    groupby: G(i.groupby)
  }, i.aggregate), n), a.params.key = n.keyRef(i.groupby), a.params.pulse = Zh(i, n), s = o = Z(n.add(a))), r = n.keyRef(i.groupby, !0))) : s = Z(n.add(Pi(null, [{}]))), s || (s = Zh(e, n)), {
    key: r,
    pulse: s,
    parent: o
  };
}
function Zh(e, t) {
  return e.$ref ? e : e.data && e.data.$ref ? e.data : Z(t.getData(e.data).output);
}
function co(e, t, n, i, r) {
  this.scope = e, this.input = t, this.output = n, this.values = i, this.aggregate = r, this.index = {};
}
co.fromEntries = function(e, t) {
  const n = t.length, i = t[n - 1], r = t[n - 2];
  let a = t[0], s = null, o = 1;
  for (a && a.type === "load" && (a = t[1]), e.add(t[0]); o < n; ++o)
    t[o].params.pulse = Z(t[o - 1]), e.add(t[o]), t[o].type === "aggregate" && (s = t[o]);
  return new co(e, a, r, i, s);
};
function bR(e) {
  return V(e) ? e : null;
}
function s4(e, t, n) {
  const i = cm(n.op, n.field);
  let r;
  if (t.ops) {
    for (let a = 0, s = t.as.length; a < s; ++a)
      if (t.as[a] === i)
        return;
  } else
    t.ops = ["count"], t.fields = [null], t.as = ["count"];
  n.op && (t.ops.push((r = n.op.signal) ? e.signalRef(r) : n.op), t.fields.push(e.fieldRef(n.field)), t.as.push(i));
}
function Ul(e, t, n, i, r, a, s) {
  const o = t[n] || (t[n] = {}), u = Ese(a);
  let l = bR(r), c, f;
  if (l != null && (e = t.scope, l = l + (u ? "|" + u : ""), c = o[l]), !c) {
    const d = a ? {
      field: bv,
      pulse: t.countsRef(e, r, a)
    } : {
      field: e.fieldRef(r),
      pulse: Z(t.output)
    };
    u && (d.sort = e.sortRef(a)), f = e.add(lm(i, void 0, d)), s && (t.index[r] = f), c = Z(f), l != null && (o[l] = c);
  }
  return c;
}
co.prototype = {
  countsRef(e, t, n) {
    const i = this, r = i.counts || (i.counts = {}), a = bR(t);
    let s, o, u;
    return a != null && (e = i.scope, s = r[a]), s ? n && n.field && s4(e, s.agg.params, n) : (u = {
      groupby: e.fieldRef(t, "key"),
      pulse: Z(i.output)
    }, n && n.field && s4(e, u, n), o = e.add(nR(u)), s = e.add(Pi({
      pulse: Z(o)
    })), s = {
      agg: o,
      ref: Z(s)
    }, a != null && (r[a] = s)), s.ref;
  },
  tuplesRef() {
    return Z(this.values);
  },
  extentRef(e, t) {
    return Ul(e, this, "extent", "extent", t, !1);
  },
  domainRef(e, t) {
    return Ul(e, this, "domain", "values", t, !1);
  },
  valuesRef(e, t, n) {
    return Ul(e, this, "vals", "values", t, n || !0);
  },
  lookupRef(e, t) {
    return Ul(e, this, "lookup", "tupleindex", t, !1);
  },
  indataRef(e, t) {
    return Ul(e, this, "indata", "tupleindex", t, !0, !0);
  }
};
function tue(e, t, n) {
  const i = e.from.facet, r = i.name, a = Zh(i, t);
  let s;
  i.name || D("Facet must have a name: " + U(i)), i.data || D("Facet must reference a data set: " + U(i)), i.field ? s = t.add(aR({
    field: t.fieldRef(i.field),
    pulse: a
  })) : i.groupby ? s = t.add(zse({
    key: t.keyRef(i.groupby),
    group: Z(t.proxy(n.parent)),
    pulse: a
  })) : D("Facet must specify groupby or field: " + U(i));
  const o = t.fork(), u = o.add(Pi()), l = o.add(Fo({
    pulse: Z(u)
  }));
  o.addData(r, new co(o, u, u, l)), o.addSignal("parent", null), s.params.subflow = {
    $subflow: o.parse(e).toRuntime()
  };
}
function nue(e, t, n) {
  const i = t.add(aR({
    pulse: n.pulse
  })), r = t.fork();
  r.add(Fo()), r.addSignal("parent", null), i.params.subflow = {
    $subflow: r.parse(e).toRuntime()
  };
}
function vR(e, t, n) {
  const i = e.remove, r = e.insert, a = e.toggle, s = e.modify, o = e.values, u = t.add(bg()), l = "if(" + e.trigger + ',modify("' + n + '",' + [r, i, a, s, o].map((f) => f ?? "null").join(",") + "),0)", c = hr(l, t);
  u.update = c.$expr, u.params = c.$params;
}
function gm(e, t) {
  const n = mR(e), i = e.type === dm, r = e.from && e.from.facet, a = e.overlap;
  let s = e.layout || n === $E || n === xE, o, u, l, c, f, d, h;
  const p = n === vE || s || r, g = eue(e.from, i, t);
  u = t.add(Lse({
    key: g.key || (e.key ? pf(e.key) : void 0),
    pulse: g.pulse,
    clean: !i
  }));
  const m = Z(u);
  u = l = t.add(Pi({
    pulse: m
  })), u = t.add(qse({
    markdef: Hoe(e),
    interactive: Voe(e.interactive, t),
    clip: Woe(e.clip, t),
    context: {
      $context: !0
    },
    groups: t.lookup(),
    parent: t.signals.parent ? t.signalRef("parent") : null,
    index: t.markpath(),
    pulse: Z(u)
  }));
  const y = Z(u);
  u = c = t.add(rR(eR(e.encode, e.type, n, e.style, t, {
    mod: !1,
    pulse: y
  }))), u.params.parent = t.encode(), e.transform && e.transform.forEach((E) => {
    const $ = OE(E, t), S = $.metadata;
    (S.generates || S.changes) && D("Mark transforms should not generate new data."), S.nomod || (c.params.mod = !0), $.params.pulse = Z(u), t.add(u = $);
  }), e.sort && (u = t.add(Qse({
    sort: t.compareRef(e.sort),
    pulse: Z(u)
  })));
  const b = Z(u);
  (r || s) && (s = t.add(oR({
    layout: t.objectProperty(e.layout),
    legends: t.legends,
    mark: y,
    pulse: b
  })), d = Z(s));
  const v = t.add(iR({
    mark: y,
    pulse: d || b
  }));
  h = Z(v), i && (p && (o = t.operators, o.pop(), s && o.pop()), t.pushState(b, d || h, m), r ? tue(e, t, g) : p ? nue(e, t, g) : t.parse(e), t.popState(), p && (s && o.push(s), o.push(v))), a && (h = iue(a, h, t));
  const x = t.add(sR({
    pulse: h
  })), w = t.add(Fo({
    pulse: Z(x)
  }, void 0, t.parent()));
  e.name != null && (f = e.name, t.addData(f, new co(t, l, x, w)), e.on && e.on.forEach((E) => {
    (E.insert || E.remove || E.toggle) && D("Marks only support modify triggers."), vR(E, t, f);
  }));
}
function iue(e, t, n) {
  const i = e.method, r = e.bound, a = e.separation, s = {
    separation: rt(a) ? n.signalRef(a.signal) : a,
    method: rt(i) ? n.signalRef(i.signal) : i,
    pulse: t
  };
  if (e.order && (s.sort = n.compareRef({
    field: e.order
  })), r) {
    const o = r.tolerance;
    s.boundTolerance = rt(o) ? n.signalRef(o.signal) : +o, s.boundScale = n.scaleRef(r.scale), s.boundOrient = r.orient;
  }
  return Z(n.add(Hse(s)));
}
function rue(e, t) {
  const n = t.config.legend, i = e.encode || {}, r = kn(e, n), a = i.legend || {}, s = a.name || void 0, o = a.interactive, u = a.style, l = {};
  let c = 0, f, d, h;
  kE.forEach((v) => e[v] ? (l[v] = e[v], c = c || e[v]) : 0), c || D("Missing valid scale for legend.");
  const p = aue(e, t.scaleType(c)), g = {
    title: e.title != null,
    scales: l,
    type: p,
    vgrad: p !== "symbol" && r.isVertical()
  }, m = Z(t.add(Pi(null, [g]))), y = {
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    }
  }, b = Z(t.add(jse(d = {
    type: p,
    scale: t.scaleRef(c),
    count: t.objectProperty(r("tickCount")),
    limit: t.property(r("symbolLimit")),
    values: t.objectProperty(e.values),
    minstep: t.property(e.tickMinStep),
    formatType: t.property(e.formatType),
    formatSpecifier: t.property(e.format)
  })));
  return p === Qh ? (h = [Ooe(e, c, n, i.gradient), e4(e, n, i.labels, b)], d.count = d.count || t.signalRef(`max(2,2*floor((${Ks(r.gradientLength())})/100))`)) : p === wv ? h = [Roe(e, c, n, i.gradient, b), e4(e, n, i.labels, b)] : (f = Loe(e, n), h = [Noe(e, n, i, b, Ks(f.columns))], d.size = uue(e, t, h[0].marks)), h = [mf({
    role: ise,
    from: m,
    encode: y,
    marks: h,
    layout: f,
    interactive: o
  })], g.title && h.push(Goe(e, n, i.title, m)), gm(mf({
    role: tse,
    from: m,
    encode: ml(oue(r, e, n), a, Ad),
    marks: h,
    aria: r("aria"),
    description: r("description"),
    zindex: r("zindex"),
    name: s,
    interactive: o,
    style: u
  }), t);
}
function aue(e, t) {
  let n = e.type || ZA;
  return !e.type && sue(e) === 1 && (e.fill || e.stroke) && (n = Iae(t) ? Qh : HA(t) ? wv : ZA), n !== Qh ? n : HA(t) ? wv : Qh;
}
function sue(e) {
  return kE.reduce((t, n) => t + (e[n] ? 1 : 0), 0);
}
function oue(e, t, n) {
  const i = {
    enter: {},
    update: {}
  };
  return Ct(i, {
    orient: e("orient"),
    offset: e("offset"),
    padding: e("padding"),
    titlePadding: e("titlePadding"),
    cornerRadius: e("cornerRadius"),
    fill: e("fillColor"),
    stroke: e("strokeColor"),
    strokeWidth: n.strokeWidth,
    strokeDash: n.strokeDash,
    x: e("legendX"),
    y: e("legendY"),
    // accessibility support
    format: t.format,
    formatType: t.formatType
  }), i;
}
function uue(e, t, n) {
  const i = Ks(o4("size", e, n)), r = Ks(o4("strokeWidth", e, n)), a = Ks(lue(n[1].encode, t, Sd));
  return hr(`max(ceil(sqrt(${i})+${r}),${a})`, t);
}
function o4(e, t, n) {
  return t[e] ? `scale("${t[e]}",datum)` : pR(e, n[0].encode);
}
function lue(e, t, n) {
  return pR("fontSize", e) || Foe("fontSize", t, n);
}
const cue = `item.orient==="${yl}"?-90:item.orient==="${bl}"?90:0`;
function fue(e, t) {
  e = V(e) ? {
    text: e
  } : e;
  const n = kn(e, t.config.title), i = e.encode || {}, r = i.group || {}, a = r.name || void 0, s = r.interactive, o = r.style, u = [], l = {}, c = Z(t.add(Pi(null, [l])));
  return u.push(pue(e, n, due(e), c)), e.subtitle && u.push(gue(e, n, i.subtitle, c)), gm(mf({
    role: ose,
    from: c,
    encode: hue(n, r),
    marks: u,
    aria: n("aria"),
    description: n("description"),
    zindex: n("zindex"),
    name: a,
    interactive: s,
    style: o
  }), t);
}
function due(e) {
  const t = e.encode;
  return t && t.title || ue({
    name: e.name,
    interactive: e.interactive,
    style: e.style
  }, t);
}
function hue(e, t) {
  const n = {
    enter: {},
    update: {}
  };
  return Ct(n, {
    orient: e("orient"),
    anchor: e("anchor"),
    align: {
      signal: _E
    },
    angle: {
      signal: cue
    },
    limit: e("limit"),
    frame: e("frame"),
    offset: e("offset") || 0,
    padding: e("subtitlePadding")
  }), ml(n, t, Ad);
}
function pue(e, t, n, i) {
  const r = {
    value: 0
  }, a = e.text, s = {
    enter: {
      opacity: r
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: r
    }
  };
  return Ct(s, {
    text: a,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: t("dx"),
    dy: t("dy"),
    fill: t("color"),
    font: t("font"),
    fontSize: t("fontSize"),
    fontStyle: t("fontStyle"),
    fontWeight: t("fontWeight"),
    lineHeight: t("lineHeight")
  }, {
    // update
    align: t("align"),
    angle: t("angle"),
    baseline: t("baseline")
  }), In({
    type: Mo,
    role: use,
    style: xoe,
    from: i,
    encode: s
  }, n);
}
function gue(e, t, n, i) {
  const r = {
    value: 0
  }, a = e.subtitle, s = {
    enter: {
      opacity: r
    },
    update: {
      opacity: {
        value: 1
      }
    },
    exit: {
      opacity: r
    }
  };
  return Ct(s, {
    text: a,
    align: {
      signal: "item.mark.group.align"
    },
    angle: {
      signal: "item.mark.group.angle"
    },
    limit: {
      signal: "item.mark.group.limit"
    },
    baseline: "top",
    dx: t("dx"),
    dy: t("dy"),
    fill: t("subtitleColor"),
    font: t("subtitleFont"),
    fontSize: t("subtitleFontSize"),
    fontStyle: t("subtitleFontStyle"),
    fontWeight: t("subtitleFontWeight"),
    lineHeight: t("subtitleLineHeight")
  }, {
    // update
    align: t("align"),
    angle: t("angle"),
    baseline: t("baseline")
  }), In({
    type: Mo,
    role: lse,
    style: $oe,
    from: i,
    encode: s
  }, n);
}
function mue(e, t) {
  const n = [];
  e.transform && e.transform.forEach((i) => {
    n.push(OE(i, t));
  }), e.on && e.on.forEach((i) => {
    vR(i, t, e.name);
  }), t.addDataPipeline(e.name, yue(e, t, n));
}
function yue(e, t, n) {
  const i = [];
  let r = null, a = !1, s = !1, o, u, l, c, f;
  for (e.values ? rt(e.values) || Kh(e.format) ? (i.push(u4(t, e)), i.push(r = vs())) : i.push(r = vs({
    $ingest: e.values,
    $format: e.format
  })) : e.url ? Kh(e.url) || Kh(e.format) ? (i.push(u4(t, e)), i.push(r = vs())) : i.push(r = vs({
    $request: e.url,
    $format: e.format
  })) : e.source && (r = o = G(e.source).map((d) => Z(t.getData(d).output)), i.push(null)), u = 0, l = n.length; u < l; ++u)
    c = n[u], f = c.metadata, !r && !f.source && i.push(r = vs()), i.push(c), f.generates && (s = !0), f.modifies && !s && (a = !0), f.source ? r = c : f.changes && (r = null);
  return o && (l = o.length - 1, i[0] = Kse({
    derive: a,
    pulse: l ? o : o[0]
  }), (a || l) && i.splice(1, 0, vs())), r || i.push(vs()), i.push(Fo({})), i;
}
function vs(e) {
  const t = Pi({}, e);
  return t.metadata = {
    source: !0
  }, t;
}
function u4(e, t) {
  return Use({
    url: t.url ? e.property(t.url) : void 0,
    async: t.async ? e.property(t.async) : void 0,
    values: t.values ? e.property(t.values) : void 0,
    format: e.objectProperty(t.format)
  });
}
const xR = (e) => e === Ka || e === zi, mm = (e, t, n) => rt(e) ? $ue(e.signal, t, n) : e === yl || e === zi ? t : n, ht = (e, t, n) => rt(e) ? vue(e.signal, t, n) : xR(e) ? t : n, Si = (e, t, n) => rt(e) ? xue(e.signal, t, n) : xR(e) ? n : t, $R = (e, t, n) => rt(e) ? wue(e.signal, t, n) : e === zi ? {
  value: t
} : {
  value: n
}, bue = (e, t, n) => rt(e) ? Eue(e.signal, t, n) : e === bl ? {
  value: t
} : {
  value: n
}, vue = (e, t, n) => wR(`${e} === '${zi}' || ${e} === '${Ka}'`, t, n), xue = (e, t, n) => wR(`${e} !== '${zi}' && ${e} !== '${Ka}'`, t, n), $ue = (e, t, n) => RE(`${e} === '${yl}' || ${e} === '${zi}'`, t, n), wue = (e, t, n) => RE(`${e} === '${zi}'`, t, n), Eue = (e, t, n) => RE(`${e} === '${bl}'`, t, n), wR = (e, t, n) => (t = t != null ? dt(t) : t, n = n != null ? dt(n) : n, l4(t) && l4(n) ? (t = t ? t.signal || U(t.value) : null, n = n ? n.signal || U(n.value) : null, {
  signal: `${e} ? (${t}) : (${n})`
}) : [ue({
  test: e
}, t)].concat(n || [])), l4 = (e) => e == null || Object.keys(e).length === 1, RE = (e, t, n) => ({
  signal: `${e} ? (${su(t)}) : (${su(n)})`
}), Sue = (e, t, n, i, r) => ({
  signal: (i != null ? `${e} === '${yl}' ? (${su(i)}) : ` : "") + (n != null ? `${e} === '${Ka}' ? (${su(n)}) : ` : "") + (r != null ? `${e} === '${bl}' ? (${su(r)}) : ` : "") + (t != null ? `${e} === '${zi}' ? (${su(t)}) : ` : "") + "(null)"
}), su = (e) => rt(e) ? e.signal : e == null ? null : U(e), Aue = (e, t) => t === 0 ? 0 : rt(e) ? {
  signal: `(${e.signal}) * ${t}`
} : {
  value: e * t
}, lu = (e, t) => {
  const n = e.signal;
  return n && n.endsWith("(null)") ? {
    signal: n.slice(0, -6) + t.signal
  } : e;
};
function Vo(e, t, n, i) {
  let r;
  if (t && Y(t, e))
    return t[e];
  if (Y(n, e))
    return n[e];
  if (e.startsWith("title")) {
    switch (e) {
      case "titleColor":
        r = "fill";
        break;
      case "titleFont":
      case "titleFontSize":
      case "titleFontWeight":
        r = e[5].toLowerCase() + e.slice(6);
    }
    return i[AE][r];
  } else if (e.startsWith("label")) {
    switch (e) {
      case "labelColor":
        r = "fill";
        break;
      case "labelFont":
      case "labelFontSize":
        r = e[5].toLowerCase() + e.slice(6);
    }
    return i[Sd][r];
  }
  return null;
}
function c4(e) {
  const t = {};
  for (const n of e)
    if (n)
      for (const i in n)
        t[i] = 1;
  return Object.keys(t);
}
function kue(e, t) {
  var n = t.config, i = n.style, r = n.axis, a = t.scaleType(e.scale) === "band" && n.axisBand, s = e.orient, o, u, l;
  if (rt(s)) {
    const f = c4([n.axisX, n.axisY]), d = c4([n.axisTop, n.axisBottom, n.axisLeft, n.axisRight]);
    o = {};
    for (l of f)
      o[l] = ht(s, Vo(l, n.axisX, r, i), Vo(l, n.axisY, r, i));
    u = {};
    for (l of d)
      u[l] = Sue(s.signal, Vo(l, n.axisTop, r, i), Vo(l, n.axisBottom, r, i), Vo(l, n.axisLeft, r, i), Vo(l, n.axisRight, r, i));
  } else
    o = s === zi || s === Ka ? n.axisX : n.axisY, u = n["axis" + s[0].toUpperCase() + s.slice(1)];
  return o || u || a ? ue({}, r, o, u, a) : r;
}
function Cue(e, t, n, i) {
  const r = kn(e, t), a = e.orient;
  let s, o;
  const u = {
    enter: s = {
      opacity: me
    },
    update: o = {
      opacity: Qn
    },
    exit: {
      opacity: me
    }
  };
  Ct(u, {
    stroke: r("domainColor"),
    strokeCap: r("domainCap"),
    strokeDash: r("domainDash"),
    strokeDashOffset: r("domainDashOffset"),
    strokeWidth: r("domainWidth"),
    strokeOpacity: r("domainOpacity")
  });
  const l = f4(e, 0), c = f4(e, 1);
  return s.x = o.x = ht(a, l, me), s.x2 = o.x2 = ht(a, c), s.y = o.y = Si(a, l, me), s.y2 = o.y2 = Si(a, c), In({
    type: CE,
    role: Kae,
    from: i,
    encode: u
  }, n);
}
function f4(e, t) {
  return {
    scale: e.scale,
    range: t
  };
}
function _ue(e, t, n, i, r) {
  const a = kn(e, t), s = e.orient, o = e.gridScale, u = mm(s, 1, -1), l = Fue(e.offset, u);
  let c, f, d;
  const h = {
    enter: c = {
      opacity: me
    },
    update: d = {
      opacity: Qn
    },
    exit: f = {
      opacity: me
    }
  };
  Ct(h, {
    stroke: a("gridColor"),
    strokeCap: a("gridCap"),
    strokeDash: a("gridDash"),
    strokeDashOffset: a("gridDashOffset"),
    strokeOpacity: a("gridOpacity"),
    strokeWidth: a("gridWidth")
  });
  const p = {
    scale: e.scale,
    field: Jn,
    band: r.band,
    extra: r.extra,
    offset: r.offset,
    round: a("tickRound")
  }, g = ht(s, {
    signal: "height"
  }, {
    signal: "width"
  }), m = o ? {
    scale: o,
    range: 0,
    mult: u,
    offset: l
  } : {
    value: 0,
    offset: l
  }, y = o ? {
    scale: o,
    range: 1,
    mult: u,
    offset: l
  } : ue(g, {
    mult: u,
    offset: l
  });
  return c.x = d.x = ht(s, p, m), c.y = d.y = Si(s, p, m), c.x2 = d.x2 = Si(s, y), c.y2 = d.y2 = ht(s, y), f.x = ht(s, p), f.y = Si(s, p), In({
    type: CE,
    role: Jae,
    key: Jn,
    from: i,
    encode: h
  }, n);
}
function Fue(e, t) {
  if (t !== 1)
    if (!X(e))
      e = rt(t) ? {
        signal: `(${t.signal}) * (${e || 0})`
      } : t * (e || 0);
    else {
      let n = e = ue({}, e);
      for (; n.mult != null; )
        if (X(n.mult))
          n = n.mult = ue({}, n.mult);
        else
          return n.mult = rt(t) ? {
            signal: `(${n.mult}) * (${t.signal})`
          } : n.mult * t, e;
      n.mult = t;
    }
  return e;
}
function Mue(e, t, n, i, r, a) {
  const s = kn(e, t), o = e.orient, u = mm(o, -1, 1);
  let l, c, f;
  const d = {
    enter: l = {
      opacity: me
    },
    update: f = {
      opacity: Qn
    },
    exit: c = {
      opacity: me
    }
  };
  Ct(d, {
    stroke: s("tickColor"),
    strokeCap: s("tickCap"),
    strokeDash: s("tickDash"),
    strokeDashOffset: s("tickDashOffset"),
    strokeOpacity: s("tickOpacity"),
    strokeWidth: s("tickWidth")
  });
  const h = dt(r);
  h.mult = u;
  const p = {
    scale: e.scale,
    field: Jn,
    band: a.band,
    extra: a.extra,
    offset: a.offset,
    round: s("tickRound")
  };
  return f.y = l.y = ht(o, me, p), f.y2 = l.y2 = ht(o, h), c.x = ht(o, p), f.x = l.x = Si(o, me, p), f.x2 = l.x2 = Si(o, h), c.y = Si(o, p), In({
    type: CE,
    role: Zae,
    key: Jn,
    from: i,
    encode: d
  }, n);
}
function fy(e, t, n, i, r) {
  return {
    signal: 'flush(range("' + e + '"), scale("' + e + '", datum.value), ' + t + "," + n + "," + i + "," + r + ")"
  };
}
function Oue(e, t, n, i, r, a) {
  const s = kn(e, t), o = e.orient, u = e.scale, l = mm(o, -1, 1), c = Ks(s("labelFlush")), f = Ks(s("labelFlushOffset")), d = s("labelAlign"), h = s("labelBaseline");
  let p = c === 0 || !!c, g;
  const m = dt(r);
  m.mult = l, m.offset = dt(s("labelPadding") || 0), m.offset.mult = l;
  const y = {
    scale: u,
    field: Jn,
    band: 0.5,
    offset: gR(a.offset, s("labelOffset"))
  }, b = ht(o, p ? fy(u, c, '"left"', '"right"', '"center"') : {
    value: "center"
  }, bue(o, "left", "right")), v = ht(o, $R(o, "bottom", "top"), p ? fy(u, c, '"top"', '"bottom"', '"middle"') : {
    value: "middle"
  }), x = fy(u, c, `-(${f})`, f, 0);
  p = p && f;
  const w = {
    opacity: me,
    x: ht(o, y, m),
    y: Si(o, y, m)
  }, E = {
    enter: w,
    update: g = {
      opacity: Qn,
      text: {
        field: SE
      },
      x: w.x,
      y: w.y,
      align: b,
      baseline: v
    },
    exit: {
      opacity: me,
      x: w.x,
      y: w.y
    }
  };
  Ct(E, {
    dx: !d && p ? ht(o, x) : null,
    dy: !h && p ? Si(o, x) : null
  }), Ct(E, {
    angle: s("labelAngle"),
    fill: s("labelColor"),
    fillOpacity: s("labelOpacity"),
    font: s("labelFont"),
    fontSize: s("labelFontSize"),
    fontWeight: s("labelFontWeight"),
    fontStyle: s("labelFontStyle"),
    limit: s("labelLimit"),
    lineHeight: s("labelLineHeight")
  }, {
    align: d,
    baseline: h
  });
  const $ = s("labelBound");
  let S = s("labelOverlap");
  return S = S || $ ? {
    separation: s("labelSeparation"),
    method: S,
    order: "datum.index",
    bound: $ ? {
      scale: u,
      orient: o,
      tolerance: $
    } : null
  } : void 0, g.align !== b && (g.align = lu(g.align, b)), g.baseline !== v && (g.baseline = lu(g.baseline, v)), In({
    type: Mo,
    role: Qae,
    style: Sd,
    key: Jn,
    from: i,
    encode: E,
    overlap: S
  }, n);
}
function Rue(e, t, n, i) {
  const r = kn(e, t), a = e.orient, s = mm(a, -1, 1);
  let o, u;
  const l = {
    enter: o = {
      opacity: me,
      anchor: dt(r("titleAnchor", null)),
      align: {
        signal: _E
      }
    },
    update: u = ue({}, o, {
      opacity: Qn,
      text: dt(e.title)
    }),
    exit: {
      opacity: me
    }
  }, c = {
    signal: `lerp(range("${e.scale}"), ${hm(0, 1, 0.5)})`
  };
  return u.x = ht(a, c), u.y = Si(a, c), o.angle = ht(a, me, Aue(s, 90)), o.baseline = ht(a, $R(a, Ka, zi), {
    value: Ka
  }), u.angle = o.angle, u.baseline = o.baseline, Ct(l, {
    fill: r("titleColor"),
    fillOpacity: r("titleOpacity"),
    font: r("titleFont"),
    fontSize: r("titleFontSize"),
    fontStyle: r("titleFontStyle"),
    fontWeight: r("titleFontWeight"),
    limit: r("titleLimit"),
    lineHeight: r("titleLineHeight")
  }, {
    // require update
    align: r("titleAlign"),
    angle: r("titleAngle"),
    baseline: r("titleBaseline")
  }), Tue(r, a, l, n), l.update.align = lu(l.update.align, o.align), l.update.angle = lu(l.update.angle, o.angle), l.update.baseline = lu(l.update.baseline, o.baseline), In({
    type: Mo,
    role: ese,
    style: AE,
    from: i,
    encode: l
  }, n);
}
function Tue(e, t, n, i) {
  const r = (o, u) => o != null ? (n.update[u] = lu(dt(o), n.update[u]), !1) : !eu(u, i), a = r(e("titleX"), "x"), s = r(e("titleY"), "y");
  n.enter.auto = s === a ? dt(s) : ht(t, dt(s), dt(a));
}
function Due(e, t) {
  const n = kue(e, t), i = e.encode || {}, r = i.axis || {}, a = r.name || void 0, s = r.interactive, o = r.style, u = kn(e, n), l = Moe(u), c = {
    scale: e.scale,
    ticks: !!u("ticks"),
    labels: !!u("labels"),
    grid: !!u("grid"),
    domain: !!u("domain"),
    title: e.title != null
  }, f = Z(t.add(Pi({}, [c]))), d = Z(t.add(Nse({
    scale: t.scaleRef(e.scale),
    extra: t.property(l.extra),
    count: t.objectProperty(e.tickCount),
    values: t.objectProperty(e.values),
    minstep: t.property(e.tickMinStep),
    formatType: t.property(e.formatType),
    formatSpecifier: t.property(e.format)
  }))), h = [];
  let p;
  return c.grid && h.push(_ue(e, n, i.grid, d, l)), c.ticks && (p = u("tickSize"), h.push(Mue(e, n, i.ticks, d, p, l))), c.labels && (p = c.ticks ? p : 0, h.push(Oue(e, n, i.labels, d, p, l))), c.domain && h.push(Cue(e, n, i.domain, f)), c.title && h.push(Rue(e, n, i.title, f)), gm(mf({
    role: Yae,
    from: f,
    encode: ml(Nue(u, e), r, Ad),
    marks: h,
    aria: u("aria"),
    description: u("description"),
    zindex: u("zindex"),
    name: a,
    interactive: s,
    style: o
  }), t);
}
function Nue(e, t) {
  const n = {
    enter: {},
    update: {}
  };
  return Ct(n, {
    orient: e("orient"),
    offset: e("offset") || 0,
    position: hi(t.position, 0),
    titlePadding: e("titlePadding"),
    minExtent: e("minExtent"),
    maxExtent: e("maxExtent"),
    range: {
      signal: `abs(span(range("${t.scale}")))`
    },
    translate: e("translate"),
    // accessibility support
    format: t.format,
    formatType: t.formatType
  }), n;
}
function ER(e, t, n) {
  const i = G(e.signals), r = G(e.scales);
  return n || i.forEach((a) => tR(a, t)), G(e.projections).forEach((a) => hoe(a, t)), r.forEach((a) => toe(a, t)), G(e.data).forEach((a) => mue(a, t)), r.forEach((a) => noe(a, t)), (n || i).forEach((a) => Dse(a, t)), G(e.axes).forEach((a) => Due(a, t)), G(e.marks).forEach((a) => gm(a, t)), G(e.legends).forEach((a) => rue(a, t)), e.title && fue(e.title, t), t.parseLambdas(), t;
}
const Lue = (e) => ml({
  enter: {
    x: {
      value: 0
    },
    y: {
      value: 0
    }
  },
  update: {
    width: {
      signal: "width"
    },
    height: {
      signal: "height"
    }
  }
}, e);
function Pue(e, t) {
  const n = t.config, i = Z(t.root = t.add(bg())), r = zue(e, n);
  r.forEach((l) => tR(l, t)), t.description = e.description || n.description, t.eventConfig = n.events, t.legends = t.objectProperty(n.legend && n.legend.layout), t.locale = n.locale;
  const a = t.add(Pi()), s = t.add(rR(eR(Lue(e.encode), dm, xE, e.style, t, {
    pulse: Z(a)
  }))), o = t.add(oR({
    layout: t.objectProperty(e.layout),
    legends: t.legends,
    autosize: t.signalRef("autosize"),
    mark: i,
    pulse: Z(s)
  }));
  t.operators.pop(), t.pushState(Z(s), Z(o), null), ER(e, t, r), t.operators.push(o);
  let u = t.add(iR({
    mark: i,
    pulse: Z(o)
  }));
  return u = t.add(sR({
    pulse: Z(u)
  })), u = t.add(Fo({
    pulse: Z(u)
  })), t.addData("root", new co(t, a, a, u)), t;
}
function ql(e, t) {
  return t && t.signal ? {
    name: e,
    update: t.signal
  } : {
    name: e,
    value: t
  };
}
function zue(e, t) {
  const n = (s) => hi(e[s], t[s]), i = [ql("background", n("background")), ql("autosize", Hae(n("autosize"))), ql("padding", Xae(n("padding"))), ql("width", n("width") || 0), ql("height", n("height") || 0)], r = i.reduce((s, o) => (s[o.name] = o, s), {}), a = {};
  return G(e.signals).forEach((s) => {
    Y(r, s.name) ? s = ue(r[s.name], s) : i.push(s), a[s.name] = s;
  }), G(t.signals).forEach((s) => {
    !Y(a, s.name) && !Y(r, s.name) && i.push(s);
  }), i;
}
function SR(e, t) {
  this.config = e || {}, this.options = t || {}, this.bindings = [], this.field = {}, this.signals = {}, this.lambdas = {}, this.scales = {}, this.events = {}, this.data = {}, this.streams = [], this.updates = [], this.operators = [], this.eventConfig = null, this.locale = null, this._id = 0, this._subid = 0, this._nextsub = [0], this._parent = [], this._encode = [], this._lookup = [], this._markpath = [];
}
function d4(e) {
  this.config = e.config, this.options = e.options, this.legends = e.legends, this.field = Object.create(e.field), this.signals = Object.create(e.signals), this.lambdas = Object.create(e.lambdas), this.scales = Object.create(e.scales), this.events = Object.create(e.events), this.data = Object.create(e.data), this.streams = [], this.updates = [], this.operators = [], this._id = 0, this._subid = ++e._nextsub[0], this._nextsub = e._nextsub, this._parent = e._parent.slice(), this._encode = e._encode.slice(), this._lookup = e._lookup.slice(), this._markpath = e._markpath;
}
SR.prototype = d4.prototype = {
  parse(e) {
    return ER(e, this);
  },
  fork() {
    return new d4(this);
  },
  isSubscope() {
    return this._subid > 0;
  },
  toRuntime() {
    return this.finish(), {
      description: this.description,
      operators: this.operators,
      streams: this.streams,
      updates: this.updates,
      bindings: this.bindings,
      eventConfig: this.eventConfig,
      locale: this.locale
    };
  },
  id() {
    return (this._subid ? this._subid + ":" : 0) + this._id++;
  },
  add(e) {
    return this.operators.push(e), e.id = this.id(), e.refs && (e.refs.forEach((t) => {
      t.$ref = e.id;
    }), e.refs = null), e;
  },
  proxy(e) {
    const t = e instanceof yv ? Z(e) : e;
    return this.add(Yse({
      value: t
    }));
  },
  addStream(e) {
    return this.streams.push(e), e.id = this.id(), e;
  },
  addUpdate(e) {
    return this.updates.push(e), e;
  },
  // Apply metadata
  finish() {
    let e, t;
    this.root && (this.root.root = !0);
    for (e in this.signals)
      this.signals[e].signal = e;
    for (e in this.scales)
      this.scales[e].scale = e;
    function n(i, r, a) {
      let s, o;
      i && (s = i.data || (i.data = {}), o = s[r] || (s[r] = []), o.push(a));
    }
    for (e in this.data) {
      t = this.data[e], n(t.input, e, "input"), n(t.output, e, "output"), n(t.values, e, "values");
      for (const i in t.index)
        n(t.index[i], e, "index:" + i);
    }
    return this;
  },
  // ----
  pushState(e, t, n) {
    this._encode.push(Z(this.add(Fo({
      pulse: e
    })))), this._parent.push(t), this._lookup.push(n ? Z(this.proxy(n)) : null), this._markpath.push(-1);
  },
  popState() {
    this._encode.pop(), this._parent.pop(), this._lookup.pop(), this._markpath.pop();
  },
  parent() {
    return ae(this._parent);
  },
  encode() {
    return ae(this._encode);
  },
  lookup() {
    return ae(this._lookup);
  },
  markpath() {
    const e = this._markpath;
    return ++e[e.length - 1];
  },
  // ----
  fieldRef(e, t) {
    if (V(e))
      return pf(e, t);
    e.signal || D("Unsupported field reference: " + U(e));
    const n = e.signal;
    let i = this.field[n];
    if (!i) {
      const r = {
        name: this.signalRef(n)
      };
      t && (r.as = t), this.field[n] = i = Z(this.add(Ise(r)));
    }
    return i;
  },
  compareRef(e) {
    let t = !1;
    const n = (a) => rt(a) ? (t = !0, this.signalRef(a.signal)) : Sse(a) ? (t = !0, this.exprRef(a.expr)) : a, i = G(e.field).map(n), r = G(e.order).map(n);
    return t ? Z(this.add(QA({
      fields: i,
      orders: r
    }))) : KA(i, r);
  },
  keyRef(e, t) {
    let n = !1;
    const i = (a) => rt(a) ? (n = !0, Z(r[a.signal])) : a, r = this.signals;
    return e = G(e).map(i), n ? Z(this.add(Bse({
      fields: e,
      flat: t
    }))) : xse(e, t);
  },
  sortRef(e) {
    if (!e)
      return e;
    const t = cm(e.op, e.field), n = e.order || $se;
    return n.signal ? Z(this.add(QA({
      fields: t,
      orders: this.signalRef(n.signal)
    }))) : KA(t, n);
  },
  // ----
  event(e, t) {
    const n = e + ":" + t;
    if (!this.events[n]) {
      const i = this.id();
      this.streams.push({
        id: i,
        source: e,
        type: t
      }), this.events[n] = i;
    }
    return this.events[n];
  },
  // ----
  hasOwnSignal(e) {
    return Y(this.signals, e);
  },
  addSignal(e, t) {
    this.hasOwnSignal(e) && D("Duplicate signal name: " + U(e));
    const n = t instanceof yv ? t : this.add(bg(t));
    return this.signals[e] = n;
  },
  getSignal(e) {
    return this.signals[e] || D("Unrecognized signal name: " + U(e)), this.signals[e];
  },
  signalRef(e) {
    return this.signals[e] ? Z(this.signals[e]) : (Y(this.lambdas, e) || (this.lambdas[e] = this.add(bg(null))), Z(this.lambdas[e]));
  },
  parseLambdas() {
    const e = Object.keys(this.lambdas);
    for (let t = 0, n = e.length; t < n; ++t) {
      const i = e[t], r = hr(i, this), a = this.lambdas[i];
      a.params = r.$params, a.update = r.$expr;
    }
  },
  property(e) {
    return e && e.signal ? this.signalRef(e.signal) : e;
  },
  objectProperty(e) {
    return !e || !X(e) ? e : this.signalRef(e.signal || TE(e));
  },
  exprRef(e, t) {
    const n = {
      expr: hr(e, this)
    };
    return t && (n.expr.$name = t), Z(this.add(Pse(n)));
  },
  addBinding(e, t) {
    this.bindings || D("Nested signals do not support binding: " + U(e)), this.bindings.push(ue({
      signal: e
    }, t));
  },
  // ----
  addScaleProj(e, t) {
    Y(this.scales, e) && D("Duplicate scale or projection name: " + U(e)), this.scales[e] = this.add(t);
  },
  addScale(e, t) {
    this.addScaleProj(e, Jse(t));
  },
  addProjection(e, t) {
    this.addScaleProj(e, Xse(t));
  },
  getScale(e) {
    return this.scales[e] || D("Unrecognized scale name: " + U(e)), this.scales[e];
  },
  scaleRef(e) {
    return Z(this.getScale(e));
  },
  scaleType(e) {
    return this.getScale(e).params.type;
  },
  projectionRef(e) {
    return this.scaleRef(e);
  },
  projectionType(e) {
    return this.scaleType(e);
  },
  // ----
  addData(e, t) {
    return Y(this.data, e) && D("Duplicate data set name: " + U(e)), this.data[e] = t;
  },
  getData(e) {
    return this.data[e] || D("Undefined data set name: " + U(e)), this.data[e];
  },
  addDataPipeline(e, t) {
    return Y(this.data, e) && D("Duplicate data set name: " + U(e)), this.addData(e, co.fromEntries(this, t));
  }
};
function TE(e) {
  return (R(e) ? Iue : Bue)(e);
}
function Iue(e) {
  const t = e.length;
  let n = "[";
  for (let i = 0; i < t; ++i) {
    const r = e[i];
    n += (i > 0 ? "," : "") + (X(r) ? r.signal || TE(r) : U(r));
  }
  return n + "]";
}
function Bue(e) {
  let t = "{", n = 0, i, r;
  for (i in e)
    r = e[i], t += (++n > 1 ? "," : "") + U(i) + ":" + (X(r) ? r.signal || TE(r) : U(r));
  return t + "}";
}
function jue() {
  const e = "sans-serif", i = "#4c78a8", r = "#000", a = "#888", s = "#ddd";
  return {
    // default visualization description
    description: "Vega visualization",
    // default padding around visualization
    padding: 0,
    // default for automatic sizing; options: 'none', 'pad', 'fit'
    // or provide an object (e.g., {'type': 'pad', 'resize': true})
    autosize: "pad",
    // default view background color
    // covers the entire view component
    background: null,
    // default event handling configuration
    // preventDefault for view-sourced event types except 'wheel'
    events: {
      defaults: {
        allow: ["wheel"]
      }
    },
    // defaults for top-level group marks
    // accepts mark properties (fill, stroke, etc)
    // covers the data rectangle within group width/height
    group: null,
    // defaults for basic mark types
    // each subset accepts mark properties (fill, stroke, etc)
    mark: null,
    arc: {
      fill: i
    },
    area: {
      fill: i
    },
    image: null,
    line: {
      stroke: i,
      strokeWidth: 2
    },
    path: {
      stroke: i
    },
    rect: {
      fill: i
    },
    rule: {
      stroke: r
    },
    shape: {
      stroke: i
    },
    symbol: {
      fill: i,
      size: 64
    },
    text: {
      fill: r,
      font: e,
      fontSize: 11
    },
    trail: {
      fill: i,
      size: 2
    },
    // style definitions
    style: {
      // axis & legend labels
      "guide-label": {
        fill: r,
        font: e,
        fontSize: 10
      },
      // axis & legend titles
      "guide-title": {
        fill: r,
        font: e,
        fontSize: 11,
        fontWeight: "bold"
      },
      // headers, including chart title
      "group-title": {
        fill: r,
        font: e,
        fontSize: 13,
        fontWeight: "bold"
      },
      // chart subtitle
      "group-subtitle": {
        fill: r,
        font: e,
        fontSize: 12
      },
      // defaults for styled point marks in Vega-Lite
      point: {
        size: 30,
        strokeWidth: 2,
        shape: "circle"
      },
      circle: {
        size: 30,
        strokeWidth: 2
      },
      square: {
        size: 30,
        strokeWidth: 2,
        shape: "square"
      },
      // defaults for styled group marks in Vega-Lite
      cell: {
        fill: "transparent",
        stroke: s
      },
      view: {
        fill: "transparent"
      }
    },
    // defaults for title
    title: {
      orient: "top",
      anchor: "middle",
      offset: 4,
      subtitlePadding: 3
    },
    // defaults for axes
    axis: {
      minExtent: 0,
      maxExtent: 200,
      bandPosition: 0.5,
      domain: !0,
      domainWidth: 1,
      domainColor: a,
      grid: !1,
      gridWidth: 1,
      gridColor: s,
      labels: !0,
      labelAngle: 0,
      labelLimit: 180,
      labelOffset: 0,
      labelPadding: 2,
      ticks: !0,
      tickColor: a,
      tickOffset: 0,
      tickRound: !0,
      tickSize: 5,
      tickWidth: 1,
      titlePadding: 4
    },
    // correction for centering bias
    axisBand: {
      tickOffset: -0.5
    },
    // defaults for cartographic projection
    projection: {
      type: "mercator"
    },
    // defaults for legends
    legend: {
      orient: "right",
      padding: 0,
      gridAlign: "each",
      columnPadding: 10,
      rowPadding: 2,
      symbolDirection: "vertical",
      gradientDirection: "vertical",
      gradientLength: 200,
      gradientThickness: 16,
      gradientStrokeColor: s,
      gradientStrokeWidth: 0,
      gradientLabelOffset: 2,
      labelAlign: "left",
      labelBaseline: "middle",
      labelLimit: 160,
      labelOffset: 4,
      labelOverlap: !0,
      symbolLimit: 30,
      symbolType: "circle",
      symbolSize: 100,
      symbolOffset: 0,
      symbolStrokeWidth: 1.5,
      symbolBaseFillColor: "transparent",
      symbolBaseStrokeColor: a,
      titleLimit: 180,
      titleOrient: "top",
      titlePadding: 5,
      layout: {
        offset: 18,
        direction: "horizontal",
        left: {
          direction: "vertical"
        },
        right: {
          direction: "vertical"
        }
      }
    },
    // defaults for scale ranges
    range: {
      category: {
        scheme: "tableau10"
      },
      ordinal: {
        scheme: "blues"
      },
      heatmap: {
        scheme: "yellowgreenblue"
      },
      ramp: {
        scheme: "blues"
      },
      diverging: {
        scheme: "blueorange",
        extent: [1, 0]
      },
      symbol: ["circle", "square", "triangle-up", "cross", "diamond", "triangle-right", "triangle-down", "triangle-left"]
    }
  };
}
function Uue(e, t, n) {
  return X(e) || D("Input Vega specification must be an object."), t = el(jue(), t, e.config), Pue(e, new SR(t, n)).toRuntime();
}
var que = "5.26.1";
ue($u, zq, DV, dX, qX, KX, EY, nY, AY, FY, IY, HY);
const Gue = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Bounds: $n,
  CanvasHandler: Fu,
  CanvasRenderer: uf,
  DATE: xn,
  DAY: Dt,
  DAYOFYEAR: fr,
  Dataflow: uu,
  Debug: V9,
  Error: $2,
  EventStream: p0,
  Gradient: LK,
  GroupItem: lw,
  HOURS: Nn,
  Handler: Ya,
  HybridHandler: Dw,
  HybridRenderer: og,
  Info: H9,
  Item: uw,
  MILLISECONDS: _i,
  MINUTES: Ln,
  MONTH: zt,
  Marks: Mi,
  MultiPulse: ix,
  None: W9,
  Operator: Me,
  Parameters: h0,
  Pulse: Da,
  QUARTER: vn,
  RenderType: fZ,
  Renderer: jn,
  ResourceLoader: cw,
  SECONDS: ei,
  SVGHandler: Cw,
  SVGRenderer: K0,
  SVGStringRenderer: Tw,
  Scenegraph: lM,
  TIME_UNITS: B2,
  Transform: T,
  View: wO,
  WEEK: nt,
  Warn: w2,
  YEAR: Et,
  accessor: An,
  accessorFields: Pt,
  accessorName: Ve,
  array: G,
  ascending: s0,
  bandwidthNRD: ox,
  bin: D8,
  bootstrapCI: N8,
  boundClip: gZ,
  boundContext: fd,
  boundItem: Zb,
  boundMark: aM,
  boundStroke: Co,
  changeset: ko,
  clampRange: M2,
  codegenExpression: Vw,
  compare: O2,
  constant: Ut,
  cumulativeLogNormal: b0,
  cumulativeNormal: Wf,
  cumulativeUniform: w0,
  dayofyear: G2,
  debounce: R2,
  defaultLocale: Q2,
  definition: O8,
  densityLogNormal: y0,
  densityNormal: g0,
  densityUniform: $0,
  domChild: tt,
  domClear: Wn,
  domCreate: Oa,
  domFind: Aw,
  dotbin: L8,
  error: D,
  expressionFunction: Qe,
  extend: ue,
  extent: Ci,
  extentIndex: Q9,
  falsy: ha,
  fastmap: nl,
  field: At,
  flush: T2,
  font: X0,
  fontFamily: pd,
  fontSize: vr,
  format: _h,
  formatLocale: Rp,
  formats: tx,
  hasOwnProperty: Y,
  id: qf,
  identity: kt,
  inferType: x8,
  inferTypes: $8,
  ingest: $e,
  inherits: B,
  inrange: bi,
  interpolate: UM,
  interpolateColors: jM,
  interpolateRange: IZ,
  intersect: hZ,
  intersectBoxLine: au,
  intersectPath: fw,
  intersectPoint: dw,
  intersectRule: XF,
  isArray: R,
  isBoolean: Zr,
  isDate: Kn,
  isFunction: oe,
  isIterable: Z9,
  isNumber: ye,
  isObject: X,
  isRegExp: D2,
  isString: V,
  isTuple: ol,
  key: N2,
  lerp: L2,
  lineHeight: Va,
  loader: sl,
  locale: b8,
  logger: E2,
  lruCache: P2,
  markup: Rw,
  merge: e8,
  mergeConfig: el,
  multiLineOffset: $Q,
  one: Zu,
  pad: z2,
  panLinear: S2,
  panLog: A2,
  panPow: k2,
  panSymlog: C2,
  parse: Uue,
  parseExpression: Gw,
  parseSelector: ls,
  path: Cf,
  pathCurves: aw,
  pathEqual: PM,
  pathParse: rf,
  pathRectangle: qF,
  pathRender: Kp,
  pathSymbols: UF,
  pathTrail: GF,
  peek: ae,
  point: kw,
  projection: A$,
  quantileLogNormal: v0,
  quantileNormal: Hf,
  quantileUniform: E0,
  quantiles: ax,
  quantizeInterpolator: BZ,
  quarter: _2,
  quartiles: sx,
  get random() {
    return Pn;
  },
  randomInteger: UU,
  randomKDE: lx,
  randomLCG: jU,
  randomLogNormal: z8,
  randomMixture: I8,
  randomNormal: ux,
  randomUniform: B8,
  read: S8,
  regressionConstant: cx,
  regressionExp: U8,
  regressionLinear: fx,
  regressionLoess: W8,
  regressionLog: j8,
  regressionPoly: G8,
  regressionPow: q8,
  regressionQuad: dx,
  renderModule: dZ,
  repeat: rc,
  resetDefaultLocale: zj,
  resetSVGClipId: HF,
  resetSVGDefIds: bZ,
  responseType: E8,
  runtimeContext: lO,
  sampleCurve: A0,
  sampleLogNormal: m0,
  sampleNormal: Gf,
  sampleUniform: x0,
  scale: Oe,
  sceneEqual: Nw,
  sceneFromJSON: oM,
  scenePickVisit: Qp,
  sceneToJSON: sM,
  sceneVisit: Fi,
  sceneZOrder: hw,
  scheme: WM,
  serializeXML: AM,
  setHybridRendererOptions: cZ,
  setRandom: IU,
  span: il,
  splitAccessPath: br,
  stringValue: U,
  textMetrics: Pa,
  timeBin: f8,
  timeFloor: a8,
  timeFormatLocale: Hc,
  timeInterval: rl,
  timeOffset: X2,
  timeSequence: K2,
  timeUnitSpecifier: U2,
  timeUnits: j2,
  toBoolean: o0,
  toDate: u0,
  toNumber: Fe,
  toSet: an,
  toString: l0,
  transform: R8,
  transforms: $u,
  truncate: I2,
  truthy: jt,
  tupleid: ee,
  typeParsers: bb,
  utcFloor: s8,
  utcInterval: al,
  utcOffset: Y2,
  utcSequence: J2,
  utcdayofyear: H2,
  utcquarter: F2,
  utcweek: V2,
  version: que,
  visitArray: ya,
  week: W2,
  writeConfig: tl,
  zero: wa,
  zoomLinear: i0,
  zoomLog: r0,
  zoomPow: Wc,
  zoomSymlog: a0
}, Symbol.toStringTag, { value: "Module" }));
function Wue(e, t, n) {
  let i;
  t.x2 && (t.x ? (n && e.x > e.x2 && (i = e.x, e.x = e.x2, e.x2 = i), e.width = e.x2 - e.x) : e.x = e.x2 - (e.width || 0)), t.xc && (e.x = e.xc - (e.width || 0) / 2), t.y2 && (t.y ? (n && e.y > e.y2 && (i = e.y, e.y = e.y2, e.y2 = i), e.height = e.y2 - e.y) : e.y = e.y2 - (e.height || 0)), t.yc && (e.y = e.yc - (e.height || 0) / 2);
}
var Hue = {
  NaN: NaN,
  E: Math.E,
  LN2: Math.LN2,
  LN10: Math.LN10,
  LOG2E: Math.LOG2E,
  LOG10E: Math.LOG10E,
  PI: Math.PI,
  SQRT1_2: Math.SQRT1_2,
  SQRT2: Math.SQRT2,
  MIN_VALUE: Number.MIN_VALUE,
  MAX_VALUE: Number.MAX_VALUE
}, Vue = {
  "*": (e, t) => e * t,
  "+": (e, t) => e + t,
  "-": (e, t) => e - t,
  "/": (e, t) => e / t,
  "%": (e, t) => e % t,
  ">": (e, t) => e > t,
  "<": (e, t) => e < t,
  "<=": (e, t) => e <= t,
  ">=": (e, t) => e >= t,
  "==": (e, t) => e == t,
  "!=": (e, t) => e != t,
  "===": (e, t) => e === t,
  "!==": (e, t) => e !== t,
  "&": (e, t) => e & t,
  "|": (e, t) => e | t,
  "^": (e, t) => e ^ t,
  "<<": (e, t) => e << t,
  ">>": (e, t) => e >> t,
  ">>>": (e, t) => e >>> t
}, Xue = {
  "+": (e) => +e,
  "-": (e) => -e,
  "~": (e) => ~e,
  "!": (e) => !e
};
const Yue = Array.prototype.slice, xs = (e, t, n) => {
  const i = n ? n(t[0]) : t[0];
  return i[e].apply(i, Yue.call(t, 1));
}, Kue = (e, t, n, i, r, a, s) => new Date(e, t || 0, n ?? 1, i || 0, r || 0, a || 0, s || 0);
var Jue = {
  // math functions
  isNaN: Number.isNaN,
  isFinite: Number.isFinite,
  abs: Math.abs,
  acos: Math.acos,
  asin: Math.asin,
  atan: Math.atan,
  atan2: Math.atan2,
  ceil: Math.ceil,
  cos: Math.cos,
  exp: Math.exp,
  floor: Math.floor,
  log: Math.log,
  max: Math.max,
  min: Math.min,
  pow: Math.pow,
  random: Math.random,
  round: Math.round,
  sin: Math.sin,
  sqrt: Math.sqrt,
  tan: Math.tan,
  clamp: (e, t, n) => Math.max(t, Math.min(n, e)),
  // date functions
  now: Date.now,
  utc: Date.UTC,
  datetime: Kue,
  date: (e) => new Date(e).getDate(),
  day: (e) => new Date(e).getDay(),
  year: (e) => new Date(e).getFullYear(),
  month: (e) => new Date(e).getMonth(),
  hours: (e) => new Date(e).getHours(),
  minutes: (e) => new Date(e).getMinutes(),
  seconds: (e) => new Date(e).getSeconds(),
  milliseconds: (e) => new Date(e).getMilliseconds(),
  time: (e) => new Date(e).getTime(),
  timezoneoffset: (e) => new Date(e).getTimezoneOffset(),
  utcdate: (e) => new Date(e).getUTCDate(),
  utcday: (e) => new Date(e).getUTCDay(),
  utcyear: (e) => new Date(e).getUTCFullYear(),
  utcmonth: (e) => new Date(e).getUTCMonth(),
  utchours: (e) => new Date(e).getUTCHours(),
  utcminutes: (e) => new Date(e).getUTCMinutes(),
  utcseconds: (e) => new Date(e).getUTCSeconds(),
  utcmilliseconds: (e) => new Date(e).getUTCMilliseconds(),
  // sequence functions
  length: (e) => e.length,
  join: function() {
    return xs("join", arguments);
  },
  indexof: function() {
    return xs("indexOf", arguments);
  },
  lastindexof: function() {
    return xs("lastIndexOf", arguments);
  },
  slice: function() {
    return xs("slice", arguments);
  },
  reverse: (e) => e.slice().reverse(),
  // string functions
  parseFloat,
  parseInt,
  upper: (e) => String(e).toUpperCase(),
  lower: (e) => String(e).toLowerCase(),
  substring: function() {
    return xs("substring", arguments, String);
  },
  split: function() {
    return xs("split", arguments, String);
  },
  replace: function() {
    return xs("replace", arguments, String);
  },
  trim: (e) => String(e).trim(),
  // regexp functions
  regexp: RegExp,
  test: (e, t) => RegExp(e).test(t)
};
const Que = ["view", "item", "group", "xy", "x", "y"], Sv = /* @__PURE__ */ new Set([Function, eval, setTimeout, setInterval]);
typeof setImmediate == "function" && Sv.add(setImmediate);
const Zue = {
  Literal: (e, t) => t.value,
  Identifier: (e, t) => {
    const n = t.name;
    return e.memberDepth > 0 ? n : n === "datum" ? e.datum : n === "event" ? e.event : n === "item" ? e.item : Hue[n] || e.params["$" + n];
  },
  MemberExpression: (e, t) => {
    const n = !t.computed, i = e(t.object);
    n && (e.memberDepth += 1);
    const r = e(t.property);
    if (n && (e.memberDepth -= 1), Sv.has(i[r])) {
      console.error(`Prevented interpretation of member "${r}" which could lead to insecure code execution`);
      return;
    }
    return i[r];
  },
  CallExpression: (e, t) => {
    const n = t.arguments;
    let i = t.callee.name;
    return i.startsWith("_") && (i = i.slice(1)), i === "if" ? e(n[0]) ? e(n[1]) : e(n[2]) : (e.fn[i] || Jue[i]).apply(e.fn, n.map(e));
  },
  ArrayExpression: (e, t) => t.elements.map(e),
  BinaryExpression: (e, t) => Vue[t.operator](e(t.left), e(t.right)),
  UnaryExpression: (e, t) => Xue[t.operator](e(t.argument)),
  ConditionalExpression: (e, t) => e(t.test) ? e(t.consequent) : e(t.alternate),
  LogicalExpression: (e, t) => t.operator === "&&" ? e(t.left) && e(t.right) : e(t.left) || e(t.right),
  ObjectExpression: (e, t) => t.properties.reduce((n, i) => {
    e.memberDepth += 1;
    const r = e(i.key);
    return e.memberDepth -= 1, Sv.has(e(i.value)) ? console.error(`Prevented interpretation of property "${r}" which could lead to insecure code execution`) : n[r] = e(i.value), n;
  }, {})
};
function Gl(e, t, n, i, r, a) {
  const s = (o) => Zue[o.type](s, o);
  return s.memberDepth = 0, s.fn = Object.create(t), s.params = n, s.datum = i, s.event = r, s.item = a, Que.forEach((o) => s.fn[o] = function() {
    return r.vega[o](...arguments);
  }), s(e);
}
var ele = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator(e, t) {
    const n = t.ast, i = e.functions;
    return (r) => Gl(n, i, r);
  },
  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter(e, t) {
    const n = t.ast, i = e.functions;
    return (r, a) => Gl(n, i, a, r);
  },
  /**
   * Parse an expression applied to an event stream.
   */
  event(e, t) {
    const n = t.ast, i = e.functions;
    return (r) => Gl(n, i, void 0, void 0, r);
  },
  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler(e, t) {
    const n = t.ast, i = e.functions;
    return (r, a) => {
      const s = a.item && a.item.datum;
      return Gl(n, i, r, s, a);
    };
  },
  /**
   * Parse an expression that performs visual encoding.
   */
  encode(e, t) {
    const {
      marktype: n,
      channels: i
    } = t, r = e.functions, a = n === "group" || n === "image" || n === "rect";
    return (s, o) => {
      const u = s.datum;
      let l = 0, c;
      for (const f in i)
        c = Gl(i[f].ast, r, o, u, void 0, s), s[f] !== c && (s[f] = c, l = 1);
      return n !== "rule" && Wue(s, i, a), l;
    };
  }
};
const tle = "vega-lite", nle = 'Dominik Moritz, Kanit "Ham" Wongsuphasawat, Arvind Satyanarayan, Jeffrey Heer', ile = "5.16.3", rle = [
  "Kanit Wongsuphasawat (http://kanitw.yellowpigz.com)",
  "Dominik Moritz (https://www.domoritz.de)",
  "Arvind Satyanarayan (https://arvindsatya.com)",
  "Jeffrey Heer (https://jheer.org)"
], ale = "https://vega.github.io/vega-lite/", sle = "Vega-Lite is a concise high-level language for interactive visualization.", ole = [
  "vega",
  "chart",
  "visualization"
], ule = "build/vega-lite.js", lle = "build/vega-lite.min.js", cle = "build/vega-lite.min.js", fle = "build/src/index", dle = "build/src/index.d.ts", hle = {
  vl2pdf: "./bin/vl2pdf",
  vl2png: "./bin/vl2png",
  vl2svg: "./bin/vl2svg",
  vl2vg: "./bin/vl2vg"
}, ple = [
  "bin",
  "build",
  "src",
  "vega-lite*",
  "tsconfig.json"
], gle = {
  changelog: "conventional-changelog -p angular -r 2",
  prebuild: "yarn clean:build",
  build: "yarn build:only",
  "build:only": "tsc -p tsconfig.build.json && rollup -c",
  "prebuild:examples": "yarn build:only",
  "build:examples": "yarn data && TZ=America/Los_Angeles scripts/build-examples.sh",
  "prebuild:examples-full": "yarn build:only",
  "build:examples-full": "TZ=America/Los_Angeles scripts/build-examples.sh 1",
  "build:example": "TZ=America/Los_Angeles scripts/build-example.sh",
  "build:toc": "yarn build:jekyll && scripts/generate-toc",
  "build:site": "rollup -c site/rollup.config.mjs",
  "build:jekyll": "pushd site && bundle exec jekyll build -q && popd",
  "build:versions": "scripts/update-version.sh",
  clean: "yarn clean:build && del-cli 'site/data/*' 'examples/compiled/*.png' && find site/examples ! -name 'index.md' ! -name 'data' -type f -delete",
  "clean:build": "del-cli 'build/*' !build/vega-lite-schema.json",
  data: "rsync -r node_modules/vega-datasets/data/* site/data",
  schema: "mkdir -p build && ts-json-schema-generator -f tsconfig.json -p src/index.ts -t TopLevelSpec --no-type-check --no-ref-encode > build/vega-lite-schema.json && yarn renameschema && cp build/vega-lite-schema.json site/_data/",
  renameschema: "scripts/rename-schema.sh",
  presite: "yarn data && yarn schema && yarn build:site && yarn build:versions && scripts/create-example-pages.sh",
  site: "yarn site:only",
  "site:only": "pushd site && bundle exec jekyll serve -I -l && popd",
  prettierbase: "prettier '**/*.{md,css,yml}'",
  format: "eslint . --fix && yarn prettierbase --write",
  lint: "eslint . && yarn prettierbase --check",
  jest: "NODE_OPTIONS=--experimental-vm-modules npx jest",
  test: "yarn jest test/ && yarn lint && yarn schema && yarn jest examples/ && yarn test:runtime",
  "test:cover": "yarn jest --collectCoverage test/",
  "test:inspect": "node --inspect-brk --experimental-vm-modules ./node_modules/.bin/jest --runInBand test",
  "test:runtime": "NODE_OPTIONS=--experimental-vm-modules TZ=America/Los_Angeles npx jest test-runtime/ --config test-runtime/jest-config.json",
  "test:runtime:generate": "yarn build:only && del-cli test-runtime/resources && VL_GENERATE_TESTS=true yarn test:runtime",
  watch: "tsc -p tsconfig.build.json -w",
  "watch:site": "yarn build:site -w",
  "watch:test": "yarn jest --watch test/",
  "watch:test:runtime": "NODE_OPTIONS=--experimental-vm-modules TZ=America/Los_Angeles npx jest --watch test-runtime/ --config test-runtime/jest-config.json",
  release: "release-it"
}, mle = {
  type: "git",
  url: "https://github.com/vega/vega-lite.git"
}, yle = "BSD-3-Clause", ble = {
  url: "https://github.com/vega/vega-lite/issues"
}, vle = {
  "@babel/core": "^7.22.10",
  "@babel/plugin-proposal-class-properties": "^7.18.6",
  "@babel/preset-env": "^7.22.10",
  "@babel/preset-typescript": "^7.22.5",
  "@release-it/conventional-changelog": "^7.0.0",
  "@rollup/plugin-alias": "^5.0.0",
  "@rollup/plugin-babel": "^6.0.3",
  "@rollup/plugin-commonjs": "^25.0.4",
  "@rollup/plugin-json": "^6.0.0",
  "@rollup/plugin-node-resolve": "^15.2.1",
  "@rollup/plugin-terser": "^0.4.3",
  "@types/chai": "^4.3.5",
  "@types/d3": "^7.4.0",
  "@types/jest": "^29.5.4",
  "@types/pako": "^2.0.0",
  "@typescript-eslint/eslint-plugin": "^6.4.1",
  "@typescript-eslint/parser": "^6.4.1",
  ajv: "^8.12.0",
  "ajv-formats": "^2.1.1",
  chai: "^4.3.7",
  cheerio: "^1.0.0-rc.12",
  "conventional-changelog-cli": "^4.0.0",
  d3: "^7.8.5",
  "del-cli": "^5.0.0",
  eslint: "^8.47.0",
  "eslint-config-prettier": "^9.0.0",
  "eslint-plugin-jest": "^27.2.3",
  "eslint-plugin-prettier": "^5.0.0",
  "fast-json-stable-stringify": "~2.1.0",
  "highlight.js": "^11.8.0",
  jest: "^29.6.3",
  "jest-dev-server": "^9.0.0",
  mkdirp: "^3.0.1",
  pako: "^2.1.0",
  prettier: "^3.0.2",
  puppeteer: "^15.0.0",
  "release-it": "^16.1.5",
  rollup: "^3.28.1",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-sourcemaps": "^0.6.3",
  serve: "^14.2.1",
  terser: "^5.19.2",
  "ts-jest": "^29.1.1",
  "ts-json-schema-generator": "^1.3.0",
  typescript: "~5.2.2",
  "vega-cli": "^5.25.0",
  "vega-datasets": "^2.7.0",
  "vega-embed": "^6.22.2",
  "vega-tooltip": "^0.33.0",
  "yaml-front-matter": "^4.1.1"
}, xle = {
  "json-stringify-pretty-compact": "~3.0.0",
  tslib: "~2.6.2",
  "vega-event-selector": "~3.0.1",
  "vega-expression": "~5.1.0",
  "vega-util": "~1.17.2",
  yargs: "~17.7.2"
}, $le = {
  vega: "^5.24.0"
}, wle = {
  node: ">=18"
}, Ele = {
  name: tle,
  author: nle,
  version: ile,
  collaborators: rle,
  homepage: ale,
  description: sle,
  keywords: ole,
  main: ule,
  unpkg: lle,
  jsdelivr: cle,
  module: fle,
  types: dle,
  bin: hle,
  files: ple,
  scripts: gle,
  repository: mle,
  license: yle,
  bugs: ble,
  devDependencies: vle,
  dependencies: xle,
  peerDependencies: $le,
  engines: wle
};
function DE(e) {
  return !!e.or;
}
function NE(e) {
  return !!e.and;
}
function LE(e) {
  return !!e.not;
}
function ep(e, t) {
  if (LE(e))
    ep(e.not, t);
  else if (NE(e))
    for (const n of e.and)
      ep(n, t);
  else if (DE(e))
    for (const n of e.or)
      ep(n, t);
  else
    t(e);
}
function cu(e, t) {
  return LE(e) ? { not: cu(e.not, t) } : NE(e) ? { and: e.and.map((n) => cu(n, t)) } : DE(e) ? { or: e.or.map((n) => cu(n, t)) } : t(e);
}
const se = structuredClone;
function AR(e) {
  throw new Error(e);
}
function Tu(e, t) {
  const n = {};
  for (const i of t)
    Y(e, i) && (n[i] = e[i]);
  return n;
}
function mn(e, t) {
  const n = { ...e };
  for (const i of t)
    delete n[i];
  return n;
}
Set.prototype.toJSON = function() {
  return `Set(${[...this].map((e) => Ce(e)).join(",")})`;
};
function he(e) {
  if (ye(e))
    return e;
  const t = V(e) ? e : Ce(e);
  if (t.length < 250)
    return t;
  let n = 0;
  for (let i = 0; i < t.length; i++) {
    const r = t.charCodeAt(i);
    n = (n << 5) - n + r, n = n & n;
  }
  return n;
}
function Av(e) {
  return e === !1 || e === null;
}
function pe(e, t) {
  return e.includes(t);
}
function fo(e, t) {
  let n = 0;
  for (const [i, r] of e.entries())
    if (t(r, i, n++))
      return !0;
  return !1;
}
function PE(e, t) {
  let n = 0;
  for (const [i, r] of e.entries())
    if (!t(r, i, n++))
      return !1;
  return !0;
}
function kR(e, ...t) {
  for (const n of t)
    Sle(e, n ?? {});
  return e;
}
function Sle(e, t) {
  for (const n of I(t))
    tl(e, n, t[n], !0);
}
function rr(e, t) {
  const n = [], i = {};
  let r;
  for (const a of e)
    r = t(a), !(r in i) && (i[r] = 1, n.push(a));
  return n;
}
function Ale(e, t) {
  const n = I(e), i = I(t);
  if (n.length !== i.length)
    return !1;
  for (const r of n)
    if (e[r] !== t[r])
      return !1;
  return !0;
}
function CR(e, t) {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
}
function zE(e, t) {
  for (const n of e)
    if (t.has(n))
      return !0;
  return !1;
}
function kv(e) {
  const t = /* @__PURE__ */ new Set();
  for (const n of e) {
    const r = br(n).map((s, o) => o === 0 ? s : `[${s}]`), a = r.map((s, o) => r.slice(0, o + 1).join(""));
    for (const s of a)
      t.add(s);
  }
  return t;
}
function IE(e, t) {
  return e === void 0 || t === void 0 ? !0 : zE(kv(e), kv(t));
}
function ke(e) {
  return I(e).length === 0;
}
const I = Object.keys, St = Object.values, Ja = Object.entries;
function yf(e) {
  return e === !0 || e === !1;
}
function Be(e) {
  const t = e.replace(/\W/g, "_");
  return (e.match(/^\d+/) ? "_" : "") + t;
}
function Nc(e, t) {
  return LE(e) ? `!(${Nc(e.not, t)})` : NE(e) ? `(${e.and.map((n) => Nc(n, t)).join(") && (")})` : DE(e) ? `(${e.or.map((n) => Nc(n, t)).join(") || (")})` : t(e);
}
function vg(e, t) {
  if (t.length === 0)
    return !0;
  const n = t.shift();
  return n in e && vg(e[n], t) && delete e[n], ke(e);
}
function kd(e) {
  return e.charAt(0).toUpperCase() + e.substr(1);
}
function BE(e, t = "datum") {
  const n = br(e), i = [];
  for (let r = 1; r <= n.length; r++) {
    const a = `[${n.slice(0, r).map(U).join("][")}]`;
    i.push(`${t}${a}`);
  }
  return i.join(" && ");
}
function _R(e, t = "datum") {
  return `${t}[${U(br(e).join("."))}]`;
}
function kle(e) {
  return e.replace(/(\[|\]|\.|'|")/g, "\\$1");
}
function ni(e) {
  return `${br(e).map(kle).join("\\.")}`;
}
function ho(e, t, n) {
  return e.replace(new RegExp(t.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&"), "g"), n);
}
function jE(e) {
  return `${br(e).join(".")}`;
}
function Du(e) {
  return e ? br(e).length : 0;
}
function Ke(...e) {
  for (const t of e)
    if (t !== void 0)
      return t;
}
let FR = 42;
function MR(e) {
  const t = ++FR;
  return e ? String(e) + t : t;
}
function Cle() {
  FR = 42;
}
function OR(e) {
  return RR(e) ? e : `__${e}`;
}
function RR(e) {
  return e.startsWith("__");
}
function bf(e) {
  if (e !== void 0)
    return (e % 360 + 360) % 360;
}
function ym(e) {
  return ye(e) ? !0 : !isNaN(e) && !isNaN(parseFloat(e));
}
const h4 = Object.getPrototypeOf(structuredClone({}));
function Tn(e, t) {
  if (e === t)
    return !0;
  if (e && t && typeof e == "object" && typeof t == "object") {
    if (e.constructor.name !== t.constructor.name)
      return !1;
    let n, i;
    if (Array.isArray(e)) {
      if (n = e.length, n != t.length)
        return !1;
      for (i = n; i-- !== 0; )
        if (!Tn(e[i], t[i]))
          return !1;
      return !0;
    }
    if (e instanceof Map && t instanceof Map) {
      if (e.size !== t.size)
        return !1;
      for (i of e.entries())
        if (!t.has(i[0]))
          return !1;
      for (i of e.entries())
        if (!Tn(i[1], t.get(i[0])))
          return !1;
      return !0;
    }
    if (e instanceof Set && t instanceof Set) {
      if (e.size !== t.size)
        return !1;
      for (i of e.entries())
        if (!t.has(i[0]))
          return !1;
      return !0;
    }
    if (ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) {
      if (n = e.length, n != t.length)
        return !1;
      for (i = n; i-- !== 0; )
        if (e[i] !== t[i])
          return !1;
      return !0;
    }
    if (e.constructor === RegExp)
      return e.source === t.source && e.flags === t.flags;
    if (e.valueOf !== Object.prototype.valueOf && e.valueOf !== h4.valueOf)
      return e.valueOf() === t.valueOf();
    if (e.toString !== Object.prototype.toString && e.toString !== h4.toString)
      return e.toString() === t.toString();
    const r = Object.keys(e);
    if (n = r.length, n !== Object.keys(t).length)
      return !1;
    for (i = n; i-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t, r[i]))
        return !1;
    for (i = n; i-- !== 0; ) {
      const a = r[i];
      if (!Tn(e[a], t[a]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Ce(e) {
  const t = [];
  return function n(i) {
    if (i && i.toJSON && typeof i.toJSON == "function" && (i = i.toJSON()), i === void 0)
      return;
    if (typeof i == "number")
      return isFinite(i) ? "" + i : "null";
    if (typeof i != "object")
      return JSON.stringify(i);
    let r, a;
    if (Array.isArray(i)) {
      for (a = "[", r = 0; r < i.length; r++)
        r && (a += ","), a += n(i[r]) || "null";
      return a + "]";
    }
    if (i === null)
      return "null";
    if (t.includes(i))
      throw new TypeError("Converting circular structure to JSON");
    const s = t.push(i) - 1, o = Object.keys(i).sort();
    for (a = "", r = 0; r < o.length; r++) {
      const u = o[r], l = n(i[u]);
      l && (a && (a += ","), a += JSON.stringify(u) + ":" + l);
    }
    return t.splice(s, 1), `{${a}}`;
  }(e);
}
const qr = "row", Gr = "column", bm = "facet", je = "x", bt = "y", Ii = "x2", wr = "y2", cs = "xOffset", vl = "yOffset", Bi = "radius", ra = "radius2", ai = "theta", aa = "theta2", ji = "latitude", Ui = "longitude", qi = "latitude2", ii = "longitude2", wn = "color", Er = "fill", Sr = "stroke", En = "shape", sa = "size", Oo = "angle", oa = "opacity", fs = "fillOpacity", ds = "strokeOpacity", hs = "strokeWidth", ps = "strokeDash", Cd = "text", Nu = "order", _d = "detail", vm = "key", po = "tooltip", xm = "href", $m = "url", wm = "description", _le = {
  x: 1,
  y: 1,
  x2: 1,
  y2: 1
}, TR = {
  theta: 1,
  theta2: 1,
  radius: 1,
  radius2: 1
};
function DR(e) {
  return e in TR;
}
const UE = {
  longitude: 1,
  longitude2: 1,
  latitude: 1,
  latitude2: 1
};
function NR(e) {
  switch (e) {
    case ji:
      return "y";
    case qi:
      return "y2";
    case Ui:
      return "x";
    case ii:
      return "x2";
  }
}
function LR(e) {
  return e in UE;
}
const Fle = I(UE), qE = {
  ..._le,
  ...TR,
  ...UE,
  xOffset: 1,
  yOffset: 1,
  // color
  color: 1,
  fill: 1,
  stroke: 1,
  // other non-position with scale
  opacity: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  strokeWidth: 1,
  strokeDash: 1,
  size: 1,
  angle: 1,
  shape: 1,
  // channels without scales
  order: 1,
  text: 1,
  detail: 1,
  key: 1,
  tooltip: 1,
  href: 1,
  url: 1,
  description: 1
};
function fu(e) {
  return e === wn || e === Er || e === Sr;
}
const PR = {
  row: 1,
  column: 1,
  facet: 1
}, Yn = I(PR), GE = {
  ...qE,
  ...PR
}, Mle = I(GE), { order: nve, detail: ive, tooltip: rve, ...Ole } = GE, { row: ave, column: sve, facet: ove, ...Rle } = Ole;
function Tle(e) {
  return !!Rle[e];
}
function zR(e) {
  return !!GE[e];
}
const Dle = [Ii, wr, qi, ii, aa, ra];
function IR(e) {
  return Ro(e) !== e;
}
function Ro(e) {
  switch (e) {
    case Ii:
      return je;
    case wr:
      return bt;
    case qi:
      return ji;
    case ii:
      return Ui;
    case aa:
      return ai;
    case ra:
      return Bi;
  }
  return e;
}
function Qa(e) {
  if (DR(e))
    switch (e) {
      case ai:
        return "startAngle";
      case aa:
        return "endAngle";
      case Bi:
        return "outerRadius";
      case ra:
        return "innerRadius";
    }
  return e;
}
function Ar(e) {
  switch (e) {
    case je:
      return Ii;
    case bt:
      return wr;
    case ji:
      return qi;
    case Ui:
      return ii;
    case ai:
      return aa;
    case Bi:
      return ra;
  }
}
function Sn(e) {
  switch (e) {
    case je:
    case Ii:
      return "width";
    case bt:
    case wr:
      return "height";
  }
}
function BR(e) {
  switch (e) {
    case je:
      return "xOffset";
    case bt:
      return "yOffset";
    case Ii:
      return "x2Offset";
    case wr:
      return "y2Offset";
    case ai:
      return "thetaOffset";
    case Bi:
      return "radiusOffset";
    case aa:
      return "theta2Offset";
    case ra:
      return "radius2Offset";
  }
}
function WE(e) {
  switch (e) {
    case je:
      return "xOffset";
    case bt:
      return "yOffset";
  }
}
function Nle(e) {
  switch (e) {
    case "xOffset":
      return "x";
    case "yOffset":
      return "y";
  }
}
const Lle = I(qE), {
  x: uve,
  y: lve,
  // x2 and y2 share the same scale as x and y
  x2: cve,
  y2: fve,
  //
  xOffset: dve,
  yOffset: hve,
  latitude: pve,
  longitude: gve,
  latitude2: mve,
  longitude2: yve,
  theta: bve,
  theta2: vve,
  radius: xve,
  radius2: $ve,
  // The rest of unit channels then have scale
  ...HE
} = qE, Ple = I(HE), VE = {
  x: 1,
  y: 1
}, kr = I(VE);
function Je(e) {
  return e in VE;
}
const XE = {
  theta: 1,
  radius: 1
}, zle = I(XE);
function Em(e) {
  return e === "width" ? je : bt;
}
const jR = { xOffset: 1, yOffset: 1 };
function Fd(e) {
  return e in jR;
}
const {
  // x2 and y2 share the same scale as x and y
  // text and tooltip have format instead of scale,
  // href has neither format, nor scale
  text: wve,
  tooltip: Eve,
  href: Sve,
  url: Ave,
  description: kve,
  // detail and order have no scale
  detail: Cve,
  key: _ve,
  order: Fve,
  ...UR
} = HE, Ile = I(UR);
function Ble(e) {
  return !!HE[e];
}
function jle(e) {
  switch (e) {
    case wn:
    case Er:
    case Sr:
    case sa:
    case En:
    case oa:
    case hs:
    case ps:
      return !0;
    case fs:
    case ds:
    case Oo:
      return !1;
  }
}
const qR = {
  ...VE,
  ...XE,
  ...jR,
  ...UR
}, Sm = I(qR);
function ua(e) {
  return !!qR[e];
}
function Ule(e, t) {
  return Gle(e)[t];
}
const GR = {
  // all marks
  arc: "always",
  area: "always",
  bar: "always",
  circle: "always",
  geoshape: "always",
  image: "always",
  line: "always",
  rule: "always",
  point: "always",
  rect: "always",
  square: "always",
  trail: "always",
  text: "always",
  tick: "always"
}, { geoshape: Mve, ...qle } = GR;
function Gle(e) {
  switch (e) {
    case wn:
    case Er:
    case Sr:
    case wm:
    case _d:
    case vm:
    case po:
    case xm:
    case Nu:
    case oa:
    case fs:
    case ds:
    case hs:
    case bm:
    case qr:
    case Gr:
      return GR;
    case je:
    case bt:
    case cs:
    case vl:
    case ji:
    case Ui:
      return qle;
    case Ii:
    case wr:
    case qi:
    case ii:
      return {
        area: "always",
        bar: "always",
        image: "always",
        rect: "always",
        rule: "always",
        circle: "binned",
        point: "binned",
        square: "binned",
        tick: "binned",
        line: "binned",
        trail: "binned"
      };
    case sa:
      return {
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        text: "always",
        line: "always",
        trail: "always"
      };
    case ps:
      return {
        line: "always",
        point: "always",
        tick: "always",
        rule: "always",
        circle: "always",
        square: "always",
        bar: "always",
        geoshape: "always"
      };
    case En:
      return { point: "always", geoshape: "always" };
    case Cd:
      return { text: "always" };
    case Oo:
      return { point: "always", square: "always", text: "always" };
    case $m:
      return { image: "always" };
    case ai:
      return { text: "always", arc: "always" };
    case Bi:
      return { text: "always", arc: "always" };
    case aa:
    case ra:
      return { arc: "always" };
  }
}
function dy(e) {
  switch (e) {
    case je:
    case bt:
    case ai:
    case Bi:
    case cs:
    case vl:
    case sa:
    case Oo:
    case hs:
    case oa:
    case fs:
    case ds:
    case Ii:
    case wr:
    case aa:
    case ra:
      return;
    case bm:
    case qr:
    case Gr:
    case En:
    case ps:
    case Cd:
    case po:
    case xm:
    case $m:
    case wm:
      return "discrete";
    case wn:
    case Er:
    case Sr:
      return "flexible";
    case ji:
    case Ui:
    case qi:
    case ii:
    case _d:
    case vm:
    case Nu:
      return;
  }
}
const Wle = {
  argmax: 1,
  argmin: 1,
  average: 1,
  count: 1,
  distinct: 1,
  product: 1,
  max: 1,
  mean: 1,
  median: 1,
  min: 1,
  missing: 1,
  q1: 1,
  q3: 1,
  ci0: 1,
  ci1: 1,
  stderr: 1,
  stdev: 1,
  stdevp: 1,
  sum: 1,
  valid: 1,
  values: 1,
  variance: 1,
  variancep: 1
}, Hle = {
  count: 1,
  min: 1,
  max: 1
};
function Kr(e) {
  return !!e && !!e.argmin;
}
function gs(e) {
  return !!e && !!e.argmax;
}
function YE(e) {
  return V(e) && !!Wle[e];
}
const Vle = /* @__PURE__ */ new Set([
  "count",
  "valid",
  "missing",
  "distinct"
]);
function WR(e) {
  return V(e) && Vle.has(e);
}
function Xle(e) {
  return V(e) && pe(["min", "max"], e);
}
const Yle = /* @__PURE__ */ new Set([
  "count",
  "sum",
  "distinct",
  "valid",
  "missing"
]), Kle = /* @__PURE__ */ new Set([
  "mean",
  "average",
  "median",
  "q1",
  "q3",
  "min",
  "max"
]);
function HR(e) {
  return Zr(e) && (e = Lm(e, void 0)), "bin" + I(e).map((t) => Am(e[t]) ? Be(`_${t}_${Ja(e[t])}`) : Be(`_${t}_${e[t]}`)).join("");
}
function De(e) {
  return e === !0 || To(e) && !e.binned;
}
function vt(e) {
  return e === "binned" || To(e) && e.binned === !0;
}
function To(e) {
  return X(e);
}
function Am(e) {
  return e == null ? void 0 : e.param;
}
function p4(e) {
  switch (e) {
    case qr:
    case Gr:
    case sa:
    case wn:
    case Er:
    case Sr:
    case hs:
    case oa:
    case fs:
    case ds:
    case En:
      return 6;
    case ps:
      return 4;
    default:
      return 10;
  }
}
function Md(e) {
  return !!(e != null && e.expr);
}
function hn(e) {
  const t = I(e || {}), n = {};
  for (const i of t)
    n[i] = On(e[i]);
  return n;
}
function VR(e) {
  const {
    // These are non-mark title config that need to be hardcoded
    anchor: t,
    frame: n,
    offset: i,
    orient: r,
    angle: a,
    limit: s,
    // color needs to be redirect to fill
    color: o,
    // subtitle properties
    subtitleColor: u,
    subtitleFont: l,
    subtitleFontSize: c,
    subtitleFontStyle: f,
    subtitleFontWeight: d,
    subtitleLineHeight: h,
    subtitlePadding: p,
    // The rest are mark config.
    ...g
  } = e, m = {
    ...g,
    ...o ? { fill: o } : {}
  }, y = {
    ...t ? { anchor: t } : {},
    ...n ? { frame: n } : {},
    ...i ? { offset: i } : {},
    ...r ? { orient: r } : {},
    ...a !== void 0 ? { angle: a } : {},
    ...s !== void 0 ? { limit: s } : {}
  }, b = {
    ...u ? { subtitleColor: u } : {},
    ...l ? { subtitleFont: l } : {},
    ...c ? { subtitleFontSize: c } : {},
    ...f ? { subtitleFontStyle: f } : {},
    ...d ? { subtitleFontWeight: d } : {},
    ...h ? { subtitleLineHeight: h } : {},
    ...p ? { subtitlePadding: p } : {}
  }, v = Tu(e, ["align", "baseline", "dx", "dy", "limit"]);
  return { titleMarkConfig: m, subtitleMarkConfig: v, nonMarkTitleProperties: y, subtitle: b };
}
function xa(e) {
  return V(e) || R(e) && V(e[0]);
}
function Q(e) {
  return !!(e != null && e.signal);
}
function ms(e) {
  return !!e.step;
}
function Jle(e) {
  return R(e) ? !1 : "fields" in e && !("data" in e);
}
function Qle(e) {
  return R(e) ? !1 : "fields" in e && "data" in e;
}
function jr(e) {
  return R(e) ? !1 : "field" in e && "data" in e;
}
const Zle = {
  aria: 1,
  description: 1,
  ariaRole: 1,
  ariaRoleDescription: 1,
  blend: 1,
  opacity: 1,
  fill: 1,
  fillOpacity: 1,
  stroke: 1,
  strokeCap: 1,
  strokeWidth: 1,
  strokeOpacity: 1,
  strokeDash: 1,
  strokeDashOffset: 1,
  strokeJoin: 1,
  strokeOffset: 1,
  strokeMiterLimit: 1,
  startAngle: 1,
  endAngle: 1,
  padAngle: 1,
  innerRadius: 1,
  outerRadius: 1,
  size: 1,
  shape: 1,
  interpolate: 1,
  tension: 1,
  orient: 1,
  align: 1,
  baseline: 1,
  text: 1,
  dir: 1,
  dx: 1,
  dy: 1,
  ellipsis: 1,
  limit: 1,
  radius: 1,
  theta: 1,
  angle: 1,
  font: 1,
  fontSize: 1,
  fontWeight: 1,
  fontStyle: 1,
  lineBreak: 1,
  lineHeight: 1,
  cursor: 1,
  href: 1,
  tooltip: 1,
  cornerRadius: 1,
  cornerRadiusTopLeft: 1,
  cornerRadiusTopRight: 1,
  cornerRadiusBottomLeft: 1,
  cornerRadiusBottomRight: 1,
  aspect: 1,
  width: 1,
  height: 1,
  url: 1,
  smooth: 1
  // commented below are vg channel that do not have mark config.
  // x: 1,
  // y: 1,
  // x2: 1,
  // y2: 1,
  // xc'|'yc'
  // clip: 1,
  // path: 1,
  // url: 1,
}, ece = I(Zle), tce = {
  arc: 1,
  area: 1,
  group: 1,
  image: 1,
  line: 1,
  path: 1,
  rect: 1,
  rule: 1,
  shape: 1,
  symbol: 1,
  text: 1,
  trail: 1
}, Cv = [
  "cornerRadius",
  "cornerRadiusTopLeft",
  "cornerRadiusTopRight",
  "cornerRadiusBottomLeft",
  "cornerRadiusBottomRight"
];
function XR(e) {
  const t = R(e.condition) ? e.condition.map(g4) : g4(e.condition);
  return {
    ...On(e),
    condition: t
  };
}
function On(e) {
  if (Md(e)) {
    const { expr: t, ...n } = e;
    return { signal: t, ...n };
  }
  return e;
}
function g4(e) {
  if (Md(e)) {
    const { expr: t, ...n } = e;
    return { signal: t, ...n };
  }
  return e;
}
function ze(e) {
  if (Md(e)) {
    const { expr: t, ...n } = e;
    return { signal: t, ...n };
  }
  return Q(e) ? e : e !== void 0 ? { value: e } : void 0;
}
function nce(e) {
  return Q(e) ? e.signal : U(e);
}
function m4(e) {
  return Q(e) ? e.signal : U(e.value);
}
function xi(e) {
  return Q(e) ? e.signal : e == null ? null : U(e);
}
function ice(e, t, n) {
  for (const i of n) {
    const r = Jr(i, t.markDef, t.config);
    r !== void 0 && (e[i] = ze(r));
  }
  return e;
}
function YR(e) {
  return [].concat(e.type, e.style ?? []);
}
function Ee(e, t, n, i = {}) {
  const { vgChannel: r, ignoreVgConfig: a } = i;
  return r && t[r] !== void 0 ? t[r] : t[e] !== void 0 ? t[e] : a && (!r || r === e) ? void 0 : Jr(e, t, n, i);
}
function Jr(e, t, n, { vgChannel: i } = {}) {
  return Ke(
    // style config has highest precedence
    i ? xg(e, t, n.style) : void 0,
    xg(e, t, n.style),
    // then mark-specific config
    i ? n[t.type][i] : void 0,
    n[t.type][e],
    // Need to cast because MarkDef doesn't perfectly match with AnyMarkConfig, but if the type isn't available, we'll get nothing here, which is fine
    // If there is vgChannel, skip vl channel.
    // For example, vl size for text is vg fontSize, but config.mark.size is only for point size.
    i ? n.mark[i] : n.mark[e]
    // Need to cast for the same reason as above
  );
}
function xg(e, t, n) {
  return KR(e, YR(t), n);
}
function KR(e, t, n) {
  t = G(t);
  let i;
  for (const r of t) {
    const a = n[r];
    a && a[e] !== void 0 && (i = a[e]);
  }
  return i;
}
function JR(e, t) {
  return G(e).reduce((n, i) => (n.field.push(H(i, t)), n.order.push(i.sort ?? "ascending"), n), { field: [], order: [] });
}
function QR(e, t) {
  const n = [...e];
  return t.forEach((i) => {
    for (const r of n)
      if (Tn(r, i))
        return;
    n.push(i);
  }), n;
}
function ZR(e, t) {
  return Tn(e, t) || !t ? e : e ? [...G(e), ...G(t)].join(", ") : t;
}
function eT(e, t) {
  const n = e.value, i = t.value;
  if (n == null || i === null)
    return {
      explicit: e.explicit,
      value: null
    };
  if ((xa(n) || Q(n)) && (xa(i) || Q(i)))
    return {
      explicit: e.explicit,
      value: ZR(n, i)
    };
  if (xa(n) || Q(n))
    return {
      explicit: e.explicit,
      value: n
    };
  if (xa(i) || Q(i))
    return {
      explicit: e.explicit,
      value: i
    };
  if (!xa(n) && !Q(n) && !xa(i) && !Q(i))
    return {
      explicit: e.explicit,
      value: QR(n, i)
    };
  throw new Error("It should never reach here");
}
function KE(e) {
  return `Invalid specification ${Ce(e)}. Make sure the specification includes at least one of the following properties: "mark", "layer", "facet", "hconcat", "vconcat", "concat", or "repeat".`;
}
const rce = 'Autosize "fit" only works for single views and layered views.';
function y4(e) {
  return `${e == "width" ? "Width" : "Height"} "container" only works for single views and layered views.`;
}
function b4(e) {
  const t = e == "width" ? "Width" : "Height", n = e == "width" ? "x" : "y";
  return `${t} "container" only works well with autosize "fit" or "fit-${n}".`;
}
function v4(e) {
  return e ? `Dropping "fit-${e}" because spec has discrete ${Sn(e)}.` : 'Dropping "fit" because spec has discrete size.';
}
function JE(e) {
  return `Unknown field for ${e}. Cannot calculate view size.`;
}
function x4(e) {
  return `Cannot project a selection on encoding channel "${e}", which has no field.`;
}
function ace(e, t) {
  return `Cannot project a selection on encoding channel "${e}" as it uses an aggregate function ("${t}").`;
}
function sce(e) {
  return `The "nearest" transform is not supported for ${e} marks.`;
}
function tT(e) {
  return `Selection not supported for ${e} yet.`;
}
function oce(e) {
  return `Cannot find a selection named "${e}".`;
}
const uce = "Scale bindings are currently only supported for scales with unbinned, continuous domains.", lce = "Legend bindings are only supported for selections over an individual field or encoding channel.";
function cce(e) {
  return `Lookups can only be performed on selection parameters. "${e}" is a variable parameter.`;
}
function fce(e) {
  return `Cannot define and lookup the "${e}" selection in the same view. Try moving the lookup into a second, layered view?`;
}
const dce = "The same selection must be used to override scale domains in a layered view.", hce = 'Interval selections should be initialized using "x", "y", "longitude", or "latitude" keys.';
function pce(e) {
  return `Unknown repeated value "${e}".`;
}
function $4(e) {
  return `The "columns" property cannot be used when "${e}" has nested row/column.`;
}
const gce = "Axes cannot be shared in concatenated or repeated views yet (https://github.com/vega/vega-lite/issues/2415).";
function mce(e) {
  return `Unrecognized parse "${e}".`;
}
function w4(e, t, n) {
  return `An ancestor parsed field "${e}" as ${n} but a child wants to parse the field as ${t}.`;
}
const yce = "Attempt to add the same child twice.";
function bce(e) {
  return `Ignoring an invalid transform: ${Ce(e)}.`;
}
const vce = 'If "from.fields" is not specified, "as" has to be a string that specifies the key to be used for the data from the secondary source.';
function E4(e) {
  return `Config.customFormatTypes is not true, thus custom format type and format for channel ${e} are dropped.`;
}
function xce(e) {
  const { parentProjection: t, projection: n } = e;
  return `Layer's shared projection ${Ce(t)} is overridden by a child projection ${Ce(n)}.`;
}
const $ce = "Arc marks uses theta channel rather than angle, replacing angle with theta.";
function wce(e) {
  return `${e}Offset dropped because ${e} is continuous`;
}
function Ece(e, t, n) {
  return `Channel ${e} is a ${t}. Converted to {value: ${Ce(n)}}.`;
}
function nT(e) {
  return `Invalid field type "${e}".`;
}
function Sce(e, t) {
  return `Invalid field type "${e}" for aggregate: "${t}", using "quantitative" instead.`;
}
function Ace(e) {
  return `Invalid aggregation operator "${e}".`;
}
function iT(e, t) {
  const { fill: n, stroke: i } = t;
  return `Dropping color ${e} as the plot also has ${n && i ? "fill and stroke" : n ? "fill" : "stroke"}.`;
}
function kce(e) {
  return `Position range does not support relative band size for ${e}.`;
}
function _v(e, t) {
  return `Dropping ${Ce(e)} from channel "${t}" since it does not contain any data field, datum, value, or signal.`;
}
const Cce = "Line marks cannot encode size with a non-groupby field. You may want to use trail marks instead.";
function km(e, t, n) {
  return `${e} dropped as it is incompatible with "${t}"${n ? ` when ${n}` : ""}.`;
}
function _ce(e) {
  return `${e}-encoding is dropped as ${e} is not a valid encoding channel.`;
}
function Fce(e) {
  return `${e} encoding should be discrete (ordinal / nominal / binned).`;
}
function Mce(e) {
  return `${e} encoding should be discrete (ordinal / nominal / binned) or use a discretizing scale (e.g. threshold).`;
}
function Oce(e) {
  return `Facet encoding dropped as ${e.join(" and ")} ${e.length > 1 ? "are" : "is"} also specified.`;
}
function hy(e, t) {
  return `Using discrete channel "${e}" to encode "${t}" field can be misleading as it does not encode ${t === "ordinal" ? "order" : "magnitude"}.`;
}
function Rce(e) {
  return `The ${e} for range marks cannot be an expression`;
}
function Tce(e, t) {
  return `Line mark is for continuous lines and thus cannot be used with ${e && t ? "x2 and y2" : e ? "x2" : "y2"}. We will use the rule mark (line segments) instead.`;
}
function Dce(e, t) {
  return `Specified orient "${e}" overridden with "${t}".`;
}
function Nce(e) {
  return `Cannot use the scale property "${e}" with non-color channel.`;
}
function Lce(e) {
  return `Cannot use the relative band size with ${e} scale.`;
}
function Pce(e) {
  return `Using unaggregated domain with raw field has no effect (${Ce(e)}).`;
}
function zce(e) {
  return `Unaggregated domain not applicable for "${e}" since it produces values outside the origin domain of the source data.`;
}
function Ice(e) {
  return `Unaggregated domain is currently unsupported for log scale (${Ce(e)}).`;
}
function Bce(e) {
  return `Cannot apply size to non-oriented mark "${e}".`;
}
function jce(e, t, n) {
  return `Channel "${e}" does not work with "${t}" scale. We are using "${n}" scale instead.`;
}
function Uce(e, t) {
  return `FieldDef does not work with "${e}" scale. We are using "${t}" scale instead.`;
}
function rT(e, t, n) {
  return `${n}-scale's "${t}" is dropped as it does not work with ${e} scale.`;
}
function aT(e) {
  return `The step for "${e}" is dropped because the ${e === "width" ? "x" : "y"} is continuous.`;
}
function qce(e, t, n, i) {
  return `Conflicting ${t.toString()} property "${e.toString()}" (${Ce(n)} and ${Ce(i)}). Using ${Ce(n)}.`;
}
function Gce(e, t, n, i) {
  return `Conflicting ${t.toString()} property "${e.toString()}" (${Ce(n)} and ${Ce(i)}). Using the union of the two domains.`;
}
function Wce(e) {
  return `Setting the scale to be independent for "${e}" means we also have to set the guide (axis or legend) to be independent.`;
}
function Hce(e) {
  return `Dropping sort property ${Ce(e)} as unioned domains only support boolean or op "count", "min", and "max".`;
}
const S4 = "Domains that should be unioned has conflicting sort properties. Sort will be set to true.", Vce = "Detected faceted independent scales that union domain of multiple fields from different data sources. We will use the first field. The result view size may be incorrect.", Xce = "Detected faceted independent scales that union domain of the same fields from different source. We will assume that this is the same field from a different fork of the same data source. However, if this is not the case, the result view size may be incorrect.", Yce = "Detected faceted independent scales that union domain of multiple fields from the same data source. We will use the first field. The result view size may be incorrect.";
function Kce(e) {
  return `Cannot stack "${e}" if there is already "${e}2".`;
}
function Jce(e) {
  return `Cannot stack non-linear scale (${e}).`;
}
function Qce(e) {
  return `Stacking is applied even though the aggregate function is non-summative ("${e}").`;
}
function $g(e, t) {
  return `Invalid ${e}: ${Ce(t)}.`;
}
function Zce(e) {
  return `Dropping day from datetime ${Ce(e)} as day cannot be combined with other units.`;
}
function efe(e, t) {
  return `${t ? "extent " : ""}${t && e ? "and " : ""}${e ? "center " : ""}${t && e ? "are " : "is "}not needed when data are aggregated.`;
}
function tfe(e, t, n) {
  return `${e} is not usually used with ${t} for ${n}.`;
}
function nfe(e, t) {
  return `Continuous axis should not have customized aggregation function ${e}; ${t} already agregates the axis.`;
}
function A4(e) {
  return `1D error band does not support ${e}.`;
}
function sT(e) {
  return `Channel ${e} is required for "binned" bin.`;
}
function ife(e) {
  return `Channel ${e} should not be used with "binned" bin.`;
}
function rfe(e) {
  return `Domain for ${e} is required for threshold scale.`;
}
const oT = E2(w2);
let Lu = oT;
function afe(e) {
  return Lu = e, Lu;
}
function sfe() {
  return Lu = oT, Lu;
}
function q(...e) {
  Lu.warn(...e);
}
function ofe(...e) {
  Lu.debug(...e);
}
function Do(e) {
  if (e && X(e)) {
    for (const t of ZE)
      if (t in e)
        return !0;
  }
  return !1;
}
const uT = [
  "january",
  "february",
  "march",
  "april",
  "may",
  "june",
  "july",
  "august",
  "september",
  "october",
  "november",
  "december"
], ufe = uT.map((e) => e.substr(0, 3)), lT = ["sunday", "monday", "tuesday", "wednesday", "thursday", "friday", "saturday"], lfe = lT.map((e) => e.substr(0, 3));
function cfe(e) {
  if (ym(e) && (e = +e), ye(e))
    return e > 4 && q($g("quarter", e)), e - 1;
  throw new Error($g("quarter", e));
}
function ffe(e) {
  if (ym(e) && (e = +e), ye(e))
    return e - 1;
  {
    const t = e.toLowerCase(), n = uT.indexOf(t);
    if (n !== -1)
      return n;
    const i = t.substr(0, 3), r = ufe.indexOf(i);
    if (r !== -1)
      return r;
    throw new Error($g("month", e));
  }
}
function dfe(e) {
  if (ym(e) && (e = +e), ye(e))
    return e % 7;
  {
    const t = e.toLowerCase(), n = lT.indexOf(t);
    if (n !== -1)
      return n;
    const i = t.substr(0, 3), r = lfe.indexOf(i);
    if (r !== -1)
      return r;
    throw new Error($g("day", e));
  }
}
function QE(e, t) {
  const n = [];
  if (t && e.day !== void 0 && I(e).length > 1 && (q(Zce(e)), e = se(e), delete e.day), e.year !== void 0 ? n.push(e.year) : n.push(2012), e.month !== void 0) {
    const i = t ? ffe(e.month) : e.month;
    n.push(i);
  } else if (e.quarter !== void 0) {
    const i = t ? cfe(e.quarter) : e.quarter;
    n.push(ye(i) ? i * 3 : `${i}*3`);
  } else
    n.push(0);
  if (e.date !== void 0)
    n.push(e.date);
  else if (e.day !== void 0) {
    const i = t ? dfe(e.day) : e.day;
    n.push(ye(i) ? i + 1 : `${i}+1`);
  } else
    n.push(1);
  for (const i of ["hours", "minutes", "seconds", "milliseconds"]) {
    const r = e[i];
    n.push(typeof r > "u" ? 0 : r);
  }
  return n;
}
function go(e) {
  const n = QE(e, !0).join(", ");
  return e.utc ? `utc(${n})` : `datetime(${n})`;
}
function hfe(e) {
  const n = QE(e, !1).join(", ");
  return e.utc ? `utc(${n})` : `datetime(${n})`;
}
function pfe(e) {
  const t = QE(e, !0);
  return e.utc ? +new Date(Date.UTC(...t)) : +new Date(...t);
}
const cT = {
  year: 1,
  quarter: 1,
  month: 1,
  week: 1,
  day: 1,
  dayofyear: 1,
  date: 1,
  hours: 1,
  minutes: 1,
  seconds: 1,
  milliseconds: 1
}, ZE = I(cT);
function gfe(e) {
  return !!cT[e];
}
function No(e) {
  return X(e) ? e.binned : fT(e);
}
function fT(e) {
  return e && e.startsWith("binned");
}
function e3(e) {
  return e.startsWith("utc");
}
function mfe(e) {
  return e.substring(3);
}
const yfe = {
  "year-month": "%b %Y ",
  "year-month-date": "%b %d, %Y "
};
function Cm(e) {
  return ZE.filter((t) => hT(e, t));
}
function dT(e) {
  const t = Cm(e);
  return t[t.length - 1];
}
function hT(e, t) {
  const n = e.indexOf(t);
  return !(n < 0 || n > 0 && t === "seconds" && e.charAt(n - 1) === "i" || e.length > n + 3 && t === "day" && e.charAt(n + 3) === "o" || n > 0 && t === "year" && e.charAt(n - 1) === "f");
}
function bfe(e, t, { end: n } = { end: !1 }) {
  const i = BE(t), r = e3(e) ? "utc" : "";
  function a(u) {
    return u === "quarter" ? `(${r}quarter(${i})-1)` : `${r}${u}(${i})`;
  }
  let s;
  const o = {};
  for (const u of ZE)
    hT(e, u) && (o[u] = a(u), s = u);
  return n && (o[s] += "+1"), hfe(o);
}
function pT(e) {
  if (!e)
    return;
  const t = Cm(e);
  return `timeUnitSpecifier(${Ce(t)}, ${Ce(yfe)})`;
}
function vfe(e, t, n) {
  if (!e)
    return;
  const i = pT(e);
  return `${n || e3(e) ? "utc" : "time"}Format(${t}, ${i})`;
}
function pt(e) {
  if (!e)
    return;
  let t;
  return V(e) ? fT(e) ? t = {
    unit: e.substring(6),
    binned: !0
  } : t = {
    unit: e
  } : X(e) && (t = {
    ...e,
    ...e.unit ? { unit: e.unit } : {}
  }), e3(t.unit) && (t.utc = !0, t.unit = mfe(t.unit)), t;
}
function xfe(e) {
  const { utc: t, ...n } = pt(e);
  return n.unit ? (t ? "utc" : "") + I(n).map((i) => Be(`${i === "unit" ? "" : `_${i}_`}${n[i]}`)).join("") : (t ? "utc" : "") + "timeunit" + I(n).map((i) => Be(`_${i}_${n[i]}`)).join("");
}
function gT(e, t = (n) => n) {
  const n = pt(e), i = dT(n.unit);
  if (i && i !== "day") {
    const r = {
      year: 2001,
      month: 1,
      date: 1,
      hours: 0,
      minutes: 0,
      seconds: 0,
      milliseconds: 0
    }, { step: a, part: s } = mT(i, n.step), o = {
      ...r,
      [s]: +r[s] + a
    };
    return `${t(go(o))} - ${t(go(r))}`;
  }
}
const $fe = {
  year: 1,
  month: 1,
  date: 1,
  hours: 1,
  minutes: 1,
  seconds: 1,
  milliseconds: 1
};
function wfe(e) {
  return !!$fe[e];
}
function mT(e, t = 1) {
  if (wfe(e))
    return { part: e, step: t };
  switch (e) {
    case "day":
    case "dayofyear":
      return { part: "date", step: t };
    case "quarter":
      return { part: "month", step: t * 3 };
    case "week":
      return { part: "date", step: t * 7 };
  }
}
function Efe(e) {
  return e == null ? void 0 : e.param;
}
function t3(e) {
  return !!(e != null && e.field) && e.equal !== void 0;
}
function n3(e) {
  return !!(e != null && e.field) && e.lt !== void 0;
}
function i3(e) {
  return !!(e != null && e.field) && e.lte !== void 0;
}
function r3(e) {
  return !!(e != null && e.field) && e.gt !== void 0;
}
function a3(e) {
  return !!(e != null && e.field) && e.gte !== void 0;
}
function s3(e) {
  if (e != null && e.field) {
    if (R(e.range) && e.range.length === 2)
      return !0;
    if (Q(e.range))
      return !0;
  }
  return !1;
}
function o3(e) {
  return !!(e != null && e.field) && (R(e.oneOf) || R(e.in));
}
function Sfe(e) {
  return !!(e != null && e.field) && e.valid !== void 0;
}
function yT(e) {
  return o3(e) || t3(e) || s3(e) || n3(e) || r3(e) || i3(e) || a3(e);
}
function Hi(e, t) {
  return Pm(e, { timeUnit: t, wrapTime: !0 });
}
function Afe(e, t) {
  return e.map((n) => Hi(n, t));
}
function bT(e, t = !0) {
  const { field: n } = e, i = pt(e.timeUnit), { unit: r, binned: a } = i || {}, s = H(e, { expr: "datum" }), o = r ? (
    // For timeUnit, cast into integer with time() so we can use ===, inrange, indexOf to compare values directly.
    // TODO: We calculate timeUnit on the fly here. Consider if we would like to consolidate this with timeUnit pipeline
    // TODO: support utc
    `time(${a ? s : bfe(r, n)})`
  ) : s;
  if (t3(e))
    return `${o}===${Hi(e.equal, r)}`;
  if (n3(e)) {
    const u = e.lt;
    return `${o}<${Hi(u, r)}`;
  } else if (r3(e)) {
    const u = e.gt;
    return `${o}>${Hi(u, r)}`;
  } else if (i3(e)) {
    const u = e.lte;
    return `${o}<=${Hi(u, r)}`;
  } else if (a3(e)) {
    const u = e.gte;
    return `${o}>=${Hi(u, r)}`;
  } else {
    if (o3(e))
      return `indexof([${Afe(e.oneOf, r).join(",")}], ${o}) !== -1`;
    if (Sfe(e))
      return u3(o, e.valid);
    if (s3(e)) {
      const { range: u } = e, l = Q(u) ? { signal: `${u.signal}[0]` } : u[0], c = Q(u) ? { signal: `${u.signal}[1]` } : u[1];
      if (l !== null && c !== null && t)
        return "inrange(" + o + ", [" + Hi(l, r) + ", " + Hi(c, r) + "])";
      const f = [];
      return l !== null && f.push(`${o} >= ${Hi(l, r)}`), c !== null && f.push(`${o} <= ${Hi(c, r)}`), f.length > 0 ? f.join(" && ") : "true";
    }
  }
  throw new Error(`Invalid field predicate: ${Ce(e)}`);
}
function u3(e, t = !0) {
  return t ? `isValid(${e}) && isFinite(+${e})` : `!isValid(${e}) || !isFinite(+${e})`;
}
function kfe(e) {
  return yT(e) && e.timeUnit ? {
    ...e,
    timeUnit: pt(e.timeUnit)
  } : e;
}
const Od = {
  quantitative: "quantitative",
  ordinal: "ordinal",
  temporal: "temporal",
  nominal: "nominal",
  geojson: "geojson"
};
function Cfe(e) {
  return e === "quantitative" || e === "temporal";
}
function vT(e) {
  return e === "ordinal" || e === "nominal";
}
const mo = Od.quantitative, l3 = Od.ordinal, Pu = Od.temporal, c3 = Od.nominal, xl = Od.geojson;
function _fe(e) {
  if (e)
    switch (e = e.toLowerCase(), e) {
      case "q":
      case mo:
        return "quantitative";
      case "t":
      case Pu:
        return "temporal";
      case "o":
      case l3:
        return "ordinal";
      case "n":
      case c3:
        return "nominal";
      case xl:
        return "geojson";
    }
}
const yn = {
  // Continuous - Quantitative
  LINEAR: "linear",
  LOG: "log",
  POW: "pow",
  SQRT: "sqrt",
  SYMLOG: "symlog",
  IDENTITY: "identity",
  SEQUENTIAL: "sequential",
  // Continuous - Time
  TIME: "time",
  UTC: "utc",
  // Discretizing scales
  QUANTILE: "quantile",
  QUANTIZE: "quantize",
  THRESHOLD: "threshold",
  BIN_ORDINAL: "bin-ordinal",
  // Discrete scales
  ORDINAL: "ordinal",
  POINT: "point",
  BAND: "band"
}, Fv = {
  linear: "numeric",
  log: "numeric",
  pow: "numeric",
  sqrt: "numeric",
  symlog: "numeric",
  identity: "numeric",
  sequential: "numeric",
  time: "time",
  utc: "time",
  ordinal: "ordinal",
  "bin-ordinal": "bin-ordinal",
  point: "ordinal-position",
  band: "ordinal-position",
  quantile: "discretizing",
  quantize: "discretizing",
  threshold: "discretizing"
};
function Ffe(e, t) {
  const n = Fv[e], i = Fv[t];
  return n === i || n === "ordinal-position" && i === "time" || i === "ordinal-position" && n === "time";
}
const Mfe = {
  // numeric
  linear: 0,
  log: 1,
  pow: 1,
  sqrt: 1,
  symlog: 1,
  identity: 1,
  sequential: 1,
  // time
  time: 0,
  utc: 0,
  // ordinal-position -- these have higher precedence than continuous scales as they support more types of data
  point: 10,
  band: 11,
  // non grouped types
  ordinal: 0,
  "bin-ordinal": 0,
  quantile: 0,
  quantize: 0,
  threshold: 0
};
function k4(e) {
  return Mfe[e];
}
const xT = /* @__PURE__ */ new Set([
  "linear",
  "log",
  "pow",
  "sqrt",
  "symlog"
]), $T = /* @__PURE__ */ new Set([
  ...xT,
  "time",
  "utc"
]);
function wT(e) {
  return xT.has(e);
}
const ET = /* @__PURE__ */ new Set([
  "quantile",
  "quantize",
  "threshold"
]), Ofe = /* @__PURE__ */ new Set([
  ...$T,
  ...ET,
  "sequential",
  "identity"
]), Rfe = /* @__PURE__ */ new Set([
  "ordinal",
  "bin-ordinal",
  "point",
  "band"
]);
function gt(e) {
  return Rfe.has(e);
}
function Bn(e) {
  return Ofe.has(e);
}
function $i(e) {
  return $T.has(e);
}
function zu(e) {
  return ET.has(e);
}
const Tfe = {
  pointPadding: 0.5,
  barBandPaddingInner: 0.1,
  rectBandPaddingInner: 0,
  bandWithNestedOffsetPaddingInner: 0.2,
  bandWithNestedOffsetPaddingOuter: 0.2,
  minBandSize: 2,
  minFontSize: 8,
  maxFontSize: 40,
  minOpacity: 0.3,
  maxOpacity: 0.8,
  // FIXME: revise if these *can* become ratios of width/height step
  minSize: 9,
  minStrokeWidth: 1,
  maxStrokeWidth: 4,
  quantileCount: 4,
  quantizeCount: 4,
  zero: !0
};
function Dfe(e) {
  return !V(e) && !!e.name;
}
function ST(e) {
  return e == null ? void 0 : e.param;
}
function Nfe(e) {
  return e == null ? void 0 : e.unionWith;
}
function Lfe(e) {
  return X(e) && "field" in e;
}
const Pfe = {
  type: 1,
  domain: 1,
  domainMax: 1,
  domainMin: 1,
  domainMid: 1,
  domainRaw: 1,
  align: 1,
  range: 1,
  rangeMax: 1,
  rangeMin: 1,
  scheme: 1,
  bins: 1,
  // Other properties
  reverse: 1,
  round: 1,
  // quantitative / time
  clamp: 1,
  nice: 1,
  // quantitative
  base: 1,
  exponent: 1,
  constant: 1,
  interpolate: 1,
  zero: 1,
  // band/point
  padding: 1,
  paddingInner: 1,
  paddingOuter: 1
}, { type: Ove, domain: Rve, range: Tve, rangeMax: Dve, rangeMin: Nve, scheme: Lve, ...zfe } = Pfe, Ife = I(zfe);
function Mv(e, t) {
  switch (t) {
    case "type":
    case "domain":
    case "reverse":
    case "range":
      return !0;
    case "scheme":
    case "interpolate":
      return !["point", "band", "identity"].includes(e);
    case "bins":
      return !["point", "band", "identity", "ordinal"].includes(e);
    case "round":
      return $i(e) || e === "band" || e === "point";
    case "padding":
    case "rangeMin":
    case "rangeMax":
      return $i(e) || ["point", "band"].includes(e);
    case "paddingOuter":
    case "align":
      return ["point", "band"].includes(e);
    case "paddingInner":
      return e === "band";
    case "domainMax":
    case "domainMid":
    case "domainMin":
    case "domainRaw":
    case "clamp":
      return $i(e);
    case "nice":
      return $i(e) || e === "quantize" || e === "threshold";
    case "exponent":
      return e === "pow";
    case "base":
      return e === "log";
    case "constant":
      return e === "symlog";
    case "zero":
      return Bn(e) && !pe([
        "log",
        "time",
        "utc",
        "threshold",
        "quantile"
        // quantile depends on distribution so zero does not matter
      ], e);
  }
}
function AT(e, t) {
  switch (t) {
    case "interpolate":
    case "scheme":
    case "domainMid":
      return fu(e) ? void 0 : Nce(t);
    case "align":
    case "type":
    case "bins":
    case "domain":
    case "domainMax":
    case "domainMin":
    case "domainRaw":
    case "range":
    case "base":
    case "exponent":
    case "constant":
    case "nice":
    case "padding":
    case "paddingInner":
    case "paddingOuter":
    case "rangeMax":
    case "rangeMin":
    case "reverse":
    case "round":
    case "clamp":
    case "zero":
      return;
  }
}
function Bfe(e, t) {
  return pe([l3, c3], t) ? e === void 0 || gt(e) : t === Pu ? pe([yn.TIME, yn.UTC, void 0], e) : t === mo ? wT(e) || zu(e) || e === void 0 : !0;
}
function jfe(e, t, n = !1) {
  if (!ua(e))
    return !1;
  switch (e) {
    case je:
    case bt:
    case cs:
    case vl:
    case ai:
    case Bi:
      return $i(t) || t === "band" ? !0 : t === "point" ? !n : !1;
    case sa:
    case hs:
    case oa:
    case fs:
    case ds:
    case Oo:
      return $i(t) || zu(t) || pe(["band", "point", "ordinal"], t);
    case wn:
    case Er:
    case Sr:
      return t !== "band";
    case ps:
    case En:
      return t === "ordinal" || zu(t);
  }
}
const un = {
  arc: "arc",
  area: "area",
  bar: "bar",
  image: "image",
  line: "line",
  point: "point",
  rect: "rect",
  rule: "rule",
  text: "text",
  tick: "tick",
  trail: "trail",
  circle: "circle",
  square: "square",
  geoshape: "geoshape"
}, kT = un.arc, _m = un.area, Fm = un.bar, Ufe = un.image, Mm = un.line, Om = un.point, qfe = un.rect, wg = un.rule, CT = un.text, f3 = un.tick, Gfe = un.trail, d3 = un.circle, h3 = un.square, _T = un.geoshape;
function ys(e) {
  return ["line", "area", "trail"].includes(e);
}
function vf(e) {
  return [
    "rect",
    "bar",
    "image",
    "arc"
    /* arc is rect/interval in polar coordinate */
  ].includes(e);
}
const Wfe = new Set(I(un));
function pr(e) {
  return e.type;
}
const Hfe = [
  "stroke",
  "strokeWidth",
  "strokeDash",
  "strokeDashOffset",
  "strokeOpacity",
  "strokeJoin",
  "strokeMiterLimit"
], Vfe = ["fill", "fillOpacity"], Xfe = [...Hfe, ...Vfe], Yfe = {
  color: 1,
  filled: 1,
  invalid: 1,
  order: 1,
  radius2: 1,
  theta2: 1,
  timeUnitBandSize: 1,
  timeUnitBandPosition: 1
}, C4 = I(Yfe), Kfe = {
  area: ["line", "point"],
  bar: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
  rect: ["binSpacing", "continuousBandSize", "discreteBandSize", "minBandSize"],
  line: ["point"],
  tick: ["bandSize", "thickness"]
}, Jfe = {
  color: "#4c78a8",
  invalid: "filter",
  timeUnitBandSize: 1
}, Qfe = {
  mark: 1,
  arc: 1,
  area: 1,
  bar: 1,
  circle: 1,
  image: 1,
  line: 1,
  point: 1,
  rect: 1,
  rule: 1,
  square: 1,
  text: 1,
  tick: 1,
  trail: 1,
  geoshape: 1
}, FT = I(Qfe);
function yo(e) {
  return e && e.band != null;
}
const Zfe = {
  horizontal: ["cornerRadiusTopRight", "cornerRadiusBottomRight"],
  vertical: ["cornerRadiusTopLeft", "cornerRadiusTopRight"]
}, MT = 5, ede = {
  binSpacing: 1,
  continuousBandSize: MT,
  minBandSize: 0.25,
  timeUnitBandPosition: 0.5
}, tde = {
  binSpacing: 0,
  continuousBandSize: MT,
  minBandSize: 0.25,
  timeUnitBandPosition: 0.5
}, nde = {
  thickness: 1
};
function ide(e) {
  return pr(e) ? e.type : e;
}
function p3(e) {
  const { channel: t, channelDef: n, markDef: i, scale: r, config: a } = e, s = m3(e);
  return (
    // Only this for field def without counting aggregate (as count wouldn't be null)
    j(n) && !WR(n.aggregate) && // and only for continuous scale
    r && $i(r.get("type")) ? rde({
      fieldDef: n,
      channel: t,
      markDef: i,
      ref: s,
      config: a
    }) : s
  );
}
function rde({ fieldDef: e, channel: t, markDef: n, ref: i, config: r }) {
  return ys(n.type) ? i : Ee("invalid", n, r) === null ? [ade(e, t), i] : i;
}
function ade(e, t) {
  const n = g3(e, !0), r = Ro(t) === "y" ? { field: { group: "height" } } : (
    // x / angle / radius can all use 0
    { value: 0 }
  );
  return { test: n, ...r };
}
function g3(e, t = !0) {
  return u3(V(e) ? e : H(e, { expr: "datum" }), !t);
}
function sde(e) {
  const { datum: t } = e;
  return Do(t) ? go(t) : `${Ce(t)}`;
}
function Js(e, t, n, i) {
  const r = {};
  if (t && (r.scale = t), Cr(e)) {
    const { datum: a } = e;
    Do(a) ? r.signal = go(a) : Q(a) ? r.signal = a.signal : Md(a) ? r.signal = a.expr : r.value = a;
  } else
    r.field = H(e, n);
  if (i) {
    const { offset: a, band: s } = i;
    a && (r.offset = a), s && (r.band = s);
  }
  return r;
}
function Eg({ scaleName: e, fieldOrDatumDef: t, fieldOrDatumDef2: n, offset: i, startSuffix: r, endSuffix: a = "end", bandPosition: s = 0.5 }) {
  const o = !Q(s) && 0 < s && s < 1 ? "datum" : void 0, u = H(t, { expr: o, suffix: r }), l = n !== void 0 ? H(n, { expr: o }) : H(t, { suffix: a, expr: o }), c = {};
  if (s === 0 || s === 1) {
    c.scale = e;
    const f = s === 0 ? u : l;
    c.field = f;
  } else {
    const f = Q(s) ? `(1-${s.signal}) * ${u} + ${s.signal} * ${l}` : `${1 - s} * ${u} + ${s} * ${l}`;
    c.signal = `scale("${e}", ${f})`;
  }
  return i && (c.offset = i), c;
}
function ode({ scaleName: e, fieldDef: t }) {
  const n = H(t, { expr: "datum" }), i = H(t, { expr: "datum", suffix: "end" });
  return `abs(scale("${e}", ${i}) - scale("${e}", ${n}))`;
}
function m3({ channel: e, channelDef: t, channel2Def: n, markDef: i, config: r, scaleName: a, scale: s, stack: o, offset: u, defaultRef: l, bandPosition: c }) {
  if (t) {
    if (le(t)) {
      const f = s == null ? void 0 : s.get("type");
      if (sn(t)) {
        c ?? (c = Za({
          fieldDef: t,
          fieldDef2: n,
          markDef: i,
          config: r
        }));
        const { bin: d, timeUnit: h, type: p } = t;
        if (De(d) || c && h && p === Pu)
          return o != null && o.impute ? Js(t, a, { binSuffix: "mid" }, { offset: u }) : c && !gt(f) ? Eg({ scaleName: a, fieldOrDatumDef: t, bandPosition: c, offset: u }) : Js(t, a, Nd(t, e) ? { binSuffix: "range" } : {}, {
            offset: u
          });
        if (vt(d)) {
          if (j(n))
            return Eg({
              scaleName: a,
              fieldOrDatumDef: t,
              fieldOrDatumDef2: n,
              bandPosition: c,
              offset: u
            });
          q(sT(e === je ? Ii : wr));
        }
      }
      return Js(
        t,
        a,
        gt(f) ? { binSuffix: "range" } : {},
        // no need for bin suffix if there is no scale
        {
          offset: u,
          // For band, to get mid point, need to offset by half of the band
          band: f === "band" ? c ?? t.bandPosition ?? 0.5 : void 0
        }
      );
    } else if (Oi(t)) {
      const f = t.value, d = u ? { offset: u } : {};
      return { ...Lc(e, f), ...d };
    }
  }
  return oe(l) && (l = l()), l && {
    ...l,
    // only include offset when it is non-zero (zero = no offset)
    ...u ? { offset: u } : {}
  };
}
function Lc(e, t) {
  return pe(["x", "x2"], e) && t === "width" ? { field: { group: "width" } } : pe(["y", "y2"], e) && t === "height" ? { field: { group: "height" } } : ze(t);
}
function bo(e) {
  return e && e !== "number" && e !== "time";
}
function OT(e, t, n) {
  return `${e}(${t}${n ? `, ${Ce(n)}` : ""})`;
}
const ude = "  ";
function y3({ fieldOrDatumDef: e, format: t, formatType: n, expr: i, normalizeStack: r, config: a }) {
  var u, l;
  if (bo(n))
    return wi({
      fieldOrDatumDef: e,
      format: t,
      formatType: n,
      expr: i,
      config: a
    });
  const s = RT(e, i, r), o = Iu(e);
  if (t === void 0 && n === void 0 && a.customFormatTypes) {
    if (o === "quantitative") {
      if (r && a.normalizedNumberFormatType)
        return wi({
          fieldOrDatumDef: e,
          format: a.normalizedNumberFormat,
          formatType: a.normalizedNumberFormatType,
          expr: i,
          config: a
        });
      if (a.numberFormatType)
        return wi({
          fieldOrDatumDef: e,
          format: a.numberFormat,
          formatType: a.numberFormatType,
          expr: i,
          config: a
        });
    }
    if (o === "temporal" && a.timeFormatType && j(e) && e.timeUnit === void 0)
      return wi({
        fieldOrDatumDef: e,
        format: a.timeFormat,
        formatType: a.timeFormatType,
        expr: i,
        config: a
      });
  }
  if (ju(e)) {
    const c = cde({
      field: s,
      timeUnit: j(e) ? (u = pt(e.timeUnit)) == null ? void 0 : u.unit : void 0,
      format: t,
      formatType: a.timeFormatType,
      rawTimeFormat: a.timeFormat,
      isUTCScale: Lo(e) && ((l = e.scale) == null ? void 0 : l.type) === yn.UTC
    });
    return c ? { signal: c } : void 0;
  }
  if (t = Ov({ type: o, specifiedFormat: t, config: a, normalizeStack: r }), j(e) && De(e.bin)) {
    const c = H(e, { expr: i, binSuffix: "end" });
    return {
      signal: Rd(s, c, t, n, a)
    };
  } else
    return t || Iu(e) === "quantitative" ? {
      signal: `${NT(s, t)}`
    } : { signal: `isValid(${s}) ? ${s} : ""+${s}` };
}
function RT(e, t, n) {
  return j(e) ? n ? `${H(e, { expr: t, suffix: "end" })}-${H(e, {
    expr: t,
    suffix: "start"
  })}` : H(e, { expr: t }) : sde(e);
}
function wi({ fieldOrDatumDef: e, format: t, formatType: n, expr: i, normalizeStack: r, config: a, field: s }) {
  if (s ?? (s = RT(e, i, r)), s !== "datum.value" && // For axis/legend, we can't correctly know the end of the bin from `datum`
  j(e) && De(e.bin)) {
    const o = H(e, { expr: i, binSuffix: "end" });
    return {
      signal: Rd(s, o, t, n, a)
    };
  }
  return { signal: OT(n, s, t) };
}
function TT(e, t, n, i, r, a) {
  var s;
  if (!(V(i) && bo(i)) && !(n === void 0 && i === void 0 && r.customFormatTypes && Iu(e) === "quantitative" && (r.normalizedNumberFormatType && Bu(e) && e.stack === "normalize" || r.numberFormatType))) {
    if (Bu(e) && e.stack === "normalize" && r.normalizedNumberFormat)
      return Ov({
        type: "quantitative",
        config: r,
        normalizeStack: !0
      });
    if (ju(e)) {
      const o = j(e) ? (s = pt(e.timeUnit)) == null ? void 0 : s.unit : void 0;
      return o === void 0 && r.customFormatTypes && r.timeFormatType ? void 0 : lde({ specifiedFormat: n, timeUnit: o, config: r, omitTimeFormatConfig: a });
    }
    return Ov({ type: t, specifiedFormat: n, config: r });
  }
}
function DT(e, t, n) {
  var i;
  if (e && (Q(e) || e === "number" || e === "time"))
    return e;
  if (ju(t) && n !== "time" && n !== "utc")
    return j(t) && ((i = pt(t == null ? void 0 : t.timeUnit)) != null && i.utc) ? "utc" : "time";
}
function Ov({ type: e, specifiedFormat: t, config: n, normalizeStack: i }) {
  if (V(t))
    return t;
  if (e === mo)
    return i ? n.normalizedNumberFormat : n.numberFormat;
}
function lde({ specifiedFormat: e, timeUnit: t, config: n, omitTimeFormatConfig: i }) {
  return e || (t ? {
    signal: pT(t)
  } : i ? void 0 : n.timeFormat);
}
function NT(e, t) {
  return `format(${e}, "${t || ""}")`;
}
function _4(e, t, n, i) {
  return bo(n) ? OT(n, e, t) : NT(e, (V(t) ? t : void 0) ?? i.numberFormat);
}
function Rd(e, t, n, i, r) {
  if (n === void 0 && i === void 0 && r.customFormatTypes && r.numberFormatType)
    return Rd(e, t, r.numberFormat, r.numberFormatType, r);
  const a = _4(e, n, i, r), s = _4(t, n, i, r);
  return `${u3(e, !1)} ? "null" : ${a} + "${ude}" + ${s}`;
}
function cde({ field: e, timeUnit: t, format: n, formatType: i, rawTimeFormat: r, isUTCScale: a }) {
  return !t || n ? !t && i ? `${i}(${e}, '${n}')` : (n = V(n) ? n : r, `${a ? "utc" : "time"}Format(${e}, '${n}')`) : vfe(t, e, a);
}
const Rm = "min", fde = {
  x: 1,
  y: 1,
  color: 1,
  fill: 1,
  stroke: 1,
  strokeWidth: 1,
  size: 1,
  shape: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  opacity: 1,
  text: 1
};
function F4(e) {
  return e in fde;
}
function LT(e) {
  return !!(e != null && e.encoding);
}
function or(e) {
  return e && (e.op === "count" || !!e.field);
}
function PT(e) {
  return e && R(e);
}
function Td(e) {
  return "row" in e || "column" in e;
}
function b3(e) {
  return !!e && "header" in e;
}
function Tm(e) {
  return "facet" in e;
}
function dde(e) {
  return e.param;
}
function hde(e) {
  return e && !V(e) && "repeat" in e;
}
function M4(e) {
  const { field: t, timeUnit: n, bin: i, aggregate: r } = e;
  return {
    ...n ? { timeUnit: n } : {},
    ...i ? { bin: i } : {},
    ...r ? { aggregate: r } : {},
    field: t
  };
}
function v3(e) {
  return "sort" in e;
}
function Za({ fieldDef: e, fieldDef2: t, markDef: n, config: i }) {
  if (le(e) && e.bandPosition !== void 0)
    return e.bandPosition;
  if (j(e)) {
    const { timeUnit: r, bin: a } = e;
    if (r && !t)
      return Jr("timeUnitBandPosition", n, i);
    if (De(a))
      return 0.5;
  }
}
function zT({ channel: e, fieldDef: t, fieldDef2: n, markDef: i, config: r, scaleType: a, useVlSizeChannel: s }) {
  var l, c, f;
  const o = Sn(e), u = Ee(s ? "size" : o, i, r, {
    vgChannel: o
  });
  if (u !== void 0)
    return u;
  if (j(t)) {
    const { timeUnit: d, bin: h } = t;
    if (d && !n)
      return { band: Jr("timeUnitBandSize", i, r) };
    if (De(h) && !gt(a))
      return { band: 1 };
  }
  if (vf(i.type))
    return a ? gt(a) ? ((l = r[i.type]) == null ? void 0 : l.discreteBandSize) || { band: 1 } : (c = r[i.type]) == null ? void 0 : c.continuousBandSize : (f = r[i.type]) == null ? void 0 : f.discreteBandSize;
}
function IT(e, t, n, i) {
  return De(e.bin) || e.timeUnit && sn(e) && e.type === "temporal" ? Za({ fieldDef: e, fieldDef2: t, markDef: n, config: i }) !== void 0 : !1;
}
function BT(e) {
  return e && !!e.sort && !e.field;
}
function Dm(e) {
  return e && "condition" in e;
}
function Nm(e) {
  const t = e == null ? void 0 : e.condition;
  return !!t && !R(t) && j(t);
}
function Dd(e) {
  const t = e == null ? void 0 : e.condition;
  return !!t && !R(t) && le(t);
}
function pde(e) {
  const t = e == null ? void 0 : e.condition;
  return !!t && (R(t) || Oi(t));
}
function j(e) {
  return e && (!!e.field || e.aggregate === "count");
}
function Iu(e) {
  return e == null ? void 0 : e.type;
}
function Cr(e) {
  return e && "datum" in e;
}
function Ta(e) {
  return sn(e) && !Ag(e) || Sg(e);
}
function O4(e) {
  return sn(e) && e.type === "quantitative" && !e.bin || Sg(e);
}
function Sg(e) {
  return Cr(e) && ye(e.datum);
}
function le(e) {
  return j(e) || Cr(e);
}
function sn(e) {
  return e && ("field" in e || e.aggregate === "count") && "type" in e;
}
function Oi(e) {
  return e && "value" in e && "value" in e;
}
function Lo(e) {
  return e && ("scale" in e || "sort" in e);
}
function Bu(e) {
  return e && ("axis" in e || "stack" in e || "impute" in e);
}
function jT(e) {
  return e && "legend" in e;
}
function UT(e) {
  return e && ("format" in e || "formatType" in e);
}
function gde(e) {
  return mn(e, ["legend", "axis", "header", "scale"]);
}
function mde(e) {
  return "op" in e;
}
function H(e, t = {}) {
  let n = e.field;
  const i = t.prefix;
  let r = t.suffix, a = "";
  if (bde(e))
    n = OR("count");
  else {
    let s;
    if (!t.nofn)
      if (mde(e))
        s = e.op;
      else {
        const { bin: o, aggregate: u, timeUnit: l } = e;
        De(o) ? (s = HR(o), r = (t.binSuffix ?? "") + (t.suffix ?? "")) : u ? gs(u) ? (a = `["${n}"]`, n = `argmax_${u.argmax}`) : Kr(u) ? (a = `["${n}"]`, n = `argmin_${u.argmin}`) : s = String(u) : l && !No(l) && (s = xfe(l), r = (!["range", "mid"].includes(t.binSuffix) && t.binSuffix || "") + (t.suffix ?? ""));
      }
    s && (n = n ? `${s}_${n}` : s);
  }
  return r && (n = `${n}_${r}`), i && (n = `${i}_${n}`), t.forAs ? jE(n) : t.expr ? _R(n, t.expr) + a : ni(n) + a;
}
function Ag(e) {
  switch (e.type) {
    case "nominal":
    case "ordinal":
    case "geojson":
      return !0;
    case "quantitative":
      return j(e) && !!e.bin;
    case "temporal":
      return !1;
  }
  throw new Error(nT(e.type));
}
function yde(e) {
  var t;
  return Lo(e) && zu((t = e.scale) == null ? void 0 : t.type);
}
function bde(e) {
  return e.aggregate === "count";
}
function vde(e, t) {
  var s;
  const { field: n, bin: i, timeUnit: r, aggregate: a } = e;
  if (a === "count")
    return t.countTitle;
  if (De(i))
    return `${n} (binned)`;
  if (r && !No(r)) {
    const o = (s = pt(r)) == null ? void 0 : s.unit;
    if (o)
      return `${n} (${Cm(o).join("-")})`;
  } else if (a)
    return gs(a) ? `${n} for max ${a.argmax}` : Kr(a) ? `${n} for min ${a.argmin}` : `${kd(a)} of ${n}`;
  return n;
}
function xde(e) {
  const { aggregate: t, bin: n, timeUnit: i, field: r } = e;
  if (gs(t))
    return `${r} for argmax(${t.argmax})`;
  if (Kr(t))
    return `${r} for argmin(${t.argmin})`;
  const a = i && !No(i) ? pt(i) : void 0, s = t || (a == null ? void 0 : a.unit) || (a == null ? void 0 : a.maxbins) && "timeunit" || De(n) && "bin";
  return s ? `${s.toUpperCase()}(${r})` : r;
}
const qT = (e, t) => {
  switch (t.fieldTitle) {
    case "plain":
      return e.field;
    case "functional":
      return xde(e);
    default:
      return vde(e, t);
  }
};
let GT = qT;
function WT(e) {
  GT = e;
}
function $de() {
  WT(qT);
}
function du(e, t, { allowDisabling: n, includeDefault: i = !0 }) {
  var o;
  const r = (o = x3(e)) == null ? void 0 : o.title;
  if (!j(e))
    return r ?? e.title;
  const a = e, s = i ? $3(a, t) : void 0;
  return n ? Ke(r, a.title, s) : r ?? a.title ?? s;
}
function x3(e) {
  if (Bu(e) && e.axis)
    return e.axis;
  if (jT(e) && e.legend)
    return e.legend;
  if (b3(e) && e.header)
    return e.header;
}
function $3(e, t) {
  return GT(e, t);
}
function kg(e) {
  if (UT(e)) {
    const { format: t, formatType: n } = e;
    return { format: t, formatType: n };
  } else {
    const t = x3(e) ?? {}, { format: n, formatType: i } = t;
    return { format: n, formatType: i };
  }
}
function wde(e, t) {
  var a;
  switch (t) {
    case "latitude":
    case "longitude":
      return "quantitative";
    case "row":
    case "column":
    case "facet":
    case "shape":
    case "strokeDash":
      return "nominal";
    case "order":
      return "ordinal";
  }
  if (v3(e) && R(e.sort))
    return "ordinal";
  const { aggregate: n, bin: i, timeUnit: r } = e;
  if (r)
    return "temporal";
  if (i || n && !gs(n) && !Kr(n))
    return "quantitative";
  if (Lo(e) && ((a = e.scale) != null && a.type))
    switch (Fv[e.scale.type]) {
      case "numeric":
      case "discretizing":
        return "quantitative";
      case "time":
        return "temporal";
    }
  return "nominal";
}
function gr(e) {
  if (j(e))
    return e;
  if (Nm(e))
    return e.condition;
}
function it(e) {
  if (le(e))
    return e;
  if (Dd(e))
    return e.condition;
}
function HT(e, t, n, i = {}) {
  if (V(e) || ye(e) || Zr(e)) {
    const r = V(e) ? "string" : ye(e) ? "number" : "boolean";
    return q(Ece(t, r, e)), { value: e };
  }
  return le(e) ? Cg(e, t, n, i) : Dd(e) ? {
    ...e,
    // Need to cast as normalizeFieldDef normally return FieldDef, but here we know that it is definitely Condition<FieldDef>
    condition: Cg(e.condition, t, n, i)
  } : e;
}
function Cg(e, t, n, i) {
  if (UT(e)) {
    const { format: r, formatType: a, ...s } = e;
    if (bo(a) && !n.customFormatTypes)
      return q(E4(t)), Cg(s, t, n, i);
  } else {
    const r = Bu(e) ? "axis" : jT(e) ? "legend" : b3(e) ? "header" : null;
    if (r && e[r]) {
      const { format: a, formatType: s, ...o } = e[r];
      if (bo(s) && !n.customFormatTypes)
        return q(E4(t)), Cg({ ...e, [r]: o }, t, n, i);
    }
  }
  return j(e) ? w3(e, t, i) : Ede(e);
}
function Ede(e) {
  let t = e.type;
  if (t)
    return e;
  const { datum: n } = e;
  return t = ye(n) ? "quantitative" : V(n) ? "nominal" : Do(n) ? "temporal" : void 0, { ...e, type: t };
}
function w3(e, t, { compositeMark: n = !1 } = {}) {
  const { aggregate: i, timeUnit: r, bin: a, field: s } = e, o = { ...e };
  if (!n && i && !YE(i) && !gs(i) && !Kr(i) && (q(Ace(i)), delete o.aggregate), r && (o.timeUnit = pt(r)), s && (o.field = `${s}`), De(a) && (o.bin = Lm(a, t)), vt(a) && !Je(t) && q(ife(t)), sn(o)) {
    const { type: u } = o, l = _fe(u);
    u !== l && (o.type = l), u !== "quantitative" && WR(i) && (q(Sce(u, i)), o.type = "quantitative");
  } else if (!IR(t)) {
    const u = wde(o, t);
    o.type = u;
  }
  if (sn(o)) {
    const { compatible: u, warning: l } = Sde(o, t) || {};
    u === !1 && q(l);
  }
  if (v3(o) && V(o.sort)) {
    const { sort: u } = o;
    if (F4(u))
      return {
        ...o,
        sort: { encoding: u }
      };
    const l = u.substr(1);
    if (u.charAt(0) === "-" && F4(l))
      return {
        ...o,
        sort: { encoding: l, order: "descending" }
      };
  }
  if (b3(o)) {
    const { header: u } = o;
    if (u) {
      const { orient: l, ...c } = u;
      if (l)
        return {
          ...o,
          header: {
            ...c,
            labelOrient: u.labelOrient || l,
            titleOrient: u.titleOrient || l
          }
        };
    }
  }
  return o;
}
function Lm(e, t) {
  return Zr(e) ? { maxbins: p4(t) } : e === "binned" ? {
    binned: !0
  } : !e.maxbins && !e.step ? { ...e, maxbins: p4(t) } : e;
}
const Xo = { compatible: !0 };
function Sde(e, t) {
  const n = e.type;
  if (n === "geojson" && t !== "shape")
    return {
      compatible: !1,
      warning: `Channel ${t} should not be used with a geojson data.`
    };
  switch (t) {
    case qr:
    case Gr:
    case bm:
      return Ag(e) ? Xo : {
        compatible: !1,
        warning: Fce(t)
      };
    case je:
    case bt:
    case cs:
    case vl:
    case wn:
    case Er:
    case Sr:
    case Cd:
    case _d:
    case vm:
    case po:
    case xm:
    case $m:
    case Oo:
    case ai:
    case Bi:
    case wm:
      return Xo;
    case Ui:
    case ii:
    case ji:
    case qi:
      return n !== mo ? {
        compatible: !1,
        warning: `Channel ${t} should be used with a quantitative field only, not ${e.type} field.`
      } : Xo;
    case oa:
    case fs:
    case ds:
    case hs:
    case sa:
    case aa:
    case ra:
    case Ii:
    case wr:
      return n === "nominal" && !e.sort ? {
        compatible: !1,
        warning: `Channel ${t} should not be used with an unsorted discrete field.`
      } : Xo;
    case En:
    case ps:
      return !Ag(e) && !yde(e) ? {
        compatible: !1,
        warning: Mce(t)
      } : Xo;
    case Nu:
      return e.type === "nominal" && !("sort" in e) ? {
        compatible: !1,
        warning: "Channel order is inappropriate for nominal field, which has no inherent order."
      } : Xo;
  }
}
function ju(e) {
  const { formatType: t } = kg(e);
  return t === "time" || !t && Ade(e);
}
function Ade(e) {
  return e && (e.type === "temporal" || j(e) && !!e.timeUnit);
}
function Pm(e, { timeUnit: t, type: n, wrapTime: i, undefinedIfExprNotRequired: r }) {
  var u;
  const a = t && ((u = pt(t)) == null ? void 0 : u.unit);
  let s = a || n === "temporal", o;
  return Md(e) ? o = e.expr : Q(e) ? o = e.signal : Do(e) ? (s = !0, o = go(e)) : (V(e) || ye(e)) && s && (o = `datetime(${Ce(e)})`, gfe(a) && (ye(e) && e < 1e4 || V(e) && isNaN(Date.parse(e))) && (o = go({ [a]: e }))), o ? i && s ? `time(${o})` : o : r ? void 0 : Ce(e);
}
function VT(e, t) {
  const { type: n } = e;
  return t.map((i) => {
    const r = j(e) && !No(e.timeUnit) ? e.timeUnit : void 0, a = Pm(i, {
      timeUnit: r,
      type: n,
      undefinedIfExprNotRequired: !0
    });
    return a !== void 0 ? { signal: a } : i;
  });
}
function Nd(e, t) {
  return De(e.bin) ? ua(t) && ["ordinal", "nominal"].includes(e.type) : (console.warn("Only call this method for binned field defs."), !1);
}
const R4 = {
  labelAlign: {
    part: "labels",
    vgProp: "align"
  },
  labelBaseline: {
    part: "labels",
    vgProp: "baseline"
  },
  labelColor: {
    part: "labels",
    vgProp: "fill"
  },
  labelFont: {
    part: "labels",
    vgProp: "font"
  },
  labelFontSize: {
    part: "labels",
    vgProp: "fontSize"
  },
  labelFontStyle: {
    part: "labels",
    vgProp: "fontStyle"
  },
  labelFontWeight: {
    part: "labels",
    vgProp: "fontWeight"
  },
  labelOpacity: {
    part: "labels",
    vgProp: "opacity"
  },
  labelOffset: null,
  labelPadding: null,
  gridColor: {
    part: "grid",
    vgProp: "stroke"
  },
  gridDash: {
    part: "grid",
    vgProp: "strokeDash"
  },
  gridDashOffset: {
    part: "grid",
    vgProp: "strokeDashOffset"
  },
  gridOpacity: {
    part: "grid",
    vgProp: "opacity"
  },
  gridWidth: {
    part: "grid",
    vgProp: "strokeWidth"
  },
  tickColor: {
    part: "ticks",
    vgProp: "stroke"
  },
  tickDash: {
    part: "ticks",
    vgProp: "strokeDash"
  },
  tickDashOffset: {
    part: "ticks",
    vgProp: "strokeDashOffset"
  },
  tickOpacity: {
    part: "ticks",
    vgProp: "opacity"
  },
  tickSize: null,
  tickWidth: {
    part: "ticks",
    vgProp: "strokeWidth"
  }
};
function Ld(e) {
  return e == null ? void 0 : e.condition;
}
const XT = ["domain", "grid", "labels", "ticks", "title"], kde = {
  grid: "grid",
  gridCap: "grid",
  gridColor: "grid",
  gridDash: "grid",
  gridDashOffset: "grid",
  gridOpacity: "grid",
  gridScale: "grid",
  gridWidth: "grid",
  orient: "main",
  bandPosition: "both",
  aria: "main",
  description: "main",
  domain: "main",
  domainCap: "main",
  domainColor: "main",
  domainDash: "main",
  domainDashOffset: "main",
  domainOpacity: "main",
  domainWidth: "main",
  format: "main",
  formatType: "main",
  labelAlign: "main",
  labelAngle: "main",
  labelBaseline: "main",
  labelBound: "main",
  labelColor: "main",
  labelFlush: "main",
  labelFlushOffset: "main",
  labelFont: "main",
  labelFontSize: "main",
  labelFontStyle: "main",
  labelFontWeight: "main",
  labelLimit: "main",
  labelLineHeight: "main",
  labelOffset: "main",
  labelOpacity: "main",
  labelOverlap: "main",
  labelPadding: "main",
  labels: "main",
  labelSeparation: "main",
  maxExtent: "main",
  minExtent: "main",
  offset: "both",
  position: "main",
  tickCap: "main",
  tickColor: "main",
  tickDash: "main",
  tickDashOffset: "main",
  tickMinStep: "both",
  tickOffset: "both",
  tickOpacity: "main",
  tickRound: "both",
  ticks: "main",
  tickSize: "main",
  tickWidth: "both",
  title: "main",
  titleAlign: "main",
  titleAnchor: "main",
  titleAngle: "main",
  titleBaseline: "main",
  titleColor: "main",
  titleFont: "main",
  titleFontSize: "main",
  titleFontStyle: "main",
  titleFontWeight: "main",
  titleLimit: "main",
  titleLineHeight: "main",
  titleOpacity: "main",
  titlePadding: "main",
  titleX: "main",
  titleY: "main",
  encode: "both",
  scale: "both",
  tickBand: "both",
  tickCount: "both",
  tickExtra: "both",
  translate: "both",
  values: "both",
  zindex: "both"
  // this is actually set afterward, so it doesn't matter
}, YT = {
  orient: 1,
  aria: 1,
  bandPosition: 1,
  description: 1,
  domain: 1,
  domainCap: 1,
  domainColor: 1,
  domainDash: 1,
  domainDashOffset: 1,
  domainOpacity: 1,
  domainWidth: 1,
  format: 1,
  formatType: 1,
  grid: 1,
  gridCap: 1,
  gridColor: 1,
  gridDash: 1,
  gridDashOffset: 1,
  gridOpacity: 1,
  gridWidth: 1,
  labelAlign: 1,
  labelAngle: 1,
  labelBaseline: 1,
  labelBound: 1,
  labelColor: 1,
  labelFlush: 1,
  labelFlushOffset: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelLineHeight: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labels: 1,
  labelSeparation: 1,
  maxExtent: 1,
  minExtent: 1,
  offset: 1,
  position: 1,
  tickBand: 1,
  tickCap: 1,
  tickColor: 1,
  tickCount: 1,
  tickDash: 1,
  tickDashOffset: 1,
  tickExtra: 1,
  tickMinStep: 1,
  tickOffset: 1,
  tickOpacity: 1,
  tickRound: 1,
  ticks: 1,
  tickSize: 1,
  tickWidth: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleAngle: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titlePadding: 1,
  titleX: 1,
  titleY: 1,
  translate: 1,
  values: 1,
  zindex: 1
}, Cde = {
  ...YT,
  style: 1,
  labelExpr: 1,
  encoding: 1
};
function T4(e) {
  return !!Cde[e];
}
const _de = {
  axis: 1,
  axisBand: 1,
  axisBottom: 1,
  axisDiscrete: 1,
  axisLeft: 1,
  axisPoint: 1,
  axisQuantitative: 1,
  axisRight: 1,
  axisTemporal: 1,
  axisTop: 1,
  axisX: 1,
  axisXBand: 1,
  axisXDiscrete: 1,
  axisXPoint: 1,
  axisXQuantitative: 1,
  axisXTemporal: 1,
  axisY: 1,
  axisYBand: 1,
  axisYDiscrete: 1,
  axisYPoint: 1,
  axisYQuantitative: 1,
  axisYTemporal: 1
}, KT = I(_de);
function la(e) {
  return "mark" in e;
}
class zm {
  constructor(t, n) {
    this.name = t, this.run = n;
  }
  hasMatchingType(t) {
    return la(t) ? ide(t.mark) === this.name : !1;
  }
}
function Qs(e, t) {
  const n = e && e[t];
  return n ? R(n) ? fo(n, (i) => !!i.field) : j(n) || Nm(n) : !1;
}
function JT(e, t) {
  const n = e && e[t];
  return n ? R(n) ? fo(n, (i) => !!i.field) : j(n) || Cr(n) || Dd(n) : !1;
}
function QT(e, t) {
  if (Je(t)) {
    const n = e[t];
    if ((j(n) || Cr(n)) && (vT(n.type) || j(n) && n.timeUnit)) {
      const i = WE(t);
      return JT(e, i);
    }
  }
  return !1;
}
function E3(e) {
  return fo(Mle, (t) => {
    if (Qs(e, t)) {
      const n = e[t];
      if (R(n))
        return fo(n, (i) => !!i.aggregate);
      {
        const i = gr(n);
        return i && !!i.aggregate;
      }
    }
    return !1;
  });
}
function ZT(e, t) {
  const n = [], i = [], r = [], a = [], s = {};
  return S3(e, (o, u) => {
    if (j(o)) {
      const { field: l, aggregate: c, bin: f, timeUnit: d, ...h } = o;
      if (c || d || f) {
        const p = x3(o), g = p == null ? void 0 : p.title;
        let m = H(o, { forAs: !0 });
        const y = {
          // Only add title if it doesn't exist
          ...g ? [] : { title: du(o, t, { allowDisabling: !0 }) },
          ...h,
          // Always overwrite field
          field: m
        };
        if (c) {
          let b;
          if (gs(c) ? (b = "argmax", m = H({ op: "argmax", field: c.argmax }, { forAs: !0 }), y.field = `${m}.${l}`) : Kr(c) ? (b = "argmin", m = H({ op: "argmin", field: c.argmin }, { forAs: !0 }), y.field = `${m}.${l}`) : c !== "boxplot" && c !== "errorbar" && c !== "errorband" && (b = c), b) {
            const v = {
              op: b,
              as: m
            };
            l && (v.field = l), a.push(v);
          }
        } else if (n.push(m), sn(o) && De(f)) {
          if (i.push({ bin: f, field: l, as: m }), n.push(H(o, { binSuffix: "end" })), Nd(o, u) && n.push(H(o, { binSuffix: "range" })), Je(u)) {
            const b = {
              field: `${m}_end`
            };
            s[`${u}2`] = b;
          }
          y.bin = "binned", IR(u) || (y.type = mo);
        } else if (d && !No(d)) {
          r.push({
            timeUnit: d,
            field: l,
            as: m
          });
          const b = sn(o) && o.type !== Pu && "time";
          b && (u === Cd || u === po ? y.formatType = b : Ble(u) ? y.legend = {
            formatType: b,
            ...y.legend
          } : Je(u) && (y.axis = {
            formatType: b,
            ...y.axis
          }));
        }
        s[u] = y;
      } else
        n.push(l), s[u] = e[u];
    } else
      s[u] = e[u];
  }), {
    bins: i,
    timeUnits: r,
    aggregate: a,
    groupby: n,
    encoding: s
  };
}
function Fde(e, t, n) {
  const i = Ule(t, n);
  if (i) {
    if (i === "binned") {
      const r = e[t === Ii ? je : bt];
      return !!(j(r) && j(e[t]) && vt(r.bin));
    }
  } else
    return !1;
  return !0;
}
function Mde(e, t, n, i) {
  const r = {};
  for (const a of I(e))
    zR(a) || q(_ce(a));
  for (let a of Lle) {
    if (!e[a])
      continue;
    const s = e[a];
    if (Fd(a)) {
      const o = Nle(a), u = r[o];
      if (j(u) && Cfe(u.type) && j(s) && !u.timeUnit) {
        q(wce(o));
        continue;
      }
    }
    if (a === "angle" && t === "arc" && !e.theta && (q($ce), a = ai), !Fde(e, a, t)) {
      q(km(a, t));
      continue;
    }
    if (a === sa && t === "line") {
      const o = gr(e[a]);
      if (o != null && o.aggregate) {
        q(Cce);
        continue;
      }
    }
    if (a === wn && (n ? "fill" in e : "stroke" in e)) {
      q(iT("encoding", { fill: "fill" in e, stroke: "stroke" in e }));
      continue;
    }
    if (a === _d || a === Nu && !R(s) && !Oi(s) || a === po && R(s)) {
      if (s) {
        if (a === Nu) {
          const o = e[a];
          if (BT(o)) {
            r[a] = o;
            continue;
          }
        }
        r[a] = G(s).reduce((o, u) => (j(u) ? o.push(w3(u, a)) : q(_v(u, a)), o), []);
      }
    } else {
      if (a === po && s === null)
        r[a] = null;
      else if (!j(s) && !Cr(s) && !Oi(s) && !Dm(s) && !Q(s)) {
        q(_v(s, a));
        continue;
      }
      r[a] = HT(s, a, i);
    }
  }
  return r;
}
function Im(e, t) {
  const n = {};
  for (const i of I(e)) {
    const r = HT(e[i], i, t, { compositeMark: !0 });
    n[i] = r;
  }
  return n;
}
function Ode(e) {
  const t = [];
  for (const n of I(e))
    if (Qs(e, n)) {
      const i = e[n], r = G(i);
      for (const a of r)
        j(a) ? t.push(a) : Nm(a) && t.push(a.condition);
    }
  return t;
}
function S3(e, t, n) {
  if (e)
    for (const i of I(e)) {
      const r = e[i];
      if (R(r))
        for (const a of r)
          t.call(n, a, i);
      else
        t.call(n, r, i);
    }
}
function Rde(e, t, n, i) {
  return e ? I(e).reduce((r, a) => {
    const s = e[a];
    return R(s) ? s.reduce((o, u) => t.call(i, o, u, a), r) : t.call(i, r, s, a);
  }, n) : n;
}
function eD(e, t) {
  return I(t).reduce((n, i) => {
    switch (i) {
      case je:
      case bt:
      case xm:
      case wm:
      case $m:
      case Ii:
      case wr:
      case cs:
      case vl:
      case ai:
      case aa:
      case Bi:
      case ra:
      case ji:
      case Ui:
      case qi:
      case ii:
      case Cd:
      case En:
      case Oo:
      case po:
        return n;
      case Nu:
        if (e === "line" || e === "trail")
          return n;
      case _d:
      case vm: {
        const r = t[i];
        if (R(r) || j(r))
          for (const a of G(r))
            a.aggregate || n.push(H(a, {}));
        return n;
      }
      case sa:
        if (e === "trail")
          return n;
      case wn:
      case Er:
      case Sr:
      case oa:
      case fs:
      case ds:
      case ps:
      case hs: {
        const r = gr(t[i]);
        return r && !r.aggregate && n.push(H(r, {})), n;
      }
    }
  }, []);
}
function Tde(e) {
  const { tooltip: t, ...n } = e;
  if (!t)
    return { filteredEncoding: n };
  let i, r;
  if (R(t)) {
    for (const a of t)
      a.aggregate ? (i || (i = []), i.push(a)) : (r || (r = []), r.push(a));
    i && (n.tooltip = i);
  } else
    t.aggregate ? n.tooltip = t : r = t;
  return R(r) && r.length === 1 && (r = r[0]), { customTooltipWithoutAggregatedField: r, filteredEncoding: n };
}
function Rv(e, t, n, i = !0) {
  if ("tooltip" in n)
    return { tooltip: n.tooltip };
  const r = e.map(({ fieldPrefix: s, titlePrefix: o }) => {
    const u = i ? ` of ${A3(t)}` : "";
    return {
      field: s + t.field,
      type: t.type,
      title: Q(o) ? { signal: `${o}"${escape(u)}"` } : o + u
    };
  }), a = Ode(n).map(gde);
  return {
    tooltip: [
      ...r,
      // need to cast because TextFieldDef supports fewer types of bin
      ...rr(a, he)
    ]
  };
}
function A3(e) {
  const { title: t, field: n } = e;
  return Ke(t, n);
}
function k3(e, t, n, i, r) {
  const { scale: a, axis: s } = n;
  return ({ partName: o, mark: u, positionPrefix: l, endPositionPrefix: c = void 0, extraEncoding: f = {} }) => {
    const d = A3(n);
    return tD(e, o, r, {
      mark: u,
      encoding: {
        [t]: {
          field: `${l}_${n.field}`,
          type: n.type,
          ...d !== void 0 ? { title: d } : {},
          ...a !== void 0 ? { scale: a } : {},
          ...s !== void 0 ? { axis: s } : {}
        },
        ...V(c) ? {
          [`${t}2`]: {
            field: `${c}_${n.field}`
          }
        } : {},
        ...i,
        ...f
      }
    });
  };
}
function tD(e, t, n, i) {
  const { clip: r, color: a, opacity: s } = e, o = e.type;
  return e[t] || e[t] === void 0 && n[t] ? [
    {
      ...i,
      mark: {
        ...n[t],
        ...r ? { clip: r } : {},
        ...a ? { color: a } : {},
        ...s ? { opacity: s } : {},
        ...pr(i.mark) ? i.mark : { type: i.mark },
        style: `${o}-${String(t)}`,
        ...Zr(e[t]) ? {} : e[t]
      }
    }
  ] : [];
}
function nD(e, t, n) {
  const { encoding: i } = e, r = t === "vertical" ? "y" : "x", a = i[r], s = i[`${r}2`], o = i[`${r}Error`], u = i[`${r}Error2`];
  return {
    continuousAxisChannelDef: hh(a, n),
    continuousAxisChannelDef2: hh(s, n),
    continuousAxisChannelDefError: hh(o, n),
    continuousAxisChannelDefError2: hh(u, n),
    continuousAxis: r
  };
}
function hh(e, t) {
  if (e != null && e.aggregate) {
    const { aggregate: n, ...i } = e;
    return n !== t && q(nfe(n, t)), i;
  } else
    return e;
}
function iD(e, t) {
  const { mark: n, encoding: i } = e, { x: r, y: a } = i;
  if (pr(n) && n.orient)
    return n.orient;
  if (Ta(r)) {
    if (Ta(a)) {
      const s = j(r) && r.aggregate, o = j(a) && a.aggregate;
      if (!s && o === t)
        return "vertical";
      if (!o && s === t)
        return "horizontal";
      if (s === t && o === t)
        throw new Error("Both x and y cannot have aggregate");
      return ju(a) && !ju(r) ? "horizontal" : "vertical";
    }
    return "horizontal";
  } else {
    if (Ta(a))
      return "vertical";
    throw new Error(`Need a valid continuous axis for ${t}s`);
  }
}
const _g = "boxplot", Dde = ["box", "median", "outliers", "rule", "ticks"], Nde = new zm(_g, aD);
function rD(e) {
  return ye(e) ? "tukey" : e;
}
function aD(e, { config: t }) {
  e = {
    ...e,
    encoding: Im(e.encoding, t)
  };
  const { mark: n, encoding: i, params: r, projection: a, ...s } = e, o = pr(n) ? n : { type: n };
  r && q(tT("boxplot"));
  const u = o.extent ?? t.boxplot.extent, l = Ee(
    "size",
    o,
    // TODO: https://github.com/vega/vega-lite/issues/6245
    t
  ), c = o.invalid, f = rD(u), { bins: d, timeUnits: h, transform: p, continuousAxisChannelDef: g, continuousAxis: m, groupby: y, aggregate: b, encodingWithoutContinuousAxis: v, ticksOrient: x, boxOrient: w, customTooltipWithoutAggregatedField: E } = Lde(e, u, t), { color: $, size: S, ...A } = v, k = (nL) => k3(o, m, g, nL, t.boxplot), _ = k(A), P = k(v), F = k({ ...A, ...S ? { size: S } : {} }), M = Rv([
    { fieldPrefix: f === "min-max" ? "upper_whisker_" : "max_", titlePrefix: "Max" },
    { fieldPrefix: "upper_box_", titlePrefix: "Q3" },
    { fieldPrefix: "mid_box_", titlePrefix: "Median" },
    { fieldPrefix: "lower_box_", titlePrefix: "Q1" },
    { fieldPrefix: f === "min-max" ? "lower_whisker_" : "min_", titlePrefix: "Min" }
  ], g, v), C = { type: "tick", color: "black", opacity: 1, orient: x, invalid: c, aria: !1 }, O = f === "min-max" ? M : (
    // for tukey / k-IQR, just show upper/lower-whisker
    Rv([
      { fieldPrefix: "upper_whisker_", titlePrefix: "Upper Whisker" },
      { fieldPrefix: "lower_whisker_", titlePrefix: "Lower Whisker" }
    ], g, v)
  ), L = [
    ..._({
      partName: "rule",
      mark: { type: "rule", invalid: c, aria: !1 },
      positionPrefix: "lower_whisker",
      endPositionPrefix: "lower_box",
      extraEncoding: O
    }),
    ..._({
      partName: "rule",
      mark: { type: "rule", invalid: c, aria: !1 },
      positionPrefix: "upper_box",
      endPositionPrefix: "upper_whisker",
      extraEncoding: O
    }),
    ..._({
      partName: "ticks",
      mark: C,
      positionPrefix: "lower_whisker",
      extraEncoding: O
    }),
    ..._({
      partName: "ticks",
      mark: C,
      positionPrefix: "upper_whisker",
      extraEncoding: O
    })
  ], z = [
    ...f !== "tukey" ? L : [],
    ...P({
      partName: "box",
      mark: {
        type: "bar",
        ...l ? { size: l } : {},
        orient: w,
        invalid: c,
        ariaRoleDescription: "box"
      },
      positionPrefix: "lower_box",
      endPositionPrefix: "upper_box",
      extraEncoding: M
    }),
    ...F({
      partName: "median",
      mark: {
        type: "tick",
        invalid: c,
        ...X(t.boxplot.median) && t.boxplot.median.color ? { color: t.boxplot.median.color } : {},
        ...l ? { size: l } : {},
        orient: x,
        aria: !1
      },
      positionPrefix: "mid_box",
      extraEncoding: M
    })
  ];
  if (f === "min-max")
    return {
      ...s,
      transform: (s.transform ?? []).concat(p),
      layer: z
    };
  const W = `datum["lower_box_${g.field}"]`, J = `datum["upper_box_${g.field}"]`, ie = `(${J} - ${W})`, de = `${W} - ${u} * ${ie}`, Re = `${J} + ${u} * ${ie}`, we = `datum["${g.field}"]`, ln = {
    joinaggregate: sD(g.field),
    groupby: y
  }, u1 = {
    transform: [
      {
        filter: `(${de} <= ${we}) && (${we} <= ${Re})`
      },
      {
        aggregate: [
          {
            op: "min",
            field: g.field,
            as: `lower_whisker_${g.field}`
          },
          {
            op: "max",
            field: g.field,
            as: `upper_whisker_${g.field}`
          },
          // preserve lower_box / upper_box
          {
            op: "min",
            field: `lower_box_${g.field}`,
            as: `lower_box_${g.field}`
          },
          {
            op: "max",
            field: `upper_box_${g.field}`,
            as: `upper_box_${g.field}`
          },
          ...b
        ],
        groupby: y
      }
    ],
    layer: L
  }, { tooltip: Ube, ...eL } = A, { scale: c5, axis: tL } = g, f5 = A3(g), d5 = mn(tL, ["title"]), h5 = tD(o, "outliers", t.boxplot, {
    transform: [{ filter: `(${we} < ${de}) || (${we} > ${Re})` }],
    mark: "point",
    encoding: {
      [m]: {
        field: g.field,
        type: g.type,
        ...f5 !== void 0 ? { title: f5 } : {},
        ...c5 !== void 0 ? { scale: c5 } : {},
        // add axis without title since we already added the title above
        ...ke(d5) ? {} : { axis: d5 }
      },
      ...eL,
      ...$ ? { color: $ } : {},
      ...E ? { tooltip: E } : {}
    }
  })[0];
  let Bd;
  const p5 = [...d, ...h, ln];
  return h5 ? Bd = {
    transform: p5,
    layer: [h5, u1]
  } : (Bd = u1, Bd.transform.unshift(...p5)), {
    ...s,
    layer: [
      Bd,
      {
        // boxplot
        transform: p,
        layer: z
      }
    ]
  };
}
function sD(e) {
  return [
    {
      op: "q1",
      field: e,
      as: `lower_box_${e}`
    },
    {
      op: "q3",
      field: e,
      as: `upper_box_${e}`
    }
  ];
}
function Lde(e, t, n) {
  const i = iD(e, _g), { continuousAxisChannelDef: r, continuousAxis: a } = nD(e, i, _g), s = r.field, o = rD(t), u = [
    ...sD(s),
    {
      op: "median",
      field: s,
      as: `mid_box_${s}`
    },
    {
      op: "min",
      field: s,
      as: (o === "min-max" ? "lower_whisker_" : "min_") + s
    },
    {
      op: "max",
      field: s,
      as: (o === "min-max" ? "upper_whisker_" : "max_") + s
    }
  ], l = o === "min-max" || o === "tukey" ? [] : [
    // This is for the  original k-IQR, which we do not expose
    {
      calculate: `datum["upper_box_${s}"] - datum["lower_box_${s}"]`,
      as: `iqr_${s}`
    },
    {
      calculate: `min(datum["upper_box_${s}"] + datum["iqr_${s}"] * ${t}, datum["max_${s}"])`,
      as: `upper_whisker_${s}`
    },
    {
      calculate: `max(datum["lower_box_${s}"] - datum["iqr_${s}"] * ${t}, datum["min_${s}"])`,
      as: `lower_whisker_${s}`
    }
  ], { [a]: c, ...f } = e.encoding, { customTooltipWithoutAggregatedField: d, filteredEncoding: h } = Tde(f), { bins: p, timeUnits: g, aggregate: m, groupby: y, encoding: b } = ZT(h, n), v = i === "vertical" ? "horizontal" : "vertical", x = i, w = [
    ...p,
    ...g,
    {
      aggregate: [...m, ...u],
      groupby: y
    },
    ...l
  ];
  return {
    bins: p,
    timeUnits: g,
    transform: w,
    groupby: y,
    aggregate: m,
    continuousAxisChannelDef: r,
    continuousAxis: a,
    encodingWithoutContinuousAxis: b,
    ticksOrient: v,
    boxOrient: x,
    customTooltipWithoutAggregatedField: d
  };
}
const C3 = "errorbar", Pde = ["ticks", "rule"], zde = new zm(C3, oD);
function oD(e, { config: t }) {
  e = {
    ...e,
    encoding: Im(e.encoding, t)
  };
  const { transform: n, continuousAxisChannelDef: i, continuousAxis: r, encodingWithoutContinuousAxis: a, ticksOrient: s, markDef: o, outerSpec: u, tooltipEncoding: l } = uD(e, C3, t);
  delete a.size;
  const c = k3(o, r, i, a, t.errorbar), f = o.thickness, d = o.size, h = {
    type: "tick",
    orient: s,
    aria: !1,
    ...f !== void 0 ? { thickness: f } : {},
    ...d !== void 0 ? { size: d } : {}
  }, p = [
    ...c({
      partName: "ticks",
      mark: h,
      positionPrefix: "lower",
      extraEncoding: l
    }),
    ...c({
      partName: "ticks",
      mark: h,
      positionPrefix: "upper",
      extraEncoding: l
    }),
    ...c({
      partName: "rule",
      mark: {
        type: "rule",
        ariaRoleDescription: "errorbar",
        ...f !== void 0 ? { size: f } : {}
      },
      positionPrefix: "lower",
      endPositionPrefix: "upper",
      extraEncoding: l
    })
  ];
  return {
    ...u,
    transform: n,
    ...p.length > 1 ? { layer: p } : { ...p[0] }
  };
}
function Ide(e, t) {
  const { encoding: n } = e;
  if (Bde(n))
    return {
      orient: iD(e, t),
      inputType: "raw"
    };
  const i = jde(n), r = Ude(n), a = n.x, s = n.y;
  if (i) {
    if (r)
      throw new Error(`${t} cannot be both type aggregated-upper-lower and aggregated-error`);
    const o = n.x2, u = n.y2;
    if (le(o) && le(u))
      throw new Error(`${t} cannot have both x2 and y2`);
    if (le(o)) {
      if (Ta(a))
        return { orient: "horizontal", inputType: "aggregated-upper-lower" };
      throw new Error(`Both x and x2 have to be quantitative in ${t}`);
    } else if (le(u)) {
      if (Ta(s))
        return { orient: "vertical", inputType: "aggregated-upper-lower" };
      throw new Error(`Both y and y2 have to be quantitative in ${t}`);
    }
    throw new Error("No ranged axis");
  } else {
    const o = n.xError, u = n.xError2, l = n.yError, c = n.yError2;
    if (le(u) && !le(o))
      throw new Error(`${t} cannot have xError2 without xError`);
    if (le(c) && !le(l))
      throw new Error(`${t} cannot have yError2 without yError`);
    if (le(o) && le(l))
      throw new Error(`${t} cannot have both xError and yError with both are quantiative`);
    if (le(o)) {
      if (Ta(a))
        return { orient: "horizontal", inputType: "aggregated-error" };
      throw new Error("All x, xError, and xError2 (if exist) have to be quantitative");
    } else if (le(l)) {
      if (Ta(s))
        return { orient: "vertical", inputType: "aggregated-error" };
      throw new Error("All y, yError, and yError2 (if exist) have to be quantitative");
    }
    throw new Error("No ranged axis");
  }
}
function Bde(e) {
  return (le(e.x) || le(e.y)) && !le(e.x2) && !le(e.y2) && !le(e.xError) && !le(e.xError2) && !le(e.yError) && !le(e.yError2);
}
function jde(e) {
  return le(e.x2) || le(e.y2);
}
function Ude(e) {
  return le(e.xError) || le(e.xError2) || le(e.yError) || le(e.yError2);
}
function uD(e, t, n) {
  const { mark: i, encoding: r, params: a, projection: s, ...o } = e, u = pr(i) ? i : { type: i };
  a && q(tT(t));
  const { orient: l, inputType: c } = Ide(e, t), { continuousAxisChannelDef: f, continuousAxisChannelDef2: d, continuousAxisChannelDefError: h, continuousAxisChannelDefError2: p, continuousAxis: g } = nD(e, l, t), { errorBarSpecificAggregate: m, postAggregateCalculates: y, tooltipSummary: b, tooltipTitleWithFieldName: v } = qde(u, f, d, h, p, c, t, n), { [g]: x, [g === "x" ? "x2" : "y2"]: w, [g === "x" ? "xError" : "yError"]: E, [g === "x" ? "xError2" : "yError2"]: $, ...S } = r, { bins: A, timeUnits: k, aggregate: _, groupby: P, encoding: F } = ZT(S, n), M = [..._, ...m], C = c !== "raw" ? [] : P, O = Rv(b, f, F, v);
  return {
    transform: [
      ...o.transform ?? [],
      ...A,
      ...k,
      ...M.length === 0 ? [] : [{ aggregate: M, groupby: C }],
      ...y
    ],
    groupby: C,
    continuousAxisChannelDef: f,
    continuousAxis: g,
    encodingWithoutContinuousAxis: F,
    ticksOrient: l === "vertical" ? "horizontal" : "vertical",
    markDef: u,
    outerSpec: o,
    tooltipEncoding: O
  };
}
function qde(e, t, n, i, r, a, s, o) {
  let u = [], l = [];
  const c = t.field;
  let f, d = !1;
  if (a === "raw") {
    const h = e.center ? e.center : e.extent ? e.extent === "iqr" ? "median" : "mean" : o.errorbar.center, p = e.extent ? e.extent : h === "mean" ? "stderr" : "iqr";
    if (h === "median" != (p === "iqr") && q(tfe(h, p, s)), p === "stderr" || p === "stdev")
      u = [
        { op: p, field: c, as: `extent_${c}` },
        { op: h, field: c, as: `center_${c}` }
      ], l = [
        {
          calculate: `datum["center_${c}"] + datum["extent_${c}"]`,
          as: `upper_${c}`
        },
        {
          calculate: `datum["center_${c}"] - datum["extent_${c}"]`,
          as: `lower_${c}`
        }
      ], f = [
        { fieldPrefix: "center_", titlePrefix: kd(h) },
        { fieldPrefix: "upper_", titlePrefix: D4(h, p, "+") },
        { fieldPrefix: "lower_", titlePrefix: D4(h, p, "-") }
      ], d = !0;
    else {
      let g, m, y;
      p === "ci" ? (g = "mean", m = "ci0", y = "ci1") : (g = "median", m = "q1", y = "q3"), u = [
        { op: m, field: c, as: `lower_${c}` },
        { op: y, field: c, as: `upper_${c}` },
        { op: g, field: c, as: `center_${c}` }
      ], f = [
        {
          fieldPrefix: "upper_",
          titlePrefix: du({ field: c, aggregate: y, type: "quantitative" }, o, {
            allowDisabling: !1
          })
        },
        {
          fieldPrefix: "lower_",
          titlePrefix: du({ field: c, aggregate: m, type: "quantitative" }, o, {
            allowDisabling: !1
          })
        },
        {
          fieldPrefix: "center_",
          titlePrefix: du({ field: c, aggregate: g, type: "quantitative" }, o, {
            allowDisabling: !1
          })
        }
      ];
    }
  } else {
    (e.center || e.extent) && q(efe(e.center, e.extent)), a === "aggregated-upper-lower" ? (f = [], l = [
      { calculate: `datum["${n.field}"]`, as: `upper_${c}` },
      { calculate: `datum["${c}"]`, as: `lower_${c}` }
    ]) : a === "aggregated-error" && (f = [{ fieldPrefix: "", titlePrefix: c }], l = [
      {
        calculate: `datum["${c}"] + datum["${i.field}"]`,
        as: `upper_${c}`
      }
    ], r ? l.push({
      calculate: `datum["${c}"] + datum["${r.field}"]`,
      as: `lower_${c}`
    }) : l.push({
      calculate: `datum["${c}"] - datum["${i.field}"]`,
      as: `lower_${c}`
    }));
    for (const h of l)
      f.push({
        fieldPrefix: h.as.substring(0, 6),
        titlePrefix: ho(ho(h.calculate, 'datum["', ""), '"]', "")
      });
  }
  return { postAggregateCalculates: l, errorBarSpecificAggregate: u, tooltipSummary: f, tooltipTitleWithFieldName: d };
}
function D4(e, t, n) {
  return `${kd(e)} ${n} ${t}`;
}
const _3 = "errorband", Gde = ["band", "borders"], Wde = new zm(_3, lD);
function lD(e, { config: t }) {
  e = {
    ...e,
    encoding: Im(e.encoding, t)
  };
  const { transform: n, continuousAxisChannelDef: i, continuousAxis: r, encodingWithoutContinuousAxis: a, markDef: s, outerSpec: o, tooltipEncoding: u } = uD(e, _3, t), l = s, c = k3(l, r, i, a, t.errorband), f = e.encoding.x !== void 0 && e.encoding.y !== void 0;
  let d = { type: f ? "area" : "rect" }, h = { type: f ? "line" : "rule" };
  const p = {
    ...l.interpolate ? { interpolate: l.interpolate } : {},
    ...l.tension && l.interpolate ? { tension: l.tension } : {}
  };
  return f ? (d = {
    ...d,
    ...p,
    ariaRoleDescription: "errorband"
  }, h = {
    ...h,
    ...p,
    aria: !1
  }) : l.interpolate ? q(A4("interpolate")) : l.tension && q(A4("tension")), {
    ...o,
    transform: n,
    layer: [
      ...c({
        partName: "band",
        mark: d,
        positionPrefix: "lower",
        endPositionPrefix: "upper",
        extraEncoding: u
      }),
      ...c({
        partName: "borders",
        mark: h,
        positionPrefix: "lower",
        extraEncoding: u
      }),
      ...c({
        partName: "borders",
        mark: h,
        positionPrefix: "upper",
        extraEncoding: u
      })
    ]
  };
}
const cD = {};
function F3(e, t, n) {
  const i = new zm(e, t);
  cD[e] = { normalizer: i, parts: n };
}
function Hde() {
  return I(cD);
}
F3(_g, aD, Dde);
F3(C3, oD, Pde);
F3(_3, lD, Gde);
const Vde = [
  "gradientHorizontalMaxLength",
  "gradientHorizontalMinLength",
  "gradientVerticalMaxLength",
  "gradientVerticalMinLength",
  "unselectedOpacity"
], fD = {
  titleAlign: "align",
  titleAnchor: "anchor",
  titleAngle: "angle",
  titleBaseline: "baseline",
  titleColor: "color",
  titleFont: "font",
  titleFontSize: "fontSize",
  titleFontStyle: "fontStyle",
  titleFontWeight: "fontWeight",
  titleLimit: "limit",
  titleLineHeight: "lineHeight",
  titleOrient: "orient",
  titlePadding: "offset"
}, dD = {
  labelAlign: "align",
  labelAnchor: "anchor",
  labelAngle: "angle",
  labelBaseline: "baseline",
  labelColor: "color",
  labelFont: "font",
  labelFontSize: "fontSize",
  labelFontStyle: "fontStyle",
  labelFontWeight: "fontWeight",
  labelLimit: "limit",
  labelLineHeight: "lineHeight",
  labelOrient: "orient",
  labelPadding: "offset"
}, Xde = I(fD), Yde = I(dD), Kde = {
  header: 1,
  headerRow: 1,
  headerColumn: 1,
  headerFacet: 1
}, hD = I(Kde), pD = [
  "size",
  "shape",
  "fill",
  "stroke",
  "strokeDash",
  "strokeWidth",
  "opacity"
], Jde = {
  gradientHorizontalMaxLength: 200,
  gradientHorizontalMinLength: 100,
  gradientVerticalMaxLength: 200,
  gradientVerticalMinLength: 64,
  unselectedOpacity: 0.35
}, Qde = {
  aria: 1,
  clipHeight: 1,
  columnPadding: 1,
  columns: 1,
  cornerRadius: 1,
  description: 1,
  direction: 1,
  fillColor: 1,
  format: 1,
  formatType: 1,
  gradientLength: 1,
  gradientOpacity: 1,
  gradientStrokeColor: 1,
  gradientStrokeWidth: 1,
  gradientThickness: 1,
  gridAlign: 1,
  labelAlign: 1,
  labelBaseline: 1,
  labelColor: 1,
  labelFont: 1,
  labelFontSize: 1,
  labelFontStyle: 1,
  labelFontWeight: 1,
  labelLimit: 1,
  labelOffset: 1,
  labelOpacity: 1,
  labelOverlap: 1,
  labelPadding: 1,
  labelSeparation: 1,
  legendX: 1,
  legendY: 1,
  offset: 1,
  orient: 1,
  padding: 1,
  rowPadding: 1,
  strokeColor: 1,
  symbolDash: 1,
  symbolDashOffset: 1,
  symbolFillColor: 1,
  symbolLimit: 1,
  symbolOffset: 1,
  symbolOpacity: 1,
  symbolSize: 1,
  symbolStrokeColor: 1,
  symbolStrokeWidth: 1,
  symbolType: 1,
  tickCount: 1,
  tickMinStep: 1,
  title: 1,
  titleAlign: 1,
  titleAnchor: 1,
  titleBaseline: 1,
  titleColor: 1,
  titleFont: 1,
  titleFontSize: 1,
  titleFontStyle: 1,
  titleFontWeight: 1,
  titleLimit: 1,
  titleLineHeight: 1,
  titleOpacity: 1,
  titleOrient: 1,
  titlePadding: 1,
  type: 1,
  values: 1,
  zindex: 1
}, Ri = "_vgsid_", Zde = {
  point: {
    on: "click",
    fields: [Ri],
    toggle: "event.shiftKey",
    resolve: "global",
    clear: "dblclick"
  },
  interval: {
    on: "[pointerdown, window:pointerup] > window:pointermove!",
    encodings: ["x", "y"],
    translate: "[pointerdown, window:pointerup] > window:pointermove!",
    zoom: "wheel!",
    mark: { fill: "#333", fillOpacity: 0.125, stroke: "white" },
    resolve: "global",
    clear: "dblclick"
  }
};
function M3(e) {
  return e === "legend" || !!(e != null && e.legend);
}
function py(e) {
  return M3(e) && X(e);
}
function O3(e) {
  return !!(e != null && e.select);
}
function gD(e) {
  const t = [];
  for (const n of e || []) {
    if (O3(n))
      continue;
    const { expr: i, bind: r, ...a } = n;
    if (r && i) {
      const s = {
        ...a,
        bind: r,
        init: i
      };
      t.push(s);
    } else {
      const s = {
        ...a,
        ...i ? { update: i } : {},
        ...r ? { bind: r } : {}
      };
      t.push(s);
    }
  }
  return t;
}
function ehe(e) {
  return Bm(e) || T3(e) || R3(e);
}
function R3(e) {
  return "concat" in e;
}
function Bm(e) {
  return "vconcat" in e;
}
function T3(e) {
  return "hconcat" in e;
}
function mD({ step: e, offsetIsDiscrete: t }) {
  return t ? e.for ?? "offset" : "position";
}
function mr(e) {
  return X(e) && e.step !== void 0;
}
function N4(e) {
  return e.view || e.width || e.height;
}
const L4 = 20, the = {
  align: 1,
  bounds: 1,
  center: 1,
  columns: 1,
  spacing: 1
}, nhe = I(the);
function ihe(e, t, n) {
  const i = n[t], r = {}, { spacing: a, columns: s } = i;
  a !== void 0 && (r.spacing = a), s !== void 0 && (Tm(e) && !Td(e.facet) || R3(e)) && (r.columns = s), Bm(e) && (r.columns = 1);
  for (const o of nhe)
    if (e[o] !== void 0)
      if (o === "spacing") {
        const u = e[o];
        r[o] = ye(u) ? u : {
          row: u.row ?? a,
          column: u.column ?? a
        };
      } else
        r[o] = e[o];
  return r;
}
function Tv(e, t) {
  return e[t] ?? e[t === "width" ? "continuousWidth" : "continuousHeight"];
}
function Fg(e, t) {
  const n = Mg(e, t);
  return mr(n) ? n.step : yD;
}
function Mg(e, t) {
  const n = e[t] ?? e[t === "width" ? "discreteWidth" : "discreteHeight"];
  return Ke(n, { step: e.step });
}
const yD = 20, rhe = {
  continuousWidth: 200,
  continuousHeight: 200,
  step: yD
}, ahe = {
  background: "white",
  padding: 5,
  timeFormat: "%b %d, %Y",
  countTitle: "Count of Records",
  view: rhe,
  mark: Jfe,
  arc: {},
  area: {},
  bar: ede,
  circle: {},
  geoshape: {},
  image: {},
  line: {},
  point: {},
  rect: tde,
  rule: { color: "black" },
  square: {},
  text: { color: "black" },
  tick: nde,
  trail: {},
  boxplot: {
    size: 14,
    extent: 1.5,
    box: {},
    median: { color: "white" },
    outliers: {},
    rule: {},
    ticks: null
  },
  errorbar: {
    center: "mean",
    rule: !0,
    ticks: !1
  },
  errorband: {
    band: {
      opacity: 0.3
    },
    borders: !1
  },
  scale: Tfe,
  projection: {},
  legend: Jde,
  header: { titlePadding: 10, labelPadding: 10 },
  headerColumn: {},
  headerRow: {},
  headerFacet: {},
  selection: Zde,
  style: {},
  title: {},
  facet: { spacing: L4 },
  concat: { spacing: L4 },
  normalizedNumberFormat: ".0%"
}, Rr = [
  "#4c78a8",
  "#f58518",
  "#e45756",
  "#72b7b2",
  "#54a24b",
  "#eeca3b",
  "#b279a2",
  "#ff9da6",
  "#9d755d",
  "#bab0ac"
], P4 = {
  text: 11,
  guideLabel: 10,
  guideTitle: 11,
  groupTitle: 13,
  groupSubtitle: 12
}, z4 = {
  blue: Rr[0],
  orange: Rr[1],
  red: Rr[2],
  teal: Rr[3],
  green: Rr[4],
  yellow: Rr[5],
  purple: Rr[6],
  pink: Rr[7],
  brown: Rr[8],
  gray0: "#000",
  gray1: "#111",
  gray2: "#222",
  gray3: "#333",
  gray4: "#444",
  gray5: "#555",
  gray6: "#666",
  gray7: "#777",
  gray8: "#888",
  gray9: "#999",
  gray10: "#aaa",
  gray11: "#bbb",
  gray12: "#ccc",
  gray13: "#ddd",
  gray14: "#eee",
  gray15: "#fff"
};
function she(e = {}) {
  return {
    signals: [
      {
        name: "color",
        value: X(e) ? { ...z4, ...e } : z4
      }
    ],
    mark: { color: { signal: "color.blue" } },
    rule: { color: { signal: "color.gray0" } },
    text: {
      color: { signal: "color.gray0" }
    },
    style: {
      "guide-label": {
        fill: { signal: "color.gray0" }
      },
      "guide-title": {
        fill: { signal: "color.gray0" }
      },
      "group-title": {
        fill: { signal: "color.gray0" }
      },
      "group-subtitle": {
        fill: { signal: "color.gray0" }
      },
      cell: {
        stroke: { signal: "color.gray8" }
      }
    },
    axis: {
      domainColor: { signal: "color.gray13" },
      gridColor: { signal: "color.gray8" },
      tickColor: { signal: "color.gray13" }
    },
    range: {
      category: [
        { signal: "color.blue" },
        { signal: "color.orange" },
        { signal: "color.red" },
        { signal: "color.teal" },
        { signal: "color.green" },
        { signal: "color.yellow" },
        { signal: "color.purple" },
        { signal: "color.pink" },
        { signal: "color.brown" },
        { signal: "color.grey8" }
      ]
    }
  };
}
function ohe(e) {
  return {
    signals: [
      {
        name: "fontSize",
        value: X(e) ? { ...P4, ...e } : P4
      }
    ],
    text: {
      fontSize: { signal: "fontSize.text" }
    },
    style: {
      "guide-label": {
        fontSize: { signal: "fontSize.guideLabel" }
      },
      "guide-title": {
        fontSize: { signal: "fontSize.guideTitle" }
      },
      "group-title": {
        fontSize: { signal: "fontSize.groupTitle" }
      },
      "group-subtitle": {
        fontSize: { signal: "fontSize.groupSubtitle" }
      }
    }
  };
}
function uhe(e) {
  return {
    text: { font: e },
    style: {
      "guide-label": { font: e },
      "guide-title": { font: e },
      "group-title": { font: e },
      "group-subtitle": { font: e }
    }
  };
}
function bD(e) {
  const t = I(e || {}), n = {};
  for (const i of t) {
    const r = e[i];
    n[i] = Ld(r) ? XR(r) : On(r);
  }
  return n;
}
function lhe(e) {
  const t = I(e), n = {};
  for (const i of t)
    n[i] = bD(e[i]);
  return n;
}
const che = [
  ...FT,
  ...KT,
  ...hD,
  "background",
  "padding",
  "legend",
  "lineBreak",
  "scale",
  "style",
  "title",
  "view"
];
function vD(e = {}) {
  const { color: t, font: n, fontSize: i, selection: r, ...a } = e, s = el({}, se(ahe), n ? uhe(n) : {}, t ? she(t) : {}, i ? ohe(i) : {}, a || {});
  r && tl(s, "selection", r, !0);
  const o = mn(s, che);
  for (const u of ["background", "lineBreak", "padding"])
    s[u] && (o[u] = On(s[u]));
  for (const u of FT)
    s[u] && (o[u] = hn(s[u]));
  for (const u of KT)
    s[u] && (o[u] = bD(s[u]));
  for (const u of hD)
    s[u] && (o[u] = hn(s[u]));
  return s.legend && (o.legend = hn(s.legend)), s.scale && (o.scale = hn(s.scale)), s.style && (o.style = lhe(s.style)), s.title && (o.title = hn(s.title)), s.view && (o.view = hn(s.view)), o;
}
const fhe = /* @__PURE__ */ new Set(["view", ...Wfe]), dhe = [
  "color",
  "fontSize",
  "background",
  "padding",
  "facet",
  "concat",
  "numberFormat",
  "numberFormatType",
  "normalizedNumberFormat",
  "normalizedNumberFormatType",
  "timeFormat",
  "countTitle",
  "header",
  "axisQuantitative",
  "axisTemporal",
  "axisDiscrete",
  "axisPoint",
  "axisXBand",
  "axisXPoint",
  "axisXDiscrete",
  "axisXQuantitative",
  "axisXTemporal",
  "axisYBand",
  "axisYPoint",
  "axisYDiscrete",
  "axisYQuantitative",
  "axisYTemporal",
  "scale",
  "selection",
  "overlay"
  // FIXME: Redesign and unhide this
], hhe = {
  view: ["continuousWidth", "continuousHeight", "discreteWidth", "discreteHeight", "step"],
  ...Kfe
};
function phe(e) {
  e = se(e);
  for (const t of dhe)
    delete e[t];
  if (e.axis)
    for (const t in e.axis)
      Ld(e.axis[t]) && delete e.axis[t];
  if (e.legend)
    for (const t of Vde)
      delete e.legend[t];
  if (e.mark) {
    for (const t of C4)
      delete e.mark[t];
    e.mark.tooltip && X(e.mark.tooltip) && delete e.mark.tooltip;
  }
  e.params && (e.signals = (e.signals || []).concat(gD(e.params)), delete e.params);
  for (const t of fhe) {
    for (const i of C4)
      delete e[t][i];
    const n = hhe[t];
    if (n)
      for (const i of n)
        delete e[t][i];
    mhe(e, t);
  }
  for (const t of Hde())
    delete e[t];
  ghe(e);
  for (const t in e)
    X(e[t]) && ke(e[t]) && delete e[t];
  return ke(e) ? void 0 : e;
}
function ghe(e) {
  const { titleMarkConfig: t, subtitleMarkConfig: n, subtitle: i } = VR(e.title);
  ke(t) || (e.style["group-title"] = {
    ...e.style["group-title"],
    ...t
    // config.title has higher precedence than config.style.group-title in Vega
  }), ke(n) || (e.style["group-subtitle"] = {
    ...e.style["group-subtitle"],
    ...n
  }), ke(i) ? delete e.title : e.title = i;
}
function mhe(e, t, n, i) {
  const r = i ? e[t][i] : e[t];
  t === "view" && (n = "cell");
  const a = {
    ...r,
    ...e.style[n ?? t]
  };
  ke(a) || (e.style[n ?? t] = a), i || delete e[t];
}
function jm(e) {
  return "layer" in e;
}
function yhe(e) {
  return "repeat" in e;
}
function bhe(e) {
  return !R(e.repeat) && e.repeat.layer;
}
class D3 {
  map(t, n) {
    return Tm(t) ? this.mapFacet(t, n) : yhe(t) ? this.mapRepeat(t, n) : T3(t) ? this.mapHConcat(t, n) : Bm(t) ? this.mapVConcat(t, n) : R3(t) ? this.mapConcat(t, n) : this.mapLayerOrUnit(t, n);
  }
  mapLayerOrUnit(t, n) {
    if (jm(t))
      return this.mapLayer(t, n);
    if (la(t))
      return this.mapUnit(t, n);
    throw new Error(KE(t));
  }
  mapLayer(t, n) {
    return {
      ...t,
      layer: t.layer.map((i) => this.mapLayerOrUnit(i, n))
    };
  }
  mapHConcat(t, n) {
    return {
      ...t,
      hconcat: t.hconcat.map((i) => this.map(i, n))
    };
  }
  mapVConcat(t, n) {
    return {
      ...t,
      vconcat: t.vconcat.map((i) => this.map(i, n))
    };
  }
  mapConcat(t, n) {
    const { concat: i, ...r } = t;
    return {
      ...r,
      concat: i.map((a) => this.map(a, n))
    };
  }
  mapFacet(t, n) {
    return {
      // as any is required here since TS cannot infer that FO may only be FieldName or Field, but not RepeatRef
      ...t,
      // TODO: remove "any" once we support all facet listed in https://github.com/vega/vega-lite/issues/2760
      spec: this.map(t.spec, n)
    };
  }
  mapRepeat(t, n) {
    return {
      ...t,
      // as any is required here since TS cannot infer that the output type satisfies the input type
      spec: this.map(t.spec, n)
    };
  }
}
const vhe = {
  zero: 1,
  center: 1,
  normalize: 1
};
function xhe(e) {
  return e in vhe;
}
const $he = /* @__PURE__ */ new Set([kT, Fm, _m, wg, Om, d3, h3, Mm, CT, f3]), whe = /* @__PURE__ */ new Set([Fm, _m, kT]);
function Yo(e) {
  return j(e) && Iu(e) === "quantitative" && !e.bin;
}
function I4(e, t, { orient: n, type: i }) {
  const r = t === "x" ? "y" : "radius", a = t === "x" && ["bar", "area"].includes(i), s = e[t], o = e[r];
  if (j(s) && j(o))
    if (Yo(s) && Yo(o)) {
      if (s.stack)
        return t;
      if (o.stack)
        return r;
      const u = j(s) && !!s.aggregate, l = j(o) && !!o.aggregate;
      if (u !== l)
        return u ? t : r;
      if (a) {
        if (n === "vertical")
          return r;
        if (n === "horizontal")
          return t;
      }
    } else {
      if (Yo(s))
        return t;
      if (Yo(o))
        return r;
    }
  else {
    if (Yo(s))
      return a && n === "vertical" ? void 0 : t;
    if (Yo(o))
      return a && n === "horizontal" ? void 0 : r;
  }
}
function Ehe(e) {
  switch (e) {
    case "x":
      return "y";
    case "y":
      return "x";
    case "theta":
      return "radius";
    case "radius":
      return "theta";
  }
}
function xD(e, t) {
  var g, m;
  const n = pr(e) ? e : { type: e }, i = n.type;
  if (!$he.has(i))
    return null;
  const r = I4(t, "x", n) || I4(t, "theta", n);
  if (!r)
    return null;
  const a = t[r], s = j(a) ? H(a, {}) : void 0, o = Ehe(r), u = [], l = /* @__PURE__ */ new Set();
  if (t[o]) {
    const y = t[o], b = j(y) ? H(y, {}) : void 0;
    b && b !== s && (u.push(o), l.add(b));
  }
  const c = o === "x" ? "xOffset" : "yOffset", f = t[c], d = j(f) ? H(f, {}) : void 0;
  d && d !== s && (u.push(c), l.add(d));
  const h = Ple.reduce((y, b) => {
    if (b !== "tooltip" && Qs(t, b)) {
      const v = t[b];
      for (const x of G(v)) {
        const w = gr(x);
        if (w.aggregate)
          continue;
        const E = H(w, {});
        // if fielddef is a repeat, just include it in the stack by
        (!E || // otherwise, the field must be different from the groupBy fields.
        !l.has(E)) && y.push({ channel: b, fieldDef: w });
      }
    }
    return y;
  }, []);
  let p;
  return a.stack !== void 0 ? Zr(a.stack) ? p = a.stack ? "zero" : null : p = a.stack : whe.has(i) && (p = "zero"), !p || !xhe(p) || E3(t) && h.length === 0 ? null : (g = a == null ? void 0 : a.scale) != null && g.type && ((m = a == null ? void 0 : a.scale) == null ? void 0 : m.type) !== yn.LINEAR ? (a != null && a.stack && q(Jce(a.scale.type)), null) : le(t[Ar(r)]) ? (a.stack !== void 0 && q(Kce(r)), null) : (j(a) && a.aggregate && !Yle.has(a.aggregate) && q(Qce(a.aggregate)), {
    groupbyChannels: u,
    groupbyFields: l,
    fieldChannel: r,
    impute: a.impute === null ? !1 : ys(i),
    stackBy: h,
    offset: p
  });
}
function $D(e, t, n) {
  const i = hn(e), r = Ee("orient", i, n);
  if (i.orient = Che(i.type, t, r), r !== void 0 && r !== i.orient && q(Dce(i.orient, r)), i.type === "bar" && i.orient) {
    const o = Ee("cornerRadiusEnd", i, n);
    if (o !== void 0) {
      const u = i.orient === "horizontal" && t.x2 || i.orient === "vertical" && t.y2 ? ["cornerRadius"] : Zfe[i.orient];
      for (const l of u)
        i[l] = o;
      i.cornerRadiusEnd !== void 0 && delete i.cornerRadiusEnd;
    }
  }
  return Ee("opacity", i, n) === void 0 && (i.opacity = Ahe(i.type, t)), Ee("cursor", i, n) === void 0 && (i.cursor = She(i, t, n)), i;
}
function She(e, t, n) {
  return t.href || e.href || Ee("href", e, n) ? "pointer" : e.cursor;
}
function Ahe(e, t) {
  if (pe([Om, f3, d3, h3], e) && !E3(t))
    return 0.7;
}
function khe(e, t, { graticule: n }) {
  if (n)
    return !1;
  const i = Jr("filled", e, t), r = e.type;
  return Ke(i, r !== Om && r !== Mm && r !== wg);
}
function Che(e, t, n) {
  switch (e) {
    case Om:
    case d3:
    case h3:
    case CT:
    case qfe:
    case Ufe:
      return;
  }
  const { x: i, y: r, x2: a, y2: s } = t;
  switch (e) {
    case Fm:
      if (j(i) && (vt(i.bin) || j(r) && r.aggregate && !i.aggregate))
        return "vertical";
      if (j(r) && (vt(r.bin) || j(i) && i.aggregate && !r.aggregate))
        return "horizontal";
      if (s || a) {
        if (n)
          return n;
        if (!a)
          return (j(i) && i.type === mo && !De(i.bin) || Sg(i)) && j(r) && vt(r.bin) ? "horizontal" : "vertical";
        if (!s)
          return (j(r) && r.type === mo && !De(r.bin) || Sg(r)) && j(i) && vt(i.bin) ? "vertical" : "horizontal";
      }
    case wg:
      if (a && !(j(i) && vt(i.bin)) && s && !(j(r) && vt(r.bin)))
        return;
    case _m:
      if (s)
        return j(r) && vt(r.bin) ? "horizontal" : "vertical";
      if (a)
        return j(i) && vt(i.bin) ? "vertical" : "horizontal";
      if (e === wg) {
        if (i && !r)
          return "vertical";
        if (r && !i)
          return "horizontal";
      }
    case Mm:
    case f3: {
      const o = O4(i), u = O4(r);
      if (n)
        return n;
      if (o && !u)
        return e !== "tick" ? "horizontal" : "vertical";
      if (!o && u)
        return e !== "tick" ? "vertical" : "horizontal";
      if (o && u)
        return "vertical";
      {
        const l = sn(i) && i.type === Pu, c = sn(r) && r.type === Pu;
        if (l && !c)
          return "vertical";
        if (!l && c)
          return "horizontal";
      }
      return;
    }
  }
  return "vertical";
}
function _he(e) {
  const { point: t, line: n, ...i } = e;
  return I(i).length > 1 ? i : i.type;
}
function Fhe(e) {
  for (const t of ["line", "area", "rule", "trail"])
    e[t] && (e = {
      ...e,
      // TODO: remove as any
      [t]: mn(e[t], ["point", "line"])
    });
  return e;
}
function gy(e, t = {}, n) {
  return e.point === "transparent" ? { opacity: 0 } : e.point ? X(e.point) ? e.point : {} : e.point !== void 0 ? null : t.point || n.shape ? X(t.point) ? t.point : {} : void 0;
}
function B4(e, t = {}) {
  return e.line ? e.line === !0 ? {} : e.line : e.line !== void 0 ? null : t.line ? t.line === !0 ? {} : t.line : void 0;
}
class Mhe {
  constructor() {
    this.name = "path-overlay";
  }
  hasMatchingType(t, n) {
    if (la(t)) {
      const { mark: i, encoding: r } = t, a = pr(i) ? i : { type: i };
      switch (a.type) {
        case "line":
        case "rule":
        case "trail":
          return !!gy(a, n[a.type], r);
        case "area":
          return (
            // false / null are also included as we want to remove the properties
            !!gy(a, n[a.type], r) || !!B4(a, n[a.type])
          );
      }
    }
    return !1;
  }
  run(t, n, i) {
    const { config: r } = n, { params: a, projection: s, mark: o, name: u, encoding: l, ...c } = t, f = Im(l, r), d = pr(o) ? o : { type: o }, h = gy(d, r[d.type], f), p = d.type === "area" && B4(d, r[d.type]), g = [
      {
        name: u,
        ...a ? { params: a } : {},
        mark: _he({
          // TODO: extract this 0.7 to be shared with default opacity for point/tick/...
          ...d.type === "area" && d.opacity === void 0 && d.fillOpacity === void 0 ? { opacity: 0.7 } : {},
          ...d
        }),
        // drop shape from encoding as this might be used to trigger point overlay
        encoding: mn(f, ["shape"])
      }
    ], m = xD($D(d, f, r), f);
    let y = f;
    if (m) {
      const { fieldChannel: b, offset: v } = m;
      y = {
        ...f,
        [b]: {
          ...f[b],
          ...v ? { stack: v } : {}
        }
      };
    }
    return y = mn(y, ["y2", "x2"]), p && g.push({
      ...s ? { projection: s } : {},
      mark: {
        type: "line",
        ...Tu(d, ["clip", "interpolate", "tension", "tooltip"]),
        ...p
      },
      encoding: y
    }), h && g.push({
      ...s ? { projection: s } : {},
      mark: {
        type: "point",
        opacity: 1,
        filled: !0,
        ...Tu(d, ["clip", "tooltip"]),
        ...h
      },
      encoding: y
    }), i({
      ...c,
      layer: g
    }, {
      ...n,
      config: Fhe(r)
    });
  }
}
function Ohe(e, t) {
  return t ? Td(e) ? ED(e, t) : wD(e, t) : e;
}
function my(e, t) {
  return t ? ED(e, t) : e;
}
function Dv(e, t, n) {
  const i = t[e];
  if (hde(i)) {
    if (i.repeat in n)
      return { ...t, [e]: n[i.repeat] };
    q(pce(i.repeat));
    return;
  }
  return t;
}
function wD(e, t) {
  if (e = Dv("field", e, t), e !== void 0) {
    if (e === null)
      return null;
    if (v3(e) && or(e.sort)) {
      const n = Dv("field", e.sort, t);
      e = {
        ...e,
        ...n ? { sort: n } : {}
      };
    }
    return e;
  }
}
function j4(e, t) {
  if (j(e))
    return wD(e, t);
  {
    const n = Dv("datum", e, t);
    return n !== e && !n.type && (n.type = "nominal"), n;
  }
}
function U4(e, t) {
  if (le(e)) {
    const n = j4(e, t);
    if (n)
      return n;
    if (Dm(e))
      return { condition: e.condition };
  } else {
    if (Dd(e)) {
      const n = j4(e.condition, t);
      if (n)
        return {
          ...e,
          condition: n
        };
      {
        const { condition: i, ...r } = e;
        return r;
      }
    }
    return e;
  }
}
function ED(e, t) {
  const n = {};
  for (const i in e)
    if (Y(e, i)) {
      const r = e[i];
      if (R(r))
        n[i] = r.map((a) => U4(a, t)).filter((a) => a);
      else {
        const a = U4(r, t);
        a !== void 0 && (n[i] = a);
      }
    }
  return n;
}
class Rhe {
  constructor() {
    this.name = "RuleForRangedLine";
  }
  hasMatchingType(t) {
    if (la(t)) {
      const { encoding: n, mark: i } = t;
      if (i === "line" || pr(i) && i.type === "line")
        for (const r of Dle) {
          const a = Ro(r), s = n[a];
          if (n[r] && (j(s) && !vt(s.bin) || Cr(s)))
            return !0;
        }
    }
    return !1;
  }
  run(t, n, i) {
    const { encoding: r, mark: a } = t;
    return q(Tce(!!r.x2, !!r.y2)), i({
      ...t,
      mark: X(a) ? { ...a, type: "rule" } : "rule"
    }, n);
  }
}
class The extends D3 {
  constructor() {
    super(...arguments), this.nonFacetUnitNormalizers = [
      Nde,
      zde,
      Wde,
      new Mhe(),
      new Rhe()
    ];
  }
  map(t, n) {
    if (la(t)) {
      const i = Qs(t.encoding, qr), r = Qs(t.encoding, Gr), a = Qs(t.encoding, bm);
      if (i || r || a)
        return this.mapFacetedUnit(t, n);
    }
    return super.map(t, n);
  }
  // This is for normalizing non-facet unit
  mapUnit(t, n) {
    const { parentEncoding: i, parentProjection: r } = n, a = my(t.encoding, n.repeater), s = {
      ...t,
      ...t.name ? { name: [n.repeaterPrefix, t.name].filter((u) => u).join("_") } : {},
      ...a ? { encoding: a } : {}
    };
    if (i || r)
      return this.mapUnitWithParentEncodingOrProjection(s, n);
    const o = this.mapLayerOrUnit.bind(this);
    for (const u of this.nonFacetUnitNormalizers)
      if (u.hasMatchingType(s, n.config))
        return u.run(s, n, o);
    return s;
  }
  mapRepeat(t, n) {
    return bhe(t) ? this.mapLayerRepeat(t, n) : this.mapNonLayerRepeat(t, n);
  }
  mapLayerRepeat(t, n) {
    const { repeat: i, spec: r, ...a } = t, { row: s, column: o, layer: u } = i, { repeater: l = {}, repeaterPrefix: c = "" } = n;
    return s || o ? this.mapRepeat({
      ...t,
      repeat: {
        ...s ? { row: s } : {},
        ...o ? { column: o } : {}
      },
      spec: {
        repeat: { layer: u },
        spec: r
      }
    }, n) : {
      ...a,
      layer: u.map((f) => {
        const d = {
          ...l,
          layer: f
        }, h = `${(r.name ? `${r.name}_` : "") + c}child__layer_${Be(f)}`, p = this.mapLayerOrUnit(r, { ...n, repeater: d, repeaterPrefix: h });
        return p.name = h, p;
      })
    };
  }
  mapNonLayerRepeat(t, n) {
    const { repeat: i, spec: r, data: a, ...s } = t;
    !R(i) && t.columns && (t = mn(t, ["columns"]), q($4("repeat")));
    const o = [], { repeater: u = {}, repeaterPrefix: l = "" } = n, c = !R(i) && i.row || [u ? u.row : null], f = !R(i) && i.column || [u ? u.column : null], d = R(i) && i || [u ? u.repeat : null];
    for (const p of d)
      for (const g of c)
        for (const m of f) {
          const y = {
            repeat: p,
            row: g,
            column: m,
            layer: u.layer
          }, b = (r.name ? `${r.name}_` : "") + l + "child__" + (R(i) ? `${Be(p)}` : (i.row ? `row_${Be(g)}` : "") + (i.column ? `column_${Be(m)}` : "")), v = this.map(r, { ...n, repeater: y, repeaterPrefix: b });
          v.name = b, o.push(mn(v, ["data"]));
        }
    const h = R(i) ? t.columns : i.column ? i.column.length : 1;
    return {
      data: r.data ?? a,
      align: "all",
      ...s,
      columns: h,
      concat: o
    };
  }
  mapFacet(t, n) {
    const { facet: i } = t;
    return Td(i) && t.columns && (t = mn(t, ["columns"]), q($4("facet"))), super.mapFacet(t, n);
  }
  mapUnitWithParentEncodingOrProjection(t, n) {
    const { encoding: i, projection: r } = t, { parentEncoding: a, parentProjection: s, config: o } = n, u = G4({ parentProjection: s, projection: r }), l = q4({
      parentEncoding: a,
      encoding: my(i, n.repeater)
    });
    return this.mapUnit({
      ...t,
      ...u ? { projection: u } : {},
      ...l ? { encoding: l } : {}
    }, { config: o });
  }
  mapFacetedUnit(t, n) {
    const { row: i, column: r, facet: a, ...s } = t.encoding, { mark: o, width: u, projection: l, height: c, view: f, params: d, encoding: h, ...p } = t, { facetMapping: g, layout: m } = this.getFacetMappingAndLayout({ row: i, column: r, facet: a }, n), y = my(s, n.repeater);
    return this.mapFacet({
      ...p,
      ...m,
      // row / column has higher precedence than facet
      facet: g,
      spec: {
        ...u ? { width: u } : {},
        ...c ? { height: c } : {},
        ...f ? { view: f } : {},
        ...l ? { projection: l } : {},
        mark: o,
        encoding: y,
        ...d ? { params: d } : {}
      }
    }, n);
  }
  getFacetMappingAndLayout(t, n) {
    const { row: i, column: r, facet: a } = t;
    if (i || r) {
      a && q(Oce([...i ? [qr] : [], ...r ? [Gr] : []]));
      const s = {}, o = {};
      for (const u of [qr, Gr]) {
        const l = t[u];
        if (l) {
          const { align: c, center: f, spacing: d, columns: h, ...p } = l;
          s[u] = p;
          for (const g of ["align", "center", "spacing"])
            l[g] !== void 0 && (o[g] ?? (o[g] = {}), o[g][u] = l[g]);
        }
      }
      return { facetMapping: s, layout: o };
    } else {
      const { align: s, center: o, spacing: u, columns: l, ...c } = a;
      return {
        facetMapping: Ohe(c, n.repeater),
        layout: {
          ...s ? { align: s } : {},
          ...o ? { center: o } : {},
          ...u ? { spacing: u } : {},
          ...l ? { columns: l } : {}
        }
      };
    }
  }
  mapLayer(t, { parentEncoding: n, parentProjection: i, ...r }) {
    const { encoding: a, projection: s, ...o } = t, u = {
      ...r,
      parentEncoding: q4({ parentEncoding: n, encoding: a, layer: !0 }),
      parentProjection: G4({ parentProjection: i, projection: s })
    };
    return super.mapLayer({
      ...o,
      ...t.name ? { name: [u.repeaterPrefix, t.name].filter((l) => l).join("_") } : {}
    }, u);
  }
}
function q4({ parentEncoding: e, encoding: t = {}, layer: n }) {
  let i = {};
  if (e) {
    const r = /* @__PURE__ */ new Set([...I(e), ...I(t)]);
    for (const a of r) {
      const s = t[a], o = e[a];
      if (le(s)) {
        const u = {
          ...o,
          ...s
        };
        i[a] = u;
      } else
        Dd(s) ? i[a] = {
          ...s,
          condition: {
            ...o,
            ...s.condition
          }
        } : s || s === null ? i[a] = s : (n || Oi(o) || Q(o) || le(o) || R(o)) && (i[a] = o);
    }
  } else
    i = t;
  return !i || ke(i) ? void 0 : i;
}
function G4(e) {
  const { parentProjection: t, projection: n } = e;
  return t && n && q(xce({ parentProjection: t, projection: n })), n ?? t;
}
function N3(e) {
  return "filter" in e;
}
function Dhe(e) {
  return (e == null ? void 0 : e.stop) !== void 0;
}
function SD(e) {
  return "lookup" in e;
}
function Nhe(e) {
  return "data" in e;
}
function Lhe(e) {
  return "param" in e;
}
function Phe(e) {
  return "pivot" in e;
}
function zhe(e) {
  return "density" in e;
}
function Ihe(e) {
  return "quantile" in e;
}
function Bhe(e) {
  return "regression" in e;
}
function jhe(e) {
  return "loess" in e;
}
function Uhe(e) {
  return "sample" in e;
}
function qhe(e) {
  return "window" in e;
}
function Ghe(e) {
  return "joinaggregate" in e;
}
function Whe(e) {
  return "flatten" in e;
}
function Hhe(e) {
  return "calculate" in e;
}
function AD(e) {
  return "bin" in e;
}
function Vhe(e) {
  return "impute" in e;
}
function Xhe(e) {
  return "timeUnit" in e;
}
function Yhe(e) {
  return "aggregate" in e;
}
function Khe(e) {
  return "stack" in e;
}
function Jhe(e) {
  return "fold" in e;
}
function Qhe(e) {
  return "extent" in e && !("density" in e);
}
function Zhe(e) {
  return e.map((t) => N3(t) ? {
    filter: cu(t.filter, kfe)
  } : t);
}
class epe extends D3 {
  map(t, n) {
    return n.emptySelections ?? (n.emptySelections = {}), n.selectionPredicates ?? (n.selectionPredicates = {}), t = W4(t, n), super.map(t, n);
  }
  mapLayerOrUnit(t, n) {
    if (t = W4(t, n), t.encoding) {
      const i = {};
      for (const [r, a] of Ja(t.encoding))
        i[r] = kD(a, n);
      t = { ...t, encoding: i };
    }
    return super.mapLayerOrUnit(t, n);
  }
  mapUnit(t, n) {
    const { selection: i, ...r } = t;
    return i ? {
      ...r,
      params: Ja(i).map(([a, s]) => {
        const { init: o, bind: u, empty: l, ...c } = s;
        c.type === "single" ? (c.type = "point", c.toggle = !1) : c.type === "multi" && (c.type = "point"), n.emptySelections[a] = l !== "none";
        for (const f of St(n.selectionPredicates[a] ?? {}))
          f.empty = l !== "none";
        return { name: a, value: o, select: c, bind: u };
      })
    } : t;
  }
}
function W4(e, t) {
  const { transform: n, ...i } = e;
  if (n) {
    const r = n.map((a) => {
      if (N3(a))
        return { filter: Nv(a, t) };
      if (AD(a) && To(a.bin))
        return {
          ...a,
          bin: CD(a.bin)
        };
      if (SD(a)) {
        const { selection: s, ...o } = a.from;
        return s ? {
          ...a,
          from: { param: s, ...o }
        } : a;
      }
      return a;
    });
    return { ...i, transform: r };
  }
  return e;
}
function kD(e, t) {
  var i, r;
  const n = se(e);
  if (j(n) && To(n.bin) && (n.bin = CD(n.bin)), Lo(n) && ((r = (i = n.scale) == null ? void 0 : i.domain) != null && r.selection)) {
    const { selection: a, ...s } = n.scale.domain;
    n.scale.domain = { ...s, ...a ? { param: a } : {} };
  }
  if (Dm(n))
    if (R(n.condition))
      n.condition = n.condition.map((a) => {
        const { selection: s, param: o, test: u, ...l } = a;
        return o ? a : { ...l, test: Nv(a, t) };
      });
    else {
      const { selection: a, param: s, test: o, ...u } = kD(n.condition, t);
      n.condition = s ? n.condition : {
        ...u,
        test: Nv(n.condition, t)
      };
    }
  return n;
}
function CD(e) {
  const t = e.extent;
  if (t != null && t.selection) {
    const { selection: n, ...i } = t;
    return { ...e, extent: { ...i, param: n } };
  }
  return e;
}
function Nv(e, t) {
  const n = (i) => cu(i, (r) => {
    var a;
    const s = t.emptySelections[r] ?? !0, o = { param: r, empty: s };
    return (a = t.selectionPredicates)[r] ?? (a[r] = []), t.selectionPredicates[r].push(o), o;
  });
  return e.selection ? n(e.selection) : cu(e.test || e.filter, (i) => i.selection ? n(i.selection) : i);
}
class Lv extends D3 {
  map(t, n) {
    const i = n.selections ?? [];
    if (t.params && !la(t)) {
      const r = [];
      for (const a of t.params)
        O3(a) ? i.push(a) : r.push(a);
      t.params = r;
    }
    return n.selections = i, super.map(t, n);
  }
  mapUnit(t, n) {
    const i = n.selections;
    if (!i || !i.length)
      return t;
    const r = (n.path ?? []).concat(t.name), a = [];
    for (const s of i)
      if (!s.views || !s.views.length)
        a.push(s);
      else
        for (const o of s.views)
          (V(o) && (o === t.name || r.includes(o)) || R(o) && // logic for backwards compatibility with view paths before we had unique names
          // @ts-ignore
          o.map((u) => r.indexOf(u)).every((u, l, c) => u !== -1 && (l === 0 || u > c[l - 1]))) && a.push(s);
    return a.length && (t.params = a), t;
  }
}
for (const e of ["mapFacet", "mapRepeat", "mapHConcat", "mapVConcat", "mapLayer"]) {
  const t = Lv.prototype[e];
  Lv.prototype[e] = function(n, i) {
    return t.call(this, n, tpe(n, i));
  };
}
function tpe(e, t) {
  return e.name ? {
    ...t,
    path: (t.path ?? []).concat(e.name)
  } : t;
}
function _D(e, t) {
  t === void 0 && (t = vD(e.config));
  const n = ape(e, t), { width: i, height: r } = e, a = spe(n, { width: i, height: r, autosize: e.autosize }, t);
  return {
    ...n,
    ...a ? { autosize: a } : {}
  };
}
const npe = new The(), ipe = new epe(), rpe = new Lv();
function ape(e, t = {}) {
  const n = { config: t };
  return rpe.map(npe.map(ipe.map(e, n), n), n);
}
function H4(e) {
  return V(e) ? { type: e } : e ?? {};
}
function spe(e, t, n) {
  let { width: i, height: r } = t;
  const a = la(e) || jm(e), s = {};
  a ? i == "container" && r == "container" ? (s.type = "fit", s.contains = "padding") : i == "container" ? (s.type = "fit-x", s.contains = "padding") : r == "container" && (s.type = "fit-y", s.contains = "padding") : (i == "container" && (q(y4("width")), i = void 0), r == "container" && (q(y4("height")), r = void 0));
  const o = {
    type: "pad",
    ...s,
    ...n ? H4(n.autosize) : {},
    ...H4(e.autosize)
  };
  if (o.type === "fit" && !a && (q(rce), o.type = "pad"), i == "container" && !(o.type == "fit" || o.type == "fit-x") && q(b4("width")), r == "container" && !(o.type == "fit" || o.type == "fit-y") && q(b4("height")), !Tn(o, { type: "pad" }))
    return o;
}
function ope(e) {
  return e === "fit" || e === "fit-x" || e === "fit-y";
}
function upe(e) {
  return e ? `fit-${Em(e)}` : "fit";
}
const lpe = [
  "background",
  "padding"
  // We do not include "autosize" here as it is supported by only unit and layer specs and thus need to be normalized
];
function V4(e, t) {
  const n = {};
  for (const i of lpe)
    e && e[i] !== void 0 && (n[i] = On(e[i]));
  return t && (n.params = e.params), n;
}
class ca {
  constructor(t = {}, n = {}) {
    this.explicit = t, this.implicit = n;
  }
  clone() {
    return new ca(se(this.explicit), se(this.implicit));
  }
  combine() {
    return {
      ...this.explicit,
      ...this.implicit
    };
  }
  get(t) {
    return Ke(this.explicit[t], this.implicit[t]);
  }
  getWithExplicit(t) {
    return this.explicit[t] !== void 0 ? { explicit: !0, value: this.explicit[t] } : this.implicit[t] !== void 0 ? { explicit: !1, value: this.implicit[t] } : { explicit: !1, value: void 0 };
  }
  setWithExplicit(t, { value: n, explicit: i }) {
    n !== void 0 && this.set(t, n, i);
  }
  set(t, n, i) {
    return delete this[i ? "implicit" : "explicit"][t], this[i ? "explicit" : "implicit"][t] = n, this;
  }
  copyKeyFromSplit(t, { explicit: n, implicit: i }) {
    n[t] !== void 0 ? this.set(t, n[t], !0) : i[t] !== void 0 && this.set(t, i[t], !1);
  }
  copyKeyFromObject(t, n) {
    n[t] !== void 0 && this.set(t, n[t], !0);
  }
  /**
   * Merge split object into this split object. Properties from the other split
   * overwrite properties from this split.
   */
  copyAll(t) {
    for (const n of I(t.combine())) {
      const i = t.getWithExplicit(n);
      this.setWithExplicit(n, i);
    }
  }
}
function Ki(e) {
  return {
    explicit: !0,
    value: e
  };
}
function Cn(e) {
  return {
    explicit: !1,
    value: e
  };
}
function FD(e) {
  return (t, n, i, r) => {
    const a = e(t.value, n.value);
    return a > 0 ? t : a < 0 ? n : Um(t, n, i, r);
  };
}
function Um(e, t, n, i) {
  return e.explicit && t.explicit && q(qce(n, i, e.value, t.value)), e;
}
function es(e, t, n, i, r = Um) {
  return e === void 0 || e.value === void 0 ? t : e.explicit && !t.explicit ? e : t.explicit && !e.explicit ? t : Tn(e.value, t.value) ? e : r(e, t, n, i);
}
class cpe extends ca {
  constructor(t = {}, n = {}, i = !1) {
    super(t, n), this.explicit = t, this.implicit = n, this.parseNothing = i;
  }
  clone() {
    const t = super.clone();
    return t.parseNothing = this.parseNothing, t;
  }
}
function Uu(e) {
  return "url" in e;
}
function xf(e) {
  return "values" in e;
}
function MD(e) {
  return "name" in e && !Uu(e) && !xf(e) && !za(e);
}
function za(e) {
  return e && (OD(e) || RD(e) || L3(e));
}
function OD(e) {
  return "sequence" in e;
}
function RD(e) {
  return "sphere" in e;
}
function L3(e) {
  return "graticule" in e;
}
var Te;
(function(e) {
  e[e.Raw = 0] = "Raw", e[e.Main = 1] = "Main", e[e.Row = 2] = "Row", e[e.Column = 3] = "Column", e[e.Lookup = 4] = "Lookup";
})(Te || (Te = {}));
function TD(e) {
  const { signals: t, hasLegend: n, index: i, ...r } = e;
  return r.field = ni(r.field), r;
}
function vo(e, t = !0, n = kt) {
  if (R(e)) {
    const i = e.map((r) => vo(r, t, n));
    return t ? `[${i.join(", ")}]` : i;
  } else if (Do(e))
    return n(t ? go(e) : pfe(e));
  return t ? n(Ce(e)) : e;
}
function fpe(e, t) {
  for (const n of St(e.component.selection ?? {})) {
    const i = n.name;
    let r = `${i}${ns}, ${n.resolve === "global" ? "true" : `{unit: ${Zs(e)}}`}`;
    for (const a of Hm)
      a.defined(n) && (a.signals && (t = a.signals(e, n, t)), a.modifyExpr && (r = a.modifyExpr(e, n, r)));
    t.push({
      name: i + qpe,
      on: [
        {
          events: { signal: n.name + ns },
          update: `modify(${U(n.name + xo)}, ${r})`
        }
      ]
    });
  }
  return P3(t);
}
function dpe(e, t) {
  if (e.component.selection && I(e.component.selection).length) {
    const n = U(e.getName("cell"));
    t.unshift({
      name: "facet",
      value: {},
      on: [
        {
          events: ls("pointermove", "scope"),
          update: `isTuple(facet) ? facet : group(${n}).datum`
        }
      ]
    });
  }
  return P3(t);
}
function hpe(e, t) {
  let n = !1;
  for (const i of St(e.component.selection ?? {})) {
    const r = i.name, a = U(r + xo);
    if (t.filter((o) => o.name === r).length === 0) {
      const o = i.resolve === "global" ? "union" : i.resolve, u = i.type === "point" ? ", true, true)" : ")";
      t.push({
        name: i.name,
        update: `${JD}(${a}, ${U(o)}${u}`
      });
    }
    n = !0;
    for (const o of Hm)
      o.defined(i) && o.topLevelSignals && (t = o.topLevelSignals(e, i, t));
  }
  return n && t.filter((r) => r.name === "unit").length === 0 && t.unshift({
    name: "unit",
    value: {},
    on: [{ events: "pointermove", update: "isTuple(group()) ? group() : unit" }]
  }), P3(t);
}
function ppe(e, t) {
  const n = [...t], i = Zs(e, { escape: !1 });
  for (const r of St(e.component.selection ?? {})) {
    const a = { name: r.name + xo };
    if (r.project.hasSelectionId && (a.transform = [{ type: "collect", sort: { field: Ri } }]), r.init) {
      const o = r.project.items.map(TD);
      a.values = r.project.hasSelectionId ? r.init.map((u) => ({ unit: i, [Ri]: vo(u, !1)[0] })) : r.init.map((u) => ({ unit: i, fields: o, values: vo(u, !1) }));
    }
    n.filter((o) => o.name === r.name + xo).length || n.push(a);
  }
  return n;
}
function DD(e, t) {
  for (const n of St(e.component.selection ?? {}))
    for (const i of Hm)
      i.defined(n) && i.marks && (t = i.marks(e, n, t));
  return t;
}
function gpe(e, t) {
  for (const n of e.children)
    We(n) && (t = DD(n, t));
  return t;
}
function mpe(e, t, n, i) {
  const r = nN(e, t.param, t);
  return {
    signal: Bn(n.get("type")) && R(i) && i[0] > i[1] ? `isValid(${r}) && reverse(${r})` : r
  };
}
function P3(e) {
  return e.map((t) => (t.on && !t.on.length && delete t.on, t));
}
class Ae {
  constructor(t, n) {
    this.debugName = n, this._children = [], this._parent = null, t && (this.parent = t);
  }
  /**
   * Clone this node with a deep copy but don't clone links to children or parents.
   */
  clone() {
    throw new Error("Cannot clone node");
  }
  get parent() {
    return this._parent;
  }
  /**
   * Set the parent of the node and also add this node to the parent's children.
   */
  set parent(t) {
    this._parent = t, t && t.addChild(this);
  }
  get children() {
    return this._children;
  }
  numChildren() {
    return this._children.length;
  }
  addChild(t, n) {
    if (this._children.includes(t)) {
      q(yce);
      return;
    }
    n !== void 0 ? this._children.splice(n, 0, t) : this._children.push(t);
  }
  removeChild(t) {
    const n = this._children.indexOf(t);
    return this._children.splice(n, 1), n;
  }
  /**
   * Remove node from the dataflow.
   */
  remove() {
    let t = this._parent.removeChild(this);
    for (const n of this._children)
      n._parent = this._parent, this._parent.addChild(n, t++);
  }
  /**
   * Insert another node as a parent of this node.
   */
  insertAsParentOf(t) {
    const n = t.parent;
    n.removeChild(this), this.parent = n, t.parent = this;
  }
  swapWithParent() {
    const t = this._parent, n = t.parent;
    for (const r of this._children)
      r.parent = t;
    this._children = [], t.removeChild(this);
    const i = t.parent.removeChild(t);
    this._parent = n, n.addChild(this, i), t.parent = this;
  }
}
class tn extends Ae {
  clone() {
    const t = new this.constructor();
    return t.debugName = `clone_${this.debugName}`, t._source = this._source, t._name = `clone_${this._name}`, t.type = this.type, t.refCounts = this.refCounts, t.refCounts[t._name] = 0, t;
  }
  /**
   * @param source The name of the source. Will change in assemble.
   * @param type The type of the output node.
   * @param refCounts A global ref counter map.
   */
  constructor(t, n, i, r) {
    super(t, n), this.type = i, this.refCounts = r, this._source = this._name = n, this.refCounts && !(this._name in this.refCounts) && (this.refCounts[this._name] = 0);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return this._hash === void 0 && (this._hash = `Output ${MR()}`), this._hash;
  }
  /**
   * Request the datasource name and increase the ref counter.
   *
   * During the parsing phase, this will return the simple name such as 'main' or 'raw'.
   * It is crucial to request the name from an output node to mark it as a required node.
   * If nobody ever requests the name, this datasource will not be instantiated in the assemble phase.
   *
   * In the assemble phase, this will return the correct name.
   */
  getSource() {
    return this.refCounts[this._name]++, this._source;
  }
  isRequired() {
    return !!this.refCounts[this._name];
  }
  setSource(t) {
    this._source = t;
  }
}
function yy(e) {
  return e.as !== void 0;
}
function X4(e) {
  return `${e}_end`;
}
class ur extends Ae {
  clone() {
    return new ur(null, se(this.timeUnits));
  }
  constructor(t, n) {
    super(t), this.timeUnits = n;
  }
  static makeFromEncoding(t, n) {
    const i = n.reduceFieldDef((r, a, s) => {
      const { field: o, timeUnit: u } = a;
      if (u) {
        let l;
        if (No(u)) {
          if (We(n)) {
            const { mark: c, markDef: f, config: d } = n, h = Za({ fieldDef: a, markDef: f, config: d });
            (vf(c) || h) && (l = {
              timeUnit: pt(u),
              field: o
            });
          }
        } else
          l = {
            as: H(a, { forAs: !0 }),
            field: o,
            timeUnit: u
          };
        if (We(n)) {
          const { mark: c, markDef: f, config: d } = n, h = Za({ fieldDef: a, markDef: f, config: d });
          vf(c) && Je(s) && h !== 0.5 && (l.rectBandPosition = h);
        }
        l && (r[he(l)] = l);
      }
      return r;
    }, {});
    return ke(i) ? null : new ur(t, i);
  }
  static makeFromTransform(t, n) {
    const { timeUnit: i, ...r } = { ...n }, a = pt(i), s = {
      ...r,
      timeUnit: a
    };
    return new ur(t, {
      [he(s)]: s
    });
  }
  /**
   * Merge together TimeUnitNodes assigning the children of `other` to `this`
   * and removing `other`.
   */
  merge(t) {
    this.timeUnits = { ...this.timeUnits };
    for (const n in t.timeUnits)
      this.timeUnits[n] || (this.timeUnits[n] = t.timeUnits[n]);
    for (const n of t.children)
      t.removeChild(n), n.parent = this;
    t.remove();
  }
  /**
   * Remove time units coming from the other node.
   */
  removeFormulas(t) {
    const n = {};
    for (const [i, r] of Ja(this.timeUnits)) {
      const a = yy(r) ? r.as : `${r.field}_end`;
      t.has(a) || (n[i] = r);
    }
    this.timeUnits = n;
  }
  producedFields() {
    return new Set(St(this.timeUnits).map((t) => yy(t) ? t.as : X4(t.field)));
  }
  dependentFields() {
    return new Set(St(this.timeUnits).map((t) => t.field));
  }
  hash() {
    return `TimeUnit ${he(this.timeUnits)}`;
  }
  assemble() {
    const t = [];
    for (const n of St(this.timeUnits)) {
      const { rectBandPosition: i } = n, r = pt(n.timeUnit);
      if (yy(n)) {
        const { field: a, as: s } = n, { unit: o, utc: u, ...l } = r, c = [s, `${s}_end`];
        t.push({
          field: ni(a),
          type: "timeunit",
          ...o ? { units: Cm(o) } : {},
          ...u ? { timezone: "utc" } : {},
          ...l,
          as: c
        }), t.push(...Y4(c, i, r));
      } else if (n) {
        const { field: a } = n, s = a.replaceAll("\\.", "."), o = ND({ timeUnit: r, field: s }), u = X4(s);
        t.push({
          type: "formula",
          expr: o,
          as: u
        }), t.push(...Y4([s, u], i, r));
      }
    }
    return t;
  }
}
const qm = "offsetted_rect_start", Gm = "offsetted_rect_end";
function ND({ timeUnit: e, field: t, reverse: n }) {
  const { unit: i, utc: r } = e, a = dT(i), { part: s, step: o } = mT(a, e.step);
  return `${r ? "utcOffset" : "timeOffset"}('${s}', datum['${t}'], ${n ? -o : o})`;
}
function Y4([e, t], n, i) {
  if (n !== void 0 && n !== 0.5) {
    const r = `datum['${e}']`, a = `datum['${t}']`;
    return [
      {
        type: "formula",
        expr: K4([
          ND({
            timeUnit: i,
            field: e,
            reverse: !0
          }),
          r
        ], n + 0.5),
        as: `${e}_${qm}`
      },
      {
        type: "formula",
        expr: K4([r, a], n + 0.5),
        as: `${e}_${Gm}`
      }
    ];
  }
  return [];
}
function K4([e, t], n) {
  return `${1 - n} * ${e} + ${n} * ${t}`;
}
const Pd = "_tuple_fields";
class ype {
  constructor(...t) {
    this.items = t, this.hasChannel = {}, this.hasField = {}, this.hasSelectionId = !1;
  }
}
const bpe = {
  defined: () => !0,
  parse: (e, t, n) => {
    const i = t.name, r = t.project ?? (t.project = new ype()), a = {}, s = {}, o = /* @__PURE__ */ new Set(), u = (p, g) => {
      const m = g === "visual" ? p.channel : p.field;
      let y = Be(`${i}_${m}`);
      for (let b = 1; o.has(y); b++)
        y = Be(`${i}_${m}_${b}`);
      return o.add(y), { [g]: y };
    }, l = t.type, c = e.config.selection[l], f = n.value !== void 0 ? G(n.value) : null;
    let { fields: d, encodings: h } = X(n.select) ? n.select : {};
    if (!d && !h && f) {
      for (const p of f)
        if (X(p))
          for (const g of I(p))
            Tle(g) ? (h || (h = [])).push(g) : l === "interval" ? (q(hce), h = c.encodings) : (d ?? (d = [])).push(g);
    }
    !d && !h && (h = c.encodings, "fields" in c && (d = c.fields));
    for (const p of h ?? []) {
      const g = e.fieldDef(p);
      if (g) {
        let m = g.field;
        if (g.aggregate) {
          q(ace(p, g.aggregate));
          continue;
        } else if (!m) {
          q(x4(p));
          continue;
        }
        if (g.timeUnit && !No(g.timeUnit)) {
          m = e.vgField(p);
          const y = {
            timeUnit: g.timeUnit,
            as: m,
            field: g.field
          };
          s[he(y)] = y;
        }
        if (!a[m]) {
          const y = l === "interval" && ua(p) && Bn(e.getScaleComponent(p).get("type")) ? "R" : g.bin ? "R-RE" : "E", b = { field: m, channel: p, type: y, index: r.items.length };
          b.signals = { ...u(b, "data"), ...u(b, "visual") }, r.items.push(a[m] = b), r.hasField[m] = a[m], r.hasSelectionId = r.hasSelectionId || m === Ri, LR(p) ? (b.geoChannel = p, b.channel = NR(p), r.hasChannel[b.channel] = a[m]) : r.hasChannel[p] = a[m];
        }
      } else
        q(x4(p));
    }
    for (const p of d ?? []) {
      if (r.hasField[p])
        continue;
      const g = { type: "E", field: p, index: r.items.length };
      g.signals = { ...u(g, "data") }, r.items.push(g), r.hasField[p] = g, r.hasSelectionId = r.hasSelectionId || p === Ri;
    }
    f && (t.init = f.map((p) => r.items.map((g) => X(p) ? p[g.geoChannel || g.channel] !== void 0 ? p[g.geoChannel || g.channel] : p[g.field] : p))), ke(s) || (r.timeUnit = new ur(null, s));
  },
  signals: (e, t, n) => {
    const i = t.name + Pd;
    return n.filter((a) => a.name === i).length > 0 || t.project.hasSelectionId ? n : n.concat({
      name: i,
      value: t.project.items.map(TD)
    });
  }
}, Wr = {
  defined: (e) => e.type === "interval" && e.resolve === "global" && e.bind && e.bind === "scales",
  parse: (e, t) => {
    const n = t.scales = [];
    for (const i of t.project.items) {
      const r = i.channel;
      if (!ua(r))
        continue;
      const a = e.getScaleComponent(r), s = a ? a.get("type") : void 0;
      if (!a || !Bn(s)) {
        q(uce);
        continue;
      }
      a.set("selectionExtent", { param: t.name, field: i.field }, !0), n.push(i);
    }
  },
  topLevelSignals: (e, t, n) => {
    const i = t.scales.filter((s) => n.filter((o) => o.name === s.signals.data).length === 0);
    if (!e.parent || J4(e) || i.length === 0)
      return n;
    const r = n.filter((s) => s.name === t.name)[0];
    let a = r.update;
    if (a.indexOf(JD) >= 0)
      r.update = `{${i.map((s) => `${U(ni(s.field))}: ${s.signals.data}`).join(", ")}}`;
    else {
      for (const s of i) {
        const o = `${U(ni(s.field))}: ${s.signals.data}`;
        a.includes(o) || (a = `${a.substring(0, a.length - 1)}, ${o}}`);
      }
      r.update = a;
    }
    return n.concat(i.map((s) => ({ name: s.signals.data })));
  },
  signals: (e, t, n) => {
    if (e.parent && !J4(e))
      for (const i of t.scales) {
        const r = n.filter((a) => a.name === i.signals.data)[0];
        r.push = "outer", delete r.value, delete r.update;
      }
    return n;
  }
};
function Pv(e, t) {
  return `domain(${U(e.scaleName(t))})`;
}
function J4(e) {
  return e.parent && Al(e.parent) && !e.parent.parent;
}
const hu = "_brush", LD = "_scale_trigger", Wl = "geo_interval_init_tick", PD = "_init", vpe = "_center", xpe = {
  defined: (e) => e.type === "interval",
  parse: (e, t, n) => {
    var i;
    if (e.hasProjection) {
      const r = { ...X(n.select) ? n.select : {} };
      r.fields = [Ri], r.encodings || (r.encodings = n.value ? I(n.value) : [Ui, ji]), n.select = { type: "interval", ...r };
    }
    if (t.translate && !Wr.defined(t)) {
      const r = `!event.item || event.item.mark.name !== ${U(t.name + hu)}`;
      for (const a of t.events) {
        if (!a.between) {
          q(`${a} is not an ordered event stream for interval selections.`);
          continue;
        }
        const s = G((i = a.between[0]).filter ?? (i.filter = []));
        s.indexOf(r) < 0 && s.push(r);
      }
    }
  },
  signals: (e, t, n) => {
    const i = t.name, r = i + ns, a = St(t.project.hasChannel).filter((o) => o.channel === je || o.channel === bt), s = t.init ? t.init[0] : null;
    if (n.push(...a.reduce((o, u) => o.concat($pe(e, t, u, s && s[u.index])), [])), e.hasProjection) {
      const o = U(e.projectionName()), u = e.projectionName() + vpe, { x: l, y: c } = t.project.hasChannel, f = l && l.signals.visual, d = c && c.signals.visual, h = l ? s && s[l.index] : `${u}[0]`, p = c ? s && s[c.index] : `${u}[1]`, g = (w) => e.getSizeSignalRef(w).signal, m = `[[${f ? f + "[0]" : "0"}, ${d ? d + "[0]" : "0"}],[${f ? f + "[1]" : g("width")}, ${d ? d + "[1]" : g("height")}]]`;
      s && (n.unshift({
        name: i + PD,
        init: `[scale(${o}, [${l ? h[0] : h}, ${c ? p[0] : p}]), scale(${o}, [${l ? h[1] : h}, ${c ? p[1] : p}])]`
      }), (!l || !c) && (n.find((E) => E.name === u) || n.unshift({
        name: u,
        update: `invert(${o}, [${g("width")}/2, ${g("height")}/2])`
      })));
      const y = `intersect(${m}, {markname: ${U(e.getName("marks"))}}, unit.mark)`, b = `{unit: ${Zs(e)}}`, v = `vlSelectionTuples(${y}, ${b})`, x = a.map((w) => w.signals.visual);
      return n.concat({
        name: r,
        on: [
          {
            events: [
              ...x.length ? [{ signal: x.join(" || ") }] : [],
              ...s ? [{ signal: Wl }] : []
            ],
            update: v
          }
        ]
      });
    } else {
      if (!Wr.defined(t)) {
        const l = i + LD, c = a.map((f) => {
          const d = f.channel, { data: h, visual: p } = f.signals, g = U(e.scaleName(d)), m = e.getScaleComponent(d).get("type"), y = Bn(m) ? "+" : "";
          return `(!isArray(${h}) || (${y}invert(${g}, ${p})[0] === ${y}${h}[0] && ${y}invert(${g}, ${p})[1] === ${y}${h}[1]))`;
        });
        c.length && n.push({
          name: l,
          value: {},
          on: [
            {
              events: a.map((f) => ({ scale: e.scaleName(f.channel) })),
              update: c.join(" && ") + ` ? ${l} : {}`
            }
          ]
        });
      }
      const o = a.map((l) => l.signals.data), u = `unit: ${Zs(e)}, fields: ${i + Pd}, values`;
      return n.concat({
        name: r,
        ...s ? { init: `{${u}: ${vo(s)}}` } : {},
        ...o.length ? {
          on: [
            {
              events: [{ signal: o.join(" || ") }],
              update: `${o.join(" && ")} ? {${u}: [${o}]} : null`
            }
          ]
        } : {}
      });
    }
  },
  topLevelSignals: (e, t, n) => (We(e) && e.hasProjection && t.init && (n.filter((r) => r.name === Wl).length || n.unshift({
    name: Wl,
    value: null,
    on: [
      {
        events: "timer{1}",
        update: `${Wl} === null ? {} : ${Wl}`
      }
    ]
  })), n),
  marks: (e, t, n) => {
    const i = t.name, { x: r, y: a } = t.project.hasChannel, s = r == null ? void 0 : r.signals.visual, o = a == null ? void 0 : a.signals.visual, u = `data(${U(t.name + xo)})`;
    if (Wr.defined(t) || !r && !a)
      return n;
    const l = {
      x: r !== void 0 ? { signal: `${s}[0]` } : { value: 0 },
      y: a !== void 0 ? { signal: `${o}[0]` } : { value: 0 },
      x2: r !== void 0 ? { signal: `${s}[1]` } : { field: { group: "width" } },
      y2: a !== void 0 ? { signal: `${o}[1]` } : { field: { group: "height" } }
    };
    if (t.resolve === "global")
      for (const g of I(l))
        l[g] = [
          {
            test: `${u}.length && ${u}[0].unit === ${Zs(e)}`,
            ...l[g]
          },
          { value: 0 }
        ];
    const { fill: c, fillOpacity: f, cursor: d, ...h } = t.mark, p = I(h).reduce((g, m) => (g[m] = [
      {
        test: [r !== void 0 && `${s}[0] !== ${s}[1]`, a !== void 0 && `${o}[0] !== ${o}[1]`].filter((y) => y).join(" && "),
        value: h[m]
      },
      { value: null }
    ], g), {});
    return [
      {
        name: `${i + hu}_bg`,
        type: "rect",
        clip: !0,
        encode: {
          enter: {
            fill: { value: c },
            fillOpacity: { value: f }
          },
          update: l
        }
      },
      ...n,
      {
        name: i + hu,
        type: "rect",
        clip: !0,
        encode: {
          enter: {
            ...d ? { cursor: { value: d } } : {},
            fill: { value: "transparent" }
          },
          update: { ...l, ...p }
        }
      }
    ];
  }
};
function $pe(e, t, n, i) {
  const r = !e.hasProjection, a = n.channel, s = n.signals.visual, o = U(r ? e.scaleName(a) : e.projectionName()), u = (d) => `scale(${o}, ${d})`, l = e.getSizeSignalRef(a === je ? "width" : "height").signal, c = `${a}(unit)`, f = t.events.reduce((d, h) => [
    ...d,
    { events: h.between[0], update: `[${c}, ${c}]` },
    { events: h, update: `[${s}[0], clamp(${c}, 0, ${l})]` }
    // Brush End
  ], []);
  if (r) {
    const d = n.signals.data, h = Wr.defined(t), p = e.getScaleComponent(a), g = p ? p.get("type") : void 0, m = i ? { init: vo(i, !0, u) } : { value: [] };
    return f.push({
      events: { signal: t.name + LD },
      update: Bn(g) ? `[${u(`${d}[0]`)}, ${u(`${d}[1]`)}]` : "[0, 0]"
    }), h ? [{ name: d, on: [] }] : [
      { name: s, ...m, on: f },
      {
        name: d,
        ...i ? { init: vo(i) } : {},
        on: [
          {
            events: { signal: s },
            update: `${s}[0] === ${s}[1] ? null : invert(${o}, ${s})`
          }
        ]
      }
    ];
  } else {
    const d = a === je ? 0 : 1, h = t.name + PD, p = i ? { init: `[${h}[0][${d}], ${h}[1][${d}]]` } : { value: [] };
    return [{ name: s, ...p, on: f }];
  }
}
const wpe = {
  defined: (e) => e.type === "point",
  signals: (e, t, n) => {
    const i = t.name, r = i + Pd, a = t.project, s = "(item().isVoronoi ? datum.datum : datum)", o = St(e.component.selection ?? {}).reduce((f, d) => d.type === "interval" ? f.concat(d.name + hu) : f, []).map((f) => `indexof(item().mark.name, '${f}') < 0`).join(" && "), u = `datum && item().mark.marktype !== 'group' && indexof(item().mark.role, 'legend') < 0${o ? ` && ${o}` : ""}`;
    let l = `unit: ${Zs(e)}, `;
    if (t.project.hasSelectionId)
      l += `${Ri}: ${s}[${U(Ri)}]`;
    else {
      const f = a.items.map((d) => {
        const h = e.fieldDef(d.channel);
        return h != null && h.bin ? `[${s}[${U(e.vgField(d.channel, {}))}], ${s}[${U(e.vgField(d.channel, { binSuffix: "end" }))}]]` : `${s}[${U(d.field)}]`;
      }).join(", ");
      l += `fields: ${r}, values: [${f}]`;
    }
    const c = t.events;
    return n.concat([
      {
        name: i + ns,
        on: c ? [
          {
            events: c,
            update: `${u} ? {${l}} : null`,
            force: !0
          }
        ] : []
      }
    ]);
  }
};
function $l(e, t, n, i) {
  const r = Dm(t) && t.condition, a = i(t);
  if (r) {
    const o = G(r).map((u) => {
      const l = i(u);
      if (dde(u)) {
        const { param: c, empty: f } = u;
        return { test: tN(e, { param: c, empty: f }), ...l };
      } else
        return { test: Tg(e, u.test), ...l };
    });
    return {
      [n]: [...o, ...a !== void 0 ? [a] : []]
    };
  } else
    return a !== void 0 ? { [n]: a } : {};
}
function z3(e, t = "text") {
  const n = e.encoding[t];
  return $l(e, n, t, (i) => Wm(i, e.config));
}
function Wm(e, t, n = "datum") {
  if (e) {
    if (Oi(e))
      return ze(e.value);
    if (le(e)) {
      const { format: i, formatType: r } = kg(e);
      return y3({ fieldOrDatumDef: e, format: i, formatType: r, expr: n, config: t });
    }
  }
}
function zD(e, t = {}) {
  const { encoding: n, markDef: i, config: r, stack: a } = e, s = n.tooltip;
  if (R(s))
    return { tooltip: Q4({ tooltip: s }, a, r, t) };
  {
    const o = t.reactiveGeom ? "datum.datum" : "datum";
    return $l(e, s, "tooltip", (u) => {
      const l = Wm(u, r, o);
      if (l)
        return l;
      if (u === null)
        return;
      let c = Ee("tooltip", i, r);
      if (c === !0 && (c = { content: "encoding" }), V(c))
        return { value: c };
      if (X(c))
        return Q(c) ? c : c.content === "encoding" ? Q4(n, a, r, t) : { signal: o };
    });
  }
}
function ID(e, t, n, { reactiveGeom: i } = {}) {
  const r = { ...n, ...n.tooltipFormat }, a = {}, s = i ? "datum.datum" : "datum", o = [];
  function u(c, f) {
    const d = Ro(f), h = sn(c) ? c : {
      ...c,
      type: e[d].type
      // for secondary field def, copy type from main channel
    }, p = h.title || $3(h, r), g = G(p).join(", ").replaceAll(/"/g, '\\"');
    let m;
    if (Je(f)) {
      const y = f === "x" ? "x2" : "y2", b = gr(e[y]);
      if (vt(h.bin) && b) {
        const v = H(h, { expr: s }), x = H(b, { expr: s }), { format: w, formatType: E } = kg(h);
        m = Rd(v, x, w, E, r), a[y] = !0;
      }
    }
    if ((Je(f) || f === ai || f === Bi) && t && t.fieldChannel === f && t.offset === "normalize") {
      const { format: y, formatType: b } = kg(h);
      m = y3({
        fieldOrDatumDef: h,
        format: y,
        formatType: b,
        expr: s,
        config: r,
        normalizeStack: !0
      }).signal;
    }
    m ?? (m = Wm(h, r, s).signal), o.push({ channel: f, key: g, value: m });
  }
  S3(e, (c, f) => {
    j(c) ? u(c, f) : Nm(c) && u(c.condition, f);
  });
  const l = {};
  for (const { channel: c, key: f, value: d } of o)
    !a[c] && !l[f] && (l[f] = d);
  return l;
}
function Q4(e, t, n, { reactiveGeom: i } = {}) {
  const r = ID(e, t, n, { reactiveGeom: i }), a = Ja(r).map(([s, o]) => `"${s}": ${o}`);
  return a.length > 0 ? { signal: `{${a.join(", ")}}` } : void 0;
}
function Epe(e) {
  const { markDef: t, config: n } = e, i = Ee("aria", t, n);
  return i === !1 ? {} : {
    ...i ? { aria: i } : {},
    ...Spe(e),
    ...Ape(e)
  };
}
function Spe(e) {
  const { mark: t, markDef: n, config: i } = e;
  if (i.aria === !1)
    return {};
  const r = Ee("ariaRoleDescription", n, i);
  return r != null ? { ariaRoleDescription: { value: r } } : t in tce ? {} : { ariaRoleDescription: { value: t } };
}
function Ape(e) {
  const { encoding: t, markDef: n, config: i, stack: r } = e, a = t.description;
  if (a)
    return $l(e, a, "description", (u) => Wm(u, e.config));
  const s = Ee("description", n, i);
  if (s != null)
    return {
      description: ze(s)
    };
  if (i.aria === !1)
    return {};
  const o = ID(t, r, i);
  if (!ke(o))
    return {
      description: {
        signal: Ja(o).map(([u, l], c) => `"${c > 0 ? "; " : ""}${u}: " + (${l})`).join(" + ")
      }
    };
}
function ct(e, t, n = {}) {
  const { markDef: i, encoding: r, config: a } = t, { vgChannel: s } = n;
  let { defaultRef: o, defaultValue: u } = n;
  o === void 0 && (u ?? (u = Ee(e, i, a, { vgChannel: s, ignoreVgConfig: !0 })), u !== void 0 && (o = ze(u)));
  const l = r[e];
  return $l(t, l, s ?? e, (c) => m3({
    channel: e,
    channelDef: c,
    markDef: i,
    config: a,
    scaleName: t.scaleName(e),
    scale: t.getScaleComponent(e),
    stack: null,
    defaultRef: o
  }));
}
function BD(e, t = { filled: void 0 }) {
  const { markDef: n, encoding: i, config: r } = e, { type: a } = n, s = t.filled ?? Ee("filled", n, r), o = pe(["bar", "point", "circle", "square", "geoshape"], a) ? "transparent" : void 0, u = Ee(s === !0 ? "color" : void 0, n, r, { vgChannel: "fill" }) ?? // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
  r.mark[s === !0 && "color"] ?? // If there is no fill, always fill symbols, bar, geoshape
  // with transparent fills https://github.com/vega/vega-lite/issues/1316
  o, l = Ee(s === !1 ? "color" : void 0, n, r, { vgChannel: "stroke" }) ?? // need to add this manually as getMarkConfig normally drops config.mark[channel] if vgChannel is specified
  r.mark[s === !1 && "color"], c = s ? "fill" : "stroke", f = {
    ...u ? { fill: ze(u) } : {},
    ...l ? { stroke: ze(l) } : {}
  };
  return n.color && (s ? n.fill : n.stroke) && q(iT("property", { fill: "fill" in n, stroke: "stroke" in n })), {
    ...f,
    ...ct("color", e, {
      vgChannel: c,
      defaultValue: s ? u : l
    }),
    ...ct("fill", e, {
      // if there is encoding.fill, include default fill just in case we have conditional-only fill encoding
      defaultValue: i.fill ? u : void 0
    }),
    ...ct("stroke", e, {
      // if there is encoding.stroke, include default fill just in case we have conditional-only stroke encoding
      defaultValue: i.stroke ? l : void 0
    })
  };
}
function kpe(e) {
  const { encoding: t, mark: n } = e, i = t.order;
  return !ys(n) && Oi(i) ? $l(e, i, "zindex", (r) => ze(r.value)) : {};
}
function qu({ channel: e, markDef: t, encoding: n = {}, model: i, bandPosition: r }) {
  const a = `${e}Offset`, s = t[a], o = n[a];
  if ((a === "xOffset" || a === "yOffset") && o)
    return { offsetType: "encoding", offset: m3({
      channel: a,
      channelDef: o,
      markDef: t,
      config: i == null ? void 0 : i.config,
      scaleName: i.scaleName(a),
      scale: i.getScaleComponent(a),
      stack: null,
      defaultRef: ze(s),
      bandPosition: r
    }) };
  const u = t[a];
  return u ? { offsetType: "visual", offset: u } : {};
}
function Nt(e, t, { defaultPos: n, vgChannel: i }) {
  const { encoding: r, markDef: a, config: s, stack: o } = t, u = r[e], l = r[Ar(e)], c = t.scaleName(e), f = t.getScaleComponent(e), { offset: d, offsetType: h } = qu({
    channel: e,
    markDef: a,
    encoding: r,
    model: t,
    bandPosition: 0.5
  }), p = I3({
    model: t,
    defaultPos: n,
    channel: e,
    scaleName: c,
    scale: f
  }), g = !u && Je(e) && (r.latitude || r.longitude) ? (
    // use geopoint output if there are lat/long and there is no point position overriding lat/long.
    { field: t.getName(e) }
  ) : Cpe({
    channel: e,
    channelDef: u,
    channel2Def: l,
    markDef: a,
    config: s,
    scaleName: c,
    scale: f,
    stack: o,
    offset: d,
    defaultRef: p,
    bandPosition: h === "encoding" ? 0 : void 0
  });
  return g ? { [i || e]: g } : void 0;
}
function Cpe(e) {
  const { channel: t, channelDef: n, scaleName: i, stack: r, offset: a, markDef: s } = e;
  if (le(n) && r && t === r.fieldChannel) {
    if (j(n)) {
      let o = n.bandPosition;
      if (o === void 0 && s.type === "text" && (t === "radius" || t === "theta") && (o = 0.5), o !== void 0)
        return Eg({
          scaleName: i,
          fieldOrDatumDef: n,
          startSuffix: "start",
          bandPosition: o,
          offset: a
        });
    }
    return Js(n, i, { suffix: "end" }, { offset: a });
  }
  return p3(e);
}
function I3({ model: e, defaultPos: t, channel: n, scaleName: i, scale: r }) {
  const { markDef: a, config: s } = e;
  return () => {
    const o = Ro(n), u = Qa(n), l = Ee(n, a, s, { vgChannel: u });
    if (l !== void 0)
      return Lc(n, l);
    switch (t) {
      case "zeroOrMin":
      case "zeroOrMax":
        if (i) {
          const c = r.get("type");
          if (!pe([yn.LOG, yn.TIME, yn.UTC], c)) {
            if (r.domainDefinitelyIncludesZero())
              return {
                scale: i,
                value: 0
              };
          }
        }
        if (t === "zeroOrMin")
          return o === "y" ? { field: { group: "height" } } : { value: 0 };
        switch (o) {
          case "radius":
            return {
              signal: `min(${e.width.signal},${e.height.signal})/2`
            };
          case "theta":
            return { signal: "2*PI" };
          case "x":
            return { field: { group: "width" } };
          case "y":
            return { value: 0 };
        }
        break;
      case "mid":
        return { ...e[Sn(n)], mult: 0.5 };
    }
  };
}
const _pe = {
  left: "x",
  center: "xc",
  right: "x2"
}, Fpe = {
  top: "y",
  middle: "yc",
  bottom: "y2"
};
function jD(e, t, n, i = "middle") {
  if (e === "radius" || e === "theta")
    return Qa(e);
  const r = e === "x" ? "align" : "baseline", a = Ee(r, t, n);
  let s;
  return Q(a) ? (q(Rce(r)), s = void 0) : s = a, e === "x" ? _pe[s || (i === "top" ? "left" : "center")] : Fpe[s || i];
}
function Og(e, t, { defaultPos: n, defaultPos2: i, range: r }) {
  return r ? UD(e, t, { defaultPos: n, defaultPos2: i }) : Nt(e, t, { defaultPos: n });
}
function UD(e, t, { defaultPos: n, defaultPos2: i }) {
  const { markDef: r, config: a } = t, s = Ar(e), o = Sn(e), u = Mpe(t, i, s), l = u[o] ? (
    // If there is width/height, we need to position the marks based on the alignment.
    jD(e, r, a)
  ) : (
    // Otherwise, make sure to apply to the right Vg Channel (for arc mark)
    Qa(e)
  );
  return {
    ...Nt(e, t, { defaultPos: n, vgChannel: l }),
    ...u
  };
}
function Mpe(e, t, n) {
  const { encoding: i, mark: r, markDef: a, stack: s, config: o } = e, u = Ro(n), l = Sn(n), c = Qa(n), f = i[u], d = e.scaleName(u), h = e.getScaleComponent(u), { offset: p } = n in i || n in a ? qu({ channel: n, markDef: a, encoding: i, model: e }) : qu({ channel: u, markDef: a, encoding: i, model: e });
  if (!f && (n === "x2" || n === "y2") && (i.latitude || i.longitude)) {
    const m = Sn(n), y = e.markDef[m];
    return y != null ? {
      [m]: { value: y }
    } : {
      [c]: { field: e.getName(n) }
    };
  }
  const g = Ope({
    channel: n,
    channelDef: f,
    channel2Def: i[n],
    markDef: a,
    config: o,
    scaleName: d,
    scale: h,
    stack: s,
    offset: p,
    defaultRef: void 0
  });
  return g !== void 0 ? { [c]: g } : ph(n, a) || ph(n, {
    [n]: xg(n, a, o.style),
    [l]: xg(l, a, o.style)
  }) || ph(n, o[r]) || ph(n, o.mark) || {
    [c]: I3({
      model: e,
      defaultPos: t,
      channel: n,
      scaleName: d,
      scale: h
    })()
  };
}
function Ope({ channel: e, channelDef: t, channel2Def: n, markDef: i, config: r, scaleName: a, scale: s, stack: o, offset: u, defaultRef: l }) {
  return le(t) && o && // If fieldChannel is X and channel is X2 (or Y and Y2)
  e.charAt(0) === o.fieldChannel.charAt(0) ? Js(t, a, { suffix: "start" }, { offset: u }) : p3({
    channel: e,
    channelDef: n,
    scaleName: a,
    scale: s,
    stack: o,
    markDef: i,
    config: r,
    offset: u,
    defaultRef: l
  });
}
function ph(e, t) {
  const n = Sn(e), i = Qa(e);
  if (t[i] !== void 0)
    return { [i]: Lc(e, t[i]) };
  if (t[e] !== void 0)
    return { [i]: Lc(e, t[e]) };
  if (t[n]) {
    const r = t[n];
    if (yo(r))
      q(kce(n));
    else
      return { [n]: Lc(e, r) };
  }
}
function ts(e, t) {
  const { config: n, encoding: i, markDef: r } = e, a = r.type, s = Ar(t), o = Sn(t), u = i[t], l = i[s], c = e.getScaleComponent(t), f = c ? c.get("type") : void 0, d = r.orient, h = i[o] ?? i.size ?? Ee("size", r, n, { vgChannel: o }), p = BR(t), g = a === "bar" && (t === "x" ? d === "vertical" : d === "horizontal");
  return j(u) && (De(u.bin) || vt(u.bin) || u.timeUnit && !l) && !(h && !yo(h)) && !i[p] && !gt(f) ? Dpe({
    fieldDef: u,
    fieldDef2: l,
    channel: t,
    model: e
  }) : (le(u) && gt(f) || g) && !l ? Tpe(u, t, e) : UD(t, e, { defaultPos: "zeroOrMax", defaultPos2: "zeroOrMin" });
}
function Rpe(e, t, n, i, r, a, s) {
  if (yo(r))
    if (n) {
      const u = n.get("type");
      if (u === "band") {
        let l = `bandwidth('${t}')`;
        r.band !== 1 && (l = `${r.band} * ${l}`);
        const c = Jr("minBandSize", { type: s }, i);
        return { signal: c ? `max(${xi(c)}, ${l})` : l };
      } else
        r.band !== 1 && (q(Lce(u)), r = void 0);
    } else
      return {
        mult: r.band,
        field: { group: e }
      };
  else {
    if (Q(r))
      return r;
    if (r)
      return { value: r };
  }
  if (n) {
    const u = n.get("range");
    if (ms(u) && ye(u.step))
      return { value: u.step - 2 };
  }
  if (!a) {
    const { bandPaddingInner: u, barBandPaddingInner: l, rectBandPaddingInner: c } = i.scale, f = Ke(u, s === "bar" ? l : c);
    if (Q(f))
      return { signal: `(1 - (${f.signal})) * ${e}` };
    if (ye(f))
      return { signal: `${1 - f} * ${e}` };
  }
  return { value: Fg(i.view, e) - 2 };
}
function Tpe(e, t, n) {
  var A, k;
  const { markDef: i, encoding: r, config: a, stack: s } = n, o = i.orient, u = n.scaleName(t), l = n.getScaleComponent(t), c = Sn(t), f = Ar(t), d = BR(t), h = n.scaleName(d), p = n.getScaleComponent(WE(t)), g = o === "horizontal" && t === "y" || o === "vertical" && t === "x";
  let m;
  (r.size || i.size) && (g ? m = ct("size", n, {
    vgChannel: c,
    defaultRef: ze(i.size)
  }) : q(Bce(i.type)));
  const y = !!m, b = zT({
    channel: t,
    fieldDef: e,
    markDef: i,
    config: a,
    scaleType: (A = l || p) == null ? void 0 : A.get("type"),
    useVlSizeChannel: g
  });
  m = m || {
    [c]: Rpe(c, h || u, p || l, a, b, !!e, i.type)
  };
  const v = ((k = l || p) == null ? void 0 : k.get("type")) === "band" && yo(b) && !y ? "top" : "middle", x = jD(t, i, a, v), w = x === "xc" || x === "yc", { offset: E, offsetType: $ } = qu({ channel: t, markDef: i, encoding: r, model: n, bandPosition: w ? 0.5 : 0 }), S = p3({
    channel: t,
    channelDef: e,
    markDef: i,
    config: a,
    scaleName: u,
    scale: l,
    stack: s,
    offset: E,
    defaultRef: I3({ model: n, defaultPos: "mid", channel: t, scaleName: u, scale: l }),
    bandPosition: w ? $ === "encoding" ? 0 : 0.5 : Q(b) ? { signal: `(1-${b})/2` } : yo(b) ? (1 - b.band) / 2 : 0
  });
  if (c)
    return { [x]: S, ...m };
  {
    const _ = Qa(f), P = m[c], F = E ? { ...P, offset: E } : P;
    return {
      [x]: S,
      // posRef might be an array that wraps position invalid test
      [_]: R(S) ? [S[0], { ...S[1], offset: F }] : {
        ...S,
        offset: F
      }
    };
  }
}
function Z4(e, t, n, i, r, a, s) {
  if (DR(e))
    return 0;
  const o = e === "x" || e === "y2", u = o ? -t / 2 : t / 2;
  if (Q(n) || Q(r) || Q(i) || a) {
    const l = xi(n), c = xi(r), f = xi(i), d = xi(a), p = a ? `(${s} < ${d} ? ${o ? "" : "-"}0.5 * (${d} - (${s})) : ${u})` : u, g = f ? `${f} + ` : "", m = l ? `(${l} ? -1 : 1) * ` : "", y = c ? `(${c} + ${p})` : p;
    return {
      signal: g + m + y
    };
  } else
    return r = r || 0, i + (n ? -r - u : +r + u);
}
function Dpe({ fieldDef: e, fieldDef2: t, channel: n, model: i }) {
  var k;
  const { config: r, markDef: a, encoding: s } = i, o = i.getScaleComponent(n), u = i.scaleName(n), l = o ? o.get("type") : void 0, c = o.get("reverse"), f = zT({ channel: n, fieldDef: e, markDef: a, config: r, scaleType: l }), d = (k = i.component.axes[n]) == null ? void 0 : k[0], h = (d == null ? void 0 : d.get("translate")) ?? 0.5, p = Je(n) ? Ee("binSpacing", a, r) ?? 0 : 0, g = Ar(n), m = Qa(n), y = Qa(g), b = Jr("minBandSize", a, r), { offset: v } = qu({ channel: n, markDef: a, encoding: s, model: i, bandPosition: 0 }), { offset: x } = qu({ channel: g, markDef: a, encoding: s, model: i, bandPosition: 0 }), w = ode({ fieldDef: e, scaleName: u }), E = Z4(n, p, c, h, v, b, w), $ = Z4(g, p, c, h, x ?? v, b, w), S = Q(f) ? { signal: `(1-${f.signal})/2` } : yo(f) ? (1 - f.band) / 2 : 0.5, A = Za({ fieldDef: e, fieldDef2: t, markDef: a, config: r });
  if (De(e.bin) || e.timeUnit) {
    const _ = e.timeUnit && A !== 0.5;
    return {
      [y]: e7({
        fieldDef: e,
        scaleName: u,
        bandPosition: S,
        offset: $,
        useRectOffsetField: _
      }),
      [m]: e7({
        fieldDef: e,
        scaleName: u,
        bandPosition: Q(S) ? { signal: `1-${S.signal}` } : 1 - S,
        offset: E,
        useRectOffsetField: _
      })
    };
  } else if (vt(e.bin)) {
    const _ = Js(e, u, {}, { offset: $ });
    if (j(t))
      return {
        [y]: _,
        [m]: Js(t, u, {}, { offset: E })
      };
    if (To(e.bin) && e.bin.step)
      return {
        [y]: _,
        [m]: {
          signal: `scale("${u}", ${H(e, { expr: "datum" })} + ${e.bin.step})`,
          offset: E
        }
      };
  }
  q(sT(g));
}
function e7({ fieldDef: e, scaleName: t, bandPosition: n, offset: i, useRectOffsetField: r }) {
  return Eg({
    scaleName: t,
    fieldOrDatumDef: e,
    bandPosition: n,
    offset: i,
    ...r ? {
      startSuffix: qm,
      endSuffix: Gm
    } : {}
  });
}
const Npe = /* @__PURE__ */ new Set(["aria", "width", "height"]);
function si(e, t) {
  const { fill: n = void 0, stroke: i = void 0 } = t.color === "include" ? BD(e) : {};
  return {
    ...Lpe(e.markDef, t),
    ...t7(e, "fill", n),
    ...t7(e, "stroke", i),
    ...ct("opacity", e),
    ...ct("fillOpacity", e),
    ...ct("strokeOpacity", e),
    ...ct("strokeWidth", e),
    ...ct("strokeDash", e),
    ...kpe(e),
    ...zD(e),
    ...z3(e, "href"),
    ...Epe(e)
  };
}
function t7(e, t, n) {
  const { config: i, mark: r, markDef: a } = e;
  if (Ee("invalid", a, i) === "hide" && n && !ys(r)) {
    const o = Ppe(e, { invalid: !0, channels: Sm });
    if (o)
      return {
        [t]: [
          // prepend the invalid case
          // TODO: support custom value
          { test: o, value: null },
          ...G(n)
        ]
      };
  }
  return n ? { [t]: n } : {};
}
function Lpe(e, t) {
  return ece.reduce((n, i) => (!Npe.has(i) && e[i] !== void 0 && t[i] !== "ignore" && (n[i] = ze(e[i])), n), {});
}
function Ppe(e, { invalid: t = !1, channels: n }) {
  const i = n.reduce((a, s) => {
    const o = e.getScaleComponent(s);
    if (o) {
      const u = o.get("type"), l = e.vgField(s, { expr: "datum" });
      l && Bn(u) && (a[l] = !0);
    }
    return a;
  }, {}), r = I(i);
  if (r.length > 0) {
    const a = t ? "||" : "&&";
    return r.map((s) => g3(s, t)).join(` ${a} `);
  }
}
function B3(e) {
  const { config: t, markDef: n } = e;
  if (Ee("invalid", n, t)) {
    const r = zpe(e, { channels: kr });
    if (r)
      return { defined: { signal: r } };
  }
  return {};
}
function zpe(e, { invalid: t = !1, channels: n }) {
  const i = n.reduce((a, s) => {
    var u;
    const o = e.getScaleComponent(s);
    if (o) {
      const l = o.get("type"), c = e.vgField(s, { expr: "datum", binSuffix: (u = e.stack) != null && u.impute ? "mid" : void 0 });
      c && Bn(l) && (a[c] = !0);
    }
    return a;
  }, {}), r = I(i);
  if (r.length > 0) {
    const a = t ? "||" : "&&";
    return r.map((s) => g3(s, t)).join(` ${a} `);
  }
}
function n7(e, t) {
  if (t !== void 0)
    return { [e]: ze(t) };
}
const by = "voronoi", qD = {
  defined: (e) => e.type === "point" && e.nearest,
  parse: (e, t) => {
    if (t.events)
      for (const n of t.events)
        n.markname = e.getName(by);
  },
  marks: (e, t, n) => {
    const { x: i, y: r } = t.project.hasChannel, a = e.mark;
    if (ys(a))
      return q(sce(a)), n;
    const s = {
      name: e.getName(by),
      type: "path",
      interactive: !0,
      from: { data: e.getName("marks") },
      encode: {
        update: {
          fill: { value: "transparent" },
          strokeWidth: { value: 0.35 },
          stroke: { value: "transparent" },
          isVoronoi: { value: !0 },
          ...zD(e, { reactiveGeom: !0 })
        }
      },
      transform: [
        {
          type: "voronoi",
          x: { expr: i || !r ? "datum.datum.x || 0" : "0" },
          y: { expr: r || !i ? "datum.datum.y || 0" : "0" },
          size: [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")]
        }
      ]
    };
    let o = 0, u = !1;
    return n.forEach((l, c) => {
      const f = l.name ?? "";
      f === e.component.mark[0].name ? o = c : f.indexOf(by) >= 0 && (u = !0);
    }), u || n.splice(o + 1, 0, s), n;
  }
}, GD = {
  defined: (e) => e.type === "point" && e.resolve === "global" && e.bind && e.bind !== "scales" && !M3(e.bind),
  parse: (e, t, n) => QD(t, n),
  topLevelSignals: (e, t, n) => {
    const i = t.name, r = t.project, a = t.bind, s = t.init && t.init[0], o = qD.defined(t) ? "(item().isVoronoi ? datum.datum : datum)" : "datum";
    return r.items.forEach((u, l) => {
      const c = Be(`${i}_${u.field}`);
      n.filter((d) => d.name === c).length || n.unshift({
        name: c,
        ...s ? { init: vo(s[l]) } : { value: null },
        on: t.events ? [
          {
            events: t.events,
            update: `datum && item().mark.marktype !== 'group' ? ${o}[${U(u.field)}] : null`
          }
        ] : [],
        bind: a[u.field] ?? a[u.channel] ?? a
      });
    }), n;
  },
  signals: (e, t, n) => {
    const i = t.name, r = t.project, a = n.filter((l) => l.name === i + ns)[0], s = i + Pd, o = r.items.map((l) => Be(`${i}_${l.field}`)), u = o.map((l) => `${l} !== null`).join(" && ");
    return o.length && (a.update = `${u} ? {fields: ${s}, values: [${o.join(", ")}]} : null`), delete a.value, delete a.on, n;
  }
}, Rg = "_toggle", WD = {
  defined: (e) => e.type === "point" && !!e.toggle,
  signals: (e, t, n) => n.concat({
    name: t.name + Rg,
    value: !1,
    on: [{ events: t.events, update: t.toggle }]
  }),
  modifyExpr: (e, t) => {
    const n = t.name + ns, i = t.name + Rg;
    return `${i} ? null : ${n}, ` + (t.resolve === "global" ? `${i} ? null : true, ` : `${i} ? null : {unit: ${Zs(e)}}, `) + `${i} ? ${n} : null`;
  }
}, Ipe = {
  defined: (e) => e.clear !== void 0 && e.clear !== !1,
  parse: (e, t) => {
    t.clear && (t.clear = V(t.clear) ? ls(t.clear, "view") : t.clear);
  },
  topLevelSignals: (e, t, n) => {
    if (GD.defined(t))
      for (const i of t.project.items) {
        const r = n.findIndex((a) => a.name === Be(`${t.name}_${i.field}`));
        r !== -1 && n[r].on.push({ events: t.clear, update: "null" });
      }
    return n;
  },
  signals: (e, t, n) => {
    function i(r, a) {
      r !== -1 && n[r].on && n[r].on.push({ events: t.clear, update: a });
    }
    if (t.type === "interval")
      for (const r of t.project.items) {
        const a = n.findIndex((s) => s.name === r.signals.visual);
        if (i(a, "[0, 0]"), a === -1) {
          const s = n.findIndex((o) => o.name === r.signals.data);
          i(s, "null");
        }
      }
    else {
      let r = n.findIndex((a) => a.name === t.name + ns);
      i(r, "null"), WD.defined(t) && (r = n.findIndex((a) => a.name === t.name + Rg), i(r, "false"));
    }
    return n;
  }
}, HD = {
  defined: (e) => {
    const t = e.resolve === "global" && e.bind && M3(e.bind), n = e.project.items.length === 1 && e.project.items[0].field !== Ri;
    return t && !n && q(lce), t && n;
  },
  parse: (e, t, n) => {
    const i = se(n);
    if (i.select = V(i.select) ? { type: i.select, toggle: t.toggle } : { ...i.select, toggle: t.toggle }, QD(t, i), X(n.select) && (n.select.on || n.select.clear)) {
      const s = 'event.item && indexof(event.item.mark.role, "legend") < 0';
      for (const o of t.events)
        o.filter = G(o.filter ?? []), o.filter.includes(s) || o.filter.push(s);
    }
    const r = py(t.bind) ? t.bind.legend : "click", a = V(r) ? ls(r, "view") : G(r);
    t.bind = { legend: { merge: a } };
  },
  topLevelSignals: (e, t, n) => {
    const i = t.name, r = py(t.bind) && t.bind.legend, a = (s) => (o) => {
      const u = se(o);
      return u.markname = s, u;
    };
    for (const s of t.project.items) {
      if (!s.hasLegend)
        continue;
      const o = `${Be(s.field)}_legend`, u = `${i}_${o}`;
      if (n.filter((c) => c.name === u).length === 0) {
        const c = r.merge.map(a(`${o}_symbols`)).concat(r.merge.map(a(`${o}_labels`))).concat(r.merge.map(a(`${o}_entries`)));
        n.unshift({
          name: u,
          ...t.init ? {} : { value: null },
          on: [
            // Legend entries do not store values, so we need to walk the scenegraph to the symbol datum.
            {
              events: c,
              update: "isDefined(datum.value) ? datum.value : item().items[0].items[0].datum.value",
              force: !0
            },
            { events: r.merge, update: `!event.item || !datum ? null : ${u}`, force: !0 }
          ]
        });
      }
    }
    return n;
  },
  signals: (e, t, n) => {
    const i = t.name, r = t.project, a = n.find((d) => d.name === i + ns), s = i + Pd, o = r.items.filter((d) => d.hasLegend).map((d) => Be(`${i}_${Be(d.field)}_legend`)), l = `${o.map((d) => `${d} !== null`).join(" && ")} ? {fields: ${s}, values: [${o.join(", ")}]} : null`;
    t.events && o.length > 0 ? a.on.push({
      events: o.map((d) => ({ signal: d })),
      update: l
    }) : o.length > 0 && (a.update = l, delete a.value, delete a.on);
    const c = n.find((d) => d.name === i + Rg), f = py(t.bind) && t.bind.legend;
    return c && (t.events ? c.on.push({ ...c.on[0], events: f }) : c.on[0].events = f), n;
  }
};
function Bpe(e, t, n) {
  var r;
  const i = (r = e.fieldDef(t)) == null ? void 0 : r.field;
  for (const a of St(e.component.selection ?? {})) {
    const s = a.project.hasField[i] ?? a.project.hasChannel[t];
    if (s && HD.defined(a)) {
      const o = n.get("selections") ?? [];
      o.push(a.name), n.set("selections", o, !1), s.hasLegend = !0;
    }
  }
}
const VD = "_translate_anchor", XD = "_translate_delta", jpe = {
  defined: (e) => e.type === "interval" && e.translate,
  signals: (e, t, n) => {
    const i = t.name, r = Wr.defined(t), a = i + VD, { x: s, y: o } = t.project.hasChannel;
    let u = ls(t.translate, "scope");
    return r || (u = u.map((l) => (l.between[0].markname = i + hu, l))), n.push({
      name: a,
      value: {},
      on: [
        {
          events: u.map((l) => l.between[0]),
          update: "{x: x(unit), y: y(unit)" + (s !== void 0 ? `, extent_x: ${r ? Pv(e, je) : `slice(${s.signals.visual})`}` : "") + (o !== void 0 ? `, extent_y: ${r ? Pv(e, bt) : `slice(${o.signals.visual})`}` : "") + "}"
        }
      ]
    }, {
      name: i + XD,
      value: {},
      on: [
        {
          events: u,
          update: `{x: ${a}.x - x(unit), y: ${a}.y - y(unit)}`
        }
      ]
    }), s !== void 0 && i7(e, t, s, "width", n), o !== void 0 && i7(e, t, o, "height", n), n;
  }
};
function i7(e, t, n, i, r) {
  const a = t.name, s = a + VD, o = a + XD, u = n.channel, l = Wr.defined(t), c = r.filter((w) => w.name === n.signals[l ? "data" : "visual"])[0], f = e.getSizeSignalRef(i).signal, d = e.getScaleComponent(u), h = d && d.get("type"), p = d && d.get("reverse"), g = l ? u === je ? p ? "" : "-" : p ? "-" : "" : "", m = `${s}.extent_${u}`, y = `${g}${o}.${u} / ${l ? `${f}` : `span(${m})`}`, b = !l || !d ? "panLinear" : h === "log" ? "panLog" : h === "symlog" ? "panSymlog" : h === "pow" ? "panPow" : "panLinear", v = l ? h === "pow" ? `, ${d.get("exponent") ?? 1}` : h === "symlog" ? `, ${d.get("constant") ?? 1}` : "" : "", x = `${b}(${m}, ${y}${v})`;
  c.on.push({
    events: { signal: o },
    update: l ? x : `clampRange(${x}, 0, ${f})`
  });
}
const YD = "_zoom_anchor", KD = "_zoom_delta", Upe = {
  defined: (e) => e.type === "interval" && e.zoom,
  signals: (e, t, n) => {
    const i = t.name, r = Wr.defined(t), a = i + KD, { x: s, y: o } = t.project.hasChannel, u = U(e.scaleName(je)), l = U(e.scaleName(bt));
    let c = ls(t.zoom, "scope");
    return r || (c = c.map((f) => (f.markname = i + hu, f))), n.push({
      name: i + YD,
      on: [
        {
          events: c,
          update: r ? "{" + [u ? `x: invert(${u}, x(unit))` : "", l ? `y: invert(${l}, y(unit))` : ""].filter((f) => f).join(", ") + "}" : "{x: x(unit), y: y(unit)}"
        }
      ]
    }, {
      name: a,
      on: [
        {
          events: c,
          force: !0,
          update: "pow(1.001, event.deltaY * pow(16, event.deltaMode))"
        }
      ]
    }), s !== void 0 && r7(e, t, s, "width", n), o !== void 0 && r7(e, t, o, "height", n), n;
  }
};
function r7(e, t, n, i, r) {
  const a = t.name, s = n.channel, o = Wr.defined(t), u = r.filter((b) => b.name === n.signals[o ? "data" : "visual"])[0], l = e.getSizeSignalRef(i).signal, c = e.getScaleComponent(s), f = c && c.get("type"), d = o ? Pv(e, s) : u.name, h = a + KD, p = `${a}${YD}.${s}`, g = !o || !c ? "zoomLinear" : f === "log" ? "zoomLog" : f === "symlog" ? "zoomSymlog" : f === "pow" ? "zoomPow" : "zoomLinear", m = o ? f === "pow" ? `, ${c.get("exponent") ?? 1}` : f === "symlog" ? `, ${c.get("constant") ?? 1}` : "" : "", y = `${g}(${d}, ${p}, ${h}${m})`;
  u.on.push({
    events: { signal: h },
    update: o ? y : `clampRange(${y}, 0, ${l})`
  });
}
const xo = "_store", ns = "_tuple", qpe = "_modify", JD = "vlSelectionResolve", Hm = [
  wpe,
  xpe,
  bpe,
  WD,
  // Bindings may disable direct manipulation.
  GD,
  Wr,
  HD,
  Ipe,
  jpe,
  Upe,
  qD
];
function Gpe(e) {
  let t = e.parent;
  for (; t && !ki(t); )
    t = t.parent;
  return t;
}
function Zs(e, { escape: t } = { escape: !0 }) {
  let n = t ? U(e.name) : e.name;
  const i = Gpe(e);
  if (i) {
    const { facet: r } = i;
    for (const a of Yn)
      r[a] && (n += ` + '__facet_${a}_' + (facet[${U(i.vgField(a))}])`);
  }
  return n;
}
function j3(e) {
  return St(e.component.selection ?? {}).reduce((t, n) => t || n.project.hasSelectionId, !1);
}
function QD(e, t) {
  (V(t.select) || !t.select.on) && delete e.events, (V(t.select) || !t.select.clear) && delete e.clear, (V(t.select) || !t.select.toggle) && delete e.toggle;
}
function zv(e) {
  const t = [];
  return e.type === "Identifier" ? [e.name] : e.type === "Literal" ? [e.value] : (e.type === "MemberExpression" && (t.push(...zv(e.object)), t.push(...zv(e.property))), t);
}
function ZD(e) {
  return e.object.type === "MemberExpression" ? ZD(e.object) : e.object.name === "datum";
}
function eN(e) {
  const t = Gw(e), n = /* @__PURE__ */ new Set();
  return t.visit((i) => {
    i.type === "MemberExpression" && ZD(i) && n.add(zv(i).slice(1).join("."));
  }), n;
}
class wl extends Ae {
  clone() {
    return new wl(null, this.model, se(this.filter));
  }
  constructor(t, n, i) {
    super(t), this.model = n, this.filter = i, this.expr = Tg(this.model, this.filter, this), this._dependentFields = eN(this.expr);
  }
  dependentFields() {
    return this._dependentFields;
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  assemble() {
    return {
      type: "filter",
      expr: this.expr
    };
  }
  hash() {
    return `Filter ${this.expr}`;
  }
}
function Wpe(e, t) {
  const n = {}, i = e.config.selection;
  if (!t || !t.length)
    return n;
  for (const r of t) {
    const a = Be(r.name), s = r.select, o = V(s) ? s : s.type, u = X(s) ? se(s) : { type: o }, l = i[o];
    for (const d in l)
      d === "fields" || d === "encodings" || (d === "mark" && (u[d] = { ...l[d], ...u[d] }), (u[d] === void 0 || u[d] === !0) && (u[d] = se(l[d] ?? u[d])));
    const c = n[a] = {
      ...u,
      name: a,
      type: o,
      init: r.value,
      bind: r.bind,
      events: V(u.on) ? ls(u.on, "scope") : G(se(u.on))
    }, f = se(r);
    for (const d of Hm)
      d.defined(c) && d.parse && d.parse(e, c, f);
  }
  return n;
}
function tN(e, t, n, i = "datum") {
  const r = V(t) ? t : t.param, a = Be(r), s = U(a + xo);
  let o;
  try {
    o = e.getSelectionComponent(a, r);
  } catch {
    return `!!${a}`;
  }
  if (o.project.timeUnit) {
    const d = n ?? e.component.data.raw, h = o.project.timeUnit.clone();
    d.parent ? h.insertAsParentOf(d) : d.parent = h;
  }
  const u = o.project.hasSelectionId ? "vlSelectionIdTest(" : "vlSelectionTest(", l = o.resolve === "global" ? ")" : `, ${U(o.resolve)})`, c = `${u}${s}, ${i}${l}`, f = `length(data(${s}))`;
  return t.empty === !1 ? `${f} && ${c}` : `!${f} || ${c}`;
}
function nN(e, t, n) {
  const i = Be(t), r = n.encoding;
  let a = n.field, s;
  try {
    s = e.getSelectionComponent(i, t);
  } catch {
    return i;
  }
  if (!r && !a)
    a = s.project.items[0].field, s.project.items.length > 1 && q(`A "field" or "encoding" must be specified when using a selection as a scale domain. Using "field": ${U(a)}.`);
  else if (r && !a) {
    const o = s.project.items.filter((u) => u.channel === r);
    !o.length || o.length > 1 ? (a = s.project.items[0].field, q((o.length ? "Multiple " : "No ") + `matching ${U(r)} encoding found for selection ${U(n.param)}. Using "field": ${U(a)}.`)) : a = o[0].field;
  }
  return `${s.name}[${U(ni(a))}]`;
}
function Hpe(e, t) {
  for (const [n, i] of Ja(e.component.selection ?? {})) {
    const r = e.getName(`lookup_${n}`);
    e.component.data.outputNodes[r] = i.materialized = new tn(new wl(t, e, { param: n }), r, Te.Lookup, e.component.data.outputNodeRefCounts);
  }
}
function Tg(e, t, n) {
  return Nc(t, (i) => V(i) ? i : Efe(i) ? tN(e, i, n) : bT(i));
}
function Vpe(e, t) {
  if (e)
    return R(e) && !xa(e) ? e.map((n) => $3(n, t)).join(", ") : e;
}
function vy(e, t, n, i) {
  var r, a;
  e.encode ?? (e.encode = {}), (r = e.encode)[t] ?? (r[t] = {}), (a = e.encode[t]).update ?? (a.update = {}), e.encode[t].update[n] = i;
}
function yc(e, t, n, i = { header: !1 }) {
  var f, d;
  const { disable: r, orient: a, scale: s, labelExpr: o, title: u, zindex: l, ...c } = e.combine();
  if (!r) {
    for (const h in c) {
      const p = kde[h], g = c[h];
      if (p && p !== t && p !== "both")
        delete c[h];
      else if (Ld(g)) {
        const { condition: m, ...y } = g, b = G(m), v = R4[h];
        if (v) {
          const { vgProp: x, part: w } = v, E = [
            ...b.map(($) => {
              const { test: S, ...A } = $;
              return {
                test: Tg(null, S),
                ...A
              };
            }),
            y
          ];
          vy(c, w, x, E), delete c[h];
        } else if (v === null) {
          const x = {
            signal: b.map((w) => {
              const { test: E, ...$ } = w;
              return `${Tg(null, E)} ? ${m4($)} : `;
            }).join("") + m4(y)
          };
          c[h] = x;
        }
      } else if (Q(g)) {
        const m = R4[h];
        if (m) {
          const { vgProp: y, part: b } = m;
          vy(c, b, y, g), delete c[h];
        }
      }
      pe(["labelAlign", "labelBaseline"], h) && c[h] === null && delete c[h];
    }
    if (t === "grid") {
      if (!c.grid)
        return;
      if (c.encode) {
        const { grid: h } = c.encode;
        c.encode = {
          ...h ? { grid: h } : {}
        }, ke(c.encode) && delete c.encode;
      }
      return {
        scale: s,
        orient: a,
        ...c,
        domain: !1,
        labels: !1,
        aria: !1,
        // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`
        // would not affect gridAxis
        maxExtent: 0,
        minExtent: 0,
        ticks: !1,
        zindex: Ke(l, 0)
        // put grid behind marks by default
      };
    } else {
      if (!i.header && e.mainExtracted)
        return;
      if (o !== void 0) {
        let p = o;
        (d = (f = c.encode) == null ? void 0 : f.labels) != null && d.update && Q(c.encode.labels.update.text) && (p = ho(o, "datum.label", c.encode.labels.update.text.signal)), vy(c, "labels", "text", { signal: p });
      }
      if (c.labelAlign === null && delete c.labelAlign, c.encode) {
        for (const p of XT)
          e.hasAxisPart(p) || delete c.encode[p];
        ke(c.encode) && delete c.encode;
      }
      const h = Vpe(u, n);
      return {
        scale: s,
        orient: a,
        grid: !1,
        ...h ? { title: h } : {},
        ...c,
        ...n.aria === !1 ? { aria: !1 } : {},
        zindex: Ke(l, 0)
        // put axis line above marks by default
      };
    }
  }
}
function iN(e) {
  const { axes: t } = e.component, n = [];
  for (const i of kr)
    if (t[i]) {
      for (const r of t[i])
        if (!r.get("disable") && !r.get("gridScale")) {
          const a = i === "x" ? "height" : "width", s = e.getSizeSignalRef(a).signal;
          a !== s && n.push({
            name: a,
            update: s
          });
        }
    }
  return n;
}
function Xpe(e, t) {
  const { x: n = [], y: i = [] } = e;
  return [
    ...n.map((r) => yc(r, "grid", t)),
    ...i.map((r) => yc(r, "grid", t)),
    ...n.map((r) => yc(r, "main", t)),
    ...i.map((r) => yc(r, "main", t))
  ].filter((r) => r);
}
function a7(e, t, n, i) {
  return Object.assign.apply(null, [
    {},
    ...e.map((r) => {
      if (r === "axisOrient") {
        const a = n === "x" ? "bottom" : "left", s = t[n === "x" ? "axisBottom" : "axisLeft"] || {}, o = t[n === "x" ? "axisTop" : "axisRight"] || {}, u = /* @__PURE__ */ new Set([...I(s), ...I(o)]), l = {};
        for (const c of u.values())
          l[c] = {
            // orient is surely signal in this case
            signal: `${i.signal} === "${a}" ? ${xi(s[c])} : ${xi(o[c])}`
          };
        return l;
      }
      return t[r];
    })
  ]);
}
function Ype(e, t, n, i) {
  const r = t === "band" ? ["axisDiscrete", "axisBand"] : t === "point" ? ["axisDiscrete", "axisPoint"] : wT(t) ? ["axisQuantitative"] : t === "time" || t === "utc" ? ["axisTemporal"] : [], a = e === "x" ? "axisX" : "axisY", s = Q(n) ? "axisOrient" : `axis${kd(n)}`, o = [
    // technically Vega does have axisBand, but if we make another separation here,
    // it will further introduce complexity in the code
    ...r,
    ...r.map((l) => a + l.substr(4))
  ], u = ["axis", s, a];
  return {
    vlOnlyAxisConfig: a7(o, i, e, n),
    vgAxisConfig: a7(u, i, e, n),
    axisConfigStyle: Kpe([...u, ...o], i)
  };
}
function Kpe(e, t) {
  var i;
  const n = [{}];
  for (const r of e) {
    let a = (i = t[r]) == null ? void 0 : i.style;
    if (a) {
      a = G(a);
      for (const s of a)
        n.push(t.style[s]);
    }
  }
  return Object.assign.apply(null, n);
}
function Iv(e, t, n, i = {}) {
  var a;
  const r = KR(e, n, t);
  if (r !== void 0)
    return {
      configFrom: "style",
      configValue: r
    };
  for (const s of ["vlOnlyAxisConfig", "vgAxisConfig", "axisConfigStyle"])
    if (((a = i[s]) == null ? void 0 : a[e]) !== void 0)
      return { configFrom: s, configValue: i[s][e] };
  return {};
}
const s7 = {
  scale: ({ model: e, channel: t }) => e.scaleName(t),
  format: ({ format: e }) => e,
  formatType: ({ formatType: e }) => e,
  grid: ({ fieldOrDatumDef: e, axis: t, scaleType: n }) => t.grid ?? Jpe(n, e),
  gridScale: ({ model: e, channel: t }) => Qpe(e, t),
  labelAlign: ({ axis: e, labelAngle: t, orient: n, channel: i }) => e.labelAlign || aN(t, n, i),
  labelAngle: ({ labelAngle: e }) => e,
  labelBaseline: ({ axis: e, labelAngle: t, orient: n, channel: i }) => e.labelBaseline || rN(t, n, i),
  labelFlush: ({ axis: e, fieldOrDatumDef: t, channel: n }) => e.labelFlush ?? ege(t.type, n),
  labelOverlap: ({ axis: e, fieldOrDatumDef: t, scaleType: n }) => e.labelOverlap ?? tge(t.type, n, j(t) && !!t.timeUnit, j(t) ? t.sort : void 0),
  // we already calculate orient in parse
  orient: ({ orient: e }) => e,
  tickCount: ({ channel: e, model: t, axis: n, fieldOrDatumDef: i, scaleType: r }) => {
    const a = e === "x" ? "width" : e === "y" ? "height" : void 0, s = a ? t.getSizeSignalRef(a) : void 0;
    return n.tickCount ?? ige({ fieldOrDatumDef: i, scaleType: r, size: s, values: n.values });
  },
  tickMinStep: rge,
  title: ({ axis: e, model: t, channel: n }) => {
    if (e.title !== void 0)
      return e.title;
    const i = sN(t, n);
    if (i !== void 0)
      return i;
    const r = t.typedFieldDef(n), a = n === "x" ? "x2" : "y2", s = t.fieldDef(a);
    return QR(r ? [M4(r)] : [], j(s) ? [M4(s)] : []);
  },
  values: ({ axis: e, fieldOrDatumDef: t }) => age(e, t),
  zindex: ({ axis: e, fieldOrDatumDef: t, mark: n }) => e.zindex ?? sge(n, t)
};
function Jpe(e, t) {
  return !gt(e) && j(t) && !De(t == null ? void 0 : t.bin) && !vt(t == null ? void 0 : t.bin);
}
function Qpe(e, t) {
  const n = t === "x" ? "y" : "x";
  if (e.getScaleComponent(n))
    return e.scaleName(n);
}
function Zpe(e, t, n, i, r) {
  const a = t == null ? void 0 : t.labelAngle;
  if (a !== void 0)
    return Q(a) ? a : bf(a);
  {
    const { configValue: s } = Iv("labelAngle", i, t == null ? void 0 : t.style, r);
    return s !== void 0 ? bf(s) : n === je && pe([c3, l3], e.type) && !(j(e) && e.timeUnit) ? 270 : void 0;
  }
}
function Bv(e) {
  return `(((${e.signal} % 360) + 360) % 360)`;
}
function rN(e, t, n, i) {
  if (e !== void 0)
    if (n === "x") {
      if (Q(e)) {
        const r = Bv(e), a = Q(t) ? `(${t.signal} === "top")` : t === "top";
        return {
          signal: `(45 < ${r} && ${r} < 135) || (225 < ${r} && ${r} < 315) ? "middle" :(${r} <= 45 || 315 <= ${r}) === ${a} ? "bottom" : "top"`
        };
      }
      if (45 < e && e < 135 || 225 < e && e < 315)
        return "middle";
      if (Q(t)) {
        const r = e <= 45 || 315 <= e ? "===" : "!==";
        return { signal: `${t.signal} ${r} "top" ? "bottom" : "top"` };
      }
      return (e <= 45 || 315 <= e) == (t === "top") ? "bottom" : "top";
    } else {
      if (Q(e)) {
        const r = Bv(e), a = Q(t) ? `(${t.signal} === "left")` : t === "left";
        return {
          signal: `${r} <= 45 || 315 <= ${r} || (135 <= ${r} && ${r} <= 225) ? ${i ? '"middle"' : "null"} : (45 <= ${r} && ${r} <= 135) === ${a} ? "top" : "bottom"`
        };
      }
      if (e <= 45 || 315 <= e || 135 <= e && e <= 225)
        return i ? "middle" : null;
      if (Q(t)) {
        const r = 45 <= e && e <= 135 ? "===" : "!==";
        return { signal: `${t.signal} ${r} "left" ? "top" : "bottom"` };
      }
      return (45 <= e && e <= 135) == (t === "left") ? "top" : "bottom";
    }
}
function aN(e, t, n) {
  if (e === void 0)
    return;
  const i = n === "x", r = i ? 0 : 90, a = i ? "bottom" : "left";
  if (Q(e)) {
    const s = Bv(e), o = Q(t) ? `(${t.signal} === "${a}")` : t === a;
    return {
      signal: `(${r ? `(${s} + 90)` : s} % 180 === 0) ? ${i ? null : '"center"'} :(${r} < ${s} && ${s} < ${180 + r}) === ${o} ? "left" : "right"`
    };
  }
  if ((e + r) % 180 === 0)
    return i ? null : "center";
  if (Q(t)) {
    const s = r < e && e < 180 + r ? "===" : "!==";
    return {
      signal: `${`${t.signal} ${s} "${a}"`} ? "left" : "right"`
    };
  }
  return (r < e && e < 180 + r) == (t === a) ? "left" : "right";
}
function ege(e, t) {
  if (t === "x" && pe(["quantitative", "temporal"], e))
    return !0;
}
function tge(e, t, n, i) {
  if (n && !X(i) || e !== "nominal" && e !== "ordinal")
    return t === "log" || t === "symlog" ? "greedy" : !0;
}
function nge(e) {
  return e === "x" ? "bottom" : "left";
}
function ige({ fieldOrDatumDef: e, scaleType: t, size: n, values: i }) {
  var r;
  if (!i && !gt(t) && t !== "log") {
    if (j(e)) {
      if (De(e.bin))
        return { signal: `ceil(${n.signal}/10)` };
      if (e.timeUnit && pe(["month", "hours", "day", "quarter"], (r = pt(e.timeUnit)) == null ? void 0 : r.unit))
        return;
    }
    return { signal: `ceil(${n.signal}/40)` };
  }
}
function rge({ format: e, fieldOrDatumDef: t }) {
  if (e === "d")
    return 1;
  if (j(t)) {
    const { timeUnit: n } = t;
    if (n) {
      const i = gT(n);
      if (i)
        return { signal: i };
    }
  }
}
function sN(e, t) {
  const n = t === "x" ? "x2" : "y2", i = e.fieldDef(t), r = e.fieldDef(n), a = i ? i.title : void 0, s = r ? r.title : void 0;
  if (a && s)
    return ZR(a, s);
  if (a)
    return a;
  if (s)
    return s;
  if (a !== void 0)
    return a;
  if (s !== void 0)
    return s;
}
function age(e, t) {
  const n = e.values;
  if (R(n))
    return VT(t, n);
  if (Q(n))
    return n;
}
function sge(e, t) {
  return e === "rect" && Ag(t) ? 1 : 0;
}
class Gu extends Ae {
  clone() {
    return new Gu(null, se(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this._dependentFields = eN(this.transform.calculate);
  }
  static parseAllForSortIndex(t, n) {
    return n.forEachFieldDef((i, r) => {
      if (Lo(i) && PT(i.sort)) {
        const { field: a, timeUnit: s } = i, o = i.sort, u = o.map((l, c) => `${bT({ field: a, timeUnit: s, equal: l })} ? ${c} : `).join("") + o.length;
        t = new Gu(t, {
          calculate: u,
          as: Wu(i, r, { forAs: !0 })
        });
      }
    }), t;
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.transform.as]);
  }
  dependentFields() {
    return this._dependentFields;
  }
  assemble() {
    return {
      type: "formula",
      expr: this.transform.calculate,
      as: this.transform.as
    };
  }
  hash() {
    return `Calculate ${he(this.transform)}`;
  }
}
function Wu(e, t, n) {
  return H(e, { prefix: t, suffix: "sort_index", ...n ?? {} });
}
function Vm(e, t) {
  return pe(["top", "bottom"], t) ? "column" : pe(["left", "right"], t) || e === "row" ? "row" : "column";
}
function Hu(e, t, n, i) {
  const r = i === "row" ? n.headerRow : i === "column" ? n.headerColumn : n.headerFacet;
  return Ke((t || {})[e], r[e], n.header[e]);
}
function Xm(e, t, n, i) {
  const r = {};
  for (const a of e) {
    const s = Hu(a, t || {}, n, i);
    s !== void 0 && (r[a] = s);
  }
  return r;
}
const U3 = ["row", "column"], q3 = ["header", "footer"];
function oge(e, t) {
  const n = e.component.layoutHeaders[t].title, i = e.config ? e.config : void 0, r = e.component.layoutHeaders[t].facetFieldDef ? e.component.layoutHeaders[t].facetFieldDef : void 0, { titleAnchor: a, titleAngle: s, titleOrient: o } = Xm(["titleAnchor", "titleAngle", "titleOrient"], r.header, i, t), u = Vm(t, o), l = bf(s);
  return {
    name: `${t}-title`,
    type: "group",
    role: `${u}-title`,
    title: {
      text: n,
      ...t === "row" ? { orient: "left" } : {},
      style: "guide-title",
      ...uN(l, u),
      ...oN(u, l, a),
      ...lN(i, r, t, Xde, fD)
    }
  };
}
function oN(e, t, n = "middle") {
  switch (n) {
    case "start":
      return { align: "left" };
    case "end":
      return { align: "right" };
  }
  const i = aN(t, e === "row" ? "left" : "top", e === "row" ? "y" : "x");
  return i ? { align: i } : {};
}
function uN(e, t) {
  const n = rN(e, t === "row" ? "left" : "top", t === "row" ? "y" : "x", !0);
  return n ? { baseline: n } : {};
}
function uge(e, t) {
  const n = e.component.layoutHeaders[t], i = [];
  for (const r of q3)
    if (n[r])
      for (const a of n[r]) {
        const s = cge(e, t, r, n, a);
        s != null && i.push(s);
      }
  return i;
}
function lge(e, t) {
  const { sort: n } = e;
  return or(n) ? {
    field: H(n, { expr: "datum" }),
    order: n.order ?? "ascending"
  } : R(n) ? {
    field: Wu(e, t, { expr: "datum" }),
    order: "ascending"
  } : {
    field: H(e, { expr: "datum" }),
    order: n ?? "ascending"
  };
}
function jv(e, t, n) {
  const { format: i, formatType: r, labelAngle: a, labelAnchor: s, labelOrient: o, labelExpr: u } = Xm(["format", "formatType", "labelAngle", "labelAnchor", "labelOrient", "labelExpr"], e.header, n, t), l = y3({
    fieldOrDatumDef: e,
    format: i,
    formatType: r,
    expr: "parent",
    config: n
  }).signal, c = Vm(t, o);
  return {
    text: {
      signal: u ? ho(ho(u, "datum.label", l), "datum.value", H(e, { expr: "parent" })) : l
    },
    ...t === "row" ? { orient: "left" } : {},
    style: "guide-label",
    frame: "group",
    ...uN(a, c),
    ...oN(c, a, s),
    ...lN(n, e, t, Yde, dD)
  };
}
function cge(e, t, n, i, r) {
  if (r) {
    let a = null;
    const { facetFieldDef: s } = i, o = e.config ? e.config : void 0;
    if (s && r.labels) {
      const { labelOrient: f } = Xm(["labelOrient"], s.header, o, t);
      (t === "row" && !pe(["top", "bottom"], f) || t === "column" && !pe(["left", "right"], f)) && (a = jv(s, t, o));
    }
    const u = ki(e) && !Td(e.facet), l = r.axes, c = (l == null ? void 0 : l.length) > 0;
    if (a || c) {
      const f = t === "row" ? "height" : "width";
      return {
        name: e.getName(`${t}_${n}`),
        type: "group",
        role: `${t}-${n}`,
        ...i.facetFieldDef ? {
          from: { data: e.getName(`${t}_domain`) },
          sort: lge(s, t)
        } : {},
        ...c && u ? {
          from: { data: e.getName(`facet_domain_${t}`) }
        } : {},
        ...a ? { title: a } : {},
        ...r.sizeSignal ? {
          encode: {
            update: {
              [f]: r.sizeSignal
            }
          }
        } : {},
        ...c ? { axes: l } : {}
      };
    }
  }
  return null;
}
const fge = {
  column: {
    start: 0,
    end: 1
  },
  row: {
    start: 1,
    end: 0
  }
};
function dge(e, t) {
  return fge[t][e];
}
function hge(e, t) {
  const n = {};
  for (const i of Yn) {
    const r = e[i];
    if (r != null && r.facetFieldDef) {
      const { titleAnchor: a, titleOrient: s } = Xm(["titleAnchor", "titleOrient"], r.facetFieldDef.header, t, i), o = Vm(i, s), u = dge(a, o);
      u !== void 0 && (n[o] = u);
    }
  }
  return ke(n) ? void 0 : n;
}
function lN(e, t, n, i, r) {
  const a = {};
  for (const s of i) {
    if (!r[s])
      continue;
    const o = Hu(s, t == null ? void 0 : t.header, e, n);
    o !== void 0 && (a[r[s]] = o);
  }
  return a;
}
function G3(e) {
  return [
    ...gh(e, "width"),
    ...gh(e, "height"),
    ...gh(e, "childWidth"),
    ...gh(e, "childHeight")
  ];
}
function gh(e, t) {
  const n = t === "width" ? "x" : "y", i = e.component.layoutSize.get(t);
  if (!i || i === "merged")
    return [];
  const r = e.getSizeSignalRef(t).signal;
  if (i === "step") {
    const a = e.getScaleComponent(n);
    if (a) {
      const s = a.get("type"), o = a.get("range");
      if (gt(s) && ms(o)) {
        const u = e.scaleName(n);
        return ki(e.parent) && e.parent.component.resolve.scale[n] === "independent" ? [o7(u, o)] : [
          o7(u, o),
          {
            name: r,
            update: cN(u, a, `domain('${u}').length`)
          }
        ];
      }
    }
    throw new Error("layout size is step although width/height is not step.");
  } else if (i == "container") {
    const a = r.endsWith("width"), s = a ? "containerSize()[0]" : "containerSize()[1]", o = Tv(e.config.view, a ? "width" : "height"), u = `isFinite(${s}) ? ${s} : ${o}`;
    return [{ name: r, init: u, on: [{ update: u, events: "window:resize" }] }];
  } else
    return [
      {
        name: r,
        value: i
      }
    ];
}
function o7(e, t) {
  const n = `${e}_step`;
  return Q(t.step) ? { name: n, update: t.step.signal } : { name: n, value: t.step };
}
function cN(e, t, n) {
  const i = t.get("type"), r = t.get("padding"), a = Ke(t.get("paddingOuter"), r);
  let s = t.get("paddingInner");
  return s = i === "band" ? (
    // only band has real paddingInner
    s !== void 0 ? s : r
  ) : (
    // For point, as calculated in https://github.com/vega/vega-scale/blob/master/src/band.js#L128,
    // it's equivalent to have paddingInner = 1 since there is only n-1 steps between n points.
    1
  ), `bandspace(${n}, ${xi(s)}, ${xi(a)}) * ${e}_step`;
}
function fN(e) {
  return e === "childWidth" ? "width" : e === "childHeight" ? "height" : e;
}
function dN(e, t) {
  return I(e).reduce((n, i) => {
    const r = e[i];
    return {
      ...n,
      ...$l(t, r, i, (a) => ze(a.value))
    };
  }, {});
}
function hN(e, t) {
  if (ki(t))
    return e === "theta" ? "independent" : "shared";
  if (Al(t))
    return "shared";
  if (J3(t))
    return Je(e) || e === "theta" || e === "radius" ? "independent" : "shared";
  throw new Error("invalid model type for resolve");
}
function W3(e, t) {
  const n = e.scale[t], i = Je(t) ? "axis" : "legend";
  return n === "independent" ? (e[i][t] === "shared" && q(Wce(t)), "independent") : e[i][t] || "shared";
}
const pge = {
  ...Qde,
  disable: 1,
  labelExpr: 1,
  selections: 1,
  // channel scales
  opacity: 1,
  shape: 1,
  stroke: 1,
  fill: 1,
  size: 1,
  strokeWidth: 1,
  strokeDash: 1,
  // encode
  encode: 1
}, pN = I(pge);
class gge extends ca {
}
const u7 = {
  symbols: mge,
  gradient: yge,
  labels: bge,
  entries: vge
};
function mge(e, { fieldOrDatumDef: t, model: n, channel: i, legendCmpt: r, legendType: a }) {
  if (a !== "symbol")
    return;
  const { markDef: s, encoding: o, config: u, mark: l } = n, c = s.filled && l !== "trail";
  let f = {
    ...ice({}, n, Xfe),
    ...BD(n, { filled: c })
  };
  const d = r.get("symbolOpacity") ?? u.legend.symbolOpacity, h = r.get("symbolFillColor") ?? u.legend.symbolFillColor, p = r.get("symbolStrokeColor") ?? u.legend.symbolStrokeColor, g = d === void 0 ? gN(o.opacity) ?? s.opacity : void 0;
  if (f.fill) {
    if (i === "fill" || c && i === wn)
      delete f.fill;
    else if (f.fill.field)
      h ? delete f.fill : (f.fill = ze(u.legend.symbolBaseFillColor ?? "black"), f.fillOpacity = ze(g ?? 1));
    else if (R(f.fill)) {
      const m = Uv(o.fill ?? o.color) ?? s.fill ?? (c && s.color);
      m && (f.fill = ze(m));
    }
  }
  if (f.stroke) {
    if (i === "stroke" || !c && i === wn)
      delete f.stroke;
    else if (f.stroke.field || p)
      delete f.stroke;
    else if (R(f.stroke)) {
      const m = Ke(Uv(o.stroke || o.color), s.stroke, c ? s.color : void 0);
      m && (f.stroke = { value: m });
    }
  }
  if (i !== oa) {
    const m = j(t) && yN(n, r, t);
    m ? f.opacity = [
      { test: m, ...ze(g ?? 1) },
      ze(u.legend.unselectedOpacity)
    ] : g && (f.opacity = ze(g));
  }
  return f = { ...f, ...e }, ke(f) ? void 0 : f;
}
function yge(e, { model: t, legendType: n, legendCmpt: i }) {
  if (n !== "gradient")
    return;
  const { config: r, markDef: a, encoding: s } = t;
  let o = {};
  const l = (i.get("gradientOpacity") ?? r.legend.gradientOpacity) === void 0 ? gN(s.opacity) || a.opacity : void 0;
  return l && (o.opacity = ze(l)), o = { ...o, ...e }, ke(o) ? void 0 : o;
}
function bge(e, { fieldOrDatumDef: t, model: n, channel: i, legendCmpt: r }) {
  const a = n.legend(i) || {}, s = n.config, o = j(t) ? yN(n, r, t) : void 0, u = o ? [{ test: o, value: 1 }, { value: s.legend.unselectedOpacity }] : void 0, { format: l, formatType: c } = a;
  let f;
  bo(c) ? f = wi({
    fieldOrDatumDef: t,
    field: "datum.value",
    format: l,
    formatType: c,
    config: s
  }) : l === void 0 && c === void 0 && s.customFormatTypes && (t.type === "quantitative" && s.numberFormatType ? f = wi({
    fieldOrDatumDef: t,
    field: "datum.value",
    format: s.numberFormat,
    formatType: s.numberFormatType,
    config: s
  }) : t.type === "temporal" && s.timeFormatType && j(t) && t.timeUnit === void 0 && (f = wi({
    fieldOrDatumDef: t,
    field: "datum.value",
    format: s.timeFormat,
    formatType: s.timeFormatType,
    config: s
  })));
  const d = {
    ...u ? { opacity: u } : {},
    ...f ? { text: f } : {},
    ...e
  };
  return ke(d) ? void 0 : d;
}
function vge(e, { legendCmpt: t }) {
  const n = t.get("selections");
  return n != null && n.length ? { ...e, fill: { value: "transparent" } } : e;
}
function gN(e) {
  return mN(e, (t, n) => Math.max(t, n.value));
}
function Uv(e) {
  return mN(e, (t, n) => Ke(t, n.value));
}
function mN(e, t) {
  if (pde(e))
    return G(e.condition).reduce(t, e.value);
  if (Oi(e))
    return e.value;
}
function yN(e, t, n) {
  const i = t.get("selections");
  if (!(i != null && i.length))
    return;
  const r = U(n.field);
  return i.map((a) => `(!length(data(${U(Be(a) + xo)})) || (${a}[${r}] && indexof(${a}[${r}], datum.value) >= 0))`).join(" || ");
}
const l7 = {
  direction: ({ direction: e }) => e,
  format: ({ fieldOrDatumDef: e, legend: t, config: n }) => {
    const { format: i, formatType: r } = t;
    return TT(e, e.type, i, r, n, !1);
  },
  formatType: ({ legend: e, fieldOrDatumDef: t, scaleType: n }) => {
    const { formatType: i } = e;
    return DT(i, t, n);
  },
  gradientLength: (e) => {
    const { legend: t, legendConfig: n } = e;
    return t.gradientLength ?? n.gradientLength ?? kge(e);
  },
  labelOverlap: ({ legend: e, legendConfig: t, scaleType: n }) => e.labelOverlap ?? t.labelOverlap ?? Cge(n),
  symbolType: ({ legend: e, markDef: t, channel: n, encoding: i }) => e.symbolType ?? $ge(t.type, n, i.shape, t.shape),
  title: ({ fieldOrDatumDef: e, config: t }) => du(e, t, { allowDisabling: !0 }),
  type: ({ legendType: e, scaleType: t, channel: n }) => {
    if (fu(n) && $i(t)) {
      if (e === "gradient")
        return;
    } else if (e === "symbol")
      return;
    return e;
  },
  values: ({ fieldOrDatumDef: e, legend: t }) => xge(t, e)
};
function xge(e, t) {
  const n = e.values;
  if (R(n))
    return VT(t, n);
  if (Q(n))
    return n;
}
function $ge(e, t, n, i) {
  if (t !== "shape") {
    const r = Uv(n) ?? i;
    if (r)
      return r;
  }
  switch (e) {
    case "bar":
    case "rect":
    case "image":
    case "square":
      return "square";
    case "line":
    case "trail":
    case "rule":
      return "stroke";
    case "arc":
    case "point":
    case "circle":
    case "tick":
    case "geoshape":
    case "area":
    case "text":
      return "circle";
  }
}
function wge(e) {
  const { legend: t } = e;
  return Ke(t.type, Ege(e));
}
function Ege({ channel: e, timeUnit: t, scaleType: n }) {
  if (fu(e)) {
    if (pe(["quarter", "month", "day"], t))
      return "symbol";
    if ($i(n))
      return "gradient";
  }
  return "symbol";
}
function Sge({ legendConfig: e, legendType: t, orient: n, legend: i }) {
  return i.direction ?? e[t ? "gradientDirection" : "symbolDirection"] ?? Age(n, t);
}
function Age(e, t) {
  switch (e) {
    case "top":
    case "bottom":
      return "horizontal";
    case "left":
    case "right":
    case "none":
    case void 0:
      return;
    default:
      return t === "gradient" ? "horizontal" : void 0;
  }
}
function kge({ legendConfig: e, model: t, direction: n, orient: i, scaleType: r }) {
  const { gradientHorizontalMaxLength: a, gradientHorizontalMinLength: s, gradientVerticalMaxLength: o, gradientVerticalMinLength: u } = e;
  if ($i(r))
    return n === "horizontal" ? i === "top" || i === "bottom" ? c7(t, "width", s, a) : s : c7(t, "height", u, o);
}
function c7(e, t, n, i) {
  return { signal: `clamp(${e.getSizeSignalRef(t).signal}, ${n}, ${i})` };
}
function Cge(e) {
  if (pe(["quantile", "threshold", "log", "symlog"], e))
    return "greedy";
}
function bN(e) {
  const t = We(e) ? _ge(e) : Rge(e);
  return e.component.legends = t, t;
}
function _ge(e) {
  const { encoding: t } = e, n = {};
  for (const i of [wn, ...pD]) {
    const r = it(t[i]);
    !r || !e.getScaleComponent(i) || i === En && j(r) && r.type === xl || (n[i] = Oge(e, i));
  }
  return n;
}
function Fge(e, t) {
  const n = e.scaleName(t);
  if (e.mark === "trail") {
    if (t === "color")
      return { stroke: n };
    if (t === "size")
      return { strokeWidth: n };
  }
  return t === "color" ? e.markDef.filled ? { fill: n } : { stroke: n } : { [t]: n };
}
function Mge(e, t, n, i) {
  switch (t) {
    case "disable":
      return n !== void 0;
    case "values":
      return !!(n != null && n.values);
    case "title":
      if (t === "title" && e === (i == null ? void 0 : i.title))
        return !0;
  }
  return e === (n || {})[t];
}
function Oge(e, t) {
  var x;
  let n = e.legend(t);
  const { markDef: i, encoding: r, config: a } = e, s = a.legend, o = new gge({}, Fge(e, t));
  Bpe(e, t, o);
  const u = n !== void 0 ? !n : s.disable;
  if (o.set("disable", u, n !== void 0), u)
    return o;
  n = n || {};
  const l = e.getScaleComponent(t).get("type"), c = it(r[t]), f = j(c) ? (x = pt(c.timeUnit)) == null ? void 0 : x.unit : void 0, d = n.orient || a.legend.orient || "right", h = wge({ legend: n, channel: t, timeUnit: f, scaleType: l }), p = Sge({ legend: n, legendType: h, orient: d, legendConfig: s }), g = {
    legend: n,
    channel: t,
    model: e,
    markDef: i,
    encoding: r,
    fieldOrDatumDef: c,
    legendConfig: s,
    config: a,
    scaleType: l,
    orient: d,
    legendType: h,
    direction: p
  };
  for (const w of pN) {
    if (h === "gradient" && w.startsWith("symbol") || h === "symbol" && w.startsWith("gradient"))
      continue;
    const E = w in l7 ? l7[w](g) : n[w];
    if (E !== void 0) {
      const $ = Mge(E, w, n, e.fieldDef(t));
      ($ || a.legend[w] === void 0) && o.set(w, E, $);
    }
  }
  const m = (n == null ? void 0 : n.encoding) ?? {}, y = o.get("selections"), b = {}, v = { fieldOrDatumDef: c, model: e, channel: t, legendCmpt: o, legendType: h };
  for (const w of ["labels", "legend", "title", "symbols", "gradient", "entries"]) {
    const E = dN(m[w] ?? {}, e), $ = w in u7 ? u7[w](E, v) : E;
    $ !== void 0 && !ke($) && (b[w] = {
      ...y != null && y.length && j(c) ? { name: `${Be(c.field)}_legend_${w}` } : {},
      ...y != null && y.length ? { interactive: !!y } : {},
      update: $
    });
  }
  return ke(b) || o.set("encode", b, !!(n != null && n.encoding)), o;
}
function Rge(e) {
  const { legends: t, resolve: n } = e.component;
  for (const i of e.children) {
    bN(i);
    for (const r of I(i.component.legends))
      n.legend[r] = W3(e.component.resolve, r), n.legend[r] === "shared" && (t[r] = vN(t[r], i.component.legends[r]), t[r] || (n.legend[r] = "independent", delete t[r]));
  }
  for (const i of I(t))
    for (const r of e.children)
      r.component.legends[i] && n.legend[i] === "shared" && delete r.component.legends[i];
  return t;
}
function vN(e, t) {
  var a, s, o, u;
  if (!e)
    return t.clone();
  const n = e.getWithExplicit("orient"), i = t.getWithExplicit("orient");
  if (n.explicit && i.explicit && n.value !== i.value)
    return;
  let r = !1;
  for (const l of pN) {
    const c = es(
      e.getWithExplicit(l),
      t.getWithExplicit(l),
      l,
      "legend",
      // Tie breaker function
      (f, d) => {
        switch (l) {
          case "symbolType":
            return Tge(f, d);
          case "title":
            return eT(f, d);
          case "type":
            return r = !0, Cn("symbol");
        }
        return Um(f, d, l, "legend");
      }
    );
    e.setWithExplicit(l, c);
  }
  return r && ((s = (a = e.implicit) == null ? void 0 : a.encode) != null && s.gradient && vg(e.implicit, ["encode", "gradient"]), (u = (o = e.explicit) == null ? void 0 : o.encode) != null && u.gradient && vg(e.explicit, ["encode", "gradient"])), e;
}
function Tge(e, t) {
  return t.value === "circle" ? t : e;
}
function Dge(e, t, n, i) {
  var r, a;
  e.encode ?? (e.encode = {}), (r = e.encode)[t] ?? (r[t] = {}), (a = e.encode[t]).update ?? (a.update = {}), e.encode[t].update[n] = i;
}
function xN(e) {
  const t = e.component.legends, n = {};
  for (const r of I(t)) {
    const a = e.getScaleComponent(r), s = Ce(a.get("domains"));
    if (n[s])
      for (const o of n[s])
        vN(o, t[r]) || n[s].push(t[r]);
    else
      n[s] = [t[r].clone()];
  }
  return St(n).flat().map((r) => Nge(r, e.config)).filter((r) => r !== void 0);
}
function Nge(e, t) {
  var s, o, u;
  const { disable: n, labelExpr: i, selections: r, ...a } = e.combine();
  if (!n) {
    if (t.aria === !1 && a.aria == null && (a.aria = !1), (s = a.encode) != null && s.symbols) {
      const l = a.encode.symbols.update;
      l.fill && l.fill.value !== "transparent" && !l.stroke && !a.stroke && (l.stroke = { value: "transparent" });
      for (const c of pD)
        a[c] && delete l[c];
    }
    if (a.title || delete a.title, i !== void 0) {
      let l = i;
      (u = (o = a.encode) == null ? void 0 : o.labels) != null && u.update && Q(a.encode.labels.update.text) && (l = ho(i, "datum.label", a.encode.labels.update.text.signal)), Dge(a, "labels", "text", { signal: l });
    }
    return a;
  }
}
function Lge(e) {
  return Al(e) || J3(e) ? Pge(e) : $N(e);
}
function Pge(e) {
  return e.children.reduce((t, n) => t.concat(n.assembleProjections()), $N(e));
}
function $N(e) {
  const t = e.component.projection;
  if (!t || t.merged)
    return [];
  const n = t.combine(), { name: i } = n;
  if (t.data) {
    const r = {
      signal: `[${t.size.map((s) => s.signal).join(", ")}]`
    }, a = t.data.reduce((s, o) => {
      const u = Q(o) ? o.signal : `data('${e.lookupDataSource(o)}')`;
      return pe(s, u) || s.push(u), s;
    }, []);
    if (a.length <= 0)
      throw new Error("Projection's fit didn't find any data sources");
    return [
      {
        name: i,
        size: r,
        fit: {
          signal: a.length > 1 ? `[${a.join(", ")}]` : a[0]
        },
        ...n
      }
    ];
  } else
    return [
      {
        name: i,
        translate: { signal: "[width / 2, height / 2]" },
        // parameters, overwrite default translate if specified
        ...n
      }
    ];
}
const zge = [
  "type",
  "clipAngle",
  "clipExtent",
  "center",
  "rotate",
  "precision",
  "reflectX",
  "reflectY",
  "coefficient",
  "distance",
  "fraction",
  "lobes",
  "parallel",
  "radius",
  "ratio",
  "spacing",
  "tilt"
];
class wN extends ca {
  constructor(t, n, i, r) {
    super(
      { ...n },
      // all explicit properties of projection
      { name: t }
      // name as initial implicit property
    ), this.specifiedProjection = n, this.size = i, this.data = r, this.merged = !1;
  }
  /**
   * Whether the projection parameters should fit provided data.
   */
  get isFit() {
    return !!this.data;
  }
}
function EN(e) {
  e.component.projection = We(e) ? Ige(e) : Uge(e);
}
function Ige(e) {
  if (e.hasProjection) {
    const t = hn(e.specifiedProjection), n = !(t && (t.scale != null || t.translate != null)), i = n ? [e.getSizeSignalRef("width"), e.getSizeSignalRef("height")] : void 0, r = n ? Bge(e) : void 0, a = new wN(e.projectionName(!0), {
      ...hn(e.config.projection) ?? {},
      ...t ?? {}
    }, i, r);
    return a.get("type") || a.set("type", "equalEarth", !1), a;
  }
}
function Bge(e) {
  const t = [], { encoding: n } = e;
  for (const i of [
    [Ui, ji],
    [ii, qi]
  ])
    (it(n[i[0]]) || it(n[i[1]])) && t.push({
      signal: e.getName(`geojson_${t.length}`)
    });
  return e.channelHasField(En) && e.typedFieldDef(En).type === xl && t.push({
    signal: e.getName(`geojson_${t.length}`)
  }), t.length === 0 && t.push(e.requestDataName(Te.Main)), t;
}
function jge(e, t) {
  const n = PE(zge, (r) => !!(!Y(e.explicit, r) && !Y(t.explicit, r) || Y(e.explicit, r) && Y(t.explicit, r) && // some properties might be signals or objects and require hashing for comparison
  Tn(e.get(r), t.get(r))));
  if (Tn(e.size, t.size)) {
    if (n)
      return e;
    if (Tn(e.explicit, {}))
      return t;
    if (Tn(t.explicit, {}))
      return e;
  }
  return null;
}
function Uge(e) {
  if (e.children.length === 0)
    return;
  let t;
  for (const i of e.children)
    EN(i);
  const n = PE(e.children, (i) => {
    const r = i.component.projection;
    if (r)
      if (t) {
        const a = jge(t, r);
        return a && (t = a), !!a;
      } else
        return t = r, !0;
    else
      return !0;
  });
  if (t && n) {
    const i = e.projectionName(!0), r = new wN(i, t.specifiedProjection, t.size, se(t.data));
    for (const a of e.children) {
      const s = a.component.projection;
      s && (s.isFit && r.data.push(...a.component.projection.data), a.renameProjection(s.get("name"), i), s.merged = !0);
    }
    return r;
  }
}
function qge(e, t, n, i) {
  if (Nd(t, n)) {
    const r = We(e) ? e.axis(n) ?? e.legend(n) ?? {} : {}, a = H(t, { expr: "datum" }), s = H(t, { expr: "datum", binSuffix: "end" });
    return {
      formulaAs: H(t, { binSuffix: "range", forAs: !0 }),
      formula: Rd(a, s, r.format, r.formatType, i)
    };
  }
  return {};
}
function SN(e, t) {
  return `${HR(e)}_${t}`;
}
function Gge(e, t) {
  return {
    signal: e.getName(`${t}_bins`),
    extentSignal: e.getName(`${t}_extent`)
  };
}
function H3(e, t, n) {
  const i = Lm(n, void 0) ?? {}, r = SN(i, t);
  return e.getName(`${r}_bins`);
}
function Wge(e) {
  return "as" in e;
}
function f7(e, t, n) {
  let i, r;
  Wge(e) ? i = V(e.as) ? [e.as, `${e.as}_end`] : [e.as[0], e.as[1]] : i = [H(e, { forAs: !0 }), H(e, { binSuffix: "end", forAs: !0 })];
  const a = { ...Lm(t, void 0) }, s = SN(a, e.field), { signal: o, extentSignal: u } = Gge(n, s);
  if (Am(a.extent)) {
    const c = a.extent;
    r = nN(n, c.param, c), delete a.extent;
  }
  const l = {
    bin: a,
    field: e.field,
    as: [i],
    ...o ? { signal: o } : {},
    ...u ? { extentSignal: u } : {},
    ...r ? { span: r } : {}
  };
  return { key: s, binComponent: l };
}
class lr extends Ae {
  clone() {
    return new lr(null, se(this.bins));
  }
  constructor(t, n) {
    super(t), this.bins = n;
  }
  static makeFromEncoding(t, n) {
    const i = n.reduceFieldDef((r, a, s) => {
      if (sn(a) && De(a.bin)) {
        const { key: o, binComponent: u } = f7(a, a.bin, n);
        r[o] = {
          ...u,
          ...r[o],
          ...qge(n, a, s, n.config)
        };
      }
      return r;
    }, {});
    return ke(i) ? null : new lr(t, i);
  }
  /**
   * Creates a bin node from BinTransform.
   * The optional parameter should provide
   */
  static makeFromTransform(t, n, i) {
    const { key: r, binComponent: a } = f7(n, n.bin, i);
    return new lr(t, {
      [r]: a
    });
  }
  /**
   * Merge bin nodes. This method either integrates the bin config from the other node
   * or if this node already has a bin config, renames the corresponding signal in the model.
   */
  merge(t, n) {
    for (const i of I(t.bins))
      i in this.bins ? (n(t.bins[i].signal, this.bins[i].signal), this.bins[i].as = rr([...this.bins[i].as, ...t.bins[i].as], he)) : this.bins[i] = t.bins[i];
    for (const i of t.children)
      t.removeChild(i), i.parent = this;
    t.remove();
  }
  producedFields() {
    return new Set(St(this.bins).map((t) => t.as).flat(2));
  }
  dependentFields() {
    return new Set(St(this.bins).map((t) => t.field));
  }
  hash() {
    return `Bin ${he(this.bins)}`;
  }
  assemble() {
    return St(this.bins).flatMap((t) => {
      const n = [], [i, ...r] = t.as, { extent: a, ...s } = t.bin, o = {
        type: "bin",
        field: ni(t.field),
        as: i,
        signal: t.signal,
        ...Am(a) ? { extent: null } : { extent: a },
        ...t.span ? { span: { signal: `span(${t.span})` } } : {},
        ...s
      };
      !a && t.extentSignal && (n.push({
        type: "extent",
        field: ni(t.field),
        signal: t.extentSignal
      }), o.extent = { signal: t.extentSignal }), n.push(o);
      for (const u of r)
        for (let l = 0; l < 2; l++)
          n.push({
            type: "formula",
            expr: H({ field: i[l] }, { expr: "datum" }),
            as: u[l]
          });
      return t.formula && n.push({
        type: "formula",
        expr: t.formula,
        as: t.formulaAs
      }), n;
    });
  }
}
function Hge(e, t, n, i) {
  var a;
  const r = We(i) ? i.encoding[Ar(t)] : void 0;
  if (sn(n) && We(i) && IT(n, r, i.markDef, i.config)) {
    e.add(H(n, {})), e.add(H(n, { suffix: "end" }));
    const { mark: s, markDef: o, config: u } = i, l = Za({ fieldDef: n, markDef: o, config: u });
    vf(s) && l !== 0.5 && Je(t) && (e.add(H(n, { suffix: qm })), e.add(H(n, { suffix: Gm }))), n.bin && Nd(n, t) && e.add(H(n, { binSuffix: "range" }));
  } else if (LR(t)) {
    const s = NR(t);
    e.add(i.getName(s));
  } else
    e.add(H(n));
  return Lo(n) && Lfe((a = n.scale) == null ? void 0 : a.range) && e.add(n.scale.range.field), e;
}
function Vge(e, t) {
  for (const n of I(t)) {
    const i = t[n];
    for (const r of I(i))
      n in e ? e[n][r] = /* @__PURE__ */ new Set([...e[n][r] ?? [], ...i[r]]) : e[n] = { [r]: i[r] };
  }
}
class Ai extends Ae {
  clone() {
    return new Ai(null, new Set(this.dimensions), se(this.measures));
  }
  /**
   * @param dimensions string set for dimensions
   * @param measures dictionary mapping field name => dict of aggregation functions and names to use
   */
  constructor(t, n, i) {
    super(t), this.dimensions = n, this.measures = i;
  }
  get groupBy() {
    return this.dimensions;
  }
  static makeFromEncoding(t, n) {
    let i = !1;
    n.forEachFieldDef((s) => {
      s.aggregate && (i = !0);
    });
    const r = {}, a = /* @__PURE__ */ new Set();
    return !i || (n.forEachFieldDef((s, o) => {
      const { aggregate: u, field: l } = s;
      if (u)
        if (u === "count")
          r["*"] ?? (r["*"] = {}), r["*"].count = /* @__PURE__ */ new Set([H(s, { forAs: !0 })]);
        else {
          if (Kr(u) || gs(u)) {
            const c = Kr(u) ? "argmin" : "argmax", f = u[c];
            r[f] ?? (r[f] = {}), r[f][c] = /* @__PURE__ */ new Set([H({ op: c, field: f }, { forAs: !0 })]);
          } else
            r[l] ?? (r[l] = {}), r[l][u] = /* @__PURE__ */ new Set([H(s, { forAs: !0 })]);
          ua(o) && n.scaleDomain(o) === "unaggregated" && (r[l] ?? (r[l] = {}), r[l].min = /* @__PURE__ */ new Set([H({ field: l, aggregate: "min" }, { forAs: !0 })]), r[l].max = /* @__PURE__ */ new Set([H({ field: l, aggregate: "max" }, { forAs: !0 })]));
        }
      else
        Hge(a, o, s, n);
    }), a.size + I(r).length === 0) ? null : new Ai(t, a, r);
  }
  static makeFromTransform(t, n) {
    const i = /* @__PURE__ */ new Set(), r = {};
    for (const a of n.aggregate) {
      const { op: s, field: o, as: u } = a;
      s && (s === "count" ? (r["*"] ?? (r["*"] = {}), r["*"].count = /* @__PURE__ */ new Set([u || H(a, { forAs: !0 })])) : (r[o] ?? (r[o] = {}), r[o][s] = /* @__PURE__ */ new Set([u || H(a, { forAs: !0 })])));
    }
    for (const a of n.groupby ?? [])
      i.add(a);
    return i.size + I(r).length === 0 ? null : new Ai(t, i, r);
  }
  merge(t) {
    return CR(this.dimensions, t.dimensions) ? (Vge(this.measures, t.measures), !0) : (ofe("different dimensions, cannot merge"), !1);
  }
  addDimensions(t) {
    t.forEach(this.dimensions.add, this.dimensions);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([...this.dimensions, ...I(this.measures)]);
  }
  producedFields() {
    const t = /* @__PURE__ */ new Set();
    for (const n of I(this.measures))
      for (const i of I(this.measures[n])) {
        const r = this.measures[n][i];
        r.size === 0 ? t.add(`${i}_${n}`) : r.forEach(t.add, t);
      }
    return t;
  }
  hash() {
    return `Aggregate ${he({ dimensions: this.dimensions, measures: this.measures })}`;
  }
  assemble() {
    const t = [], n = [], i = [];
    for (const a of I(this.measures))
      for (const s of I(this.measures[a]))
        for (const o of this.measures[a][s])
          i.push(o), t.push(s), n.push(a === "*" ? null : ni(a));
    return {
      type: "aggregate",
      groupby: [...this.dimensions].map(ni),
      ops: t,
      fields: n,
      as: i
    };
  }
}
class El extends Ae {
  /**
   * @param model The facet model.
   * @param name The name that this facet source will have.
   * @param data The source data for this facet data.
   */
  constructor(t, n, i, r) {
    super(t), this.model = n, this.name = i, this.data = r;
    for (const a of Yn) {
      const s = n.facet[a];
      if (s) {
        const { bin: o, sort: u } = s;
        this[a] = {
          name: n.getName(`${a}_domain`),
          fields: [H(s), ...De(o) ? [H(s, { binSuffix: "end" })] : []],
          ...or(u) ? { sortField: u } : R(u) ? { sortIndexField: Wu(s, a) } : {}
        };
      }
    }
    this.childModel = n.child;
  }
  hash() {
    let t = "Facet";
    for (const n of Yn)
      this[n] && (t += ` ${n.charAt(0)}:${he(this[n])}`);
    return t;
  }
  get fields() {
    var n;
    const t = [];
    for (const i of Yn)
      (n = this[i]) != null && n.fields && t.push(...this[i].fields);
    return t;
  }
  dependentFields() {
    const t = new Set(this.fields);
    for (const n of Yn)
      this[n] && (this[n].sortField && t.add(this[n].sortField.field), this[n].sortIndexField && t.add(this[n].sortIndexField));
    return t;
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  /**
   * The name to reference this source is its name.
   */
  getSource() {
    return this.name;
  }
  getChildIndependentFieldsWithStep() {
    const t = {};
    for (const n of kr) {
      const i = this.childModel.component.scales[n];
      if (i && !i.merged) {
        const r = i.get("type"), a = i.get("range");
        if (gt(r) && ms(a)) {
          const s = Ym(this.childModel, n), o = K3(s);
          o ? t[n] = o : q(JE(n));
        }
      }
    }
    return t;
  }
  assembleRowColumnHeaderData(t, n, i) {
    const r = { row: "y", column: "x", facet: void 0 }[t], a = [], s = [], o = [];
    r && i && i[r] && (n ? (a.push(`distinct_${i[r]}`), s.push("max")) : (a.push(i[r]), s.push("distinct")), o.push(`distinct_${i[r]}`));
    const { sortField: u, sortIndexField: l } = this[t];
    if (u) {
      const { op: c = Rm, field: f } = u;
      a.push(f), s.push(c), o.push(H(u, { forAs: !0 }));
    } else
      l && (a.push(l), s.push("max"), o.push(l));
    return {
      name: this[t].name,
      // Use data from the crossed one if it exist
      source: n ?? this.data,
      transform: [
        {
          type: "aggregate",
          groupby: this[t].fields,
          ...a.length ? {
            fields: a,
            ops: s,
            as: o
          } : {}
        }
      ]
    };
  }
  assembleFacetHeaderData(t) {
    var u;
    const { columns: n } = this.model.layout, { layoutHeaders: i } = this.model.component, r = [], a = {};
    for (const l of U3) {
      for (const c of q3) {
        const f = (i[l] && i[l][c]) ?? [];
        for (const d of f)
          if (((u = d.axes) == null ? void 0 : u.length) > 0) {
            a[l] = !0;
            break;
          }
      }
      if (a[l]) {
        const c = `length(data("${this.facet.name}"))`, f = l === "row" ? n ? { signal: `ceil(${c} / ${n})` } : 1 : n ? { signal: `min(${c}, ${n})` } : { signal: c };
        r.push({
          name: `${this.facet.name}_${l}`,
          transform: [
            {
              type: "sequence",
              start: 0,
              stop: f
            }
          ]
        });
      }
    }
    const { row: s, column: o } = a;
    return (s || o) && r.unshift(this.assembleRowColumnHeaderData("facet", null, t)), r;
  }
  assemble() {
    const t = [];
    let n = null;
    const i = this.getChildIndependentFieldsWithStep(), { column: r, row: a, facet: s } = this;
    if (r && a && (i.x || i.y)) {
      n = `cross_${this.column.name}_${this.row.name}`;
      const o = [].concat(i.x ?? [], i.y ?? []), u = o.map(() => "distinct");
      t.push({
        name: n,
        source: this.data,
        transform: [
          {
            type: "aggregate",
            groupby: this.fields,
            fields: o,
            ops: u
          }
        ]
      });
    }
    for (const o of [Gr, qr])
      this[o] && t.push(this.assembleRowColumnHeaderData(o, n, i));
    if (s) {
      const o = this.assembleFacetHeaderData(i);
      o && t.push(...o);
    }
    return t;
  }
}
function d7(e) {
  return e.startsWith("'") && e.endsWith("'") || e.startsWith('"') && e.endsWith('"') ? e.slice(1, -1) : e;
}
function Xge(e, t) {
  const n = BE(e);
  if (t === "number")
    return `toNumber(${n})`;
  if (t === "boolean")
    return `toBoolean(${n})`;
  if (t === "string")
    return `toString(${n})`;
  if (t === "date")
    return `toDate(${n})`;
  if (t === "flatten")
    return n;
  if (t.startsWith("date:")) {
    const i = d7(t.slice(5, t.length));
    return `timeParse(${n},'${i}')`;
  } else if (t.startsWith("utc:")) {
    const i = d7(t.slice(4, t.length));
    return `utcParse(${n},'${i}')`;
  } else
    return q(mce(t)), null;
}
function Yge(e) {
  const t = {};
  return ep(e.filter, (n) => {
    if (yT(n)) {
      let i = null;
      t3(n) ? i = On(n.equal) : i3(n) ? i = On(n.lte) : n3(n) ? i = On(n.lt) : r3(n) ? i = On(n.gt) : a3(n) ? i = On(n.gte) : s3(n) ? i = n.range[0] : o3(n) && (i = (n.oneOf ?? n.in)[0]), i && (Do(i) ? t[n.field] = "date" : ye(i) ? t[n.field] = "number" : V(i) && (t[n.field] = "string")), n.timeUnit && (t[n.field] = "date");
    }
  }), t;
}
function Kge(e) {
  const t = {};
  function n(i) {
    ju(i) ? t[i.field] = "date" : i.type === "quantitative" && Xle(i.aggregate) ? t[i.field] = "number" : Du(i.field) > 1 ? i.field in t || (t[i.field] = "flatten") : Lo(i) && or(i.sort) && Du(i.sort.field) > 1 && (i.sort.field in t || (t[i.sort.field] = "flatten"));
  }
  if ((We(e) || ki(e)) && e.forEachFieldDef((i, r) => {
    if (sn(i))
      n(i);
    else {
      const a = Ro(r), s = e.fieldDef(a);
      n({
        ...i,
        type: s.type
      });
    }
  }), We(e)) {
    const { mark: i, markDef: r, encoding: a } = e;
    if (ys(i) && // No need to sort by dimension if we have a connected scatterplot (order channel is present)
    !e.encoding.order) {
      const s = r.orient === "horizontal" ? "y" : "x", o = a[s];
      j(o) && o.type === "quantitative" && !(o.field in t) && (t[o.field] = "number");
    }
  }
  return t;
}
function Jge(e) {
  const t = {};
  if (We(e) && e.component.selection)
    for (const n of I(e.component.selection)) {
      const i = e.component.selection[n];
      for (const r of i.project.items)
        !r.channel && Du(r.field) > 1 && (t[r.field] = "flatten");
    }
  return t;
}
class Lt extends Ae {
  clone() {
    return new Lt(null, se(this._parse));
  }
  constructor(t, n) {
    super(t), this._parse = n;
  }
  hash() {
    return `Parse ${he(this._parse)}`;
  }
  /**
   * Creates a parse node from a data.format.parse and updates ancestorParse.
   */
  static makeExplicit(t, n, i) {
    var s;
    let r = {};
    const a = n.data;
    return !za(a) && ((s = a == null ? void 0 : a.format) != null && s.parse) && (r = a.format.parse), this.makeWithAncestors(t, r, {}, i);
  }
  /**
   * Creates a parse node from "explicit" parse and "implicit" parse and updates ancestorParse.
   */
  static makeWithAncestors(t, n, i, r) {
    for (const o of I(i)) {
      const u = r.getWithExplicit(o);
      u.value !== void 0 && (u.explicit || u.value === i[o] || u.value === "derived" || i[o] === "flatten" ? delete i[o] : q(w4(o, i[o], u.value)));
    }
    for (const o of I(n)) {
      const u = r.get(o);
      u !== void 0 && (u === n[o] ? delete n[o] : q(w4(o, n[o], u)));
    }
    const a = new ca(n, i);
    r.copyAll(a);
    const s = {};
    for (const o of I(a.combine())) {
      const u = a.get(o);
      u !== null && (s[o] = u);
    }
    return I(s).length === 0 || r.parseNothing ? null : new Lt(t, s);
  }
  get parse() {
    return this._parse;
  }
  merge(t) {
    this._parse = { ...this._parse, ...t.parse }, t.remove();
  }
  /**
   * Assemble an object for Vega's format.parse property.
   */
  assembleFormatParse() {
    const t = {};
    for (const n of I(this._parse)) {
      const i = this._parse[n];
      Du(n) === 1 && (t[n] = i);
    }
    return t;
  }
  // format parse depends and produces all fields in its parse
  producedFields() {
    return new Set(I(this._parse));
  }
  dependentFields() {
    return new Set(I(this._parse));
  }
  assembleTransforms(t = !1) {
    return I(this._parse).filter((n) => t ? Du(n) > 1 : !0).map((n) => {
      const i = Xge(n, this._parse[n]);
      return i ? {
        type: "formula",
        expr: i,
        as: jE(n)
        // Vega output is always flattened
      } : null;
    }).filter((n) => n !== null);
  }
}
class is extends Ae {
  clone() {
    return new is(null);
  }
  constructor(t) {
    super(t);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set([Ri]);
  }
  hash() {
    return "Identifier";
  }
  assemble() {
    return { type: "identifier", as: Ri };
  }
}
class zd extends Ae {
  clone() {
    return new zd(null, this.params);
  }
  constructor(t, n) {
    super(t), this.params = n;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
  }
  hash() {
    return `Graticule ${he(this.params)}`;
  }
  assemble() {
    return {
      type: "graticule",
      ...this.params === !0 ? {} : this.params
    };
  }
}
class Id extends Ae {
  clone() {
    return new Id(null, this.params);
  }
  constructor(t, n) {
    super(t), this.params = n;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.params.as ?? "data"]);
  }
  hash() {
    return `Hash ${he(this.params)}`;
  }
  assemble() {
    return {
      type: "sequence",
      ...this.params
    };
  }
}
class $o extends Ae {
  constructor(t) {
    super(null), t ?? (t = { name: "source" });
    let n;
    if (za(t) || (n = t.format ? { ...mn(t.format, ["parse"]) } : {}), xf(t))
      this._data = { values: t.values };
    else if (Uu(t)) {
      if (this._data = { url: t.url }, !n.type) {
        let i = /(?:\.([^.]+))?$/.exec(t.url)[1];
        pe(["json", "csv", "tsv", "dsv", "topojson"], i) || (i = "json"), n.type = i;
      }
    } else
      RD(t) ? this._data = { values: [{ type: "Sphere" }] } : (MD(t) || za(t)) && (this._data = {});
    this._generator = za(t), t.name && (this._name = t.name), n && !ke(n) && (this._data.format = n);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
  }
  get data() {
    return this._data;
  }
  hasName() {
    return !!this._name;
  }
  get isGenerator() {
    return this._generator;
  }
  get dataName() {
    return this._name;
  }
  set dataName(t) {
    this._name = t;
  }
  set parent(t) {
    throw new Error("Source nodes have to be roots.");
  }
  remove() {
    throw new Error("Source nodes are roots and cannot be removed.");
  }
  hash() {
    throw new Error("Cannot hash sources");
  }
  assemble() {
    return {
      name: this._name,
      ...this._data,
      transform: []
    };
  }
}
var h7 = function(e, t, n, i, r) {
  if (i === "m")
    throw new TypeError("Private method is not writable");
  if (i === "a" && !r)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof t == "function" ? e !== t || !r : !t.has(e))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return i === "a" ? r.call(e, n) : r ? r.value = n : t.set(e, n), n;
}, Qge = function(e, t, n, i) {
  if (n === "a" && !i)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof t == "function" ? e !== t || !i : !t.has(e))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return n === "m" ? i : n === "a" ? i.call(e) : i ? i.value : t.get(e);
}, bc;
function V3(e) {
  return e instanceof $o || e instanceof zd || e instanceof Id;
}
class X3 {
  constructor() {
    bc.set(this, void 0), h7(this, bc, !1, "f");
  }
  // Once true, #modified is never set to false
  setModified() {
    h7(this, bc, !0, "f");
  }
  get modifiedFlag() {
    return Qge(this, bc, "f");
  }
}
bc = /* @__PURE__ */ new WeakMap();
class Po extends X3 {
  /**
   * Compute a map of node depths that we can use to determine a topological sort order.
   */
  getNodeDepths(t, n, i) {
    i.set(t, n);
    for (const r of t.children)
      this.getNodeDepths(r, n + 1, i);
    return i;
  }
  /**
   * Run the optimizer on all nodes starting from the leaves.
   */
  optimize(t) {
    const i = [...this.getNodeDepths(t, 0, /* @__PURE__ */ new Map()).entries()].sort((r, a) => a[1] - r[1]);
    for (const r of i)
      this.run(r[0]);
    return this.modifiedFlag;
  }
}
class Y3 extends X3 {
  /**
   * Run the optimizer depth first on all nodes starting from the roots.
   */
  optimize(t) {
    this.run(t);
    for (const n of t.children)
      this.optimize(n);
    return this.modifiedFlag;
  }
}
class Zge extends Y3 {
  mergeNodes(t, n) {
    const i = n.shift();
    for (const r of n)
      t.removeChild(r), r.parent = i, r.remove();
  }
  run(t) {
    const n = t.children.map((r) => r.hash()), i = {};
    for (let r = 0; r < n.length; r++)
      i[n[r]] === void 0 ? i[n[r]] = [t.children[r]] : i[n[r]].push(t.children[r]);
    for (const r of I(i))
      i[r].length > 1 && (this.setModified(), this.mergeNodes(t, i[r]));
  }
}
class e0e extends Y3 {
  constructor(t) {
    super(), this.requiresSelectionId = t && j3(t);
  }
  run(t) {
    t instanceof is && (this.requiresSelectionId && (V3(t.parent) || t.parent instanceof Ai || t.parent instanceof Lt) || (this.setModified(), t.remove()));
  }
}
class t0e extends X3 {
  optimize(t) {
    return this.run(t, /* @__PURE__ */ new Set()), this.modifiedFlag;
  }
  run(t, n) {
    let i = /* @__PURE__ */ new Set();
    t instanceof ur && (i = t.producedFields(), zE(i, n) && (this.setModified(), t.removeFormulas(n), t.producedFields.length === 0 && t.remove()));
    for (const r of t.children)
      this.run(r, /* @__PURE__ */ new Set([...n, ...i]));
  }
}
class n0e extends Y3 {
  constructor() {
    super();
  }
  run(t) {
    t instanceof tn && !t.isRequired() && (this.setModified(), t.remove());
  }
}
class i0e extends Po {
  run(t) {
    if (!V3(t) && !(t.numChildren() > 1)) {
      for (const n of t.children)
        if (n instanceof Lt)
          if (t instanceof Lt)
            this.setModified(), t.merge(n);
          else {
            if (IE(t.producedFields(), n.dependentFields()))
              continue;
            this.setModified(), n.swapWithParent();
          }
    }
  }
}
class r0e extends Po {
  run(t) {
    const n = [...t.children], i = t.children.filter((r) => r instanceof Lt);
    if (t.numChildren() > 1 && i.length >= 1) {
      const r = {}, a = /* @__PURE__ */ new Set();
      for (const s of i) {
        const o = s.parse;
        for (const u of I(o))
          u in r ? r[u] !== o[u] && a.add(u) : r[u] = o[u];
      }
      for (const s of a)
        delete r[s];
      if (!ke(r)) {
        this.setModified();
        const s = new Lt(t, r);
        for (const o of n) {
          if (o instanceof Lt)
            for (const u of I(r))
              delete o.parse[u];
          t.removeChild(o), o.parent = s, o instanceof Lt && I(o.parse).length === 0 && o.remove();
        }
      }
    }
  }
}
class a0e extends Po {
  run(t) {
    t instanceof tn || t.numChildren() > 0 || t instanceof El || t instanceof $o || (this.setModified(), t.remove());
  }
}
class s0e extends Po {
  run(t) {
    const n = t.children.filter((r) => r instanceof ur), i = n.pop();
    for (const r of n)
      this.setModified(), i.merge(r);
  }
}
class o0e extends Po {
  run(t) {
    const n = t.children.filter((r) => r instanceof Ai), i = {};
    for (const r of n) {
      const a = he(r.groupBy);
      a in i || (i[a] = []), i[a].push(r);
    }
    for (const r of I(i)) {
      const a = i[r];
      if (a.length > 1) {
        const s = a.pop();
        for (const o of a)
          s.merge(o) && (t.removeChild(o), o.parent = s, o.remove(), this.setModified());
      }
    }
  }
}
class u0e extends Po {
  constructor(t) {
    super(), this.model = t;
  }
  run(t) {
    const n = !(V3(t) || t instanceof wl || t instanceof Lt || t instanceof is), i = [], r = [];
    for (const a of t.children)
      a instanceof lr && (n && !IE(t.producedFields(), a.dependentFields()) ? i.push(a) : r.push(a));
    if (i.length > 0) {
      const a = i.pop();
      for (const s of i)
        a.merge(s, this.model.renameSignal.bind(this.model));
      this.setModified(), t instanceof lr ? t.merge(a, this.model.renameSignal.bind(this.model)) : a.swapWithParent();
    }
    if (r.length > 1) {
      const a = r.pop();
      for (const s of r)
        a.merge(s, this.model.renameSignal.bind(this.model));
      this.setModified();
    }
  }
}
class l0e extends Po {
  run(t) {
    const n = [...t.children];
    if (!fo(n, (s) => s instanceof tn) || t.numChildren() <= 1)
      return;
    const r = [];
    let a;
    for (const s of n)
      if (s instanceof tn) {
        let o = s;
        for (; o.numChildren() === 1; ) {
          const [u] = o.children;
          if (u instanceof tn)
            o = u;
          else
            break;
        }
        r.push(...o.children), a ? (t.removeChild(s), s.parent = a.parent, a.parent.removeChild(a), a.parent = o, this.setModified()) : a = o;
      } else
        r.push(s);
    if (r.length) {
      this.setModified();
      for (const s of r)
        s.parent.removeChild(s), s.parent = a;
    }
  }
}
class zo extends Ae {
  clone() {
    return new zo(null, se(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  addDimensions(t) {
    this.transform.groupby = rr(this.transform.groupby.concat(t), (n) => n);
  }
  dependentFields() {
    const t = /* @__PURE__ */ new Set();
    return this.transform.groupby && this.transform.groupby.forEach(t.add, t), this.transform.joinaggregate.map((n) => n.field).filter((n) => n !== void 0).forEach(t.add, t), t;
  }
  producedFields() {
    return new Set(this.transform.joinaggregate.map(this.getDefaultName));
  }
  getDefaultName(t) {
    return t.as ?? H(t);
  }
  hash() {
    return `JoinAggregateTransform ${he(this.transform)}`;
  }
  assemble() {
    const t = [], n = [], i = [];
    for (const a of this.transform.joinaggregate)
      n.push(a.op), i.push(this.getDefaultName(a)), t.push(a.field === void 0 ? null : a.field);
    const r = this.transform.groupby;
    return {
      type: "joinaggregate",
      as: i,
      ops: n,
      fields: t,
      ...r !== void 0 ? { groupby: r } : {}
    };
  }
}
function c0e(e) {
  return e.stack.stackBy.reduce((t, n) => {
    const i = n.fieldDef, r = H(i);
    return r && t.push(r), t;
  }, []);
}
function f0e(e) {
  return R(e) && e.every((t) => V(t)) && e.length > 1;
}
class Hr extends Ae {
  clone() {
    return new Hr(null, se(this._stack));
  }
  constructor(t, n) {
    super(t), this._stack = n;
  }
  static makeFromTransform(t, n) {
    const { stack: i, groupby: r, as: a, offset: s = "zero" } = n, o = [], u = [];
    if (n.sort !== void 0)
      for (const f of n.sort)
        o.push(f.field), u.push(Ke(f.order, "ascending"));
    const l = {
      field: o,
      order: u
    };
    let c;
    return f0e(a) ? c = a : V(a) ? c = [a, `${a}_end`] : c = [`${n.stack}_start`, `${n.stack}_end`], new Hr(t, {
      dimensionFieldDefs: [],
      stackField: i,
      groupby: r,
      offset: s,
      sort: l,
      facetby: [],
      as: c
    });
  }
  static makeFromEncoding(t, n) {
    const i = n.stack, { encoding: r } = n;
    if (!i)
      return null;
    const { groupbyChannels: a, fieldChannel: s, offset: o, impute: u } = i, l = a.map((h) => {
      const p = r[h];
      return gr(p);
    }).filter((h) => !!h), c = c0e(n), f = n.encoding.order;
    let d;
    if (R(f) || j(f))
      d = JR(f);
    else {
      const h = BT(f) ? f.sort : s === "y" ? "descending" : "ascending";
      d = c.reduce((p, g) => (p.field.push(g), p.order.push(h), p), { field: [], order: [] });
    }
    return new Hr(t, {
      dimensionFieldDefs: l,
      stackField: n.vgField(s),
      facetby: [],
      stackby: c,
      sort: d,
      offset: o,
      impute: u,
      as: [
        n.vgField(s, { suffix: "start", forAs: !0 }),
        n.vgField(s, { suffix: "end", forAs: !0 })
      ]
    });
  }
  get stack() {
    return this._stack;
  }
  addDimensions(t) {
    this._stack.facetby.push(...t);
  }
  dependentFields() {
    const t = /* @__PURE__ */ new Set();
    return t.add(this._stack.stackField), this.getGroupbyFields().forEach(t.add, t), this._stack.facetby.forEach(t.add, t), this._stack.sort.field.forEach(t.add, t), t;
  }
  producedFields() {
    return new Set(this._stack.as);
  }
  hash() {
    return `Stack ${he(this._stack)}`;
  }
  getGroupbyFields() {
    const { dimensionFieldDefs: t, impute: n, groupby: i } = this._stack;
    return t.length > 0 ? t.map((r) => r.bin ? n ? [H(r, { binSuffix: "mid" })] : [
      // For binned group by field without impute, we need both bin (start) and bin_end
      H(r, {}),
      H(r, { binSuffix: "end" })
    ] : [H(r)]).flat() : i ?? [];
  }
  assemble() {
    const t = [], { facetby: n, dimensionFieldDefs: i, stackField: r, stackby: a, sort: s, offset: o, impute: u, as: l } = this._stack;
    if (u)
      for (const c of i) {
        const { bandPosition: f = 0.5, bin: d } = c;
        if (d) {
          const h = H(c, { expr: "datum" }), p = H(c, { expr: "datum", binSuffix: "end" });
          t.push({
            type: "formula",
            expr: `${f}*${h}+${1 - f}*${p}`,
            as: H(c, { binSuffix: "mid", forAs: !0 })
          });
        }
        t.push({
          type: "impute",
          field: r,
          groupby: [...a, ...n],
          key: H(c, { binSuffix: "mid" }),
          method: "value",
          value: 0
        });
      }
    return t.push({
      type: "stack",
      groupby: [...this.getGroupbyFields(), ...n],
      field: r,
      sort: s,
      as: l,
      offset: o
    }), t;
  }
}
class Sl extends Ae {
  clone() {
    return new Sl(null, se(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  addDimensions(t) {
    this.transform.groupby = rr(this.transform.groupby.concat(t), (n) => n);
  }
  dependentFields() {
    const t = /* @__PURE__ */ new Set();
    return (this.transform.groupby ?? []).forEach(t.add, t), (this.transform.sort ?? []).forEach((n) => t.add(n.field)), this.transform.window.map((n) => n.field).filter((n) => n !== void 0).forEach(t.add, t), t;
  }
  producedFields() {
    return new Set(this.transform.window.map(this.getDefaultName));
  }
  getDefaultName(t) {
    return t.as ?? H(t);
  }
  hash() {
    return `WindowTransform ${he(this.transform)}`;
  }
  assemble() {
    const t = [], n = [], i = [], r = [];
    for (const f of this.transform.window)
      n.push(f.op), i.push(this.getDefaultName(f)), r.push(f.param === void 0 ? null : f.param), t.push(f.field === void 0 ? null : f.field);
    const a = this.transform.frame, s = this.transform.groupby;
    if (a && a[0] === null && a[1] === null && n.every((f) => YE(f)))
      return {
        type: "joinaggregate",
        as: i,
        ops: n,
        fields: t,
        ...s !== void 0 ? { groupby: s } : {}
      };
    const o = [], u = [];
    if (this.transform.sort !== void 0)
      for (const f of this.transform.sort)
        o.push(f.field), u.push(f.order ?? "ascending");
    const l = {
      field: o,
      order: u
    }, c = this.transform.ignorePeers;
    return {
      type: "window",
      params: r,
      as: i,
      ops: n,
      fields: t,
      sort: l,
      ...c !== void 0 ? { ignorePeers: c } : {},
      ...s !== void 0 ? { groupby: s } : {},
      ...a !== void 0 ? { frame: a } : {}
    };
  }
}
function d0e(e) {
  function t(n) {
    if (!(n instanceof El)) {
      const i = n.clone();
      if (i instanceof tn) {
        const r = Gv + i.getSource();
        i.setSource(r), e.model.component.data.outputNodes[r] = i;
      } else
        (i instanceof Ai || i instanceof Hr || i instanceof Sl || i instanceof zo) && i.addDimensions(e.fields);
      for (const r of n.children.flatMap(t))
        r.parent = i;
      return [i];
    }
    return n.children.flatMap(t);
  }
  return t;
}
function qv(e) {
  if (e instanceof El)
    if (e.numChildren() === 1 && !(e.children[0] instanceof tn)) {
      const t = e.children[0];
      (t instanceof Ai || t instanceof Hr || t instanceof Sl || t instanceof zo) && t.addDimensions(e.fields), t.swapWithParent(), qv(e);
    } else {
      const t = e.model.component.data.main;
      AN(t);
      const n = d0e(e), i = e.children.map(n).flat();
      for (const r of i)
        r.parent = t;
    }
  else
    e.children.map(qv);
}
function AN(e) {
  if (e instanceof tn && e.type === Te.Main && e.numChildren() === 1) {
    const t = e.children[0];
    t instanceof El || (t.swapWithParent(), AN(e));
  }
}
const Gv = "scale_", mh = 5;
function Wv(e) {
  for (const t of e) {
    for (const n of t.children)
      if (n.parent !== t)
        return !1;
    if (!Wv(t.children))
      return !1;
  }
  return !0;
}
function oi(e, t) {
  let n = !1;
  for (const i of t)
    n = e.optimize(i) || n;
  return n;
}
function p7(e, t, n) {
  let i = e.sources, r = !1;
  return r = oi(new n0e(), i) || r, r = oi(new e0e(t), i) || r, i = i.filter((a) => a.numChildren() > 0), r = oi(new a0e(), i) || r, i = i.filter((a) => a.numChildren() > 0), n || (r = oi(new i0e(), i) || r, r = oi(new u0e(t), i) || r, r = oi(new t0e(), i) || r, r = oi(new r0e(), i) || r, r = oi(new o0e(), i) || r, r = oi(new s0e(), i) || r, r = oi(new Zge(), i) || r, r = oi(new l0e(), i) || r), e.sources = i, r;
}
function h0e(e, t) {
  Wv(e.sources);
  let n = 0, i = 0;
  for (let r = 0; r < mh && p7(e, t, !0); r++)
    n++;
  e.sources.map(qv);
  for (let r = 0; r < mh && p7(e, t, !1); r++)
    i++;
  Wv(e.sources), Math.max(n, i) === mh && q(`Maximum optimization runs(${mh}) reached.`);
}
class lt {
  constructor(t) {
    Object.defineProperty(this, "signal", {
      enumerable: !0,
      get: t
    });
  }
  static fromName(t, n) {
    return new lt(() => t(n));
  }
}
function kN(e) {
  We(e) ? p0e(e) : g0e(e);
}
function p0e(e) {
  const t = e.component.scales;
  for (const n of I(t)) {
    const i = y0e(e, n);
    if (t[n].setWithExplicit("domains", i), v0e(e, n), e.component.data.isFaceted) {
      let a = e;
      for (; !ki(a) && a.parent; )
        a = a.parent;
      if (a.component.resolve.scale[n] === "shared")
        for (const o of i.value)
          jr(o) && (o.data = Gv + o.data.replace(Gv, ""));
    }
  }
}
function g0e(e) {
  for (const n of e.children)
    kN(n);
  const t = e.component.scales;
  for (const n of I(t)) {
    let i, r = null;
    for (const a of e.children) {
      const s = a.component.scales[n];
      if (s) {
        i === void 0 ? i = s.getWithExplicit("domains") : i = es(i, s.getWithExplicit("domains"), "domains", "scale", Hv);
        const o = s.get("selectionExtent");
        r && o && r.param !== o.param && q(dce), r = o;
      }
    }
    t[n].setWithExplicit("domains", i), r && t[n].set("selectionExtent", r, !0);
  }
}
function m0e(e, t, n, i) {
  if (e === "unaggregated") {
    const { valid: r, reason: a } = g7(t, n);
    if (!r) {
      q(a);
      return;
    }
  } else if (e === void 0 && i.useUnaggregatedDomain) {
    const { valid: r } = g7(t, n);
    if (r)
      return "unaggregated";
  }
  return e;
}
function y0e(e, t) {
  const n = e.getScaleComponent(t).get("type"), { encoding: i } = e, r = m0e(e.scaleDomain(t), e.typedFieldDef(t), n, e.config.scale);
  return r !== e.scaleDomain(t) && (e.specifiedScales[t] = {
    ...e.specifiedScales[t],
    domain: r
  }), t === "x" && it(i.x2) ? it(i.x) ? es(ga(n, r, e, "x"), ga(n, r, e, "x2"), "domain", "scale", Hv) : ga(n, r, e, "x2") : t === "y" && it(i.y2) ? it(i.y) ? es(ga(n, r, e, "y"), ga(n, r, e, "y2"), "domain", "scale", Hv) : ga(n, r, e, "y2") : ga(n, r, e, t);
}
function b0e(e, t, n) {
  return e.map((i) => ({ signal: `{data: ${Pm(i, { timeUnit: n, type: t })}}` }));
}
function xy(e, t, n) {
  var r;
  const i = (r = pt(n)) == null ? void 0 : r.unit;
  return t === "temporal" || i ? b0e(e, t, i) : [e];
}
function ga(e, t, n, i) {
  const { encoding: r, markDef: a, mark: s, config: o, stack: u } = n, l = it(r[i]), { type: c } = l, f = l.timeUnit;
  if (Nfe(t)) {
    const p = ga(e, void 0, n, i), g = xy(t.unionWith, c, f);
    return Ki([...g, ...p.value]);
  } else {
    if (Q(t))
      return Ki([t]);
    if (t && t !== "unaggregated" && !ST(t))
      return Ki(xy(t, c, f));
  }
  if (u && i === u.fieldChannel) {
    if (u.offset === "normalize")
      return Cn([[0, 1]]);
    const p = n.requestDataName(Te.Main);
    return Cn([
      {
        data: p,
        field: n.vgField(i, { suffix: "start" })
      },
      {
        data: p,
        field: n.vgField(i, { suffix: "end" })
      }
    ]);
  }
  const d = ua(i) && j(l) ? x0e(n, i, e) : void 0;
  if (Cr(l)) {
    const p = xy([l.datum], c, f);
    return Cn(p);
  }
  const h = l;
  if (t === "unaggregated") {
    const p = n.requestDataName(Te.Main), { field: g } = l;
    return Cn([
      {
        data: p,
        field: H({ field: g, aggregate: "min" })
      },
      {
        data: p,
        field: H({ field: g, aggregate: "max" })
      }
    ]);
  } else if (De(h.bin)) {
    if (gt(e))
      return Cn(e === "bin-ordinal" ? [] : [
        {
          // If sort by aggregation of a specified sort field, we need to use RAW table,
          // so we can aggregate values for the scale independently from the main aggregation.
          data: yf(d) ? n.requestDataName(Te.Main) : n.requestDataName(Te.Raw),
          // Use range if we added it and the scale does not support computing a range as a signal.
          field: n.vgField(i, Nd(h, i) ? { binSuffix: "range" } : {}),
          // we have to use a sort object if sort = true to make the sort correct by bin start
          sort: d === !0 || !X(d) ? {
            field: n.vgField(i, {}),
            op: "min"
            // min or max doesn't matter since we sort by the start of the bin range
          } : d
        }
      ]);
    {
      const { bin: p } = h;
      if (De(p)) {
        const g = H3(n, h.field, p);
        return Cn([
          new lt(() => {
            const m = n.getSignalName(g);
            return `[${m}.start, ${m}.stop]`;
          })
        ]);
      } else
        return Cn([
          {
            data: n.requestDataName(Te.Main),
            field: n.vgField(i, {})
          }
        ]);
    }
  } else if (h.timeUnit && pe(["time", "utc"], e)) {
    const p = r[Ar(i)];
    if (IT(h, p, a, o)) {
      const g = n.requestDataName(Te.Main), m = Za({ fieldDef: h, fieldDef2: p, markDef: a, config: o }), y = vf(s) && m !== 0.5 && Je(i);
      return Cn([
        {
          data: g,
          field: n.vgField(i, y ? { suffix: qm } : {})
        },
        {
          data: g,
          field: n.vgField(i, { suffix: y ? Gm : "end" })
        }
      ]);
    }
  }
  return Cn(d ? [
    {
      // If sort by aggregation of a specified sort field, we need to use RAW table,
      // so we can aggregate values for the scale independently from the main aggregation.
      data: yf(d) ? n.requestDataName(Te.Main) : n.requestDataName(Te.Raw),
      field: n.vgField(i),
      sort: d
    }
  ] : [
    {
      data: n.requestDataName(Te.Main),
      field: n.vgField(i)
    }
  ]);
}
function $y(e, t) {
  const { op: n, field: i, order: r } = e;
  return {
    // Apply default op
    op: n ?? (t ? "sum" : Rm),
    // flatten nested fields
    ...i ? { field: ni(i) } : {},
    ...r ? { order: r } : {}
  };
}
function v0e(e, t) {
  var o;
  const n = e.component.scales[t], i = e.specifiedScales[t].domain, r = (o = e.fieldDef(t)) == null ? void 0 : o.bin, a = ST(i) && i, s = To(r) && Am(r.extent) && r.extent;
  (a || s) && n.set("selectionExtent", a ?? s, !0);
}
function x0e(e, t, n) {
  if (!gt(n))
    return;
  const i = e.fieldDef(t), r = i.sort;
  if (PT(r))
    return {
      op: "min",
      field: Wu(i, t),
      order: "ascending"
    };
  const { stack: a } = e, s = a ? /* @__PURE__ */ new Set([...a.groupbyFields, ...a.stackBy.map((o) => o.fieldDef.field)]) : void 0;
  if (or(r)) {
    const o = a && !s.has(r.field);
    return $y(r, o);
  } else if (LT(r)) {
    const { encoding: o, order: u } = r, l = e.fieldDef(o), { aggregate: c, field: f } = l, d = a && !s.has(f);
    if (Kr(c) || gs(c))
      return $y({
        field: H(l),
        order: u
      }, d);
    if (YE(c) || !c)
      return $y({
        op: c,
        field: f,
        order: u
      }, d);
  } else {
    if (r === "descending")
      return {
        op: "min",
        field: e.vgField(t),
        order: "descending"
      };
    if (pe([
      "ascending",
      void 0
      /* default =ascending*/
    ], r))
      return !0;
  }
}
function g7(e, t) {
  const { aggregate: n, type: i } = e;
  return n ? V(n) && !Kle.has(n) ? {
    valid: !1,
    reason: zce(n)
  } : i === "quantitative" && t === "log" ? {
    valid: !1,
    reason: Ice(e)
  } : { valid: !0 } : {
    valid: !1,
    reason: Pce(e)
  };
}
function Hv(e, t, n, i) {
  return e.explicit && t.explicit && q(Gce(n, i, e.value, t.value)), { explicit: e.explicit, value: [...e.value, ...t.value] };
}
function $0e(e) {
  const t = rr(e.map((s) => {
    if (jr(s)) {
      const { sort: o, ...u } = s;
      return u;
    }
    return s;
  }), he), n = rr(e.map((s) => {
    if (jr(s)) {
      const o = s.sort;
      return o !== void 0 && !yf(o) && ("op" in o && o.op === "count" && delete o.field, o.order === "ascending" && delete o.order), o;
    }
  }).filter((s) => s !== void 0), he);
  if (t.length === 0)
    return;
  if (t.length === 1) {
    const s = e[0];
    if (jr(s) && n.length > 0) {
      let o = n[0];
      if (n.length > 1) {
        q(S4);
        const u = n.filter((l) => X(l) && "op" in l && l.op !== "min");
        n.every((l) => X(l) && "op" in l) && u.length === 1 ? o = u[0] : o = !0;
      } else if (X(o) && "field" in o) {
        const u = o.field;
        s.field === u && (o = o.order ? { order: o.order } : !0);
      }
      return {
        ...s,
        sort: o
      };
    }
    return s;
  }
  const i = rr(n.map((s) => yf(s) || !("op" in s) || V(s.op) && s.op in Hle ? s : (q(Hce(s)), !0)), he);
  let r;
  i.length === 1 ? r = i[0] : i.length > 1 && (q(S4), r = !0);
  const a = rr(e.map((s) => jr(s) ? s.data : null), (s) => s);
  return a.length === 1 && a[0] !== null ? {
    data: a[0],
    fields: t.map((o) => o.field),
    ...r ? { sort: r } : {}
  } : { fields: t, ...r ? { sort: r } : {} };
}
function K3(e) {
  if (jr(e) && V(e.field))
    return e.field;
  if (Jle(e)) {
    let t;
    for (const n of e.fields)
      if (jr(n) && V(n.field)) {
        if (!t)
          t = n.field;
        else if (t !== n.field)
          return q(Vce), t;
      }
    return q(Xce), t;
  } else if (Qle(e)) {
    q(Yce);
    const t = e.fields[0];
    return V(t) ? t : void 0;
  }
}
function Ym(e, t) {
  const i = e.component.scales[t].get("domains").map((r) => (jr(r) && (r.data = e.lookupDataSource(r.data)), r));
  return $0e(i);
}
function CN(e) {
  return Al(e) || J3(e) ? e.children.reduce((t, n) => t.concat(CN(n)), m7(e)) : m7(e);
}
function m7(e) {
  return I(e.component.scales).reduce((t, n) => {
    const i = e.component.scales[n];
    if (i.merged)
      return t;
    const r = i.combine(), { name: a, type: s, selectionExtent: o, domains: u, range: l, reverse: c, ...f } = r, d = w0e(r.range, a, n, e), h = Ym(e, n), p = o ? mpe(e, o, i, h) : null;
    return t.push({
      name: a,
      type: s,
      ...h ? { domain: h } : {},
      ...p ? { domainRaw: p } : {},
      range: d,
      ...c !== void 0 ? { reverse: c } : {},
      ...f
    }), t;
  }, []);
}
function w0e(e, t, n, i) {
  if (Je(n)) {
    if (ms(e))
      return {
        step: { signal: `${t}_step` }
      };
  } else if (X(e) && jr(e))
    return {
      ...e,
      data: i.lookupDataSource(e.data)
    };
  return e;
}
class _N extends ca {
  constructor(t, n) {
    super(
      {},
      // no initial explicit property
      { name: t }
      // name as initial implicit property
    ), this.merged = !1, this.setWithExplicit("type", n);
  }
  /**
   * Whether the scale definitely includes zero in the domain
   */
  domainDefinitelyIncludesZero() {
    return this.get("zero") !== !1 ? !0 : fo(this.get("domains"), (t) => R(t) && t.length === 2 && ye(t[0]) && t[0] <= 0 && ye(t[1]) && t[1] >= 0);
  }
}
const E0e = ["range", "scheme"];
function S0e(e) {
  const t = e.component.scales;
  for (const n of Sm) {
    const i = t[n];
    if (!i)
      continue;
    const r = A0e(n, e);
    i.setWithExplicit("range", r);
  }
}
function y7(e, t) {
  const n = e.fieldDef(t);
  if (n != null && n.bin) {
    const { bin: i, field: r } = n, a = Sn(t), s = e.getName(a);
    if (X(i) && i.binned && i.step !== void 0)
      return new lt(() => {
        const o = e.scaleName(t), u = `(domain("${o}")[1] - domain("${o}")[0]) / ${i.step}`;
        return `${e.getSignalName(s)} / (${u})`;
      });
    if (De(i)) {
      const o = H3(e, r, i);
      return new lt(() => {
        const u = e.getSignalName(o), l = `(${u}.stop - ${u}.start) / ${u}.step`;
        return `${e.getSignalName(s)} / (${l})`;
      });
    }
  }
}
function A0e(e, t) {
  const n = t.specifiedScales[e], { size: i } = t, a = t.getScaleComponent(e).get("type");
  for (const f of E0e)
    if (n[f] !== void 0) {
      const d = Mv(a, f), h = AT(e, f);
      if (!d)
        q(rT(a, f, e));
      else if (h)
        q(h);
      else
        switch (f) {
          case "range": {
            const p = n.range;
            if (R(p)) {
              if (Je(e))
                return Ki(p.map((g) => {
                  if (g === "width" || g === "height") {
                    const m = t.getName(g), y = t.getSignalName.bind(t);
                    return lt.fromName(y, m);
                  }
                  return g;
                }));
            } else if (X(p))
              return Ki({
                data: t.requestDataName(Te.Main),
                field: p.field,
                sort: { op: "min", field: t.vgField(e) }
              });
            return Ki(p);
          }
          case "scheme":
            return Ki(k0e(n[f]));
        }
    }
  const s = e === je || e === "xOffset" ? "width" : "height", o = i[s];
  if (mr(o)) {
    if (Je(e))
      if (gt(a)) {
        const f = MN(o, t, e);
        if (f)
          return Ki({ step: f });
      } else
        q(aT(s));
    else if (Fd(e)) {
      const f = e === cs ? "x" : "y";
      if (t.getScaleComponent(f).get("type") === "band") {
        const p = ON(o, a);
        if (p)
          return Ki(p);
      }
    }
  }
  const { rangeMin: u, rangeMax: l } = n, c = C0e(e, t);
  return (u !== void 0 || l !== void 0) && // it's ok to check just rangeMin's compatibility since rangeMin/rangeMax are the same
  Mv(a, "rangeMin") && R(c) && c.length === 2 ? Ki([u ?? c[0], l ?? c[1]]) : Cn(c);
}
function k0e(e) {
  return Dfe(e) ? {
    scheme: e.name,
    ...mn(e, ["name"])
  } : { scheme: e };
}
function FN(e, t, n, { center: i } = {}) {
  const r = Sn(e), a = t.getName(r), s = t.getSignalName.bind(t);
  return e === bt && Bn(n) ? i ? [
    lt.fromName((o) => `${s(o)}/2`, a),
    lt.fromName((o) => `-${s(o)}/2`, a)
  ] : [lt.fromName(s, a), 0] : i ? [
    lt.fromName((o) => `-${s(o)}/2`, a),
    lt.fromName((o) => `${s(o)}/2`, a)
  ] : [0, lt.fromName(s, a)];
}
function C0e(e, t) {
  const { size: n, config: i, mark: r, encoding: a } = t, { type: s } = it(a[e]), u = t.getScaleComponent(e).get("type"), { domain: l, domainMid: c } = t.specifiedScales[e];
  switch (e) {
    case je:
    case bt: {
      if (pe(["point", "band"], u)) {
        const f = RN(e, n, i.view);
        if (mr(f))
          return { step: MN(f, t, e) };
      }
      return FN(e, t, u);
    }
    case cs:
    case vl:
      return _0e(e, t, u);
    case sa: {
      const f = t.component.scales[e].get("zero"), d = TN(r, f, i), h = O0e(r, n, t, i);
      return zu(u) ? M0e(d, h, F0e(u, i, l, e)) : [d, h];
    }
    case ai:
      return [0, Math.PI * 2];
    case Oo:
      return [0, 360];
    case Bi:
      return [
        0,
        new lt(() => {
          const f = t.getSignalName("width"), d = t.getSignalName("height");
          return `min(${f},${d})/2`;
        })
      ];
    case hs:
      return [i.scale.minStrokeWidth, i.scale.maxStrokeWidth];
    case ps:
      return [
        // TODO: add this to Vega's config.range?
        [1, 0],
        [4, 2],
        [2, 1],
        [1, 1],
        [1, 2, 4, 2]
      ];
    case En:
      return "symbol";
    case wn:
    case Er:
    case Sr:
      return u === "ordinal" ? s === "nominal" ? "category" : "ordinal" : c !== void 0 ? "diverging" : r === "rect" || r === "geoshape" ? "heatmap" : "ramp";
    case oa:
    case fs:
    case ds:
      return [i.scale.minOpacity, i.scale.maxOpacity];
  }
}
function MN(e, t, n) {
  const { encoding: i } = t, r = t.getScaleComponent(n), a = WE(n), s = i[a];
  if (mD({ step: e, offsetIsDiscrete: le(s) && vT(s.type) }) === "offset" && JT(i, a)) {
    const u = t.getScaleComponent(a);
    let c = `domain('${t.scaleName(a)}').length`;
    if (u.get("type") === "band") {
      const d = u.get("paddingInner") ?? u.get("padding") ?? 0, h = u.get("paddingOuter") ?? u.get("padding") ?? 0;
      c = `bandspace(${c}, ${d}, ${h})`;
    }
    const f = r.get("paddingInner") ?? r.get("padding");
    return {
      signal: `${e.step} * ${c} / (1-${nce(f)})`
    };
  } else
    return e.step;
}
function ON(e, t) {
  if (mD({ step: e, offsetIsDiscrete: gt(t) }) === "offset")
    return { step: e.step };
}
function _0e(e, t, n) {
  const i = e === cs ? "x" : "y", r = t.getScaleComponent(i);
  if (!r)
    return FN(i, t, n, { center: !0 });
  const a = r.get("type"), s = t.scaleName(i), { markDef: o, config: u } = t;
  if (a === "band") {
    const l = RN(i, t.size, t.config.view);
    if (mr(l)) {
      const c = ON(l, n);
      if (c)
        return c;
    }
    return [0, { signal: `bandwidth('${s}')` }];
  } else {
    const l = t.encoding[i];
    if (j(l) && l.timeUnit) {
      const c = gT(l.timeUnit, (p) => `scale('${s}', ${p})`), f = t.config.scale.bandWithNestedOffsetPaddingInner, d = Za({
        fieldDef: l,
        markDef: o,
        config: u
      }) - 0.5, h = d !== 0 ? ` + ${d}` : "";
      if (f) {
        const p = Q(f) ? `${f.signal}/2` + h : `${f / 2 + d}`, g = Q(f) ? `(1 - ${f.signal}/2)` + h : `${1 - f / 2 + d}`;
        return [{ signal: `${p} * (${c})` }, { signal: `${g} * (${c})` }];
      }
      return [0, { signal: c }];
    }
    return AR(`Cannot use ${e} scale if ${i} scale is not discrete.`);
  }
}
function RN(e, t, n) {
  const i = e === je ? "width" : "height", r = t[i];
  return r || Mg(n, i);
}
function F0e(e, t, n, i) {
  switch (e) {
    case "quantile":
      return t.scale.quantileCount;
    case "quantize":
      return t.scale.quantizeCount;
    case "threshold":
      return n !== void 0 && R(n) ? n.length + 1 : (q(rfe(i)), 3);
  }
}
function M0e(e, t, n) {
  const i = () => {
    const r = xi(t), a = xi(e), s = `(${r} - ${a}) / (${n} - 1)`;
    return `sequence(${a}, ${r} + ${s}, ${s})`;
  };
  return Q(t) ? new lt(i) : { signal: i() };
}
function TN(e, t, n) {
  if (t)
    return Q(t) ? { signal: `${t.signal} ? 0 : ${TN(e, !1, n)}` } : 0;
  switch (e) {
    case "bar":
    case "tick":
      return n.scale.minBandSize;
    case "line":
    case "trail":
    case "rule":
      return n.scale.minStrokeWidth;
    case "text":
      return n.scale.minFontSize;
    case "point":
    case "square":
    case "circle":
      return n.scale.minSize;
  }
  throw new Error(km("size", e));
}
const b7 = 0.95;
function O0e(e, t, n, i) {
  const r = {
    x: y7(n, "x"),
    y: y7(n, "y")
  };
  switch (e) {
    case "bar":
    case "tick": {
      if (i.scale.maxBandSize !== void 0)
        return i.scale.maxBandSize;
      const a = v7(t, r, i.view);
      return ye(a) ? a - 1 : new lt(() => `${a.signal} - 1`);
    }
    case "line":
    case "trail":
    case "rule":
      return i.scale.maxStrokeWidth;
    case "text":
      return i.scale.maxFontSize;
    case "point":
    case "square":
    case "circle": {
      if (i.scale.maxSize)
        return i.scale.maxSize;
      const a = v7(t, r, i.view);
      return ye(a) ? Math.pow(b7 * a, 2) : new lt(() => `pow(${b7} * ${a.signal}, 2)`);
    }
  }
  throw new Error(km("size", e));
}
function v7(e, t, n) {
  const i = mr(e.width) ? e.width.step : Fg(n, "width"), r = mr(e.height) ? e.height.step : Fg(n, "height");
  return t.x || t.y ? new lt(() => `min(${[
    t.x ? t.x.signal : i,
    t.y ? t.y.signal : r
  ].join(", ")})`) : Math.min(i, r);
}
function DN(e, t) {
  We(e) ? R0e(e, t) : LN(e, t);
}
function R0e(e, t) {
  const n = e.component.scales, { config: i, encoding: r, markDef: a, specifiedScales: s } = e;
  for (const o of I(n)) {
    const u = s[o], l = n[o], c = e.getScaleComponent(o), f = it(r[o]), d = u[t], h = c.get("type"), p = c.get("padding"), g = c.get("paddingInner"), m = Mv(h, t), y = AT(o, t);
    if (d !== void 0 && (m ? y && q(y) : q(rT(h, t, o))), m && y === void 0)
      if (d !== void 0) {
        const b = f.timeUnit, v = f.type;
        switch (t) {
          case "domainMax":
          case "domainMin":
            Do(u[t]) || v === "temporal" || b ? l.set(t, { signal: Pm(u[t], { type: v, timeUnit: b }) }, !0) : l.set(t, u[t], !0);
            break;
          default:
            l.copyKeyFromObject(t, u);
        }
      } else {
        const b = t in x7 ? x7[t]({
          model: e,
          channel: o,
          fieldOrDatumDef: f,
          scaleType: h,
          scalePadding: p,
          scalePaddingInner: g,
          domain: u.domain,
          domainMin: u.domainMin,
          domainMax: u.domainMax,
          markDef: a,
          config: i,
          hasNestedOffsetScale: QT(r, o),
          hasSecondaryRangeChannel: !!r[Ar(o)]
        }) : i.scale[t];
        b !== void 0 && l.set(t, b, !1);
      }
  }
}
const x7 = {
  bins: ({ model: e, fieldOrDatumDef: t }) => j(t) ? T0e(e, t) : void 0,
  interpolate: ({ channel: e, fieldOrDatumDef: t }) => D0e(e, t.type),
  nice: ({ scaleType: e, channel: t, domain: n, domainMin: i, domainMax: r, fieldOrDatumDef: a }) => N0e(e, t, n, i, r, a),
  padding: ({ channel: e, scaleType: t, fieldOrDatumDef: n, markDef: i, config: r }) => L0e(e, t, r.scale, n, i, r.bar),
  paddingInner: ({ scalePadding: e, channel: t, markDef: n, scaleType: i, config: r, hasNestedOffsetScale: a }) => P0e(e, t, n.type, i, r.scale, a),
  paddingOuter: ({ scalePadding: e, channel: t, scaleType: n, scalePaddingInner: i, config: r, hasNestedOffsetScale: a }) => z0e(e, t, n, i, r.scale, a),
  reverse: ({ fieldOrDatumDef: e, scaleType: t, channel: n, config: i }) => {
    const r = j(e) ? e.sort : void 0;
    return I0e(t, r, n, i.scale);
  },
  zero: ({ channel: e, fieldOrDatumDef: t, domain: n, markDef: i, scaleType: r, config: a, hasSecondaryRangeChannel: s }) => B0e(e, t, n, i, r, a.scale, s)
};
function NN(e) {
  We(e) ? S0e(e) : LN(e, "range");
}
function LN(e, t) {
  const n = e.component.scales;
  for (const i of e.children)
    t === "range" ? NN(i) : DN(i, t);
  for (const i of I(n)) {
    let r;
    for (const a of e.children) {
      const s = a.component.scales[i];
      if (s) {
        const o = s.getWithExplicit(t);
        r = es(r, o, t, "scale", FD((u, l) => {
          switch (t) {
            case "range":
              return u.step && l.step ? u.step - l.step : 0;
          }
          return 0;
        }));
      }
    }
    n[i].setWithExplicit(t, r);
  }
}
function T0e(e, t) {
  const n = t.bin;
  if (De(n)) {
    const i = H3(e, t.field, n);
    return new lt(() => e.getSignalName(i));
  } else if (vt(n) && To(n) && n.step !== void 0)
    return {
      step: n.step
    };
}
function D0e(e, t) {
  if (pe([wn, Er, Sr], e) && t !== "nominal")
    return "hcl";
}
function N0e(e, t, n, i, r, a) {
  var s;
  if (!((s = gr(a)) != null && s.bin || R(n) || r != null || i != null || pe([yn.TIME, yn.UTC], e)))
    return Je(t) ? !0 : void 0;
}
function L0e(e, t, n, i, r, a) {
  if (Je(e)) {
    if ($i(t)) {
      if (n.continuousPadding !== void 0)
        return n.continuousPadding;
      const { type: s, orient: o } = r;
      if (s === "bar" && !(j(i) && (i.bin || i.timeUnit)) && (o === "vertical" && e === "x" || o === "horizontal" && e === "y"))
        return a.continuousBandSize;
    }
    if (t === yn.POINT)
      return n.pointPadding;
  }
}
function P0e(e, t, n, i, r, a = !1) {
  if (e === void 0) {
    if (Je(t)) {
      const { bandPaddingInner: s, barBandPaddingInner: o, rectBandPaddingInner: u, bandWithNestedOffsetPaddingInner: l } = r;
      return a ? l : Ke(s, n === "bar" ? o : u);
    } else if (Fd(t) && i === yn.BAND)
      return r.offsetBandPaddingInner;
  }
}
function z0e(e, t, n, i, r, a = !1) {
  if (e === void 0) {
    if (Je(t)) {
      const { bandPaddingOuter: s, bandWithNestedOffsetPaddingOuter: o } = r;
      if (a)
        return o;
      if (n === yn.BAND)
        return Ke(
          s,
          /* By default, paddingOuter is paddingInner / 2. The reason is that
            size (width/height) = step * (cardinality - paddingInner + 2 * paddingOuter).
            and we want the width/height to be integer by default.
            Note that step (by default) and cardinality are integers.) */
          Q(i) ? { signal: `${i.signal}/2` } : i / 2
        );
    } else if (Fd(t)) {
      if (n === yn.POINT)
        return 0.5;
      if (n === yn.BAND)
        return r.offsetBandPaddingOuter;
    }
  }
}
function I0e(e, t, n, i) {
  if (n === "x" && i.xReverse !== void 0)
    return Bn(e) && t === "descending" ? Q(i.xReverse) ? { signal: `!${i.xReverse.signal}` } : !i.xReverse : i.xReverse;
  if (Bn(e) && t === "descending")
    return !0;
}
function B0e(e, t, n, i, r, a, s) {
  if (!!n && n !== "unaggregated" && Bn(r)) {
    if (R(n)) {
      const u = n[0], l = n[n.length - 1];
      if (ye(u) && u <= 0 && ye(l) && l >= 0)
        return !0;
    }
    return !1;
  }
  if (e === "size" && t.type === "quantitative" && !zu(r))
    return !0;
  if (!(j(t) && t.bin) && pe([...kr, ...zle], e)) {
    const { orient: u, type: l } = i;
    return pe(["bar", "area", "line", "trail"], l) && (u === "horizontal" && e === "y" || u === "vertical" && e === "x") ? !1 : pe(["bar", "area"], l) && !s ? !0 : a == null ? void 0 : a.zero;
  }
  return !1;
}
function j0e(e, t, n, i, r = !1) {
  const a = U0e(t, n, i, r), { type: s } = e;
  return ua(t) ? s !== void 0 ? jfe(t, s) ? j(n) && !Bfe(s, n.type) ? (q(Uce(s, a)), a) : s : (q(jce(t, s, a)), a) : a : null;
}
function U0e(e, t, n, i) {
  var r;
  switch (t.type) {
    case "nominal":
    case "ordinal": {
      if (fu(e) || dy(e) === "discrete")
        return e === "shape" && t.type === "ordinal" && q(hy(e, "ordinal")), "ordinal";
      if (Je(e) || Fd(e)) {
        if (pe(["rect", "bar", "image", "rule"], n.type) || i)
          return "band";
      } else if (n.type === "arc" && e in XE)
        return "band";
      const a = n[Sn(e)];
      return yo(a) || Bu(t) && ((r = t.axis) != null && r.tickBand) ? "band" : "point";
    }
    case "temporal":
      return fu(e) ? "time" : dy(e) === "discrete" ? (q(hy(e, "temporal")), "ordinal") : j(t) && t.timeUnit && pt(t.timeUnit).utc ? "utc" : "time";
    case "quantitative":
      return fu(e) ? j(t) && De(t.bin) ? "bin-ordinal" : "linear" : dy(e) === "discrete" ? (q(hy(e, "quantitative")), "ordinal") : "linear";
    case "geojson":
      return;
  }
  throw new Error(nT(t.type));
}
function q0e(e, { ignoreRange: t } = {}) {
  PN(e), kN(e);
  for (const n of Ife)
    DN(e, n);
  t || NN(e);
}
function PN(e) {
  We(e) ? e.component.scales = G0e(e) : e.component.scales = H0e(e);
}
function G0e(e) {
  const { encoding: t, mark: n, markDef: i } = e, r = {};
  for (const a of Sm) {
    const s = it(t[a]);
    if (s && n === _T && a === En && s.type === xl)
      continue;
    let o = s && s.scale;
    if (s && o !== null && o !== !1) {
      o ?? (o = {});
      const u = QT(t, a), l = j0e(o, a, s, i, u);
      r[a] = new _N(e.scaleName(`${a}`, !0), {
        value: l,
        explicit: o.type === l
      });
    }
  }
  return r;
}
const W0e = FD((e, t) => k4(e) - k4(t));
function H0e(e) {
  var t;
  const n = e.component.scales = {}, i = {}, r = e.component.resolve;
  for (const a of e.children) {
    PN(a);
    for (const s of I(a.component.scales))
      if ((t = r.scale)[s] ?? (t[s] = hN(s, e)), r.scale[s] === "shared") {
        const o = i[s], u = a.component.scales[s].getWithExplicit("type");
        o ? Ffe(o.value, u.value) ? i[s] = es(o, u, "type", "scale", W0e) : (r.scale[s] = "independent", delete i[s]) : i[s] = u;
      }
  }
  for (const a of I(i)) {
    const s = e.scaleName(a, !0), o = i[a];
    n[a] = new _N(s, o);
    for (const u of e.children) {
      const l = u.component.scales[a];
      l && (u.renameScale(l.get("name"), s), l.merged = !0);
    }
  }
  return n;
}
class wy {
  constructor() {
    this.nameMap = {};
  }
  rename(t, n) {
    this.nameMap[t] = n;
  }
  has(t) {
    return this.nameMap[t] !== void 0;
  }
  get(t) {
    for (; this.nameMap[t] && t !== this.nameMap[t]; )
      t = this.nameMap[t];
    return t;
  }
}
function We(e) {
  return (e == null ? void 0 : e.type) === "unit";
}
function ki(e) {
  return (e == null ? void 0 : e.type) === "facet";
}
function J3(e) {
  return (e == null ? void 0 : e.type) === "concat";
}
function Al(e) {
  return (e == null ? void 0 : e.type) === "layer";
}
class Q3 {
  constructor(t, n, i, r, a, s, o) {
    this.type = n, this.parent = i, this.config = a, this.correctDataNames = (u) => {
      var l, c, f;
      return (l = u.from) != null && l.data && (u.from.data = this.lookupDataSource(u.from.data)), (f = (c = u.from) == null ? void 0 : c.facet) != null && f.data && (u.from.facet.data = this.lookupDataSource(u.from.facet.data)), u;
    }, this.parent = i, this.config = a, this.view = hn(o), this.name = t.name ?? r, this.title = xa(t.title) ? { text: t.title } : t.title ? hn(t.title) : void 0, this.scaleNameMap = i ? i.scaleNameMap : new wy(), this.projectionNameMap = i ? i.projectionNameMap : new wy(), this.signalNameMap = i ? i.signalNameMap : new wy(), this.data = t.data, this.description = t.description, this.transforms = Zhe(t.transform ?? []), this.layout = n === "layer" || n === "unit" ? {} : ihe(t, n, a), this.component = {
      data: {
        sources: i ? i.component.data.sources : [],
        outputNodes: i ? i.component.data.outputNodes : {},
        outputNodeRefCounts: i ? i.component.data.outputNodeRefCounts : {},
        // data is faceted if the spec is a facet spec or the parent has faceted data and data is undefined
        isFaceted: Tm(t) || (i == null ? void 0 : i.component.data.isFaceted) && t.data === void 0
      },
      layoutSize: new ca(),
      layoutHeaders: { row: {}, column: {}, facet: {} },
      mark: null,
      resolve: {
        scale: {},
        axis: {},
        legend: {},
        ...s ? se(s) : {}
      },
      selection: null,
      scales: null,
      projection: null,
      axes: {},
      legends: {}
    };
  }
  get width() {
    return this.getSizeSignalRef("width");
  }
  get height() {
    return this.getSizeSignalRef("height");
  }
  parse() {
    this.parseScale(), this.parseLayoutSize(), this.renameTopLevelLayoutSizeSignal(), this.parseSelections(), this.parseProjection(), this.parseData(), this.parseAxesAndHeaders(), this.parseLegends(), this.parseMarkGroup();
  }
  parseScale() {
    q0e(this);
  }
  parseProjection() {
    EN(this);
  }
  /**
   * Rename top-level spec's size to be just width / height, ignoring model name.
   * This essentially merges the top-level spec's width/height signals with the width/height signals
   * to help us reduce redundant signals declaration.
   */
  renameTopLevelLayoutSizeSignal() {
    this.getName("width") !== "width" && this.renameSignal(this.getName("width"), "width"), this.getName("height") !== "height" && this.renameSignal(this.getName("height"), "height");
  }
  parseLegends() {
    bN(this);
  }
  assembleEncodeFromView(t) {
    const { style: n, ...i } = t, r = {};
    for (const a of I(i)) {
      const s = i[a];
      s !== void 0 && (r[a] = ze(s));
    }
    return r;
  }
  assembleGroupEncodeEntry(t) {
    let n = {};
    return this.view && (n = this.assembleEncodeFromView(this.view)), !t && (this.description && (n.description = ze(this.description)), this.type === "unit" || this.type === "layer") ? {
      width: this.getSizeSignalRef("width"),
      height: this.getSizeSignalRef("height"),
      ...n ?? {}
    } : ke(n) ? void 0 : n;
  }
  assembleLayout() {
    if (!this.layout)
      return;
    const { spacing: t, ...n } = this.layout, { component: i, config: r } = this, a = hge(i.layoutHeaders, r);
    return {
      padding: t,
      ...this.assembleDefaultLayout(),
      ...n,
      ...a ? { titleBand: a } : {}
    };
  }
  assembleDefaultLayout() {
    return {};
  }
  assembleHeaderMarks() {
    const { layoutHeaders: t } = this.component;
    let n = [];
    for (const i of Yn)
      t[i].title && n.push(oge(this, i));
    for (const i of U3)
      n = n.concat(uge(this, i));
    return n;
  }
  assembleAxes() {
    return Xpe(this.component.axes, this.config);
  }
  assembleLegends() {
    return xN(this);
  }
  assembleProjections() {
    return Lge(this);
  }
  assembleTitle() {
    const { encoding: t, ...n } = this.title ?? {}, i = {
      ...VR(this.config.title).nonMarkTitleProperties,
      ...n,
      ...t ? { encode: { update: t } } : {}
    };
    if (i.text)
      return pe(["unit", "layer"], this.type) ? pe(["middle", void 0], i.anchor) && (i.frame ?? (i.frame = "group")) : i.anchor ?? (i.anchor = "start"), ke(i) ? void 0 : i;
  }
  /**
   * Assemble the mark group for this model. We accept optional `signals` so that we can include concat top-level signals with the top-level model's local signals.
   */
  assembleGroup(t = []) {
    const n = {};
    t = t.concat(this.assembleSignals()), t.length > 0 && (n.signals = t);
    const i = this.assembleLayout();
    i && (n.layout = i), n.marks = [].concat(this.assembleHeaderMarks(), this.assembleMarks());
    const r = !this.parent || ki(this.parent) ? CN(this) : [];
    r.length > 0 && (n.scales = r);
    const a = this.assembleAxes();
    a.length > 0 && (n.axes = a);
    const s = this.assembleLegends();
    return s.length > 0 && (n.legends = s), n;
  }
  getName(t) {
    return Be((this.name ? `${this.name}_` : "") + t);
  }
  getDataName(t) {
    return this.getName(Te[t].toLowerCase());
  }
  /**
   * Request a data source name for the given data source type and mark that data source as required.
   * This method should be called in parse, so that all used data source can be correctly instantiated in assembleData().
   * You can lookup the correct dataset name in assemble with `lookupDataSource`.
   */
  requestDataName(t) {
    const n = this.getDataName(t), i = this.component.data.outputNodeRefCounts;
    return i[n] = (i[n] || 0) + 1, n;
  }
  getSizeSignalRef(t) {
    if (ki(this.parent)) {
      const n = fN(t), i = Em(n), r = this.component.scales[i];
      if (r && !r.merged) {
        const a = r.get("type"), s = r.get("range");
        if (gt(a) && ms(s)) {
          const o = r.get("name"), u = Ym(this, i), l = K3(u);
          if (l) {
            const c = H({ aggregate: "distinct", field: l }, { expr: "datum" });
            return {
              signal: cN(o, r, c)
            };
          } else
            return q(JE(i)), null;
        }
      }
    }
    return {
      signal: this.signalNameMap.get(this.getName(t))
    };
  }
  /**
   * Lookup the name of the datasource for an output node. You probably want to call this in assemble.
   */
  lookupDataSource(t) {
    const n = this.component.data.outputNodes[t];
    return n ? n.getSource() : t;
  }
  getSignalName(t) {
    return this.signalNameMap.get(t);
  }
  renameSignal(t, n) {
    this.signalNameMap.rename(t, n);
  }
  renameScale(t, n) {
    this.scaleNameMap.rename(t, n);
  }
  renameProjection(t, n) {
    this.projectionNameMap.rename(t, n);
  }
  /**
   * @return scale name for a given channel after the scale has been parsed and named.
   */
  scaleName(t, n) {
    if (n)
      return this.getName(t);
    if (
      // If there is a scale for the channel, there should be a local scale component for it
      zR(t) && ua(t) && this.component.scales[t] || // in the scale name map (the scale get merged by its parent)
      this.scaleNameMap.has(this.getName(t))
    )
      return this.scaleNameMap.get(this.getName(t));
  }
  /**
   * @return projection name after the projection has been parsed and named.
   */
  projectionName(t) {
    if (t)
      return this.getName("projection");
    if (this.component.projection && !this.component.projection.merged || this.projectionNameMap.has(this.getName("projection")))
      return this.projectionNameMap.get(this.getName("projection"));
  }
  /**
   * Traverse a model's hierarchy to get the scale component for a particular channel.
   */
  getScaleComponent(t) {
    if (!this.component.scales)
      throw new Error("getScaleComponent cannot be called before parseScale(). Make sure you have called parseScale or use parseUnitModelWithScale().");
    const n = this.component.scales[t];
    return n && !n.merged ? n : this.parent ? this.parent.getScaleComponent(t) : void 0;
  }
  /**
   * Traverse a model's hierarchy to get a particular selection component.
   */
  getSelectionComponent(t, n) {
    let i = this.component.selection[t];
    if (!i && this.parent && (i = this.parent.getSelectionComponent(t, n)), !i)
      throw new Error(oce(n));
    return i;
  }
  /**
   * Returns true if the model has a signalRef for an axis orient.
   */
  hasAxisOrientSignalRef() {
    var t, n;
    return ((t = this.component.axes.x) == null ? void 0 : t.some((i) => i.hasOrientSignalRef())) || ((n = this.component.axes.y) == null ? void 0 : n.some((i) => i.hasOrientSignalRef()));
  }
}
class zN extends Q3 {
  /** Get "field" reference for Vega */
  vgField(t, n = {}) {
    const i = this.fieldDef(t);
    if (i)
      return H(i, n);
  }
  reduceFieldDef(t, n) {
    return Rde(this.getMapping(), (i, r, a) => {
      const s = gr(r);
      return s ? t(i, s, a) : i;
    }, n);
  }
  forEachFieldDef(t, n) {
    S3(this.getMapping(), (i, r) => {
      const a = gr(i);
      a && t(a, r);
    }, n);
  }
}
class Km extends Ae {
  clone() {
    return new Km(null, se(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = se(n);
    const i = this.transform.as ?? [void 0, void 0];
    this.transform.as = [i[0] ?? "value", i[1] ?? "density"];
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.density, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `DensityTransform ${he(this.transform)}`;
  }
  assemble() {
    const { density: t, ...n } = this.transform, i = {
      type: "kde",
      field: t,
      ...n
    };
    return this.transform.groupby && (i.resolve = "shared"), i;
  }
}
class Jm extends Ae {
  clone() {
    return new Jm(null, se(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = se(n);
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.extent]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set([]);
  }
  hash() {
    return `ExtentTransform ${he(this.transform)}`;
  }
  assemble() {
    const { extent: t, param: n } = this.transform;
    return {
      type: "extent",
      field: t,
      signal: n
    };
  }
}
class $f extends Ae {
  clone() {
    return new $f(null, { ...this.filter });
  }
  constructor(t, n) {
    super(t), this.filter = n;
  }
  static make(t, n) {
    const { config: i, mark: r, markDef: a } = n;
    if (Ee("invalid", a, i) !== "filter")
      return null;
    const o = n.reduceFieldDef((u, l, c) => {
      const f = ua(c) && n.getScaleComponent(c);
      if (f) {
        const d = f.get("type");
        Bn(d) && l.aggregate !== "count" && !ys(r) && (u[l.field] = l);
      }
      return u;
    }, {});
    return I(o).length ? new $f(t, o) : null;
  }
  dependentFields() {
    return new Set(I(this.filter));
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `FilterInvalid ${he(this.filter)}`;
  }
  /**
   * Create the VgTransforms for each of the filtered fields.
   */
  assemble() {
    const t = I(this.filter).reduce((n, i) => {
      const r = this.filter[i], a = H(r, { expr: "datum" });
      return r !== null && (r.type === "temporal" ? n.push(`(isDate(${a}) || (isValid(${a}) && isFinite(+${a})))`) : r.type === "quantitative" && (n.push(`isValid(${a})`), n.push(`isFinite(+${a})`))), n;
    }, []);
    return t.length > 0 ? {
      type: "filter",
      expr: t.join(" && ")
    } : null;
  }
}
class Qm extends Ae {
  clone() {
    return new Qm(this.parent, se(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = se(n);
    const { flatten: i, as: r = [] } = this.transform;
    this.transform.as = i.map((a, s) => r[s] ?? a);
  }
  dependentFields() {
    return new Set(this.transform.flatten);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FlattenTransform ${he(this.transform)}`;
  }
  assemble() {
    const { flatten: t, as: n } = this.transform;
    return {
      type: "flatten",
      fields: t,
      as: n
    };
  }
}
class Zm extends Ae {
  clone() {
    return new Zm(null, se(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = se(n);
    const i = this.transform.as ?? [void 0, void 0];
    this.transform.as = [i[0] ?? "key", i[1] ?? "value"];
  }
  dependentFields() {
    return new Set(this.transform.fold);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `FoldTransform ${he(this.transform)}`;
  }
  assemble() {
    const { fold: t, as: n } = this.transform;
    return {
      type: "fold",
      fields: t,
      as: n
    };
  }
}
class pu extends Ae {
  clone() {
    return new pu(null, se(this.fields), this.geojson, this.signal);
  }
  static parseAll(t, n) {
    if (n.component.projection && !n.component.projection.isFit)
      return t;
    let i = 0;
    for (const r of [
      [Ui, ji],
      [ii, qi]
    ]) {
      const a = r.map((s) => {
        const o = it(n.encoding[s]);
        return j(o) ? o.field : Cr(o) ? { expr: `${o.datum}` } : Oi(o) ? { expr: `${o.value}` } : void 0;
      });
      (a[0] || a[1]) && (t = new pu(t, a, null, n.getName(`geojson_${i++}`)));
    }
    if (n.channelHasField(En)) {
      const r = n.typedFieldDef(En);
      r.type === xl && (t = new pu(t, null, r.field, n.getName(`geojson_${i++}`)));
    }
    return t;
  }
  constructor(t, n, i, r) {
    super(t), this.fields = n, this.geojson = i, this.signal = r;
  }
  dependentFields() {
    const t = (this.fields ?? []).filter(V);
    return /* @__PURE__ */ new Set([...this.geojson ? [this.geojson] : [], ...t]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `GeoJSON ${this.geojson} ${this.signal} ${he(this.fields)}`;
  }
  assemble() {
    return [
      ...this.geojson ? [
        {
          type: "filter",
          expr: `isValid(datum["${this.geojson}"])`
        }
      ] : [],
      {
        type: "geojson",
        ...this.fields ? { fields: this.fields } : {},
        ...this.geojson ? { geojson: this.geojson } : {},
        signal: this.signal
      }
    ];
  }
}
class wf extends Ae {
  clone() {
    return new wf(null, this.projection, se(this.fields), se(this.as));
  }
  constructor(t, n, i, r) {
    super(t), this.projection = n, this.fields = i, this.as = r;
  }
  static parseAll(t, n) {
    if (!n.projectionName())
      return t;
    for (const i of [
      [Ui, ji],
      [ii, qi]
    ]) {
      const r = i.map((s) => {
        const o = it(n.encoding[s]);
        return j(o) ? o.field : Cr(o) ? { expr: `${o.datum}` } : Oi(o) ? { expr: `${o.value}` } : void 0;
      }), a = i[0] === ii ? "2" : "";
      (r[0] || r[1]) && (t = new wf(t, n.projectionName(), r, [
        n.getName(`x${a}`),
        n.getName(`y${a}`)
      ]));
    }
    return t;
  }
  dependentFields() {
    return new Set(this.fields.filter(V));
  }
  producedFields() {
    return new Set(this.as);
  }
  hash() {
    return `Geopoint ${this.projection} ${he(this.fields)} ${he(this.as)}`;
  }
  assemble() {
    return {
      type: "geopoint",
      projection: this.projection,
      fields: this.fields,
      as: this.as
    };
  }
}
class eo extends Ae {
  clone() {
    return new eo(null, se(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.impute, this.transform.key, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return /* @__PURE__ */ new Set([this.transform.impute]);
  }
  processSequence(t) {
    const { start: n = 0, stop: i, step: r } = t;
    return { signal: `sequence(${[n, i, ...r ? [r] : []].join(",")})` };
  }
  static makeFromTransform(t, n) {
    return new eo(t, n);
  }
  static makeFromEncoding(t, n) {
    const i = n.encoding, r = i.x, a = i.y;
    if (j(r) && j(a)) {
      const s = r.impute ? r : a.impute ? a : void 0;
      if (s === void 0)
        return;
      const o = r.impute ? a : a.impute ? r : void 0, { method: u, value: l, frame: c, keyvals: f } = s.impute, d = eD(n.mark, i);
      return new eo(t, {
        impute: s.field,
        key: o.field,
        ...u ? { method: u } : {},
        ...l !== void 0 ? { value: l } : {},
        ...c ? { frame: c } : {},
        ...f !== void 0 ? { keyvals: f } : {},
        ...d.length ? { groupby: d } : {}
      });
    }
    return null;
  }
  hash() {
    return `Impute ${he(this.transform)}`;
  }
  assemble() {
    const { impute: t, key: n, keyvals: i, method: r, groupby: a, value: s, frame: o = [null, null] } = this.transform, u = {
      type: "impute",
      field: t,
      key: n,
      ...i ? { keyvals: Dhe(i) ? this.processSequence(i) : i } : {},
      method: "value",
      ...a ? { groupby: a } : {},
      value: !r || r === "value" ? s : null
    };
    if (r && r !== "value") {
      const l = {
        type: "window",
        as: [`imputed_${t}_value`],
        ops: [r],
        fields: [t],
        frame: o,
        ignorePeers: !1,
        ...a ? { groupby: a } : {}
      }, c = {
        type: "formula",
        expr: `datum.${t} === null ? datum.imputed_${t}_value : datum.${t}`,
        as: t
      };
      return [u, l, c];
    } else
      return [u];
  }
}
class e1 extends Ae {
  clone() {
    return new e1(null, se(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = se(n);
    const i = this.transform.as ?? [void 0, void 0];
    this.transform.as = [i[0] ?? n.on, i[1] ?? n.loess];
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.loess, this.transform.on, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `LoessTransform ${he(this.transform)}`;
  }
  assemble() {
    const { loess: t, on: n, ...i } = this.transform;
    return {
      type: "loess",
      x: n,
      y: t,
      ...i
    };
  }
}
class Ef extends Ae {
  clone() {
    return new Ef(null, se(this.transform), this.secondary);
  }
  constructor(t, n, i) {
    super(t), this.transform = n, this.secondary = i;
  }
  static make(t, n, i, r) {
    const a = n.component.data.sources, { from: s } = i;
    let o = null;
    if (Nhe(s)) {
      let u = jN(s.data, a);
      u || (u = new $o(s.data), a.push(u));
      const l = n.getName(`lookup_${r}`);
      o = new tn(u, l, Te.Lookup, n.component.data.outputNodeRefCounts), n.component.data.outputNodes[l] = o;
    } else if (Lhe(s)) {
      const u = s.param;
      i = { as: u, ...i };
      let l;
      try {
        l = n.getSelectionComponent(Be(u), u);
      } catch {
        throw new Error(cce(u));
      }
      if (o = l.materialized, !o)
        throw new Error(fce(u));
    }
    return new Ef(t, i, o.getSource());
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.lookup]);
  }
  producedFields() {
    return new Set(this.transform.as ? G(this.transform.as) : this.transform.from.fields);
  }
  hash() {
    return `Lookup ${he({ transform: this.transform, secondary: this.secondary })}`;
  }
  assemble() {
    let t;
    if (this.transform.from.fields)
      t = {
        values: this.transform.from.fields,
        ...this.transform.as ? { as: G(this.transform.as) } : {}
      };
    else {
      let n = this.transform.as;
      V(n) || (q(vce), n = "_lookup"), t = {
        as: [n]
      };
    }
    return {
      type: "lookup",
      from: this.secondary,
      key: this.transform.from.key,
      fields: [this.transform.lookup],
      ...t,
      ...this.transform.default ? { default: this.transform.default } : {}
    };
  }
}
class t1 extends Ae {
  clone() {
    return new t1(null, se(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = se(n);
    const i = this.transform.as ?? [void 0, void 0];
    this.transform.as = [i[0] ?? "prob", i[1] ?? "value"];
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.quantile, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `QuantileTransform ${he(this.transform)}`;
  }
  assemble() {
    const { quantile: t, ...n } = this.transform;
    return {
      type: "quantile",
      field: t,
      ...n
    };
  }
}
class n1 extends Ae {
  clone() {
    return new n1(null, se(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n, this.transform = se(n);
    const i = this.transform.as ?? [void 0, void 0];
    this.transform.as = [i[0] ?? n.on, i[1] ?? n.regression];
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.regression, this.transform.on, ...this.transform.groupby ?? []]);
  }
  producedFields() {
    return new Set(this.transform.as);
  }
  hash() {
    return `RegressionTransform ${he(this.transform)}`;
  }
  assemble() {
    const { regression: t, on: n, ...i } = this.transform;
    return {
      type: "regression",
      x: n,
      y: t,
      ...i
    };
  }
}
class i1 extends Ae {
  clone() {
    return new i1(null, se(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  addDimensions(t) {
    this.transform.groupby = rr((this.transform.groupby ?? []).concat(t), (n) => n);
  }
  producedFields() {
  }
  dependentFields() {
    return /* @__PURE__ */ new Set([this.transform.pivot, this.transform.value, ...this.transform.groupby ?? []]);
  }
  hash() {
    return `PivotTransform ${he(this.transform)}`;
  }
  assemble() {
    const { pivot: t, value: n, groupby: i, limit: r, op: a } = this.transform;
    return {
      type: "pivot",
      field: t,
      value: n,
      ...r !== void 0 ? { limit: r } : {},
      ...a !== void 0 ? { op: a } : {},
      ...i !== void 0 ? { groupby: i } : {}
    };
  }
}
class r1 extends Ae {
  clone() {
    return new r1(null, se(this.transform));
  }
  constructor(t, n) {
    super(t), this.transform = n;
  }
  dependentFields() {
    return /* @__PURE__ */ new Set();
  }
  producedFields() {
    return /* @__PURE__ */ new Set();
  }
  hash() {
    return `SampleTransform ${he(this.transform)}`;
  }
  assemble() {
    return {
      type: "sample",
      size: this.transform.sample
    };
  }
}
function IN(e) {
  let t = 0;
  function n(i, r) {
    if (i instanceof $o && !i.isGenerator && !Uu(i.data) && (e.push(r), r = {
      name: null,
      source: r.name,
      transform: []
    }), i instanceof Lt && (i.parent instanceof $o && !r.source ? (r.format = {
      ...r.format ?? {},
      parse: i.assembleFormatParse()
    }, r.transform.push(...i.assembleTransforms(!0))) : r.transform.push(...i.assembleTransforms())), i instanceof El) {
      r.name || (r.name = `data_${t++}`), !r.source || r.transform.length > 0 ? (e.push(r), i.data = r.name) : i.data = r.source, e.push(...i.assemble());
      return;
    }
    switch ((i instanceof zd || i instanceof Id || i instanceof $f || i instanceof wl || i instanceof Gu || i instanceof wf || i instanceof Ai || i instanceof Ef || i instanceof Sl || i instanceof zo || i instanceof Zm || i instanceof Qm || i instanceof Km || i instanceof e1 || i instanceof t1 || i instanceof n1 || i instanceof is || i instanceof r1 || i instanceof i1 || i instanceof Jm) && r.transform.push(i.assemble()), (i instanceof lr || i instanceof ur || i instanceof eo || i instanceof Hr || i instanceof pu) && r.transform.push(...i.assemble()), i instanceof tn && (r.source && r.transform.length === 0 ? i.setSource(r.source) : i.parent instanceof tn ? i.setSource(r.name) : (r.name || (r.name = `data_${t++}`), i.setSource(r.name), i.numChildren() === 1 && (e.push(r), r = {
      name: null,
      source: r.name,
      transform: []
    }))), i.numChildren()) {
      case 0:
        i instanceof tn && (!r.source || r.transform.length > 0) && e.push(r);
        break;
      case 1:
        n(i.children[0], r);
        break;
      default: {
        r.name || (r.name = `data_${t++}`);
        let a = r.name;
        !r.source || r.transform.length > 0 ? e.push(r) : a = r.source;
        for (const s of i.children)
          n(s, {
            name: null,
            source: a,
            transform: []
          });
        break;
      }
    }
  }
  return n;
}
function V0e(e) {
  const t = [], n = IN(t);
  for (const i of e.children)
    n(i, {
      source: e.name,
      name: null,
      transform: []
    });
  return t;
}
function X0e(e, t) {
  const n = [], i = IN(n);
  let r = 0;
  for (const s of e.sources) {
    s.hasName() || (s.dataName = `source_${r++}`);
    const o = s.assemble();
    i(s, o);
  }
  for (const s of n)
    s.transform.length === 0 && delete s.transform;
  let a = 0;
  for (const [s, o] of n.entries())
    (o.transform ?? []).length === 0 && !o.source && n.splice(a++, 0, n.splice(s, 1)[0]);
  for (const s of n)
    for (const o of s.transform ?? [])
      o.type === "lookup" && (o.from = e.outputNodes[o.from].getSource());
  for (const s of n)
    s.name in t && (s.values = t[s.name]);
  return n;
}
function Y0e(e) {
  return e === "top" || e === "left" || Q(e) ? "header" : "footer";
}
function K0e(e) {
  for (const t of Yn)
    J0e(e, t);
  $7(e, "x"), $7(e, "y");
}
function J0e(e, t) {
  var s;
  const { facet: n, config: i, child: r, component: a } = e;
  if (e.channelHasField(t)) {
    const o = n[t], u = Hu("title", null, i, t);
    let l = du(o, i, {
      allowDisabling: !0,
      includeDefault: u === void 0 || !!u
    });
    r.component.layoutHeaders[t].title && (l = R(l) ? l.join(", ") : l, l += ` / ${r.component.layoutHeaders[t].title}`, r.component.layoutHeaders[t].title = null);
    const c = Hu("labelOrient", o.header, i, t), f = o.header !== null ? Ke((s = o.header) == null ? void 0 : s.labels, i.header.labels, !0) : !1, d = pe(["bottom", "right"], c) ? "footer" : "header";
    a.layoutHeaders[t] = {
      title: o.header !== null ? l : null,
      facetFieldDef: o,
      [d]: t === "facet" ? [] : [BN(e, t, f)]
    };
  }
}
function BN(e, t, n) {
  const i = t === "row" ? "height" : "width";
  return {
    labels: n,
    sizeSignal: e.child.component.layoutSize.get(i) ? e.child.getSizeSignalRef(i) : void 0,
    axes: []
  };
}
function $7(e, t) {
  const { child: n } = e;
  if (n.component.axes[t]) {
    const { layoutHeaders: i, resolve: r } = e.component;
    if (r.axis[t] = W3(r, t), r.axis[t] === "shared") {
      const a = t === "x" ? "column" : "row", s = i[a];
      for (const o of n.component.axes[t]) {
        const u = Y0e(o.get("orient"));
        s[u] ?? (s[u] = [BN(e, a, !1)]);
        const l = yc(o, "main", e.config, { header: !0 });
        l && s[u][0].axes.push(l), o.mainExtracted = !0;
      }
    }
  }
}
function Q0e(e) {
  Z3(e), Dg(e, "width"), Dg(e, "height");
}
function Z0e(e) {
  Z3(e);
  const t = e.layout.columns === 1 ? "width" : "childWidth", n = e.layout.columns === void 0 ? "height" : "childHeight";
  Dg(e, t), Dg(e, n);
}
function Z3(e) {
  for (const t of e.children)
    t.parseLayoutSize();
}
function Dg(e, t) {
  const n = fN(t), i = Em(n), r = e.component.resolve, a = e.component.layoutSize;
  let s;
  for (const o of e.children) {
    const u = o.component.layoutSize.getWithExplicit(n), l = r.scale[i] ?? hN(i, e);
    if (l === "independent" && u.value === "step") {
      s = void 0;
      break;
    }
    if (s) {
      if (l === "independent" && s.value !== u.value) {
        s = void 0;
        break;
      }
      s = es(s, u, n, "");
    } else
      s = u;
  }
  if (s) {
    for (const o of e.children)
      e.renameSignal(o.getName(n), e.getName(t)), o.component.layoutSize.set(n, "merged", !1);
    a.setWithExplicit(t, s);
  } else
    a.setWithExplicit(t, {
      explicit: !1,
      value: void 0
    });
}
function eme(e) {
  const { size: t, component: n } = e;
  for (const i of kr) {
    const r = Sn(i);
    if (t[r]) {
      const a = t[r];
      n.layoutSize.set(r, mr(a) ? "step" : a, !0);
    } else {
      const a = tme(e, r);
      n.layoutSize.set(r, a, !1);
    }
  }
}
function tme(e, t) {
  const n = t === "width" ? "x" : "y", i = e.config, r = e.getScaleComponent(n);
  if (r) {
    const a = r.get("type"), s = r.get("range");
    if (gt(a)) {
      const o = Mg(i.view, t);
      return ms(s) || mr(o) ? "step" : o;
    } else
      return Tv(i.view, t);
  } else {
    if (e.hasProjection || e.mark === "arc")
      return Tv(i.view, t);
    {
      const a = Mg(i.view, t);
      return mr(a) ? a.step : a;
    }
  }
}
function Vv(e, t, n) {
  return H(t, { suffix: `by_${H(e)}`, ...n ?? {} });
}
class Pc extends zN {
  constructor(t, n, i, r) {
    super(t, "facet", n, i, r, t.resolve), this.child = r5(t.spec, this, this.getName("child"), void 0, r), this.children = [this.child], this.facet = this.initFacet(t.facet);
  }
  initFacet(t) {
    if (!Td(t))
      return { facet: this.initFacetFieldDef(t, "facet") };
    const n = I(t), i = {};
    for (const r of n) {
      if (![qr, Gr].includes(r)) {
        q(km(r, "facet"));
        break;
      }
      const a = t[r];
      if (a.field === void 0) {
        q(_v(a, r));
        break;
      }
      i[r] = this.initFacetFieldDef(a, r);
    }
    return i;
  }
  initFacetFieldDef(t, n) {
    const i = w3(t, n);
    return i.header ? i.header = hn(i.header) : i.header === null && (i.header = null), i;
  }
  channelHasField(t) {
    return !!this.facet[t];
  }
  fieldDef(t) {
    return this.facet[t];
  }
  parseData() {
    this.component.data = a1(this), this.child.parseData();
  }
  parseLayoutSize() {
    Z3(this);
  }
  parseSelections() {
    this.child.parseSelections(), this.component.selection = this.child.component.selection;
  }
  parseMarkGroup() {
    this.child.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    this.child.parseAxesAndHeaders(), K0e(this);
  }
  assembleSelectionTopLevelSignals(t) {
    return this.child.assembleSelectionTopLevelSignals(t);
  }
  assembleSignals() {
    return this.child.assembleSignals(), [];
  }
  assembleSelectionData(t) {
    return this.child.assembleSelectionData(t);
  }
  getHeaderLayoutMixins() {
    const t = {};
    for (const n of Yn)
      for (const i of q3) {
        const r = this.component.layoutHeaders[n], a = r[i], { facetFieldDef: s } = r;
        if (s) {
          const o = Hu("titleOrient", s.header, this.config, n);
          if (["right", "bottom"].includes(o)) {
            const u = Vm(n, o);
            t.titleAnchor ?? (t.titleAnchor = {}), t.titleAnchor[u] = "end";
          }
        }
        if (a != null && a[0]) {
          const o = n === "row" ? "height" : "width", u = i === "header" ? "headerBand" : "footerBand";
          n !== "facet" && !this.child.component.layoutSize.get(o) && (t[u] ?? (t[u] = {}), t[u][n] = 0.5), r.title && (t.offset ?? (t.offset = {}), t.offset[n === "row" ? "rowTitle" : "columnTitle"] = 10);
        }
      }
    return t;
  }
  assembleDefaultLayout() {
    const { column: t, row: n } = this.facet, i = t ? this.columnDistinctSignal() : n ? 1 : void 0;
    let r = "all";
    return (!n && this.component.resolve.scale.x === "independent" || !t && this.component.resolve.scale.y === "independent") && (r = "none"), {
      ...this.getHeaderLayoutMixins(),
      ...i ? { columns: i } : {},
      bounds: "full",
      align: r
    };
  }
  assembleLayoutSignals() {
    return this.child.assembleLayoutSignals();
  }
  columnDistinctSignal() {
    if (!(this.parent && this.parent instanceof Pc))
      return { signal: `length(data('${this.getName("column_domain")}'))` };
  }
  assembleGroupStyle() {
  }
  assembleGroup(t) {
    return this.parent && this.parent instanceof Pc ? {
      ...this.channelHasField("column") ? {
        encode: {
          update: {
            // TODO(https://github.com/vega/vega-lite/issues/2759):
            // Correct the signal for facet of concat of facet_column
            columns: { field: H(this.facet.column, { prefix: "distinct" }) }
          }
        }
      } : {},
      ...super.assembleGroup(t)
    } : super.assembleGroup(t);
  }
  /**
   * Aggregate cardinality for calculating size
   */
  getCardinalityAggregateForChild() {
    const t = [], n = [], i = [];
    if (this.child instanceof Pc) {
      if (this.child.channelHasField("column")) {
        const r = H(this.child.facet.column);
        t.push(r), n.push("distinct"), i.push(`distinct_${r}`);
      }
    } else
      for (const r of kr) {
        const a = this.child.component.scales[r];
        if (a && !a.merged) {
          const s = a.get("type"), o = a.get("range");
          if (gt(s) && ms(o)) {
            const u = Ym(this.child, r), l = K3(u);
            l ? (t.push(l), n.push("distinct"), i.push(`distinct_${l}`)) : q(JE(r));
          }
        }
      }
    return { fields: t, ops: n, as: i };
  }
  assembleFacet() {
    const { name: t, data: n } = this.component.data.facetRoot, { row: i, column: r } = this.facet, { fields: a, ops: s, as: o } = this.getCardinalityAggregateForChild(), u = [];
    for (const c of Yn) {
      const f = this.facet[c];
      if (f) {
        u.push(H(f));
        const { bin: d, sort: h } = f;
        if (De(d) && u.push(H(f, { binSuffix: "end" })), or(h)) {
          const { field: p, op: g = Rm } = h, m = Vv(f, h);
          i && r ? (a.push(m), s.push("max"), o.push(m)) : (a.push(p), s.push(g), o.push(m));
        } else if (R(h)) {
          const p = Wu(f, c);
          a.push(p), s.push("max"), o.push(p);
        }
      }
    }
    const l = !!i && !!r;
    return {
      name: t,
      data: n,
      groupby: u,
      ...l || a.length > 0 ? {
        aggregate: {
          ...l ? { cross: l } : {},
          ...a.length ? { fields: a, ops: s, as: o } : {}
        }
      } : {}
    };
  }
  facetSortFields(t) {
    const { facet: n } = this, i = n[t];
    return i ? or(i.sort) ? [Vv(i, i.sort, { expr: "datum" })] : R(i.sort) ? [Wu(i, t, { expr: "datum" })] : [H(i, { expr: "datum" })] : [];
  }
  facetSortOrder(t) {
    const { facet: n } = this, i = n[t];
    if (i) {
      const { sort: r } = i;
      return [(or(r) ? r.order : !R(r) && r) || "ascending"];
    }
    return [];
  }
  assembleLabelTitle() {
    var r;
    const { facet: t, config: n } = this;
    if (t.facet)
      return jv(t.facet, "facet", n);
    const i = {
      row: ["top", "bottom"],
      column: ["left", "right"]
    };
    for (const a of U3)
      if (t[a]) {
        const s = Hu("labelOrient", (r = t[a]) == null ? void 0 : r.header, n, a);
        if (i[a].includes(s))
          return jv(t[a], a, n);
      }
  }
  assembleMarks() {
    const { child: t } = this, n = this.component.data.facetRoot, i = V0e(n), r = t.assembleGroupEncodeEntry(!1), a = this.assembleLabelTitle() || t.assembleTitle(), s = t.assembleGroupStyle();
    return [{
      name: this.getName("cell"),
      type: "group",
      ...a ? { title: a } : {},
      ...s ? { style: s } : {},
      from: {
        facet: this.assembleFacet()
      },
      // TODO: move this to after data
      sort: {
        field: Yn.map((u) => this.facetSortFields(u)).flat(),
        order: Yn.map((u) => this.facetSortOrder(u)).flat()
      },
      ...i.length > 0 ? { data: i } : {},
      ...r ? { encode: { update: r } } : {},
      ...t.assembleGroup(dpe(this, []))
    }];
  }
  getMapping() {
    return this.facet;
  }
}
function nme(e, t) {
  const { row: n, column: i } = t;
  if (n && i) {
    let r = null;
    for (const a of [n, i])
      if (or(a.sort)) {
        const { field: s, op: o = Rm } = a.sort;
        e = r = new zo(e, {
          joinaggregate: [
            {
              op: o,
              field: s,
              as: Vv(a, a.sort, { forAs: !0 })
            }
          ],
          groupby: [H(a)]
        });
      }
    return r;
  }
  return null;
}
function jN(e, t) {
  var n, i, r, a;
  for (const s of t) {
    const o = s.data;
    if (e.name && s.hasName() && e.name !== s.dataName)
      continue;
    const u = (n = e.format) == null ? void 0 : n.mesh, l = (i = o.format) == null ? void 0 : i.feature;
    if (u && l)
      continue;
    const c = (r = e.format) == null ? void 0 : r.feature;
    if ((c || l) && c !== l)
      continue;
    const f = (a = o.format) == null ? void 0 : a.mesh;
    if (!((u || f) && u !== f)) {
      if (xf(e) && xf(o)) {
        if (Tn(e.values, o.values))
          return s;
      } else if (Uu(e) && Uu(o)) {
        if (e.url === o.url)
          return s;
      } else if (MD(e) && e.name === s.dataName)
        return s;
    }
  }
  return null;
}
function ime(e, t) {
  if (e.data || !e.parent) {
    if (e.data === null) {
      const i = new $o({ values: [] });
      return t.push(i), i;
    }
    const n = jN(e.data, t);
    if (n)
      return za(e.data) || (n.data.format = kR({}, e.data.format, n.data.format)), !n.hasName() && e.data.name && (n.dataName = e.data.name), n;
    {
      const i = new $o(e.data);
      return t.push(i), i;
    }
  } else
    return e.parent.component.data.facetRoot ? e.parent.component.data.facetRoot : e.parent.component.data.main;
}
function rme(e, t, n) {
  let i = 0;
  for (const r of t.transforms) {
    let a, s;
    if (Hhe(r))
      s = e = new Gu(e, r), a = "derived";
    else if (N3(r)) {
      const o = Yge(r);
      s = e = Lt.makeWithAncestors(e, {}, o, n) ?? e, e = new wl(e, t, r.filter);
    } else if (AD(r))
      s = e = lr.makeFromTransform(e, r, t), a = "number";
    else if (Xhe(r))
      a = "date", n.getWithExplicit(r.field).value === void 0 && (e = new Lt(e, { [r.field]: a }), n.set(r.field, a, !1)), s = e = ur.makeFromTransform(e, r);
    else if (Yhe(r))
      s = e = Ai.makeFromTransform(e, r), a = "number", j3(t) && (e = new is(e));
    else if (SD(r))
      s = e = Ef.make(e, t, r, i++), a = "derived";
    else if (qhe(r))
      s = e = new Sl(e, r), a = "number";
    else if (Ghe(r))
      s = e = new zo(e, r), a = "number";
    else if (Khe(r))
      s = e = Hr.makeFromTransform(e, r), a = "derived";
    else if (Jhe(r))
      s = e = new Zm(e, r), a = "derived";
    else if (Qhe(r))
      s = e = new Jm(e, r), a = "derived";
    else if (Whe(r))
      s = e = new Qm(e, r), a = "derived";
    else if (Phe(r))
      s = e = new i1(e, r), a = "derived";
    else if (Uhe(r))
      e = new r1(e, r);
    else if (Vhe(r))
      s = e = eo.makeFromTransform(e, r), a = "derived";
    else if (zhe(r))
      s = e = new Km(e, r), a = "derived";
    else if (Ihe(r))
      s = e = new t1(e, r), a = "derived";
    else if (Bhe(r))
      s = e = new n1(e, r), a = "derived";
    else if (jhe(r))
      s = e = new e1(e, r), a = "derived";
    else {
      q(bce(r));
      continue;
    }
    if (s && a !== void 0)
      for (const o of s.producedFields() ?? [])
        n.set(o, a, !1);
  }
  return e;
}
function a1(e) {
  var g;
  let t = ime(e, e.component.data.sources);
  const { outputNodes: n, outputNodeRefCounts: i } = e.component.data, r = e.data, s = !(r && (za(r) || Uu(r) || xf(r))) && e.parent ? e.parent.component.data.ancestorParse.clone() : new cpe();
  za(r) ? (OD(r) ? t = new Id(t, r.sequence) : L3(r) && (t = new zd(t, r.graticule)), s.parseNothing = !0) : ((g = r == null ? void 0 : r.format) == null ? void 0 : g.parse) === null && (s.parseNothing = !0), t = Lt.makeExplicit(t, e, s) ?? t, t = new is(t);
  const o = e.parent && Al(e.parent);
  (We(e) || ki(e)) && o && (t = lr.makeFromEncoding(t, e) ?? t), e.transforms.length > 0 && (t = rme(t, e, s));
  const u = Jge(e), l = Kge(e);
  t = Lt.makeWithAncestors(t, {}, { ...u, ...l }, s) ?? t, We(e) && (t = pu.parseAll(t, e), t = wf.parseAll(t, e)), (We(e) || ki(e)) && (o || (t = lr.makeFromEncoding(t, e) ?? t), t = ur.makeFromEncoding(t, e) ?? t, t = Gu.parseAllForSortIndex(t, e));
  const c = e.getDataName(Te.Raw), f = new tn(t, c, Te.Raw, i);
  if (n[c] = f, t = f, We(e)) {
    const m = Ai.makeFromEncoding(t, e);
    m && (t = m, j3(e) && (t = new is(t))), t = eo.makeFromEncoding(t, e) ?? t, t = Hr.makeFromEncoding(t, e) ?? t;
  }
  We(e) && (t = $f.make(t, e) ?? t);
  const d = e.getDataName(Te.Main), h = new tn(t, d, Te.Main, i);
  n[d] = h, t = h, We(e) && Hpe(e, h);
  let p = null;
  if (ki(e)) {
    const m = e.getName("facet");
    t = nme(t, e.facet) ?? t, p = new El(t, e, m, h.getSource()), n[m] = p;
  }
  return {
    ...e.component.data,
    outputNodes: n,
    outputNodeRefCounts: i,
    raw: f,
    main: h,
    facetRoot: p,
    ancestorParse: s
  };
}
class ame extends Q3 {
  constructor(t, n, i, r) {
    var a, s, o, u;
    super(t, "concat", n, i, r, t.resolve), (((s = (a = t.resolve) == null ? void 0 : a.axis) == null ? void 0 : s.x) === "shared" || ((u = (o = t.resolve) == null ? void 0 : o.axis) == null ? void 0 : u.y) === "shared") && q(gce), this.children = this.getChildren(t).map((l, c) => r5(l, this, this.getName(`concat_${c}`), void 0, r));
  }
  parseData() {
    this.component.data = a1(this);
    for (const t of this.children)
      t.parseData();
  }
  parseSelections() {
    this.component.selection = {};
    for (const t of this.children) {
      t.parseSelections();
      for (const n of I(t.component.selection))
        this.component.selection[n] = t.component.selection[n];
    }
  }
  parseMarkGroup() {
    for (const t of this.children)
      t.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    for (const t of this.children)
      t.parseAxesAndHeaders();
  }
  getChildren(t) {
    return Bm(t) ? t.vconcat : T3(t) ? t.hconcat : t.concat;
  }
  parseLayoutSize() {
    Z0e(this);
  }
  parseAxisGroup() {
    return null;
  }
  assembleSelectionTopLevelSignals(t) {
    return this.children.reduce((n, i) => i.assembleSelectionTopLevelSignals(n), t);
  }
  assembleSignals() {
    return this.children.forEach((t) => t.assembleSignals()), [];
  }
  assembleLayoutSignals() {
    const t = G3(this);
    for (const n of this.children)
      t.push(...n.assembleLayoutSignals());
    return t;
  }
  assembleSelectionData(t) {
    return this.children.reduce((n, i) => i.assembleSelectionData(n), t);
  }
  assembleMarks() {
    return this.children.map((t) => {
      const n = t.assembleTitle(), i = t.assembleGroupStyle(), r = t.assembleGroupEncodeEntry(!1);
      return {
        type: "group",
        name: t.getName("group"),
        ...n ? { title: n } : {},
        ...i ? { style: i } : {},
        ...r ? { encode: { update: r } } : {},
        ...t.assembleGroup()
      };
    });
  }
  assembleGroupStyle() {
  }
  assembleDefaultLayout() {
    const t = this.layout.columns;
    return {
      ...t != null ? { columns: t } : {},
      bounds: "full",
      // Use align each so it can work with multiple plots with different size
      align: "each"
    };
  }
}
function sme(e) {
  return e === !1 || e === null;
}
const ome = {
  disable: 1,
  gridScale: 1,
  scale: 1,
  ...YT,
  labelExpr: 1,
  encode: 1
}, UN = I(ome);
class e5 extends ca {
  constructor(t = {}, n = {}, i = !1) {
    super(), this.explicit = t, this.implicit = n, this.mainExtracted = i;
  }
  clone() {
    return new e5(se(this.explicit), se(this.implicit), this.mainExtracted);
  }
  hasAxisPart(t) {
    return t === "axis" ? !0 : t === "grid" || t === "title" ? !!this.get(t) : !sme(this.get(t));
  }
  hasOrientSignalRef() {
    return Q(this.explicit.orient);
  }
}
function ume(e, t, n) {
  const { encoding: i, config: r } = e, a = it(i[t]) ?? it(i[Ar(t)]), s = e.axis(t) || {}, { format: o, formatType: u } = s;
  if (bo(u))
    return {
      text: wi({
        fieldOrDatumDef: a,
        field: "datum.value",
        format: o,
        formatType: u,
        config: r
      }),
      ...n
    };
  if (o === void 0 && u === void 0 && r.customFormatTypes) {
    if (Iu(a) === "quantitative") {
      if (Bu(a) && a.stack === "normalize" && r.normalizedNumberFormatType)
        return {
          text: wi({
            fieldOrDatumDef: a,
            field: "datum.value",
            format: r.normalizedNumberFormat,
            formatType: r.normalizedNumberFormatType,
            config: r
          }),
          ...n
        };
      if (r.numberFormatType)
        return {
          text: wi({
            fieldOrDatumDef: a,
            field: "datum.value",
            format: r.numberFormat,
            formatType: r.numberFormatType,
            config: r
          }),
          ...n
        };
    }
    if (Iu(a) === "temporal" && r.timeFormatType && j(a) && !a.timeUnit)
      return {
        text: wi({
          fieldOrDatumDef: a,
          field: "datum.value",
          format: r.timeFormat,
          formatType: r.timeFormatType,
          config: r
        }),
        ...n
      };
  }
  return n;
}
function lme(e) {
  return kr.reduce((t, n) => (e.component.scales[n] && (t[n] = [mme(n, e)]), t), {});
}
const cme = {
  bottom: "top",
  top: "bottom",
  left: "right",
  right: "left"
};
function fme(e) {
  const { axes: t, resolve: n } = e.component, i = { top: 0, bottom: 0, right: 0, left: 0 };
  for (const r of e.children) {
    r.parseAxesAndHeaders();
    for (const a of I(r.component.axes))
      n.axis[a] = W3(e.component.resolve, a), n.axis[a] === "shared" && (t[a] = dme(t[a], r.component.axes[a]), t[a] || (n.axis[a] = "independent", delete t[a]));
  }
  for (const r of kr) {
    for (const a of e.children)
      if (a.component.axes[r]) {
        if (n.axis[r] === "independent") {
          t[r] = (t[r] ?? []).concat(a.component.axes[r]);
          for (const s of a.component.axes[r]) {
            const { value: o, explicit: u } = s.getWithExplicit("orient");
            if (!Q(o)) {
              if (i[o] > 0 && !u) {
                const l = cme[o];
                i[o] > i[l] && s.set("orient", l, !1);
              }
              i[o]++;
            }
          }
        }
        delete a.component.axes[r];
      }
    if (n.axis[r] === "independent" && t[r] && t[r].length > 1)
      for (const [a, s] of (t[r] || []).entries())
        a > 0 && s.get("grid") && !s.explicit.grid && (s.implicit.grid = !1);
  }
}
function dme(e, t) {
  if (e) {
    if (e.length !== t.length)
      return;
    const n = e.length;
    for (let i = 0; i < n; i++) {
      const r = e[i], a = t[i];
      if (!!r != !!a)
        return;
      if (r && a) {
        const s = r.getWithExplicit("orient"), o = a.getWithExplicit("orient");
        if (s.explicit && o.explicit && s.value !== o.value)
          return;
        e[i] = hme(r, a);
      }
    }
  } else
    return t.map((n) => n.clone());
  return e;
}
function hme(e, t) {
  for (const n of UN) {
    const i = es(
      e.getWithExplicit(n),
      t.getWithExplicit(n),
      n,
      "axis",
      // Tie breaker function
      (r, a) => {
        switch (n) {
          case "title":
            return eT(r, a);
          case "gridScale":
            return {
              explicit: r.explicit,
              value: Ke(r.value, a.value)
            };
        }
        return Um(r, a, n, "axis");
      }
    );
    e.setWithExplicit(n, i);
  }
  return e;
}
function pme(e, t, n, i, r) {
  if (t === "disable")
    return n !== void 0;
  switch (n = n || {}, t) {
    case "titleAngle":
    case "labelAngle":
      return e === (Q(n.labelAngle) ? n.labelAngle : bf(n.labelAngle));
    case "values":
      return !!n.values;
    case "encode":
      return !!n.encoding || !!n.labelAngle;
    case "title":
      if (e === sN(i, r))
        return !0;
  }
  return e === n[t];
}
const gme = /* @__PURE__ */ new Set([
  "grid",
  "translate",
  // the rest are not axis configs in Vega, but are in VL, so we need to set too.
  "format",
  "formatType",
  "orient",
  "labelExpr",
  "tickCount",
  "position",
  "tickMinStep"
]);
function mme(e, t) {
  var y, b;
  let n = t.axis(e);
  const i = new e5(), r = it(t.encoding[e]), { mark: a, config: s } = t, o = (n == null ? void 0 : n.orient) || ((y = s[e === "x" ? "axisX" : "axisY"]) == null ? void 0 : y.orient) || ((b = s.axis) == null ? void 0 : b.orient) || nge(e), u = t.getScaleComponent(e).get("type"), l = Ype(e, u, o, t.config), c = n !== void 0 ? !n : Iv("disable", s.style, n == null ? void 0 : n.style, l).configValue;
  if (i.set("disable", c, n !== void 0), c)
    return i;
  n = n || {};
  const f = Zpe(r, n, e, s.style, l), d = DT(n.formatType, r, u), h = TT(r, r.type, n.format, n.formatType, s, !0), p = {
    fieldOrDatumDef: r,
    axis: n,
    channel: e,
    model: t,
    scaleType: u,
    orient: o,
    labelAngle: f,
    format: h,
    formatType: d,
    mark: a,
    config: s
  };
  for (const v of UN) {
    const x = v in s7 ? s7[v](p) : T4(v) ? n[v] : void 0, w = x !== void 0, E = pme(x, v, n, t, e);
    if (w && E)
      i.set(v, x, E);
    else {
      const { configValue: $ = void 0, configFrom: S = void 0 } = T4(v) && v !== "values" ? Iv(v, s.style, n.style, l) : {}, A = $ !== void 0;
      w && !A ? i.set(v, x, E) : (
        // Cases need implicit values
        // 1. Axis config that aren't available in Vega
        (S !== "vgAxisConfig" || // 2. Certain properties are always included (see `propsToAlwaysIncludeConfig`'s declaration for more details)
        gme.has(v) && A || // 3. Conditional axis values and signals
        Ld($) || Q($)) && i.set(v, $, !1)
      );
    }
  }
  const g = n.encoding ?? {}, m = XT.reduce((v, x) => {
    if (!i.hasAxisPart(x))
      return v;
    const w = dN(g[x] ?? {}, t), E = x === "labels" ? ume(t, e, w) : w;
    return E !== void 0 && !ke(E) && (v[x] = { update: E }), v;
  }, {});
  return ke(m) || i.set("encode", m, !!n.encoding || n.labelAngle !== void 0), i;
}
function yme({ encoding: e, size: t }) {
  for (const n of kr) {
    const i = Sn(n);
    mr(t[i]) && Ta(e[n]) && (delete t[i], q(aT(i)));
  }
  return t;
}
const bme = {
  vgMark: "arc",
  encodeEntry: (e) => ({
    ...si(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Nt("x", e, { defaultPos: "mid" }),
    ...Nt("y", e, { defaultPos: "mid" }),
    // arcs are rectangles in polar coordinates
    ...ts(e, "radius"),
    ...ts(e, "theta")
  })
}, vme = {
  vgMark: "area",
  encodeEntry: (e) => ({
    ...si(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "include",
      size: "ignore",
      theta: "ignore"
    }),
    ...Og("x", e, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: e.markDef.orient === "horizontal"
    }),
    ...Og("y", e, {
      defaultPos: "zeroOrMin",
      defaultPos2: "zeroOrMin",
      range: e.markDef.orient === "vertical"
    }),
    ...B3(e)
  })
}, xme = {
  vgMark: "rect",
  encodeEntry: (e) => ({
    ...si(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    }),
    ...ts(e, "x"),
    ...ts(e, "y")
  })
}, $me = {
  vgMark: "shape",
  encodeEntry: (e) => ({
    ...si(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    })
  }),
  postEncodingTransform: (e) => {
    const { encoding: t } = e, n = t.shape;
    return [{
      type: "geoshape",
      projection: e.projectionName(),
      // as: 'shape',
      ...n && j(n) && n.type === xl ? { field: H(n, { expr: "datum" }) } : {}
    }];
  }
}, wme = {
  vgMark: "image",
  encodeEntry: (e) => ({
    ...si(e, {
      align: "ignore",
      baseline: "ignore",
      color: "ignore",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    }),
    ...ts(e, "x"),
    ...ts(e, "y"),
    ...z3(e, "url")
  })
}, Eme = {
  vgMark: "line",
  encodeEntry: (e) => ({
    ...si(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "ignore",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Nt("x", e, { defaultPos: "mid" }),
    ...Nt("y", e, { defaultPos: "mid" }),
    ...ct("size", e, {
      vgChannel: "strokeWidth"
      // VL's line size is strokeWidth
    }),
    ...B3(e)
  })
}, Sme = {
  vgMark: "trail",
  encodeEntry: (e) => ({
    ...si(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "include",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Nt("x", e, { defaultPos: "mid" }),
    ...Nt("y", e, { defaultPos: "mid" }),
    ...ct("size", e),
    ...B3(e)
  })
};
function t5(e, t) {
  const { config: n } = e;
  return {
    ...si(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      size: "include",
      orient: "ignore",
      theta: "ignore"
    }),
    ...Nt("x", e, { defaultPos: "mid" }),
    ...Nt("y", e, { defaultPos: "mid" }),
    ...ct("size", e),
    ...ct("angle", e),
    ...Ame(e, n, t)
  };
}
function Ame(e, t, n) {
  return n ? { shape: { value: n } } : ct("shape", e);
}
const kme = {
  vgMark: "symbol",
  encodeEntry: (e) => t5(e)
}, Cme = {
  vgMark: "symbol",
  encodeEntry: (e) => t5(e, "circle")
}, _me = {
  vgMark: "symbol",
  encodeEntry: (e) => t5(e, "square")
}, Fme = {
  vgMark: "rect",
  encodeEntry: (e) => ({
    ...si(e, {
      align: "ignore",
      baseline: "ignore",
      color: "include",
      orient: "ignore",
      size: "ignore",
      theta: "ignore"
    }),
    ...ts(e, "x"),
    ...ts(e, "y")
  })
}, Mme = {
  vgMark: "rule",
  encodeEntry: (e) => {
    const { markDef: t } = e, n = t.orient;
    return !e.encoding.x && !e.encoding.y && !e.encoding.latitude && !e.encoding.longitude ? {} : {
      ...si(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...Og("x", e, {
        defaultPos: n === "horizontal" ? "zeroOrMax" : "mid",
        defaultPos2: "zeroOrMin",
        range: n !== "vertical"
        // include x2 for horizontal or line segment rule
      }),
      ...Og("y", e, {
        defaultPos: n === "vertical" ? "zeroOrMax" : "mid",
        defaultPos2: "zeroOrMin",
        range: n !== "horizontal"
        // include y2 for vertical or line segment rule
      }),
      ...ct("size", e, {
        vgChannel: "strokeWidth"
        // VL's rule size is strokeWidth
      })
    };
  }
}, Ome = {
  vgMark: "text",
  encodeEntry: (e) => {
    const { config: t, encoding: n } = e;
    return {
      ...si(e, {
        align: "include",
        baseline: "include",
        color: "include",
        size: "ignore",
        orient: "ignore",
        theta: "include"
      }),
      ...Nt("x", e, { defaultPos: "mid" }),
      ...Nt("y", e, { defaultPos: "mid" }),
      ...z3(e),
      ...ct("size", e, {
        vgChannel: "fontSize"
        // VL's text size is fontSize
      }),
      ...ct("angle", e),
      ...n7("align", Rme(e.markDef, n, t)),
      ...n7("baseline", Tme(e.markDef, n, t)),
      ...Nt("radius", e, { defaultPos: null }),
      ...Nt("theta", e, { defaultPos: null })
    };
  }
};
function Rme(e, t, n) {
  if (Ee("align", e, n) === void 0)
    return "center";
}
function Tme(e, t, n) {
  if (Ee("baseline", e, n) === void 0)
    return "middle";
}
const Dme = {
  vgMark: "rect",
  encodeEntry: (e) => {
    const { config: t, markDef: n } = e, i = n.orient, r = i === "horizontal" ? "width" : "height", a = i === "horizontal" ? "height" : "width";
    return {
      ...si(e, {
        align: "ignore",
        baseline: "ignore",
        color: "include",
        orient: "ignore",
        size: "ignore",
        theta: "ignore"
      }),
      ...Nt("x", e, { defaultPos: "mid", vgChannel: "xc" }),
      ...Nt("y", e, { defaultPos: "mid", vgChannel: "yc" }),
      // size / thickness => width / height
      ...ct("size", e, {
        defaultValue: Nme(e),
        vgChannel: r
      }),
      [a]: ze(Ee("thickness", n, t))
    };
  }
};
function Nme(e) {
  const { config: t, markDef: n } = e, { orient: i } = n, r = i === "horizontal" ? "width" : "height", a = e.getScaleComponent(i === "horizontal" ? "x" : "y"), s = Ee("size", n, t, { vgChannel: r }) ?? t.tick.bandSize;
  if (s !== void 0)
    return s;
  {
    const o = a ? a.get("range") : void 0;
    return o && ms(o) && ye(o.step) ? o.step * 3 / 4 : Fg(t.view, r) * 3 / 4;
  }
}
const yh = {
  arc: bme,
  area: vme,
  bar: xme,
  circle: Cme,
  geoshape: $me,
  image: wme,
  line: Eme,
  point: kme,
  rect: Fme,
  rule: Mme,
  square: _me,
  text: Ome,
  tick: Dme,
  trail: Sme
};
function Lme(e) {
  if (pe([Mm, _m, Gfe], e.mark)) {
    const t = eD(e.mark, e.encoding);
    if (t.length > 0)
      return Pme(e, t);
  } else if (e.mark === Fm) {
    const t = Cv.some((n) => Ee(n, e.markDef, e.config));
    if (e.stack && !e.fieldDef("size") && t)
      return zme(e);
  }
  return n5(e);
}
const w7 = "faceted_path_";
function Pme(e, t) {
  return [
    {
      name: e.getName("pathgroup"),
      type: "group",
      from: {
        facet: {
          name: w7 + e.requestDataName(Te.Main),
          data: e.requestDataName(Te.Main),
          groupby: t
        }
      },
      encode: {
        update: {
          width: { field: { group: "width" } },
          height: { field: { group: "height" } }
        }
      },
      // With subfacet for line/area group, need to use faceted data from above.
      marks: n5(e, { fromPrefix: w7 })
    }
  ];
}
const E7 = "stack_group_";
function zme(e) {
  var l;
  const [t] = n5(e, { fromPrefix: E7 }), n = e.scaleName(e.stack.fieldChannel), i = (c = {}) => e.vgField(e.stack.fieldChannel, c), r = (c, f) => {
    const d = [
      i({ prefix: "min", suffix: "start", expr: f }),
      i({ prefix: "max", suffix: "start", expr: f }),
      i({ prefix: "min", suffix: "end", expr: f }),
      i({ prefix: "max", suffix: "end", expr: f })
    ];
    return `${c}(${d.map((h) => `scale('${n}',${h})`).join(",")})`;
  };
  let a, s;
  e.stack.fieldChannel === "x" ? (a = {
    ...Tu(t.encode.update, ["y", "yc", "y2", "height", ...Cv]),
    x: { signal: r("min", "datum") },
    x2: { signal: r("max", "datum") },
    clip: { value: !0 }
  }, s = {
    x: { field: { group: "x" }, mult: -1 },
    height: { field: { group: "height" } }
  }, t.encode.update = {
    ...mn(t.encode.update, ["y", "yc", "y2"]),
    height: { field: { group: "height" } }
  }) : (a = {
    ...Tu(t.encode.update, ["x", "xc", "x2", "width"]),
    y: { signal: r("min", "datum") },
    y2: { signal: r("max", "datum") },
    clip: { value: !0 }
  }, s = {
    y: { field: { group: "y" }, mult: -1 },
    width: { field: { group: "width" } }
  }, t.encode.update = {
    ...mn(t.encode.update, ["x", "xc", "x2"]),
    width: { field: { group: "width" } }
  });
  for (const c of Cv) {
    const f = Jr(c, e.markDef, e.config);
    t.encode.update[c] ? (a[c] = t.encode.update[c], delete t.encode.update[c]) : f && (a[c] = ze(f)), f && (t.encode.update[c] = { value: 0 });
  }
  const o = [];
  if (((l = e.stack.groupbyChannels) == null ? void 0 : l.length) > 0)
    for (const c of e.stack.groupbyChannels) {
      const f = e.fieldDef(c), d = H(f);
      d && o.push(d), (f != null && f.bin || f != null && f.timeUnit) && o.push(H(f, { binSuffix: "end" }));
    }
  return a = [
    "stroke",
    "strokeWidth",
    "strokeJoin",
    "strokeCap",
    "strokeDash",
    "strokeDashOffset",
    "strokeMiterLimit",
    "strokeOpacity"
  ].reduce((c, f) => {
    if (t.encode.update[f])
      return { ...c, [f]: t.encode.update[f] };
    {
      const d = Jr(f, e.markDef, e.config);
      return d !== void 0 ? { ...c, [f]: ze(d) } : c;
    }
  }, a), a.stroke && (a.strokeForeground = { value: !0 }, a.strokeOffset = { value: 0 }), [
    {
      type: "group",
      from: {
        facet: {
          data: e.requestDataName(Te.Main),
          name: E7 + e.requestDataName(Te.Main),
          groupby: o,
          aggregate: {
            fields: [
              i({ suffix: "start" }),
              i({ suffix: "start" }),
              i({ suffix: "end" }),
              i({ suffix: "end" })
            ],
            ops: ["min", "max", "min", "max"]
          }
        }
      },
      encode: {
        update: a
      },
      marks: [
        {
          type: "group",
          encode: { update: s },
          marks: [t]
        }
      ]
    }
  ];
}
function Ime(e) {
  var o;
  const { encoding: t, stack: n, mark: i, markDef: r, config: a } = e, s = t.order;
  if (!(!R(s) && Oi(s) && Av(s.value) || !s && Av(Ee("order", r, a)))) {
    if ((R(s) || j(s)) && !n)
      return JR(s, { expr: "datum" });
    if (ys(i)) {
      const u = r.orient === "horizontal" ? "y" : "x", l = t[u];
      if (j(l)) {
        const c = l.sort;
        if (R(c))
          return {
            field: H(l, { prefix: u, suffix: "sort_index", expr: "datum" })
          };
        if (or(c))
          return {
            field: H({
              // FIXME: this op might not already exist?
              // FIXME: what if dimensionChannel (x or y) contains custom domain?
              aggregate: E3(e.encoding) ? c.op : void 0,
              field: c.field
            }, { expr: "datum" })
          };
        if (LT(c)) {
          const f = e.fieldDef(c.encoding);
          return {
            field: H(f, { expr: "datum" }),
            order: c.order
          };
        } else
          return c === null ? void 0 : {
            field: H(l, {
              // For stack with imputation, we only have bin_mid
              binSuffix: (o = e.stack) != null && o.impute ? "mid" : void 0,
              expr: "datum"
            })
          };
      }
      return;
    }
  }
}
function n5(e, t = { fromPrefix: "" }) {
  const { mark: n, markDef: i, encoding: r, config: a } = e, s = Ke(i.clip, Bme(e), jme(e)), o = YR(i), u = r.key, l = Ime(e), c = Ume(e), f = Ee("aria", i, a), d = yh[n].postEncodingTransform ? yh[n].postEncodingTransform(e) : null;
  return [
    {
      name: e.getName("marks"),
      type: yh[n].vgMark,
      ...s ? { clip: !0 } : {},
      ...o ? { style: o } : {},
      ...u ? { key: u.field } : {},
      ...l ? { sort: l } : {},
      ...c || {},
      ...f === !1 ? { aria: f } : {},
      from: { data: t.fromPrefix + e.requestDataName(Te.Main) },
      encode: {
        update: yh[n].encodeEntry(e)
      },
      ...d ? {
        transform: d
      } : {}
    }
  ];
}
function Bme(e) {
  const t = e.getScaleComponent("x"), n = e.getScaleComponent("y");
  return t != null && t.get("selectionExtent") || n != null && n.get("selectionExtent") ? !0 : void 0;
}
function jme(e) {
  const t = e.component.projection;
  return t && !t.isFit ? !0 : void 0;
}
function Ume(e) {
  if (!e.component.selection)
    return null;
  const t = I(e.component.selection).length;
  let n = t, i = e.parent;
  for (; i && n === 0; )
    n = I(i.component.selection).length, i = i.parent;
  return n ? {
    interactive: t > 0 || e.mark === "geoshape" || !!e.encoding.tooltip
  } : null;
}
class qN extends zN {
  constructor(t, n, i, r = {}, a) {
    super(t, "unit", n, i, a, void 0, N4(t) ? t.view : void 0), this.specifiedScales = {}, this.specifiedAxes = {}, this.specifiedLegends = {}, this.specifiedProjection = {}, this.selection = [], this.children = [];
    const s = pr(t.mark) ? { ...t.mark } : { type: t.mark }, o = s.type;
    s.filled === void 0 && (s.filled = khe(s, a, {
      graticule: t.data && L3(t.data)
    }));
    const u = this.encoding = Mde(t.encoding || {}, o, s.filled, a);
    this.markDef = $D(s, u, a), this.size = yme({
      encoding: u,
      size: N4(t) ? {
        ...r,
        ...t.width ? { width: t.width } : {},
        ...t.height ? { height: t.height } : {}
      } : r
    }), this.stack = xD(this.markDef, u), this.specifiedScales = this.initScales(o, u), this.specifiedAxes = this.initAxes(u), this.specifiedLegends = this.initLegends(u), this.specifiedProjection = t.projection, this.selection = (t.params ?? []).filter((l) => O3(l));
  }
  get hasProjection() {
    const { encoding: t } = this, n = this.mark === _T, i = t && Fle.some((r) => le(t[r]));
    return n || i;
  }
  /**
   * Return specified Vega-Lite scale domain for a particular channel
   * @param channel
   */
  scaleDomain(t) {
    const n = this.specifiedScales[t];
    return n ? n.domain : void 0;
  }
  axis(t) {
    return this.specifiedAxes[t];
  }
  legend(t) {
    return this.specifiedLegends[t];
  }
  initScales(t, n) {
    return Sm.reduce((i, r) => {
      const a = it(n[r]);
      return a && (i[r] = this.initScale(a.scale ?? {})), i;
    }, {});
  }
  initScale(t) {
    const { domain: n, range: i } = t, r = hn(t);
    return R(n) && (r.domain = n.map(On)), R(i) && (r.range = i.map(On)), r;
  }
  initAxes(t) {
    return kr.reduce((n, i) => {
      const r = t[i];
      if (le(r) || i === je && le(t.x2) || i === bt && le(t.y2)) {
        const a = le(r) ? r.axis : void 0;
        n[i] = a && this.initAxis({ ...a });
      }
      return n;
    }, {});
  }
  initAxis(t) {
    const n = I(t), i = {};
    for (const r of n) {
      const a = t[r];
      i[r] = Ld(a) ? XR(a) : On(a);
    }
    return i;
  }
  initLegends(t) {
    return Ile.reduce((n, i) => {
      const r = it(t[i]);
      if (r && jle(i)) {
        const a = r.legend;
        n[i] = a && hn(a);
      }
      return n;
    }, {});
  }
  parseData() {
    this.component.data = a1(this);
  }
  parseLayoutSize() {
    eme(this);
  }
  parseSelections() {
    this.component.selection = Wpe(this, this.selection);
  }
  parseMarkGroup() {
    this.component.mark = Lme(this);
  }
  parseAxesAndHeaders() {
    this.component.axes = lme(this);
  }
  assembleSelectionTopLevelSignals(t) {
    return hpe(this, t);
  }
  assembleSignals() {
    return [...iN(this), ...fpe(this, [])];
  }
  assembleSelectionData(t) {
    return ppe(this, t);
  }
  assembleLayout() {
    return null;
  }
  assembleLayoutSignals() {
    return G3(this);
  }
  assembleMarks() {
    let t = this.component.mark ?? [];
    return (!this.parent || !Al(this.parent)) && (t = DD(this, t)), t.map(this.correctDataNames);
  }
  assembleGroupStyle() {
    const { style: t } = this.view || {};
    return t !== void 0 ? t : this.encoding.x || this.encoding.y ? "cell" : "view";
  }
  getMapping() {
    return this.encoding;
  }
  get mark() {
    return this.markDef.type;
  }
  channelHasField(t) {
    return Qs(this.encoding, t);
  }
  fieldDef(t) {
    const n = this.encoding[t];
    return gr(n);
  }
  typedFieldDef(t) {
    const n = this.fieldDef(t);
    return sn(n) ? n : null;
  }
}
class i5 extends Q3 {
  constructor(t, n, i, r, a) {
    super(t, "layer", n, i, a, t.resolve, t.view);
    const s = {
      ...r,
      ...t.width ? { width: t.width } : {},
      ...t.height ? { height: t.height } : {}
    };
    this.children = t.layer.map((o, u) => {
      if (jm(o))
        return new i5(o, this, this.getName(`layer_${u}`), s, a);
      if (la(o))
        return new qN(o, this, this.getName(`layer_${u}`), s, a);
      throw new Error(KE(o));
    });
  }
  parseData() {
    this.component.data = a1(this);
    for (const t of this.children)
      t.parseData();
  }
  parseLayoutSize() {
    Q0e(this);
  }
  parseSelections() {
    this.component.selection = {};
    for (const t of this.children) {
      t.parseSelections();
      for (const n of I(t.component.selection))
        this.component.selection[n] = t.component.selection[n];
    }
  }
  parseMarkGroup() {
    for (const t of this.children)
      t.parseMarkGroup();
  }
  parseAxesAndHeaders() {
    fme(this);
  }
  assembleSelectionTopLevelSignals(t) {
    return this.children.reduce((n, i) => i.assembleSelectionTopLevelSignals(n), t);
  }
  // TODO: Support same named selections across children.
  assembleSignals() {
    return this.children.reduce((t, n) => t.concat(n.assembleSignals()), iN(this));
  }
  assembleLayoutSignals() {
    return this.children.reduce((t, n) => t.concat(n.assembleLayoutSignals()), G3(this));
  }
  assembleSelectionData(t) {
    return this.children.reduce((n, i) => i.assembleSelectionData(n), t);
  }
  assembleGroupStyle() {
    const t = /* @__PURE__ */ new Set();
    for (const i of this.children)
      for (const r of G(i.assembleGroupStyle()))
        t.add(r);
    const n = Array.from(t);
    return n.length > 1 ? n : n.length === 1 ? n[0] : void 0;
  }
  assembleTitle() {
    let t = super.assembleTitle();
    if (t)
      return t;
    for (const n of this.children)
      if (t = n.assembleTitle(), t)
        return t;
  }
  assembleLayout() {
    return null;
  }
  assembleMarks() {
    return gpe(this, this.children.flatMap((t) => t.assembleMarks()));
  }
  assembleLegends() {
    return this.children.reduce((t, n) => t.concat(n.assembleLegends()), xN(this));
  }
}
function r5(e, t, n, i, r) {
  if (Tm(e))
    return new Pc(e, t, n, r);
  if (jm(e))
    return new i5(e, t, n, i, r);
  if (la(e))
    return new qN(e, t, n, i, r);
  if (ehe(e))
    return new ame(e, t, n, r);
  throw new Error(KE(e));
}
function qme(e, t = {}) {
  t.logger && afe(t.logger), t.fieldTitle && WT(t.fieldTitle);
  try {
    const n = vD(el(t.config, e.config)), i = _D(e, n), r = r5(i, null, "", void 0, n);
    return r.parse(), h0e(r.component.data, r), {
      spec: Wme(r, Gme(e, i.autosize, n, r), e.datasets, e.usermeta),
      normalized: i
    };
  } finally {
    t.logger && sfe(), t.fieldTitle && $de();
  }
}
function Gme(e, t, n, i) {
  const r = i.component.layoutSize.get("width"), a = i.component.layoutSize.get("height");
  if (t === void 0 ? (t = { type: "pad" }, i.hasAxisOrientSignalRef() && (t.resize = !0)) : V(t) && (t = { type: t }), r && a && ope(t.type)) {
    if (r === "step" && a === "step")
      q(v4()), t.type = "pad";
    else if (r === "step" || a === "step") {
      const s = r === "step" ? "width" : "height";
      q(v4(Em(s)));
      const o = s === "width" ? "height" : "width";
      t.type = upe(o);
    }
  }
  return {
    ...I(t).length === 1 && t.type ? t.type === "pad" ? {} : { autosize: t.type } : { autosize: t },
    ...V4(n, !1),
    ...V4(e, !0)
  };
}
function Wme(e, t, n = {}, i) {
  const r = e.config ? phe(e.config) : void 0, a = [].concat(
    e.assembleSelectionData([]),
    // only assemble data in the root
    X0e(e.component.data, n)
  ), s = e.assembleProjections(), o = e.assembleTitle(), u = e.assembleGroupStyle(), l = e.assembleGroupEncodeEntry(!0);
  let c = e.assembleLayoutSignals();
  c = c.filter((h) => (h.name === "width" || h.name === "height") && h.value !== void 0 ? (t[h.name] = +h.value, !1) : !0);
  const { params: f, ...d } = t;
  return {
    $schema: "https://vega.github.io/schema/vega/v5.json",
    ...e.description ? { description: e.description } : {},
    ...d,
    ...o ? { title: o } : {},
    ...u ? { style: u } : {},
    ...l ? { encode: { update: l } } : {},
    data: a,
    ...s.length > 0 ? { projections: s } : {},
    ...e.assembleGroup([
      ...c,
      ...e.assembleSelectionTopLevelSignals([]),
      ...gD(f)
    ]),
    ...r ? { config: r } : {},
    ...i ? { usermeta: i } : {}
  };
}
const Hme = Ele.version, Vme = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  accessPathDepth: Du,
  accessPathWithDatum: BE,
  compile: qme,
  contains: pe,
  deepEqual: Tn,
  deleteNestedProperty: vg,
  duplicate: se,
  entries: Ja,
  every: PE,
  fieldIntersection: IE,
  flatAccessWithDatum: _R,
  getFirstDefined: Ke,
  hasIntersection: zE,
  hash: he,
  internalField: OR,
  isBoolean: yf,
  isEmpty: ke,
  isEqual: Ale,
  isInternalField: RR,
  isNullOrFalse: Av,
  isNumeric: ym,
  keys: I,
  logicalExpr: Nc,
  mergeDeep: kR,
  never: AR,
  normalize: _D,
  normalizeAngle: bf,
  omit: mn,
  pick: Tu,
  prefixGenerator: kv,
  removePathFromField: jE,
  replaceAll: ho,
  replacePathInField: ni,
  resetIdCounter: Cle,
  setEqual: CR,
  some: fo,
  stringify: Ce,
  titleCase: kd,
  unique: rr,
  uniqueId: MR,
  vals: St,
  varName: Be,
  version: Hme
}, Symbol.toStringTag, { value: "Module" }));
function GN(e) {
  const [t, n] = /schema\/([\w-]+)\/([\w\.\-]+)\.json$/g.exec(e).slice(1, 3);
  return { library: t, version: n };
}
var Xme = "vega-themes", Yme = "2.14.0", Kme = "Themes for stylized Vega and Vega-Lite visualizations.", Jme = ["vega", "vega-lite", "themes", "style"], Qme = "BSD-3-Clause", Zme = {
  name: "UW Interactive Data Lab",
  url: "https://idl.cs.washington.edu"
}, e1e = [{
  name: "Emily Gu",
  url: "https://github.com/emilygu"
}, {
  name: "Arvind Satyanarayan",
  url: "http://arvindsatya.com"
}, {
  name: "Jeffrey Heer",
  url: "https://idl.cs.washington.edu"
}, {
  name: "Dominik Moritz",
  url: "https://www.domoritz.de"
}], t1e = "build/vega-themes.js", n1e = "build/vega-themes.module.js", i1e = "build/vega-themes.min.js", r1e = "build/vega-themes.min.js", a1e = "build/vega-themes.module.d.ts", s1e = {
  type: "git",
  url: "https://github.com/vega/vega-themes.git"
}, o1e = ["src", "build"], u1e = {
  prebuild: "yarn clean",
  build: "rollup -c",
  clean: "rimraf build && rimraf examples/build",
  "copy:data": "rsync -r node_modules/vega-datasets/data/* examples/data",
  "copy:build": "rsync -r build/* examples/build",
  "deploy:gh": "yarn build && mkdir -p examples/build && rsync -r build/* examples/build && gh-pages -d examples",
  preversion: "yarn lint",
  serve: "browser-sync start -s -f build examples --serveStatic examples",
  start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
  format: "eslint . --fix",
  lint: "eslint .",
  release: "release-it"
}, l1e = {
  "@babel/core": "^7.22.9",
  "@babel/plugin-proposal-async-generator-functions": "^7.20.7",
  "@babel/plugin-proposal-json-strings": "^7.18.6",
  "@babel/plugin-proposal-object-rest-spread": "^7.20.7",
  "@babel/plugin-proposal-optional-catch-binding": "^7.18.6",
  "@babel/plugin-transform-runtime": "^7.22.9",
  "@babel/preset-env": "^7.22.9",
  "@babel/preset-typescript": "^7.22.5",
  "@release-it/conventional-changelog": "^7.0.0",
  "@rollup/plugin-json": "^6.0.0",
  "@rollup/plugin-node-resolve": "^15.1.0",
  "@rollup/plugin-terser": "^0.4.3",
  "@typescript-eslint/eslint-plugin": "^6.0.0",
  "@typescript-eslint/parser": "^6.0.0",
  "browser-sync": "^2.29.3",
  concurrently: "^8.2.0",
  eslint: "^8.45.0",
  "eslint-config-prettier": "^8.8.0",
  "eslint-plugin-prettier": "^5.0.0",
  "gh-pages": "^5.0.0",
  prettier: "^3.0.0",
  "release-it": "^16.1.0",
  rollup: "^3.26.2",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-ts": "^3.2.0",
  typescript: "^5.1.6",
  vega: "^5.25.0",
  "vega-lite": "^5.9.3"
}, c1e = {
  vega: "*",
  "vega-lite": "*"
}, f1e = {}, d1e = {
  name: Xme,
  version: Yme,
  description: Kme,
  keywords: Jme,
  license: Qme,
  author: Zme,
  contributors: e1e,
  main: t1e,
  module: n1e,
  unpkg: i1e,
  jsdelivr: r1e,
  types: a1e,
  repository: s1e,
  files: o1e,
  scripts: u1e,
  devDependencies: l1e,
  peerDependencies: c1e,
  dependencies: f1e
};
const Ko = "#fff", S7 = "#888", h1e = {
  background: "#333",
  view: {
    stroke: S7
  },
  title: {
    color: Ko,
    subtitleColor: Ko
  },
  style: {
    "guide-label": {
      fill: Ko
    },
    "guide-title": {
      fill: Ko
    }
  },
  axis: {
    domainColor: Ko,
    gridColor: S7,
    tickColor: Ko
  }
}, $s = "#4572a7", p1e = {
  background: "#fff",
  arc: {
    fill: $s
  },
  area: {
    fill: $s
  },
  line: {
    stroke: $s,
    strokeWidth: 2
  },
  path: {
    stroke: $s
  },
  rect: {
    fill: $s
  },
  shape: {
    stroke: $s
  },
  symbol: {
    fill: $s,
    strokeWidth: 1.5,
    size: 50
  },
  axis: {
    bandPosition: 0.5,
    grid: !0,
    gridColor: "#000000",
    gridOpacity: 1,
    gridWidth: 0.5,
    labelPadding: 10,
    tickSize: 5,
    tickWidth: 0.5
  },
  axisBand: {
    grid: !1,
    tickExtra: !0
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 50,
    symbolType: "square"
  },
  range: {
    category: ["#4572a7", "#aa4643", "#8aa453", "#71598e", "#4598ae", "#d98445", "#94aace", "#d09393", "#b9cc98", "#a99cbc"]
  }
}, ws = "#30a2da", Ey = "#cbcbcb", g1e = "#999", m1e = "#333", A7 = "#f0f0f0", k7 = "#333", y1e = {
  arc: {
    fill: ws
  },
  area: {
    fill: ws
  },
  axis: {
    domainColor: Ey,
    grid: !0,
    gridColor: Ey,
    gridWidth: 1,
    labelColor: g1e,
    labelFontSize: 10,
    titleColor: m1e,
    tickColor: Ey,
    tickSize: 10,
    titleFontSize: 14,
    titlePadding: 10,
    labelPadding: 4
  },
  axisBand: {
    grid: !1
  },
  background: A7,
  group: {
    fill: A7
  },
  legend: {
    labelColor: k7,
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square",
    titleColor: k7,
    titleFontSize: 14,
    titlePadding: 10
  },
  line: {
    stroke: ws,
    strokeWidth: 2
  },
  path: {
    stroke: ws,
    strokeWidth: 0.5
  },
  rect: {
    fill: ws
  },
  range: {
    category: ["#30a2da", "#fc4f30", "#e5ae38", "#6d904f", "#8b8b8b", "#b96db8", "#ff9e27", "#56cc60", "#52d2ca", "#52689e", "#545454", "#9fe4f8"],
    diverging: ["#cc0020", "#e77866", "#f6e7e1", "#d6e8ed", "#91bfd9", "#1d78b5"],
    heatmap: ["#d6e8ed", "#cee0e5", "#91bfd9", "#549cc6", "#1d78b5"]
  },
  point: {
    filled: !0,
    shape: "circle"
  },
  shape: {
    stroke: ws
  },
  bar: {
    binSpacing: 2,
    fill: ws,
    stroke: null
  },
  title: {
    anchor: "start",
    fontSize: 24,
    fontWeight: 600,
    offset: 20
  }
}, Es = "#000", b1e = {
  group: {
    fill: "#e5e5e5"
  },
  arc: {
    fill: Es
  },
  area: {
    fill: Es
  },
  line: {
    stroke: Es
  },
  path: {
    stroke: Es
  },
  rect: {
    fill: Es
  },
  shape: {
    stroke: Es
  },
  symbol: {
    fill: Es,
    size: 40
  },
  axis: {
    domain: !1,
    grid: !0,
    gridColor: "#FFFFFF",
    gridOpacity: 1,
    labelColor: "#7F7F7F",
    labelPadding: 4,
    tickColor: "#7F7F7F",
    tickSize: 5.67,
    titleFontSize: 16,
    titleFontWeight: "normal"
  },
  legend: {
    labelBaseline: "middle",
    labelFontSize: 11,
    symbolSize: 40
  },
  range: {
    category: ["#000000", "#7F7F7F", "#1A1A1A", "#999999", "#333333", "#B0B0B0", "#4D4D4D", "#C9C9C9", "#666666", "#DCDCDC"]
  }
}, v1e = 22, x1e = "normal", C7 = "Benton Gothic, sans-serif", _7 = 11.5, $1e = "normal", Ss = "#82c6df", Sy = "Benton Gothic Bold, sans-serif", F7 = "normal", M7 = 13, Hl = {
  "category-6": ["#ec8431", "#829eb1", "#c89d29", "#3580b1", "#adc839", "#ab7fb4"],
  "fire-7": ["#fbf2c7", "#f9e39c", "#f8d36e", "#f4bb6a", "#e68a4f", "#d15a40", "#ab4232"],
  "fireandice-6": ["#e68a4f", "#f4bb6a", "#f9e39c", "#dadfe2", "#a6b7c6", "#849eae"],
  "ice-7": ["#edefee", "#dadfe2", "#c4ccd2", "#a6b7c6", "#849eae", "#607785", "#47525d"]
}, w1e = {
  background: "#ffffff",
  title: {
    anchor: "start",
    color: "#000000",
    font: Sy,
    fontSize: v1e,
    fontWeight: x1e
  },
  arc: {
    fill: Ss
  },
  area: {
    fill: Ss
  },
  line: {
    stroke: Ss,
    strokeWidth: 2
  },
  path: {
    stroke: Ss
  },
  rect: {
    fill: Ss
  },
  shape: {
    stroke: Ss
  },
  symbol: {
    fill: Ss,
    size: 30
  },
  axis: {
    labelFont: C7,
    labelFontSize: _7,
    labelFontWeight: $1e,
    titleFont: Sy,
    titleFontSize: M7,
    titleFontWeight: F7
  },
  axisX: {
    labelAngle: 0,
    labelPadding: 4,
    tickSize: 3
  },
  axisY: {
    labelBaseline: "middle",
    maxExtent: 45,
    minExtent: 45,
    tickSize: 2,
    titleAlign: "left",
    titleAngle: 0,
    titleX: -45,
    titleY: -11
  },
  legend: {
    labelFont: C7,
    labelFontSize: _7,
    symbolType: "square",
    titleFont: Sy,
    titleFontSize: M7,
    titleFontWeight: F7
  },
  range: {
    category: Hl["category-6"],
    diverging: Hl["fireandice-6"],
    heatmap: Hl["fire-7"],
    ordinal: Hl["fire-7"],
    ramp: Hl["fire-7"]
  }
}, As = "#ab5787", bh = "#979797", E1e = {
  background: "#f9f9f9",
  arc: {
    fill: As
  },
  area: {
    fill: As
  },
  line: {
    stroke: As
  },
  path: {
    stroke: As
  },
  rect: {
    fill: As
  },
  shape: {
    stroke: As
  },
  symbol: {
    fill: As,
    size: 30
  },
  axis: {
    domainColor: bh,
    domainWidth: 0.5,
    gridWidth: 0.2,
    labelColor: bh,
    tickColor: bh,
    tickWidth: 0.2,
    titleColor: bh
  },
  axisBand: {
    grid: !1
  },
  axisX: {
    grid: !0,
    tickSize: 10
  },
  axisY: {
    domain: !1,
    grid: !0,
    tickSize: 0
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolSize: 30,
    symbolType: "square"
  },
  range: {
    category: ["#ab5787", "#51b2e5", "#703c5c", "#168dd9", "#d190b6", "#00609f", "#d365ba", "#154866", "#666666", "#c4c4c4"]
  }
}, ks = "#3e5c69", S1e = {
  background: "#fff",
  arc: {
    fill: ks
  },
  area: {
    fill: ks
  },
  line: {
    stroke: ks
  },
  path: {
    stroke: ks
  },
  rect: {
    fill: ks
  },
  shape: {
    stroke: ks
  },
  symbol: {
    fill: ks
  },
  axis: {
    domainWidth: 0.5,
    grid: !0,
    labelPadding: 2,
    tickSize: 5,
    tickWidth: 0.5,
    titleFontWeight: "normal"
  },
  axisBand: {
    grid: !1
  },
  axisX: {
    gridWidth: 0.2
  },
  axisY: {
    gridDash: [3],
    gridWidth: 0.4
  },
  legend: {
    labelFontSize: 11,
    padding: 1,
    symbolType: "square"
  },
  range: {
    category: ["#3e5c69", "#6793a6", "#182429", "#0570b0", "#3690c0", "#74a9cf", "#a6bddb", "#e2ddf2"]
  }
}, Gn = "#1696d2", O7 = "#000000", A1e = "#FFFFFF", vh = "Lato", Ay = "Lato", k1e = "Lato", C1e = "#DEDDDD", _1e = 18, Vl = {
  "main-colors": ["#1696d2", "#d2d2d2", "#000000", "#fdbf11", "#ec008b", "#55b748", "#5c5859", "#db2b27"],
  "shades-blue": ["#CFE8F3", "#A2D4EC", "#73BFE2", "#46ABDB", "#1696D2", "#12719E", "#0A4C6A", "#062635"],
  "shades-gray": ["#F5F5F5", "#ECECEC", "#E3E3E3", "#DCDBDB", "#D2D2D2", "#9D9D9D", "#696969", "#353535"],
  "shades-yellow": ["#FFF2CF", "#FCE39E", "#FDD870", "#FCCB41", "#FDBF11", "#E88E2D", "#CA5800", "#843215"],
  "shades-magenta": ["#F5CBDF", "#EB99C2", "#E46AA7", "#E54096", "#EC008B", "#AF1F6B", "#761548", "#351123"],
  "shades-green": ["#DCEDD9", "#BCDEB4", "#98CF90", "#78C26D", "#55B748", "#408941", "#2C5C2D", "#1A2E19"],
  "shades-black": ["#D5D5D4", "#ADABAC", "#848081", "#5C5859", "#332D2F", "#262223", "#1A1717", "#0E0C0D"],
  "shades-red": ["#F8D5D4", "#F1AAA9", "#E9807D", "#E25552", "#DB2B27", "#A4201D", "#6E1614", "#370B0A"],
  "one-group": ["#1696d2", "#000000"],
  "two-groups-cat-1": ["#1696d2", "#000000"],
  "two-groups-cat-2": ["#1696d2", "#fdbf11"],
  "two-groups-cat-3": ["#1696d2", "#db2b27"],
  "two-groups-seq": ["#a2d4ec", "#1696d2"],
  "three-groups-cat": ["#1696d2", "#fdbf11", "#000000"],
  "three-groups-seq": ["#a2d4ec", "#1696d2", "#0a4c6a"],
  "four-groups-cat-1": ["#000000", "#d2d2d2", "#fdbf11", "#1696d2"],
  "four-groups-cat-2": ["#1696d2", "#ec0008b", "#fdbf11", "#5c5859"],
  "four-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a"],
  "five-groups-cat-1": ["#1696d2", "#fdbf11", "#d2d2d2", "#ec008b", "#000000"],
  "five-groups-cat-2": ["#1696d2", "#0a4c6a", "#d2d2d2", "#fdbf11", "#332d2f"],
  "five-groups-seq": ["#cfe8f3", "#73bf42", "#1696d2", "#0a4c6a", "#000000"],
  "six-groups-cat-1": ["#1696d2", "#ec008b", "#fdbf11", "#000000", "#d2d2d2", "#55b748"],
  "six-groups-cat-2": ["#1696d2", "#d2d2d2", "#ec008b", "#fdbf11", "#332d2f", "#0a4c6a"],
  "six-groups-seq": ["#cfe8f3", "#a2d4ec", "#73bfe2", "#46abdb", "#1696d2", "#12719e"],
  "diverging-colors": ["#ca5800", "#fdbf11", "#fdd870", "#fff2cf", "#cfe8f3", "#73bfe2", "#1696d2", "#0a4c6a"]
}, F1e = {
  background: A1e,
  title: {
    anchor: "start",
    fontSize: _1e,
    font: vh
  },
  axisX: {
    domain: !0,
    domainColor: O7,
    domainWidth: 1,
    grid: !1,
    labelFontSize: 12,
    labelFont: Ay,
    labelAngle: 0,
    tickColor: O7,
    tickSize: 5,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: vh
  },
  axisY: {
    domain: !1,
    domainWidth: 1,
    grid: !0,
    gridColor: C1e,
    gridWidth: 1,
    labelFontSize: 12,
    labelFont: Ay,
    labelPadding: 8,
    ticks: !1,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: vh,
    titleAngle: 0,
    titleY: -10,
    titleX: 18
  },
  legend: {
    labelFontSize: 12,
    labelFont: Ay,
    symbolSize: 100,
    titleFontSize: 12,
    titlePadding: 10,
    titleFont: vh,
    orient: "right",
    offset: 10
  },
  view: {
    stroke: "transparent"
  },
  range: {
    category: Vl["six-groups-cat-1"],
    diverging: Vl["diverging-colors"],
    heatmap: Vl["diverging-colors"],
    ordinal: Vl["six-groups-seq"],
    ramp: Vl["shades-blue"]
  },
  area: {
    fill: Gn
  },
  rect: {
    fill: Gn
  },
  line: {
    color: Gn,
    stroke: Gn,
    strokeWidth: 5
  },
  trail: {
    color: Gn,
    stroke: Gn,
    strokeWidth: 0,
    size: 1
  },
  path: {
    stroke: Gn,
    strokeWidth: 0.5
  },
  point: {
    filled: !0
  },
  text: {
    font: k1e,
    color: Gn,
    fontSize: 11,
    align: "center",
    fontWeight: 400,
    size: 11
  },
  style: {
    bar: {
      fill: Gn,
      stroke: null
    }
  },
  arc: {
    fill: Gn
  },
  shape: {
    stroke: Gn
  },
  symbol: {
    fill: Gn,
    size: 30
  }
}, Cs = "#3366CC", R7 = "#ccc", xh = "Arial, sans-serif", M1e = {
  arc: {
    fill: Cs
  },
  area: {
    fill: Cs
  },
  path: {
    stroke: Cs
  },
  rect: {
    fill: Cs
  },
  shape: {
    stroke: Cs
  },
  symbol: {
    stroke: Cs
  },
  circle: {
    fill: Cs
  },
  background: "#fff",
  padding: {
    top: 10,
    right: 10,
    bottom: 10,
    left: 10
  },
  style: {
    "guide-label": {
      font: xh,
      fontSize: 12
    },
    "guide-title": {
      font: xh,
      fontSize: 12
    },
    "group-title": {
      font: xh,
      fontSize: 12
    }
  },
  title: {
    font: xh,
    fontSize: 14,
    fontWeight: "bold",
    dy: -3,
    anchor: "start"
  },
  axis: {
    gridColor: R7,
    tickColor: R7,
    domain: !1,
    grid: !0
  },
  range: {
    category: ["#4285F4", "#DB4437", "#F4B400", "#0F9D58", "#AB47BC", "#00ACC1", "#FF7043", "#9E9D24", "#5C6BC0", "#F06292", "#00796B", "#C2185B"],
    heatmap: ["#c6dafc", "#5e97f6", "#2a56c6"]
  }
}, a5 = (e) => e * (1 / 3 + 1), T7 = a5(9), D7 = a5(10), N7 = a5(12), Xl = "Segoe UI", L7 = "wf_standard-font, helvetica, arial, sans-serif", P7 = "#252423", Yl = "#605E5C", z7 = "transparent", O1e = "#C8C6C4", ci = "#118DFF", R1e = "#12239E", T1e = "#E66C37", D1e = "#6B007B", N1e = "#E044A7", L1e = "#744EC2", P1e = "#D9B300", z1e = "#D64550", WN = ci, HN = "#DEEFFF", I7 = [HN, WN], I1e = [HN, "#c7e4ff", "#b0d9ff", "#9aceff", "#83c3ff", "#6cb9ff", "#55aeff", "#3fa3ff", "#2898ff", WN], B1e = {
  view: {
    stroke: z7
  },
  background: z7,
  font: Xl,
  header: {
    titleFont: L7,
    titleFontSize: N7,
    titleColor: P7,
    labelFont: Xl,
    labelFontSize: D7,
    labelColor: Yl
  },
  axis: {
    ticks: !1,
    grid: !1,
    domain: !1,
    labelColor: Yl,
    labelFontSize: T7,
    titleFont: L7,
    titleColor: P7,
    titleFontSize: N7,
    titleFontWeight: "normal"
  },
  axisQuantitative: {
    tickCount: 3,
    grid: !0,
    gridColor: O1e,
    gridDash: [1, 5],
    labelFlush: !1
  },
  axisBand: {
    tickExtra: !0
  },
  axisX: {
    labelPadding: 5
  },
  axisY: {
    labelPadding: 10
  },
  bar: {
    fill: ci
  },
  line: {
    stroke: ci,
    strokeWidth: 3,
    strokeCap: "round",
    strokeJoin: "round"
  },
  text: {
    font: Xl,
    fontSize: T7,
    fill: Yl
  },
  arc: {
    fill: ci
  },
  area: {
    fill: ci,
    line: !0,
    opacity: 0.6
  },
  path: {
    stroke: ci
  },
  rect: {
    fill: ci
  },
  point: {
    fill: ci,
    filled: !0,
    size: 75
  },
  shape: {
    stroke: ci
  },
  symbol: {
    fill: ci,
    strokeWidth: 1.5,
    size: 50
  },
  legend: {
    titleFont: Xl,
    titleFontWeight: "bold",
    titleColor: Yl,
    labelFont: Xl,
    labelFontSize: D7,
    labelColor: Yl,
    symbolType: "circle",
    symbolSize: 75
  },
  range: {
    category: [ci, R1e, T1e, D1e, N1e, L1e, P1e, z1e],
    diverging: I7,
    heatmap: I7,
    ordinal: I1e
  }
}, ky = 'IBM Plex Sans,system-ui,-apple-system,BlinkMacSystemFont,".sfnstext-regular",sans-serif', B7 = 400, j1e = ["#8a3ffc", "#33b1ff", "#007d79", "#ff7eb6", "#fa4d56", "#fff1f1", "#6fdc8c", "#4589ff", "#d12771", "#d2a106", "#08bdba", "#bae6ff", "#ba4e00", "#d4bbff"], U1e = ["#6929c4", "#1192e8", "#005d5d", "#9f1853", "#fa4d56", "#570408", "#198038", "#002d9c", "#ee538b", "#b28600", "#009d9a", "#012749", "#8a3800", "#a56eff"];
function s1({
  type: e,
  background: t
}) {
  const n = e === "dark" ? "#161616" : "#ffffff", i = e === "dark" ? "#f4f4f4" : "#161616", r = e === "dark" ? j1e : U1e, a = e === "dark" ? "#d4bbff" : "#6929c4";
  return {
    background: t,
    arc: {
      fill: a
    },
    area: {
      fill: a
    },
    path: {
      stroke: a
    },
    rect: {
      fill: a
    },
    shape: {
      stroke: a
    },
    symbol: {
      stroke: a
    },
    circle: {
      fill: a
    },
    view: {
      fill: n,
      stroke: n
    },
    group: {
      fill: n
    },
    title: {
      color: i,
      anchor: "start",
      dy: -15,
      fontSize: 16,
      font: ky,
      fontWeight: 600
    },
    axis: {
      labelColor: i,
      labelFontSize: 12,
      grid: !0,
      gridColor: "#525252",
      titleColor: i,
      labelAngle: 0
    },
    style: {
      "guide-label": {
        font: ky,
        fill: i,
        fontWeight: B7
      },
      "guide-title": {
        font: ky,
        fill: i,
        fontWeight: B7
      }
    },
    range: {
      category: r,
      diverging: ["#750e13", "#a2191f", "#da1e28", "#fa4d56", "#ff8389", "#ffb3b8", "#ffd7d9", "#fff1f1", "#e5f6ff", "#bae6ff", "#82cfff", "#33b1ff", "#1192e8", "#0072c3", "#00539a", "#003a6d"],
      heatmap: ["#f6f2ff", "#e8daff", "#d4bbff", "#be95ff", "#a56eff", "#8a3ffc", "#6929c4", "#491d8b", "#31135e", "#1c0f30"]
    }
  };
}
const q1e = s1({
  type: "light",
  background: "#ffffff"
}), G1e = s1({
  type: "light",
  background: "#f4f4f4"
}), W1e = s1({
  type: "dark",
  background: "#262626"
}), H1e = s1({
  type: "dark",
  background: "#161616"
}), V1e = d1e.version, X1e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  carbong10: G1e,
  carbong100: H1e,
  carbong90: W1e,
  carbonwhite: q1e,
  dark: h1e,
  excel: p1e,
  fivethirtyeight: y1e,
  ggplot2: b1e,
  googlecharts: M1e,
  latimes: w1e,
  powerbi: B1e,
  quartz: E1e,
  urbaninstitute: F1e,
  version: V1e,
  vox: S1e
}, Symbol.toStringTag, { value: "Module" }));
function Y1e(e, t, n) {
  if (R(e))
    return `[${e.map((i) => t(V(i) ? i : j7(i, n))).join(", ")}]`;
  if (X(e)) {
    let i = "";
    const {
      title: r,
      image: a,
      ...s
    } = e;
    r && (i += `<h2>${t(r)}</h2>`), a && (i += `<img src="${t(a)}">`);
    const o = Object.keys(s);
    if (o.length > 0) {
      i += "<table>";
      for (const u of o) {
        let l = s[u];
        l !== void 0 && (X(l) && (l = j7(l, n)), i += `<tr><td class="key">${t(u)}</td><td class="value">${t(l)}</td></tr>`);
      }
      i += "</table>";
    }
    return i || "{}";
  }
  return t(e);
}
function K1e(e) {
  const t = [];
  return function(n, i) {
    if (typeof i != "object" || i === null)
      return i;
    const r = t.indexOf(this) + 1;
    return t.length = r, t.length > e ? "[Object]" : t.indexOf(i) >= 0 ? "[Circular]" : (t.push(i), i);
  };
}
function j7(e, t) {
  return JSON.stringify(e, K1e(t));
}
var J1e = `#vg-tooltip-element {
  visibility: hidden;
  padding: 8px;
  position: fixed;
  z-index: 1000;
  font-family: sans-serif;
  font-size: 11px;
  border-radius: 3px;
  box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
  /* The default theme is the light theme. */
  background-color: rgba(255, 255, 255, 0.95);
  border: 1px solid #d9d9d9;
  color: black;
}
#vg-tooltip-element.visible {
  visibility: visible;
}
#vg-tooltip-element h2 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 13px;
}
#vg-tooltip-element table {
  border-spacing: 0;
}
#vg-tooltip-element table tr {
  border: none;
}
#vg-tooltip-element table tr td {
  overflow: hidden;
  text-overflow: ellipsis;
  padding-top: 2px;
  padding-bottom: 2px;
}
#vg-tooltip-element table tr td.key {
  color: #808080;
  max-width: 150px;
  text-align: right;
  padding-right: 4px;
}
#vg-tooltip-element table tr td.value {
  display: block;
  max-width: 300px;
  max-height: 7em;
  text-align: left;
}
#vg-tooltip-element.dark-theme {
  background-color: rgba(32, 32, 32, 0.9);
  border: 1px solid #f5f5f5;
  color: white;
}
#vg-tooltip-element.dark-theme td.key {
  color: #bfbfbf;
}
`;
const VN = "vg-tooltip-element", Q1e = {
  /**
   * X offset.
   */
  offsetX: 10,
  /**
   * Y offset.
   */
  offsetY: 10,
  /**
   * ID of the tooltip element.
   */
  id: VN,
  /**
   * ID of the tooltip CSS style.
   */
  styleId: "vega-tooltip-style",
  /**
   * The name of the theme. You can use the CSS class called [THEME]-theme to style the tooltips.
   *
   * There are two predefined themes: "light" (default) and "dark".
   */
  theme: "light",
  /**
   * Do not use the default styles provided by Vega Tooltip. If you enable this option, you need to use your own styles. It is not necessary to disable the default style when using a custom theme.
   */
  disableDefaultStyle: !1,
  /**
   * HTML sanitizer function that removes dangerous HTML to prevent XSS.
   *
   * This should be a function from string to string. You may replace it with a formatter such as a markdown formatter.
   */
  sanitize: Z1e,
  /**
   * The maximum recursion depth when printing objects in the tooltip.
   */
  maxDepth: 2,
  /**
   * A function to customize the rendered HTML of the tooltip.
   * @param value A value string, or object of value strings keyed by field
   * @param sanitize The `sanitize` function from `options.sanitize`
   * @returns {string} The returned string will become the `innerHTML` of the tooltip element
   */
  formatTooltip: Y1e
};
function Z1e(e) {
  return String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;");
}
function eye(e) {
  if (!/^[A-Za-z]+[-:.\w]*$/.test(e))
    throw new Error("Invalid HTML ID");
  return J1e.toString().replace(VN, e);
}
function tye(e, t, n, i) {
  let r = e.clientX + n;
  r + t.width > window.innerWidth && (r = +e.clientX - n - t.width);
  let a = e.clientY + i;
  return a + t.height > window.innerHeight && (a = +e.clientY - i - t.height), {
    x: r,
    y: a
  };
}
class nye {
  /**
   * The handler function. We bind this to this function in the constructor.
   */
  /**
   * Complete tooltip options.
   */
  /**
   * The tooltip html element.
   */
  /**
   * Create the tooltip handler and initialize the element and style.
   *
   * @param options Tooltip Options
   */
  constructor(t) {
    this.options = {
      ...Q1e,
      ...t
    };
    const n = this.options.id;
    if (this.el = null, this.call = this.tooltipHandler.bind(this), !this.options.disableDefaultStyle && !document.getElementById(this.options.styleId)) {
      const i = document.createElement("style");
      i.setAttribute("id", this.options.styleId), i.innerHTML = eye(n);
      const r = document.head;
      r.childNodes.length > 0 ? r.insertBefore(i, r.childNodes[0]) : r.appendChild(i);
    }
  }
  /**
   * The tooltip handler function.
   */
  tooltipHandler(t, n, i, r) {
    if (this.el = document.getElementById(this.options.id), this.el || (this.el = document.createElement("div"), this.el.setAttribute("id", this.options.id), this.el.classList.add("vg-tooltip"), (document.fullscreenElement ?? document.body).appendChild(this.el)), r == null || r === "") {
      this.el.classList.remove("visible", `${this.options.theme}-theme`);
      return;
    }
    this.el.innerHTML = this.options.formatTooltip(r, this.options.sanitize, this.options.maxDepth), this.el.classList.add("visible", `${this.options.theme}-theme`);
    const {
      x: a,
      y: s
    } = tye(n, this.el.getBoundingClientRect(), this.options.offsetX, this.options.offsetY);
    this.el.style.top = `${s}px`, this.el.style.left = `${a}px`;
  }
}
function Sf(e) {
  "@babel/helpers - typeof";
  return Sf = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Sf(e);
}
function iye(e, t) {
  if (Sf(e) !== "object" || e === null)
    return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var i = n.call(e, t || "default");
    if (Sf(i) !== "object")
      return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function rye(e) {
  var t = iye(e, "string");
  return Sf(t) === "symbol" ? t : String(t);
}
function aye(e, t, n) {
  return t = rye(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function sye(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Cy, U7;
function oye() {
  return U7 || (U7 = 1, Cy = function(e) {
    e.prototype[Symbol.iterator] = function* () {
      for (let t = this.head; t; t = t.next)
        yield t.value;
    };
  }), Cy;
}
var uye = xe;
xe.Node = wo;
xe.create = xe;
function xe(e) {
  var t = this;
  if (t instanceof xe || (t = new xe()), t.tail = null, t.head = null, t.length = 0, e && typeof e.forEach == "function")
    e.forEach(function(r) {
      t.push(r);
    });
  else if (arguments.length > 0)
    for (var n = 0, i = arguments.length; n < i; n++)
      t.push(arguments[n]);
  return t;
}
xe.prototype.removeNode = function(e) {
  if (e.list !== this)
    throw new Error("removing node which does not belong to this list");
  var t = e.next, n = e.prev;
  return t && (t.prev = n), n && (n.next = t), e === this.head && (this.head = t), e === this.tail && (this.tail = n), e.list.length--, e.next = null, e.prev = null, e.list = null, t;
};
xe.prototype.unshiftNode = function(e) {
  if (e !== this.head) {
    e.list && e.list.removeNode(e);
    var t = this.head;
    e.list = this, e.next = t, t && (t.prev = e), this.head = e, this.tail || (this.tail = e), this.length++;
  }
};
xe.prototype.pushNode = function(e) {
  if (e !== this.tail) {
    e.list && e.list.removeNode(e);
    var t = this.tail;
    e.list = this, e.prev = t, t && (t.next = e), this.tail = e, this.head || (this.head = e), this.length++;
  }
};
xe.prototype.push = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    cye(this, arguments[e]);
  return this.length;
};
xe.prototype.unshift = function() {
  for (var e = 0, t = arguments.length; e < t; e++)
    fye(this, arguments[e]);
  return this.length;
};
xe.prototype.pop = function() {
  if (this.tail) {
    var e = this.tail.value;
    return this.tail = this.tail.prev, this.tail ? this.tail.next = null : this.head = null, this.length--, e;
  }
};
xe.prototype.shift = function() {
  if (this.head) {
    var e = this.head.value;
    return this.head = this.head.next, this.head ? this.head.prev = null : this.tail = null, this.length--, e;
  }
};
xe.prototype.forEach = function(e, t) {
  t = t || this;
  for (var n = this.head, i = 0; n !== null; i++)
    e.call(t, n.value, i, this), n = n.next;
};
xe.prototype.forEachReverse = function(e, t) {
  t = t || this;
  for (var n = this.tail, i = this.length - 1; n !== null; i--)
    e.call(t, n.value, i, this), n = n.prev;
};
xe.prototype.get = function(e) {
  for (var t = 0, n = this.head; n !== null && t < e; t++)
    n = n.next;
  if (t === e && n !== null)
    return n.value;
};
xe.prototype.getReverse = function(e) {
  for (var t = 0, n = this.tail; n !== null && t < e; t++)
    n = n.prev;
  if (t === e && n !== null)
    return n.value;
};
xe.prototype.map = function(e, t) {
  t = t || this;
  for (var n = new xe(), i = this.head; i !== null; )
    n.push(e.call(t, i.value, this)), i = i.next;
  return n;
};
xe.prototype.mapReverse = function(e, t) {
  t = t || this;
  for (var n = new xe(), i = this.tail; i !== null; )
    n.push(e.call(t, i.value, this)), i = i.prev;
  return n;
};
xe.prototype.reduce = function(e, t) {
  var n, i = this.head;
  if (arguments.length > 1)
    n = t;
  else if (this.head)
    i = this.head.next, n = this.head.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var r = 0; i !== null; r++)
    n = e(n, i.value, r), i = i.next;
  return n;
};
xe.prototype.reduceReverse = function(e, t) {
  var n, i = this.tail;
  if (arguments.length > 1)
    n = t;
  else if (this.tail)
    i = this.tail.prev, n = this.tail.value;
  else
    throw new TypeError("Reduce of empty list with no initial value");
  for (var r = this.length - 1; i !== null; r--)
    n = e(n, i.value, r), i = i.prev;
  return n;
};
xe.prototype.toArray = function() {
  for (var e = new Array(this.length), t = 0, n = this.head; n !== null; t++)
    e[t] = n.value, n = n.next;
  return e;
};
xe.prototype.toArrayReverse = function() {
  for (var e = new Array(this.length), t = 0, n = this.tail; n !== null; t++)
    e[t] = n.value, n = n.prev;
  return e;
};
xe.prototype.slice = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var n = new xe();
  if (t < e || t < 0)
    return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var i = 0, r = this.head; r !== null && i < e; i++)
    r = r.next;
  for (; r !== null && i < t; i++, r = r.next)
    n.push(r.value);
  return n;
};
xe.prototype.sliceReverse = function(e, t) {
  t = t || this.length, t < 0 && (t += this.length), e = e || 0, e < 0 && (e += this.length);
  var n = new xe();
  if (t < e || t < 0)
    return n;
  e < 0 && (e = 0), t > this.length && (t = this.length);
  for (var i = this.length, r = this.tail; r !== null && i > t; i--)
    r = r.prev;
  for (; r !== null && i > e; i--, r = r.prev)
    n.push(r.value);
  return n;
};
xe.prototype.splice = function(e, t, ...n) {
  e > this.length && (e = this.length - 1), e < 0 && (e = this.length + e);
  for (var i = 0, r = this.head; r !== null && i < e; i++)
    r = r.next;
  for (var a = [], i = 0; r && i < t; i++)
    a.push(r.value), r = this.removeNode(r);
  r === null && (r = this.tail), r !== this.head && r !== this.tail && (r = r.prev);
  for (var i = 0; i < n.length; i++)
    r = lye(this, r, n[i]);
  return a;
};
xe.prototype.reverse = function() {
  for (var e = this.head, t = this.tail, n = e; n !== null; n = n.prev) {
    var i = n.prev;
    n.prev = n.next, n.next = i;
  }
  return this.head = t, this.tail = e, this;
};
function lye(e, t, n) {
  var i = t === e.head ? new wo(n, null, t, e) : new wo(n, t, t.next, e);
  return i.next === null && (e.tail = i), i.prev === null && (e.head = i), e.length++, i;
}
function cye(e, t) {
  e.tail = new wo(t, e.tail, null, e), e.head || (e.head = e.tail), e.length++;
}
function fye(e, t) {
  e.head = new wo(t, null, e.head, e), e.tail || (e.tail = e.head), e.length++;
}
function wo(e, t, n, i) {
  if (!(this instanceof wo))
    return new wo(e, t, n, i);
  this.list = i, this.value = e, t ? (t.next = this, this.prev = t) : this.prev = null, n ? (n.prev = this, this.next = n) : this.next = null;
}
try {
  oye()(xe);
} catch {
}
const dye = uye, zs = Symbol("max"), Pr = Symbol("length"), Jo = Symbol("lengthCalculator"), zc = Symbol("allowStale"), Gs = Symbol("maxAge"), Dr = Symbol("dispose"), q7 = Symbol("noDisposeOnSet"), ut = Symbol("lruList"), fi = Symbol("cache"), XN = Symbol("updateAgeOnGet"), _y = () => 1;
class hye {
  constructor(t) {
    if (typeof t == "number" && (t = {
      max: t
    }), t || (t = {}), t.max && (typeof t.max != "number" || t.max < 0))
      throw new TypeError("max must be a non-negative number");
    this[zs] = t.max || 1 / 0;
    const n = t.length || _y;
    if (this[Jo] = typeof n != "function" ? _y : n, this[zc] = t.stale || !1, t.maxAge && typeof t.maxAge != "number")
      throw new TypeError("maxAge must be a number");
    this[Gs] = t.maxAge || 0, this[Dr] = t.dispose, this[q7] = t.noDisposeOnSet || !1, this[XN] = t.updateAgeOnGet || !1, this.reset();
  }
  // resize the cache when the max changes.
  set max(t) {
    if (typeof t != "number" || t < 0)
      throw new TypeError("max must be a non-negative number");
    this[zs] = t || 1 / 0, Kl(this);
  }
  get max() {
    return this[zs];
  }
  set allowStale(t) {
    this[zc] = !!t;
  }
  get allowStale() {
    return this[zc];
  }
  set maxAge(t) {
    if (typeof t != "number")
      throw new TypeError("maxAge must be a non-negative number");
    this[Gs] = t, Kl(this);
  }
  get maxAge() {
    return this[Gs];
  }
  // resize the cache when the lengthCalculator changes.
  set lengthCalculator(t) {
    typeof t != "function" && (t = _y), t !== this[Jo] && (this[Jo] = t, this[Pr] = 0, this[ut].forEach((n) => {
      n.length = this[Jo](n.value, n.key), this[Pr] += n.length;
    })), Kl(this);
  }
  get lengthCalculator() {
    return this[Jo];
  }
  get length() {
    return this[Pr];
  }
  get itemCount() {
    return this[ut].length;
  }
  rforEach(t, n) {
    n = n || this;
    for (let i = this[ut].tail; i !== null; ) {
      const r = i.prev;
      G7(this, t, i, n), i = r;
    }
  }
  forEach(t, n) {
    n = n || this;
    for (let i = this[ut].head; i !== null; ) {
      const r = i.next;
      G7(this, t, i, n), i = r;
    }
  }
  keys() {
    return this[ut].toArray().map((t) => t.key);
  }
  values() {
    return this[ut].toArray().map((t) => t.value);
  }
  reset() {
    this[Dr] && this[ut] && this[ut].length && this[ut].forEach((t) => this[Dr](t.key, t.value)), this[fi] = /* @__PURE__ */ new Map(), this[ut] = new dye(), this[Pr] = 0;
  }
  dump() {
    return this[ut].map((t) => Ng(this, t) ? !1 : {
      k: t.key,
      v: t.value,
      e: t.now + (t.maxAge || 0)
    }).toArray().filter((t) => t);
  }
  dumpLru() {
    return this[ut];
  }
  set(t, n, i) {
    if (i = i || this[Gs], i && typeof i != "number")
      throw new TypeError("maxAge must be a number");
    const r = i ? Date.now() : 0, a = this[Jo](n, t);
    if (this[fi].has(t)) {
      if (a > this[zs])
        return gu(this, this[fi].get(t)), !1;
      const u = this[fi].get(t).value;
      return this[Dr] && (this[q7] || this[Dr](t, u.value)), u.now = r, u.maxAge = i, u.value = n, this[Pr] += a - u.length, u.length = a, this.get(t), Kl(this), !0;
    }
    const s = new pye(t, n, a, r, i);
    return s.length > this[zs] ? (this[Dr] && this[Dr](t, n), !1) : (this[Pr] += s.length, this[ut].unshift(s), this[fi].set(t, this[ut].head), Kl(this), !0);
  }
  has(t) {
    if (!this[fi].has(t))
      return !1;
    const n = this[fi].get(t).value;
    return !Ng(this, n);
  }
  get(t) {
    return Fy(this, t, !0);
  }
  peek(t) {
    return Fy(this, t, !1);
  }
  pop() {
    const t = this[ut].tail;
    return t ? (gu(this, t), t.value) : null;
  }
  del(t) {
    gu(this, this[fi].get(t));
  }
  load(t) {
    this.reset();
    const n = Date.now();
    for (let i = t.length - 1; i >= 0; i--) {
      const r = t[i], a = r.e || 0;
      if (a === 0)
        this.set(r.k, r.v);
      else {
        const s = a - n;
        s > 0 && this.set(r.k, r.v, s);
      }
    }
  }
  prune() {
    this[fi].forEach((t, n) => Fy(this, n, !1));
  }
}
const Fy = (e, t, n) => {
  const i = e[fi].get(t);
  if (i) {
    const r = i.value;
    if (Ng(e, r)) {
      if (gu(e, i), !e[zc])
        return;
    } else
      n && (e[XN] && (i.value.now = Date.now()), e[ut].unshiftNode(i));
    return r.value;
  }
}, Ng = (e, t) => {
  if (!t || !t.maxAge && !e[Gs])
    return !1;
  const n = Date.now() - t.now;
  return t.maxAge ? n > t.maxAge : e[Gs] && n > e[Gs];
}, Kl = (e) => {
  if (e[Pr] > e[zs])
    for (let t = e[ut].tail; e[Pr] > e[zs] && t !== null; ) {
      const n = t.prev;
      gu(e, t), t = n;
    }
}, gu = (e, t) => {
  if (t) {
    const n = t.value;
    e[Dr] && e[Dr](n.key, n.value), e[Pr] -= n.length, e[fi].delete(n.key), e[ut].removeNode(t);
  }
};
class pye {
  constructor(t, n, i, r, a) {
    this.key = t, this.value = n, this.length = i, this.now = r, this.maxAge = a || 0;
  }
}
const G7 = (e, t, n, i) => {
  let r = n.value;
  Ng(e, r) && (gu(e, n), e[zc] || (r = void 0)), r && t.call(i, r.value, r.key, e);
};
var gye = hye;
const mye = Object.freeze({
  loose: !0
}), yye = Object.freeze({}), bye = (e) => e ? typeof e != "object" ? mye : e : yye;
var s5 = bye, Xv = { exports: {} };
const vye = "2.0.0", YN = 256, xye = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
9007199254740991, $ye = 16, wye = YN - 6, Eye = ["major", "premajor", "minor", "preminor", "patch", "prepatch", "prerelease"];
var o5 = {
  MAX_LENGTH: YN,
  MAX_SAFE_COMPONENT_LENGTH: $ye,
  MAX_SAFE_BUILD_LENGTH: wye,
  MAX_SAFE_INTEGER: xye,
  RELEASE_TYPES: Eye,
  SEMVER_SPEC_VERSION: vye,
  FLAG_INCLUDE_PRERELEASE: 1,
  FLAG_LOOSE: 2
};
const Sye = typeof process == "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...e) => console.error("SEMVER", ...e) : () => {
};
var o1 = Sye;
(function(e, t) {
  const {
    MAX_SAFE_COMPONENT_LENGTH: n,
    MAX_SAFE_BUILD_LENGTH: i,
    MAX_LENGTH: r
  } = o5, a = o1;
  t = e.exports = {};
  const s = t.re = [], o = t.safeRe = [], u = t.src = [], l = t.t = {};
  let c = 0;
  const f = "[a-zA-Z0-9-]", d = [["\\s", 1], ["\\d", r], [f, i]], h = (g) => {
    for (const [m, y] of d)
      g = g.split(`${m}*`).join(`${m}{0,${y}}`).split(`${m}+`).join(`${m}{1,${y}}`);
    return g;
  }, p = (g, m, y) => {
    const b = h(m), v = c++;
    a(g, v, m), l[g] = v, u[v] = m, s[v] = new RegExp(m, y ? "g" : void 0), o[v] = new RegExp(b, y ? "g" : void 0);
  };
  p("NUMERICIDENTIFIER", "0|[1-9]\\d*"), p("NUMERICIDENTIFIERLOOSE", "\\d+"), p("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${f}*`), p("MAINVERSION", `(${u[l.NUMERICIDENTIFIER]})\\.(${u[l.NUMERICIDENTIFIER]})\\.(${u[l.NUMERICIDENTIFIER]})`), p("MAINVERSIONLOOSE", `(${u[l.NUMERICIDENTIFIERLOOSE]})\\.(${u[l.NUMERICIDENTIFIERLOOSE]})\\.(${u[l.NUMERICIDENTIFIERLOOSE]})`), p("PRERELEASEIDENTIFIER", `(?:${u[l.NUMERICIDENTIFIER]}|${u[l.NONNUMERICIDENTIFIER]})`), p("PRERELEASEIDENTIFIERLOOSE", `(?:${u[l.NUMERICIDENTIFIERLOOSE]}|${u[l.NONNUMERICIDENTIFIER]})`), p("PRERELEASE", `(?:-(${u[l.PRERELEASEIDENTIFIER]}(?:\\.${u[l.PRERELEASEIDENTIFIER]})*))`), p("PRERELEASELOOSE", `(?:-?(${u[l.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${u[l.PRERELEASEIDENTIFIERLOOSE]})*))`), p("BUILDIDENTIFIER", `${f}+`), p("BUILD", `(?:\\+(${u[l.BUILDIDENTIFIER]}(?:\\.${u[l.BUILDIDENTIFIER]})*))`), p("FULLPLAIN", `v?${u[l.MAINVERSION]}${u[l.PRERELEASE]}?${u[l.BUILD]}?`), p("FULL", `^${u[l.FULLPLAIN]}$`), p("LOOSEPLAIN", `[v=\\s]*${u[l.MAINVERSIONLOOSE]}${u[l.PRERELEASELOOSE]}?${u[l.BUILD]}?`), p("LOOSE", `^${u[l.LOOSEPLAIN]}$`), p("GTLT", "((?:<|>)?=?)"), p("XRANGEIDENTIFIERLOOSE", `${u[l.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`), p("XRANGEIDENTIFIER", `${u[l.NUMERICIDENTIFIER]}|x|X|\\*`), p("XRANGEPLAIN", `[v=\\s]*(${u[l.XRANGEIDENTIFIER]})(?:\\.(${u[l.XRANGEIDENTIFIER]})(?:\\.(${u[l.XRANGEIDENTIFIER]})(?:${u[l.PRERELEASE]})?${u[l.BUILD]}?)?)?`), p("XRANGEPLAINLOOSE", `[v=\\s]*(${u[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${u[l.XRANGEIDENTIFIERLOOSE]})(?:\\.(${u[l.XRANGEIDENTIFIERLOOSE]})(?:${u[l.PRERELEASELOOSE]})?${u[l.BUILD]}?)?)?`), p("XRANGE", `^${u[l.GTLT]}\\s*${u[l.XRANGEPLAIN]}$`), p("XRANGELOOSE", `^${u[l.GTLT]}\\s*${u[l.XRANGEPLAINLOOSE]}$`), p("COERCE", `(^|[^\\d])(\\d{1,${n}})(?:\\.(\\d{1,${n}}))?(?:\\.(\\d{1,${n}}))?(?:$|[^\\d])`), p("COERCERTL", u[l.COERCE], !0), p("LONETILDE", "(?:~>?)"), p("TILDETRIM", `(\\s*)${u[l.LONETILDE]}\\s+`, !0), t.tildeTrimReplace = "$1~", p("TILDE", `^${u[l.LONETILDE]}${u[l.XRANGEPLAIN]}$`), p("TILDELOOSE", `^${u[l.LONETILDE]}${u[l.XRANGEPLAINLOOSE]}$`), p("LONECARET", "(?:\\^)"), p("CARETTRIM", `(\\s*)${u[l.LONECARET]}\\s+`, !0), t.caretTrimReplace = "$1^", p("CARET", `^${u[l.LONECARET]}${u[l.XRANGEPLAIN]}$`), p("CARETLOOSE", `^${u[l.LONECARET]}${u[l.XRANGEPLAINLOOSE]}$`), p("COMPARATORLOOSE", `^${u[l.GTLT]}\\s*(${u[l.LOOSEPLAIN]})$|^$`), p("COMPARATOR", `^${u[l.GTLT]}\\s*(${u[l.FULLPLAIN]})$|^$`), p("COMPARATORTRIM", `(\\s*)${u[l.GTLT]}\\s*(${u[l.LOOSEPLAIN]}|${u[l.XRANGEPLAIN]})`, !0), t.comparatorTrimReplace = "$1$2$3", p("HYPHENRANGE", `^\\s*(${u[l.XRANGEPLAIN]})\\s+-\\s+(${u[l.XRANGEPLAIN]})\\s*$`), p("HYPHENRANGELOOSE", `^\\s*(${u[l.XRANGEPLAINLOOSE]})\\s+-\\s+(${u[l.XRANGEPLAINLOOSE]})\\s*$`), p("STAR", "(<|>)?=?\\s*\\*"), p("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$"), p("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
})(Xv, Xv.exports);
var u5 = Xv.exports;
const W7 = /^[0-9]+$/, KN = (e, t) => {
  const n = W7.test(e), i = W7.test(t);
  return n && i && (e = +e, t = +t), e === t ? 0 : n && !i ? -1 : i && !n ? 1 : e < t ? -1 : 1;
}, Aye = (e, t) => KN(t, e);
var kye = {
  compareIdentifiers: KN,
  rcompareIdentifiers: Aye
};
const $h = o1, {
  MAX_LENGTH: H7,
  MAX_SAFE_INTEGER: wh
} = o5, {
  safeRe: V7,
  t: X7
} = u5, Cye = s5, {
  compareIdentifiers: Qo
} = kye;
let _ye = class Vi {
  constructor(t, n) {
    if (n = Cye(n), t instanceof Vi) {
      if (t.loose === !!n.loose && t.includePrerelease === !!n.includePrerelease)
        return t;
      t = t.version;
    } else if (typeof t != "string")
      throw new TypeError(`Invalid version. Must be a string. Got type "${typeof t}".`);
    if (t.length > H7)
      throw new TypeError(`version is longer than ${H7} characters`);
    $h("SemVer", t, n), this.options = n, this.loose = !!n.loose, this.includePrerelease = !!n.includePrerelease;
    const i = t.trim().match(n.loose ? V7[X7.LOOSE] : V7[X7.FULL]);
    if (!i)
      throw new TypeError(`Invalid Version: ${t}`);
    if (this.raw = t, this.major = +i[1], this.minor = +i[2], this.patch = +i[3], this.major > wh || this.major < 0)
      throw new TypeError("Invalid major version");
    if (this.minor > wh || this.minor < 0)
      throw new TypeError("Invalid minor version");
    if (this.patch > wh || this.patch < 0)
      throw new TypeError("Invalid patch version");
    i[4] ? this.prerelease = i[4].split(".").map((r) => {
      if (/^[0-9]+$/.test(r)) {
        const a = +r;
        if (a >= 0 && a < wh)
          return a;
      }
      return r;
    }) : this.prerelease = [], this.build = i[5] ? i[5].split(".") : [], this.format();
  }
  format() {
    return this.version = `${this.major}.${this.minor}.${this.patch}`, this.prerelease.length && (this.version += `-${this.prerelease.join(".")}`), this.version;
  }
  toString() {
    return this.version;
  }
  compare(t) {
    if ($h("SemVer.compare", this.version, this.options, t), !(t instanceof Vi)) {
      if (typeof t == "string" && t === this.version)
        return 0;
      t = new Vi(t, this.options);
    }
    return t.version === this.version ? 0 : this.compareMain(t) || this.comparePre(t);
  }
  compareMain(t) {
    return t instanceof Vi || (t = new Vi(t, this.options)), Qo(this.major, t.major) || Qo(this.minor, t.minor) || Qo(this.patch, t.patch);
  }
  comparePre(t) {
    if (t instanceof Vi || (t = new Vi(t, this.options)), this.prerelease.length && !t.prerelease.length)
      return -1;
    if (!this.prerelease.length && t.prerelease.length)
      return 1;
    if (!this.prerelease.length && !t.prerelease.length)
      return 0;
    let n = 0;
    do {
      const i = this.prerelease[n], r = t.prerelease[n];
      if ($h("prerelease compare", n, i, r), i === void 0 && r === void 0)
        return 0;
      if (r === void 0)
        return 1;
      if (i === void 0)
        return -1;
      if (i === r)
        continue;
      return Qo(i, r);
    } while (++n);
  }
  compareBuild(t) {
    t instanceof Vi || (t = new Vi(t, this.options));
    let n = 0;
    do {
      const i = this.build[n], r = t.build[n];
      if ($h("prerelease compare", n, i, r), i === void 0 && r === void 0)
        return 0;
      if (r === void 0)
        return 1;
      if (i === void 0)
        return -1;
      if (i === r)
        continue;
      return Qo(i, r);
    } while (++n);
  }
  // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.
  inc(t, n, i) {
    switch (t) {
      case "premajor":
        this.prerelease.length = 0, this.patch = 0, this.minor = 0, this.major++, this.inc("pre", n, i);
        break;
      case "preminor":
        this.prerelease.length = 0, this.patch = 0, this.minor++, this.inc("pre", n, i);
        break;
      case "prepatch":
        this.prerelease.length = 0, this.inc("patch", n, i), this.inc("pre", n, i);
        break;
      case "prerelease":
        this.prerelease.length === 0 && this.inc("patch", n, i), this.inc("pre", n, i);
        break;
      case "major":
        (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) && this.major++, this.minor = 0, this.patch = 0, this.prerelease = [];
        break;
      case "minor":
        (this.patch !== 0 || this.prerelease.length === 0) && this.minor++, this.patch = 0, this.prerelease = [];
        break;
      case "patch":
        this.prerelease.length === 0 && this.patch++, this.prerelease = [];
        break;
      case "pre": {
        const r = Number(i) ? 1 : 0;
        if (!n && i === !1)
          throw new Error("invalid increment argument: identifier is empty");
        if (this.prerelease.length === 0)
          this.prerelease = [r];
        else {
          let a = this.prerelease.length;
          for (; --a >= 0; )
            typeof this.prerelease[a] == "number" && (this.prerelease[a]++, a = -2);
          if (a === -1) {
            if (n === this.prerelease.join(".") && i === !1)
              throw new Error("invalid increment argument: identifier already exists");
            this.prerelease.push(r);
          }
        }
        if (n) {
          let a = [n, r];
          i === !1 && (a = [n]), Qo(this.prerelease[0], n) === 0 ? isNaN(this.prerelease[1]) && (this.prerelease = a) : this.prerelease = a;
        }
        break;
      }
      default:
        throw new Error(`invalid increment argument: ${t}`);
    }
    return this.raw = this.format(), this.build.length && (this.raw += `+${this.build.join(".")}`), this;
  }
};
var l5 = _ye;
const Y7 = l5, Fye = (e, t, n) => new Y7(e, n).compare(new Y7(t, n));
var kl = Fye;
const Mye = kl, Oye = (e, t, n) => Mye(e, t, n) === 0;
var Rye = Oye;
const Tye = kl, Dye = (e, t, n) => Tye(e, t, n) !== 0;
var Nye = Dye;
const Lye = kl, Pye = (e, t, n) => Lye(e, t, n) > 0;
var zye = Pye;
const Iye = kl, Bye = (e, t, n) => Iye(e, t, n) >= 0;
var jye = Bye;
const Uye = kl, qye = (e, t, n) => Uye(e, t, n) < 0;
var Gye = qye;
const Wye = kl, Hye = (e, t, n) => Wye(e, t, n) <= 0;
var Vye = Hye;
const Xye = Rye, Yye = Nye, Kye = zye, Jye = jye, Qye = Gye, Zye = Vye, ebe = (e, t, n, i) => {
  switch (t) {
    case "===":
      return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e === n;
    case "!==":
      return typeof e == "object" && (e = e.version), typeof n == "object" && (n = n.version), e !== n;
    case "":
    case "=":
    case "==":
      return Xye(e, n, i);
    case "!=":
      return Yye(e, n, i);
    case ">":
      return Kye(e, n, i);
    case ">=":
      return Jye(e, n, i);
    case "<":
      return Qye(e, n, i);
    case "<=":
      return Zye(e, n, i);
    default:
      throw new TypeError(`Invalid operator: ${t}`);
  }
};
var tbe = ebe, My, K7;
function nbe() {
  if (K7)
    return My;
  K7 = 1;
  const e = Symbol("SemVer ANY");
  class t {
    static get ANY() {
      return e;
    }
    constructor(c, f) {
      if (f = n(f), c instanceof t) {
        if (c.loose === !!f.loose)
          return c;
        c = c.value;
      }
      c = c.trim().split(/\s+/).join(" "), s("comparator", c, f), this.options = f, this.loose = !!f.loose, this.parse(c), this.semver === e ? this.value = "" : this.value = this.operator + this.semver.version, s("comp", this);
    }
    parse(c) {
      const f = this.options.loose ? i[r.COMPARATORLOOSE] : i[r.COMPARATOR], d = c.match(f);
      if (!d)
        throw new TypeError(`Invalid comparator: ${c}`);
      this.operator = d[1] !== void 0 ? d[1] : "", this.operator === "=" && (this.operator = ""), d[2] ? this.semver = new o(d[2], this.options.loose) : this.semver = e;
    }
    toString() {
      return this.value;
    }
    test(c) {
      if (s("Comparator.test", c, this.options.loose), this.semver === e || c === e)
        return !0;
      if (typeof c == "string")
        try {
          c = new o(c, this.options);
        } catch {
          return !1;
        }
      return a(c, this.operator, this.semver, this.options);
    }
    intersects(c, f) {
      if (!(c instanceof t))
        throw new TypeError("a Comparator is required");
      return this.operator === "" ? this.value === "" ? !0 : new u(c.value, f).test(this.value) : c.operator === "" ? c.value === "" ? !0 : new u(this.value, f).test(c.semver) : (f = n(f), f.includePrerelease && (this.value === "<0.0.0-0" || c.value === "<0.0.0-0") || !f.includePrerelease && (this.value.startsWith("<0.0.0") || c.value.startsWith("<0.0.0")) ? !1 : !!(this.operator.startsWith(">") && c.operator.startsWith(">") || this.operator.startsWith("<") && c.operator.startsWith("<") || this.semver.version === c.semver.version && this.operator.includes("=") && c.operator.includes("=") || a(this.semver, "<", c.semver, f) && this.operator.startsWith(">") && c.operator.startsWith("<") || a(this.semver, ">", c.semver, f) && this.operator.startsWith("<") && c.operator.startsWith(">")));
    }
  }
  My = t;
  const n = s5, {
    safeRe: i,
    t: r
  } = u5, a = tbe, s = o1, o = l5, u = JN();
  return My;
}
var Oy, J7;
function JN() {
  if (J7)
    return Oy;
  J7 = 1;
  class e {
    constructor(M, C) {
      if (C = i(C), M instanceof e)
        return M.loose === !!C.loose && M.includePrerelease === !!C.includePrerelease ? M : new e(M.raw, C);
      if (M instanceof r)
        return this.raw = M.value, this.set = [[M]], this.format(), this;
      if (this.options = C, this.loose = !!C.loose, this.includePrerelease = !!C.includePrerelease, this.raw = M.trim().split(/\s+/).join(" "), this.set = this.raw.split("||").map((O) => this.parseRange(O.trim())).filter((O) => O.length), !this.set.length)
        throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
      if (this.set.length > 1) {
        const O = this.set[0];
        if (this.set = this.set.filter((L) => !p(L[0])), this.set.length === 0)
          this.set = [O];
        else if (this.set.length > 1) {
          for (const L of this.set)
            if (L.length === 1 && g(L[0])) {
              this.set = [L];
              break;
            }
        }
      }
      this.format();
    }
    format() {
      return this.range = this.set.map((M) => M.join(" ").trim()).join("||").trim(), this.range;
    }
    toString() {
      return this.range;
    }
    parseRange(M) {
      const O = ((this.options.includePrerelease && d) | (this.options.loose && h)) + ":" + M, L = n.get(O);
      if (L)
        return L;
      const z = this.options.loose, W = z ? o[u.HYPHENRANGELOOSE] : o[u.HYPHENRANGE];
      M = M.replace(W, _(this.options.includePrerelease)), a("hyphen replace", M), M = M.replace(o[u.COMPARATORTRIM], l), a("comparator trim", M), M = M.replace(o[u.TILDETRIM], c), a("tilde trim", M), M = M.replace(o[u.CARETTRIM], f), a("caret trim", M);
      let J = M.split(" ").map((we) => y(we, this.options)).join(" ").split(/\s+/).map((we) => k(we, this.options));
      z && (J = J.filter((we) => (a("loose invalid filter", we, this.options), !!we.match(o[u.COMPARATORLOOSE])))), a("range list", J);
      const ie = /* @__PURE__ */ new Map(), de = J.map((we) => new r(we, this.options));
      for (const we of de) {
        if (p(we))
          return [we];
        ie.set(we.value, we);
      }
      ie.size > 1 && ie.has("") && ie.delete("");
      const Re = [...ie.values()];
      return n.set(O, Re), Re;
    }
    intersects(M, C) {
      if (!(M instanceof e))
        throw new TypeError("a Range is required");
      return this.set.some((O) => m(O, C) && M.set.some((L) => m(L, C) && O.every((z) => L.every((W) => z.intersects(W, C)))));
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(M) {
      if (!M)
        return !1;
      if (typeof M == "string")
        try {
          M = new s(M, this.options);
        } catch {
          return !1;
        }
      for (let C = 0; C < this.set.length; C++)
        if (P(this.set[C], M, this.options))
          return !0;
      return !1;
    }
  }
  Oy = e;
  const t = gye, n = new t({
    max: 1e3
  }), i = s5, r = nbe(), a = o1, s = l5, {
    safeRe: o,
    t: u,
    comparatorTrimReplace: l,
    tildeTrimReplace: c,
    caretTrimReplace: f
  } = u5, {
    FLAG_INCLUDE_PRERELEASE: d,
    FLAG_LOOSE: h
  } = o5, p = (F) => F.value === "<0.0.0-0", g = (F) => F.value === "", m = (F, M) => {
    let C = !0;
    const O = F.slice();
    let L = O.pop();
    for (; C && O.length; )
      C = O.every((z) => L.intersects(z, M)), L = O.pop();
    return C;
  }, y = (F, M) => (a("comp", F, M), F = w(F, M), a("caret", F), F = v(F, M), a("tildes", F), F = $(F, M), a("xrange", F), F = A(F, M), a("stars", F), F), b = (F) => !F || F.toLowerCase() === "x" || F === "*", v = (F, M) => F.trim().split(/\s+/).map((C) => x(C, M)).join(" "), x = (F, M) => {
    const C = M.loose ? o[u.TILDELOOSE] : o[u.TILDE];
    return F.replace(C, (O, L, z, W, J) => {
      a("tilde", F, O, L, z, W, J);
      let ie;
      return b(L) ? ie = "" : b(z) ? ie = `>=${L}.0.0 <${+L + 1}.0.0-0` : b(W) ? ie = `>=${L}.${z}.0 <${L}.${+z + 1}.0-0` : J ? (a("replaceTilde pr", J), ie = `>=${L}.${z}.${W}-${J} <${L}.${+z + 1}.0-0`) : ie = `>=${L}.${z}.${W} <${L}.${+z + 1}.0-0`, a("tilde return", ie), ie;
    });
  }, w = (F, M) => F.trim().split(/\s+/).map((C) => E(C, M)).join(" "), E = (F, M) => {
    a("caret", F, M);
    const C = M.loose ? o[u.CARETLOOSE] : o[u.CARET], O = M.includePrerelease ? "-0" : "";
    return F.replace(C, (L, z, W, J, ie) => {
      a("caret", F, L, z, W, J, ie);
      let de;
      return b(z) ? de = "" : b(W) ? de = `>=${z}.0.0${O} <${+z + 1}.0.0-0` : b(J) ? z === "0" ? de = `>=${z}.${W}.0${O} <${z}.${+W + 1}.0-0` : de = `>=${z}.${W}.0${O} <${+z + 1}.0.0-0` : ie ? (a("replaceCaret pr", ie), z === "0" ? W === "0" ? de = `>=${z}.${W}.${J}-${ie} <${z}.${W}.${+J + 1}-0` : de = `>=${z}.${W}.${J}-${ie} <${z}.${+W + 1}.0-0` : de = `>=${z}.${W}.${J}-${ie} <${+z + 1}.0.0-0`) : (a("no pr"), z === "0" ? W === "0" ? de = `>=${z}.${W}.${J}${O} <${z}.${W}.${+J + 1}-0` : de = `>=${z}.${W}.${J}${O} <${z}.${+W + 1}.0-0` : de = `>=${z}.${W}.${J} <${+z + 1}.0.0-0`), a("caret return", de), de;
    });
  }, $ = (F, M) => (a("replaceXRanges", F, M), F.split(/\s+/).map((C) => S(C, M)).join(" ")), S = (F, M) => {
    F = F.trim();
    const C = M.loose ? o[u.XRANGELOOSE] : o[u.XRANGE];
    return F.replace(C, (O, L, z, W, J, ie) => {
      a("xRange", F, O, L, z, W, J, ie);
      const de = b(z), Re = de || b(W), we = Re || b(J), ln = we;
      return L === "=" && ln && (L = ""), ie = M.includePrerelease ? "-0" : "", de ? L === ">" || L === "<" ? O = "<0.0.0-0" : O = "*" : L && ln ? (Re && (W = 0), J = 0, L === ">" ? (L = ">=", Re ? (z = +z + 1, W = 0, J = 0) : (W = +W + 1, J = 0)) : L === "<=" && (L = "<", Re ? z = +z + 1 : W = +W + 1), L === "<" && (ie = "-0"), O = `${L + z}.${W}.${J}${ie}`) : Re ? O = `>=${z}.0.0${ie} <${+z + 1}.0.0-0` : we && (O = `>=${z}.${W}.0${ie} <${z}.${+W + 1}.0-0`), a("xRange return", O), O;
    });
  }, A = (F, M) => (a("replaceStars", F, M), F.trim().replace(o[u.STAR], "")), k = (F, M) => (a("replaceGTE0", F, M), F.trim().replace(o[M.includePrerelease ? u.GTE0PRE : u.GTE0], "")), _ = (F) => (M, C, O, L, z, W, J, ie, de, Re, we, ln, u1) => (b(O) ? C = "" : b(L) ? C = `>=${O}.0.0${F ? "-0" : ""}` : b(z) ? C = `>=${O}.${L}.0${F ? "-0" : ""}` : W ? C = `>=${C}` : C = `>=${C}${F ? "-0" : ""}`, b(de) ? ie = "" : b(Re) ? ie = `<${+de + 1}.0.0-0` : b(we) ? ie = `<${de}.${+Re + 1}.0-0` : ln ? ie = `<=${de}.${Re}.${we}-${ln}` : F ? ie = `<${de}.${Re}.${+we + 1}-0` : ie = `<=${ie}`, `${C} ${ie}`.trim()), P = (F, M, C) => {
    for (let O = 0; O < F.length; O++)
      if (!F[O].test(M))
        return !1;
    if (M.prerelease.length && !C.includePrerelease) {
      for (let O = 0; O < F.length; O++)
        if (a(F[O].semver), F[O].semver !== r.ANY && F[O].semver.prerelease.length > 0) {
          const L = F[O].semver;
          if (L.major === M.major && L.minor === M.minor && L.patch === M.patch)
            return !0;
        }
      return !1;
    }
    return !0;
  };
  return Oy;
}
const ibe = JN(), rbe = (e, t, n) => {
  try {
    t = new ibe(t, n);
  } catch {
    return !1;
  }
  return t.test(e);
};
var abe = rbe, QN = /* @__PURE__ */ sye(abe);
function sbe(e, t, n) {
  const i = e.open(t), r = 1e4, a = 250, {
    origin: s
  } = new URL(t);
  let o = ~~(r / a);
  function u(c) {
    c.source === i && (o = 0, e.removeEventListener("message", u, !1));
  }
  e.addEventListener("message", u, !1);
  function l() {
    o <= 0 || (i.postMessage(n, s), setTimeout(l, a), o -= 1);
  }
  setTimeout(l, a);
}
var obe = `.vega-embed {
  position: relative;
  display: inline-block;
  box-sizing: border-box;
}
.vega-embed.has-actions {
  padding-right: 38px;
}
.vega-embed details:not([open]) > :not(summary) {
  display: none !important;
}
.vega-embed summary {
  list-style: none;
  position: absolute;
  top: 0;
  right: 0;
  padding: 6px;
  z-index: 1000;
  background: white;
  box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.1);
  color: #1b1e23;
  border: 1px solid #aaa;
  border-radius: 999px;
  opacity: 0.2;
  transition: opacity 0.4s ease-in;
  cursor: pointer;
  line-height: 0px;
}
.vega-embed summary::-webkit-details-marker {
  display: none;
}
.vega-embed summary:active {
  box-shadow: #aaa 0px 0px 0px 1px inset;
}
.vega-embed summary svg {
  width: 14px;
  height: 14px;
}
.vega-embed details[open] summary {
  opacity: 0.7;
}
.vega-embed:hover summary, .vega-embed:focus-within summary {
  opacity: 1 !important;
  transition: opacity 0.2s ease;
}
.vega-embed .vega-actions {
  position: absolute;
  z-index: 1001;
  top: 35px;
  right: -9px;
  display: flex;
  flex-direction: column;
  padding-bottom: 8px;
  padding-top: 8px;
  border-radius: 4px;
  box-shadow: 0 2px 8px 0 rgba(0, 0, 0, 0.2);
  border: 1px solid #d9d9d9;
  background: white;
  animation-duration: 0.15s;
  animation-name: scale-in;
  animation-timing-function: cubic-bezier(0.2, 0, 0.13, 1.5);
  text-align: left;
}
.vega-embed .vega-actions a {
  padding: 8px 16px;
  font-family: sans-serif;
  font-size: 14px;
  font-weight: 600;
  white-space: nowrap;
  color: #434a56;
  text-decoration: none;
}
.vega-embed .vega-actions a:hover, .vega-embed .vega-actions a:focus {
  background-color: #f7f7f9;
  color: black;
}
.vega-embed .vega-actions::before, .vega-embed .vega-actions::after {
  content: "";
  display: inline-block;
  position: absolute;
}
.vega-embed .vega-actions::before {
  left: auto;
  right: 14px;
  top: -16px;
  border: 8px solid rgba(0, 0, 0, 0);
  border-bottom-color: #d9d9d9;
}
.vega-embed .vega-actions::after {
  left: auto;
  right: 15px;
  top: -14px;
  border: 7px solid rgba(0, 0, 0, 0);
  border-bottom-color: #fff;
}
.vega-embed .chart-wrapper.fit-x {
  width: 100%;
}
.vega-embed .chart-wrapper.fit-y {
  height: 100%;
}

.vega-embed-wrapper {
  max-width: 100%;
  overflow: auto;
  padding-right: 14px;
}

@keyframes scale-in {
  from {
    opacity: 0;
    transform: scale(0.6);
  }
  to {
    opacity: 1;
    transform: scale(1);
  }
}
`;
function ZN(e, ...t) {
  for (const n of t)
    ube(e, n);
  return e;
}
function ube(e, t) {
  for (const n of Object.keys(t))
    tl(e, n, t[n], !0);
}
var lbe = "vega-embed", cbe = "6.23.0", fbe = "Publish Vega visualizations as embedded web components.", dbe = ["vega", "data", "visualization", "component", "embed"], hbe = {
  type: "git",
  url: "http://github.com/vega/vega-embed.git"
}, pbe = {
  name: "UW Interactive Data Lab",
  url: "http://idl.cs.washington.edu"
}, gbe = [{
  name: "Dominik Moritz",
  url: "https://www.domoritz.de"
}], mbe = {
  url: "https://github.com/vega/vega-embed/issues"
}, ybe = "https://github.com/vega/vega-embed#readme", bbe = "BSD-3-Clause", vbe = "build/vega-embed.js", xbe = "build/vega-embed.module.js", $be = "build/vega-embed.min.js", wbe = "build/vega-embed.min.js", Ebe = "build/vega-embed.module.d.ts", Sbe = ["src", "build", "patches"], Abe = {
  "@babel/core": "^7.22.9",
  "@babel/plugin-proposal-async-generator-functions": "^7.20.7",
  "@babel/plugin-proposal-json-strings": "^7.18.6",
  "@babel/plugin-proposal-object-rest-spread": "^7.20.7",
  "@babel/plugin-proposal-optional-catch-binding": "^7.18.6",
  "@babel/plugin-transform-runtime": "^7.22.9",
  "@babel/preset-env": "^7.22.9",
  "@babel/preset-typescript": "^7.22.5",
  "@release-it/conventional-changelog": "^7.0.0",
  "@rollup/plugin-commonjs": "25.0.4",
  "@rollup/plugin-json": "^6.0.0",
  "@rollup/plugin-node-resolve": "^15.1.0",
  "@rollup/plugin-terser": "^0.4.3",
  "@types/semver": "^7.5.0",
  "@typescript-eslint/eslint-plugin": "^6.2.0",
  "@typescript-eslint/parser": "^6.2.0",
  "browser-sync": "^2.29.3",
  concurrently: "^8.2.0",
  "del-cli": "^5.0.0",
  eslint: "^8.46.0",
  "eslint-config-prettier": "^9.0.0",
  "eslint-plugin-jest": "^27.2.3",
  "eslint-plugin-prettier": "^5.0.0",
  jest: "^29.6.2",
  "jest-canvas-mock": "^2.5.2",
  "jest-environment-jsdom": "^29.6.2",
  "patch-package": "^8.0.0",
  "postinstall-postinstall": "^2.1.0",
  prettier: "^3.0.0",
  "release-it": "^16.1.3",
  rollup: "3.29.1",
  "rollup-plugin-bundle-size": "^1.0.3",
  "rollup-plugin-ts": "^3.2.0",
  sass: "^1.64.1",
  typescript: "^5.1.6",
  vega: "^5.22.1",
  "vega-lite": "^5.2.0"
}, kbe = {
  vega: "^5.21.0",
  "vega-lite": "*"
}, Cbe = {
  "fast-json-patch": "^3.1.1",
  "json-stringify-pretty-compact": "^3.0.0",
  semver: "^7.5.4",
  tslib: "^2.6.1",
  "vega-interpreter": "^1.0.5",
  "vega-schema-url-parser": "^2.2.0",
  "vega-themes": "^2.14.0",
  "vega-tooltip": "^0.33.0"
}, _be = ["yallist"], Fbe = {
  prebuild: "yarn clean && yarn build:style",
  build: "rollup -c",
  "build:style": "./build-style.sh",
  clean: "del-cli build src/style.ts",
  prepublishOnly: "yarn clean && yarn build",
  preversion: "yarn lint && yarn test",
  serve: "browser-sync start --directory -s -f build *.html",
  start: "yarn build && concurrently --kill-others -n Server,Rollup 'yarn serve' 'rollup -c -w'",
  pretest: "yarn build:style",
  test: "jest",
  "test:inspect": "node --inspect-brk ./node_modules/.bin/jest --runInBand",
  prettierbase: "prettier '*.{css,scss,html}'",
  format: "eslint . --fix && yarn prettierbase --write",
  lint: "eslint . && yarn prettierbase --check",
  release: "release-it"
}, Mbe = {
  name: lbe,
  version: cbe,
  description: fbe,
  keywords: dbe,
  repository: hbe,
  author: pbe,
  contributors: gbe,
  bugs: mbe,
  homepage: ybe,
  license: bbe,
  main: vbe,
  module: xbe,
  unpkg: $be,
  jsdelivr: wbe,
  types: Ebe,
  files: Sbe,
  devDependencies: Abe,
  peerDependencies: kbe,
  dependencies: Cbe,
  bundledDependencies: _be,
  scripts: Fbe
};
function Q7(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    t && (i = i.filter(function(r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), n.push.apply(n, i);
  }
  return n;
}
function Ia(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Q7(Object(n), !0).forEach(function(i) {
      aye(e, i, n[i]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Q7(Object(n)).forEach(function(i) {
      Object.defineProperty(e, i, Object.getOwnPropertyDescriptor(n, i));
    });
  }
  return e;
}
const Pve = Mbe.version, Xi = Gue;
let Af = Vme;
const Eh = typeof window < "u" ? window : void 0;
var nk;
Af === void 0 && ((nk = Eh == null ? void 0 : Eh.vl) != null && nk.compile) && (Af = Eh.vl);
const Obe = {
  export: {
    svg: !0,
    png: !0
  },
  source: !0,
  compiled: !0,
  editor: !0
}, Rbe = {
  CLICK_TO_VIEW_ACTIONS: "Click to view actions",
  COMPILED_ACTION: "View Compiled Vega",
  EDITOR_ACTION: "Open in Vega Editor",
  PNG_ACTION: "Save as PNG",
  SOURCE_ACTION: "View Source",
  SVG_ACTION: "Save as SVG"
}, vc = {
  vega: "Vega",
  "vega-lite": "Vega-Lite"
}, Lg = {
  vega: Xi.version,
  "vega-lite": Af ? Af.version : "not available"
}, Tbe = {
  vega: (e) => e,
  "vega-lite": (e, t) => Af.compile(e, {
    config: t
  }).spec
}, Dbe = `
<svg viewBox="0 0 16 16" fill="currentColor" stroke="none" stroke-width="1" stroke-linecap="round" stroke-linejoin="round">
  <circle r="2" cy="8" cx="2"></circle>
  <circle r="2" cy="8" cx="8"></circle>
  <circle r="2" cy="8" cx="14"></circle>
</svg>`, Nbe = "chart-wrapper";
function Lbe(e) {
  return typeof e == "function";
}
function Z7(e, t, n, i) {
  const r = `<html><head>${t}</head><body><pre><code class="json">`, a = `</code></pre>${n}</body></html>`, s = window.open("");
  s.document.write(r + e + a), s.document.title = `${vc[i]} JSON Source`;
}
function Pbe(e, t) {
  if (e.$schema) {
    const n = GN(e.$schema);
    t && t !== n.library && console.warn(`The given visualization spec is written in ${vc[n.library]}, but mode argument sets ${vc[t] ?? t}.`);
    const i = n.library;
    return QN(Lg[i], `^${n.version.slice(1)}`) || console.warn(`The input spec uses ${vc[i]} ${n.version}, but the current version of ${vc[i]} is v${Lg[i]}.`), i;
  }
  return "mark" in e || "encoding" in e || "layer" in e || "hconcat" in e || "vconcat" in e || "facet" in e || "repeat" in e ? "vega-lite" : "marks" in e || "signals" in e || "scales" in e || "axes" in e ? "vega" : t ?? "vega";
}
function zbe(e) {
  return !!(e && "load" in e);
}
function ek(e) {
  return zbe(e) ? e : Xi.loader(e);
}
function Ibe(e) {
  var n;
  const t = ((n = e.usermeta) == null ? void 0 : n.embedOptions) ?? {};
  return V(t.defaultStyle) && (t.defaultStyle = !1), t;
}
async function zve(e, t, n = {}) {
  let i, r;
  V(t) ? (r = ek(n.loader), i = JSON.parse(await r.load(t))) : i = t;
  const a = Ibe(i), s = a.loader;
  (!r || s) && (r = ek(n.loader ?? s));
  const o = await tk(a, r), u = await tk(n, r), l = Ia(Ia({}, ZN(u, o)), {}, {
    config: el(u.config ?? {}, o.config ?? {})
  });
  return await jbe(e, i, l, r);
}
async function tk(e, t) {
  const n = V(e.config) ? JSON.parse(await t.load(e.config)) : e.config ?? {}, i = V(e.patch) ? JSON.parse(await t.load(e.patch)) : e.patch;
  return Ia(Ia(Ia({}, e), i ? {
    patch: i
  } : {}), n ? {
    config: n
  } : {});
}
function Bbe(e) {
  const t = e.getRootNode ? e.getRootNode() : document;
  return t instanceof ShadowRoot ? {
    root: t,
    rootContainer: t
  } : {
    root: document,
    rootContainer: document.head ?? document.body
  };
}
async function jbe(e, t, n = {}, i) {
  const r = n.theme ? el(X1e[n.theme], n.config ?? {}) : n.config, a = Zr(n.actions) ? n.actions : ZN({}, Obe, n.actions ?? {}), s = Ia(Ia({}, Rbe), n.i18n), o = n.renderer ?? "canvas", u = n.logLevel ?? Xi.Warn, l = n.downloadFileName ?? "visualization", c = typeof e == "string" ? document.querySelector(e) : e;
  if (!c)
    throw new Error(`${e} does not exist`);
  if (n.defaultStyle !== !1) {
    const w = "vega-embed-style", {
      root: E,
      rootContainer: $
    } = Bbe(c);
    if (!E.getElementById(w)) {
      const S = document.createElement("style");
      S.id = w, S.innerHTML = n.defaultStyle === void 0 || n.defaultStyle === !0 ? obe.toString() : n.defaultStyle, $.appendChild(S);
    }
  }
  const f = Pbe(t, n.mode);
  let d = Tbe[f](t, r);
  if (f === "vega-lite" && d.$schema) {
    const w = GN(d.$schema);
    QN(Lg.vega, `^${w.version.slice(1)}`) || console.warn(`The compiled spec uses Vega ${w.version}, but current version is v${Lg.vega}.`);
  }
  c.classList.add("vega-embed"), a && c.classList.add("has-actions"), c.innerHTML = "";
  let h = c;
  if (a) {
    const w = document.createElement("div");
    w.classList.add(Nbe), c.appendChild(w), h = w;
  }
  const p = n.patch;
  if (p && (d = p instanceof Function ? p(d) : e0(d, p, !0, !1).newDocument), n.formatLocale && Xi.formatLocale(n.formatLocale), n.timeFormatLocale && Xi.timeFormatLocale(n.timeFormatLocale), n.expressionFunctions)
    for (const w in n.expressionFunctions) {
      const E = n.expressionFunctions[w];
      "fn" in E ? Xi.expressionFunction(w, E.fn, E.visitor) : E instanceof Function && Xi.expressionFunction(w, E);
    }
  const {
    ast: g
  } = n, m = Xi.parse(d, f === "vega-lite" ? {} : r, {
    ast: g
  }), y = new (n.viewClass || Xi.View)(m, Ia({
    loader: i,
    logLevel: u,
    renderer: o
  }, g ? {
    expr: Xi.expressionInterpreter ?? n.expr ?? ele
  } : {}));
  if (y.addSignalListener("autosize", (w, E) => {
    const {
      type: $
    } = E;
    $ == "fit-x" ? (h.classList.add("fit-x"), h.classList.remove("fit-y")) : $ == "fit-y" ? (h.classList.remove("fit-x"), h.classList.add("fit-y")) : $ == "fit" ? h.classList.add("fit-x", "fit-y") : h.classList.remove("fit-x", "fit-y");
  }), n.tooltip !== !1) {
    const w = Lbe(n.tooltip) ? n.tooltip : (
      // user provided boolean true or tooltip options
      new nye(n.tooltip === !0 ? {} : n.tooltip).call
    );
    y.tooltip(w);
  }
  let {
    hover: b
  } = n;
  if (b === void 0 && (b = f === "vega"), b) {
    const {
      hoverSet: w,
      updateSet: E
    } = typeof b == "boolean" ? {} : b;
    y.hover(w, E);
  }
  n && (n.width != null && y.width(n.width), n.height != null && y.height(n.height), n.padding != null && y.padding(n.padding)), await y.initialize(h, n.bind).runAsync();
  let v;
  if (a !== !1) {
    let w = c;
    if (n.defaultStyle !== !1 || n.forceActionsMenu) {
      const $ = document.createElement("details");
      $.title = s.CLICK_TO_VIEW_ACTIONS, c.append($), w = $;
      const S = document.createElement("summary");
      S.innerHTML = Dbe, $.append(S), v = (A) => {
        $.contains(A.target) || $.removeAttribute("open");
      }, document.addEventListener("click", v);
    }
    const E = document.createElement("div");
    if (w.append(E), E.classList.add("vega-actions"), a === !0 || a.export !== !1) {
      for (const $ of ["svg", "png"])
        if (a === !0 || a.export === !0 || a.export[$]) {
          const S = s[`${$.toUpperCase()}_ACTION`], A = document.createElement("a"), k = X(n.scaleFactor) ? n.scaleFactor[$] : n.scaleFactor;
          A.text = S, A.href = "#", A.target = "_blank", A.download = `${l}.${$}`, A.addEventListener("mousedown", async function(_) {
            _.preventDefault();
            const P = await y.toImageURL($, k);
            this.href = P;
          }), E.append(A);
        }
    }
    if (a === !0 || a.source !== !1) {
      const $ = document.createElement("a");
      $.text = s.SOURCE_ACTION, $.href = "#", $.addEventListener("click", function(S) {
        Z7(S1(t), n.sourceHeader ?? "", n.sourceFooter ?? "", f), S.preventDefault();
      }), E.append($);
    }
    if (f === "vega-lite" && (a === !0 || a.compiled !== !1)) {
      const $ = document.createElement("a");
      $.text = s.COMPILED_ACTION, $.href = "#", $.addEventListener("click", function(S) {
        Z7(S1(d), n.sourceHeader ?? "", n.sourceFooter ?? "", "vega"), S.preventDefault();
      }), E.append($);
    }
    if (a === !0 || a.editor !== !1) {
      const $ = n.editorUrl ?? "https://vega.github.io/editor/", S = document.createElement("a");
      S.text = s.EDITOR_ACTION, S.href = "#", S.addEventListener("click", function(A) {
        sbe(window, $, {
          config: r,
          mode: f,
          renderer: o,
          spec: S1(t)
        }), A.preventDefault();
      }), E.append(S);
    }
  }
  function x() {
    v && document.removeEventListener("click", v), y.finalize();
  }
  return {
    view: y,
    spec: t,
    vgSpec: d,
    finalize: x,
    embedOptions: n
  };
}
export {
  Obe as DEFAULT_ACTIONS,
  zve as default,
  Pbe as guessMode,
  Xi as vega,
  Af as vegaLite,
  Pve as version
};
